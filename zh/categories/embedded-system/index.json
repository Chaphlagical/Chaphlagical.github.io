[{"content":"1. 样条曲面简介 当输入为一维时，将得到曲线，而将输入变为二维时，则可以得到曲面输出\n1.1. 参数样条曲面  两个参数坐标$(u,v)$ 分段双变量多项式 多片合成连续的完整一片 每个片元称为样条块Spline Patch  有两种方法进行建模：\n 张量积曲面Tensor Product Surface 全度曲面Total Degree Surface  1.2. 张量积曲面  构造简单 与曲线的情况类似 四边形块Quad Patch 度数各向异性  1.3. 全度曲面  不够直接，可借助极形式进行理解 度数各向同性 三角形块Triangle Patch 曲线的自然泛化  2. 张量积曲面 2.1. 基本思想 给定一个$n$维基函数空间\n$$\n\\pmb B^{(curv)}:=\\{b_1(t),\\cdots,b_n(t)\\}\n$$\n其中，$b_i(t):t\\in[t_0,t_1]\\rightarrow \\mathbb R^d$\n构建一个双参数基函数空间：\n$$\n\\pmb{B}^{(surf)}=\\{b_i(u)b_j(v)\\}_{i,j=1}^n\n$$\n 示例：\n张量积基函数：\n对于单项式基$b_i(t)=t^{i-1}$，有\n 张量积曲面定义为：\n$$\n\\begin{aligned} \\boldsymbol { f } ( u , v ) \u0026amp; = \\sum _ { i = 1 } ^ { n } \\sum _ { j = 1 } ^ { n } b _ { i } ( u ) b _ { j } ( v ) \\boldsymbol { p } _ { i , j } \\\\\\\\ \u0026amp; = \\sum _ { i = 1 } ^ { n } b _ { i } ( u ) \\sum _ { j = 1 } ^ { n } b _ { j } ( v ) \\boldsymbol { p } _ { i , j } \\\\\\\\ \u0026amp; = \\sum _ { j = 1 } ^ { n } b _ { j } ( v ) \\sum _ { i = 1 } ^ { n } b _ { i } ( u ) \\boldsymbol { p } _ { i , j } \\end{aligned}\n$$\n ”曲线的曲线“ 顺序无关性  基本性质：\n 线性不变性 当$\\sum_{i=1}^n b_i(t)=1$时，具有仿射不变性 当$b_i(t)\\ge 0$时，具有凸包性  偏导：\n$$\n\\begin{aligned} \\frac { \\partial ^ { r + s } } { \\partial u ^ { r } \\partial v ^ { s } } \\sum _ { i = 1 } ^ { n } \\sum _ { j = 1 } ^ { n } b _ { i } ( u ) b _ { j } ( v ) \\boldsymbol { p } _ { i , j } \u0026amp; = \\sum _ { j = 1 } ^ { n } \\left( \\frac { d ^ { s } } { d v ^ { s } } b _ { i } \\right) ( v ) \\sum _ { i = 1 } ^ { n } \\left( \\frac { d ^ { r } } { d u ^ { r } } b _ { i } \\right) ( u ) \\boldsymbol { p } _ { i , j } \\\\\\\\ \u0026amp; = \\sum _ { i = 1 } ^ { n } \\left( \\frac { d ^ { r } } { d u ^ { r } } b _ { i } \\right) ( u ) \\sum _ { j = 1 } ^ { n } \\left( \\frac { d ^ { s } } { d v ^ { s } } b _ { j } \\right) ( v ) \\boldsymbol { p } _ { i , j } \\end{aligned}\n$$\n法向量：\n$$\n\\pmb n(u,v)=\\frac{\\dfrac{\\partial \\pmb f}{\\partial u}\\times\\dfrac{\\partial \\pmb f}{\\partial v}}{\\left\\|\\dfrac{\\partial \\pmb f}{\\partial u}\\times\\dfrac{\\partial \\pmb f}{\\partial v}\\right\\|}\n$$\n2.2. 张量积Bézier曲面 2.2.1. 线性插值曲面 双线性曲面\n$$\n\\begin{aligned}\n\\pmb{h}_ 0 \u0026amp;= (1-u)\\pmb{b}_ {00}+u\\pmb{b}_ {10}\\\\\\\\\n\\pmb{h}_ 1 \u0026amp;= (1-u)\\pmb{b}_ {01}+u\\pmb{b}_ {11}\n\\end{aligned}\n$$\n故有：\n$$\n\\begin{aligned}\n\\pmb{x}(u,v) \u0026amp;= (1-v)\\pmb{h}_0 + v\\pmb{h}_1\\\\\\\\\n\u0026amp;= (1-v)((1-u)\\pmb{b}_ {00}+u\\pmb{b}_ {10}) + v((1-u)\\pmb{b}_ {01}+u\\pmb{b}_ {11})\\\\\\\\\n\u0026amp;= ( 1 - u ) ( 1 - v ) \\boldsymbol { b } _ { 00 } + u ( 1 - v ) \\boldsymbol { b } _ { 10 } + ( 1 - u ) v \\boldsymbol { b } _ { 01 } + u v \\boldsymbol { b } _ { 11 }\n\\end{aligned}\n$$\n双线性曲面的导数：\n$$\n\\begin{array} { l } { x _ { u } ( u , v ) = ( 1 - v ) \\left( \\boldsymbol { b } _ { 10 } - \\boldsymbol { b } _ { 00 } \\right) + v \\left( \\boldsymbol { b } _ { 11 } - \\boldsymbol { b } _ { 01 } \\right) } \\\\\\\\ { x _ { v } ( u , v ) = ( 1 - u ) \\left( \\boldsymbol { b } _ { 01 } - \\boldsymbol { b } _ { 00 } \\right) + u \\left( \\boldsymbol { b } _ { 11 } - \\boldsymbol { b } _ { 10 } \\right) } \\\\\\\\ { x _ { u u } ( u , v ) = x _ { v v } ( u , v ) = 0 } \\\\\\\\ { x _ { u v } ( u , v ) = x _ { v u } ( u , v ) = \\boldsymbol { b } _ { 00 } - \\boldsymbol { b } _ { 10 } - \\boldsymbol { b } _ { 01 } + \\boldsymbol { b } _ { 11 } } \\end{array}\n$$\n**双三次曲面**\n$$\n\\begin{array} { l } { \\boldsymbol { b } _ { 00 } ^ { 1 } = ( 1 - u ) ( 1 - v ) \\boldsymbol { b } _ { 00 } + u ( 1 - v ) \\boldsymbol { b } _ { 10 } + ( 1 - u ) v \\boldsymbol { b } _ { 01 } + u v \\boldsymbol { b } _ { 11 } } \\\\\\\\ { \\boldsymbol { b } _ { 10 } ^ { 1 } = ( 1 - u ) ( 1 - v ) \\boldsymbol { b } _ { 10 } + u ( 1 - v ) \\boldsymbol { b } _ { 20 } + ( 1 - u ) v \\boldsymbol { b } _ { 11 } + u v \\boldsymbol { b } _ { 21 } } \\\\\\\\ { \\boldsymbol { b } _ { 01 } ^ { 1 } = ( 1 - u ) ( 1 - v ) \\boldsymbol { b } _ { 01 } + u ( 1 - v ) \\boldsymbol { b } _ { 11 } + ( 1 - u ) v \\boldsymbol { b } _ { 02 } + u v \\boldsymbol { b } _ { 12 } } \\\\\\\\ { \\boldsymbol { b } _ { 11 } ^ { 1 } = ( 1 - u ) ( 1 - v ) \\boldsymbol { b } _ { 11 } + u ( 1 - v ) \\boldsymbol { b } _ { 21 } + ( 1 - u ) v \\boldsymbol { b } _ { 12 } + u v \\boldsymbol { b } _ { 22 } } \\end{array}\n$$\n又有：\n$$\n\\begin{aligned} { \\pmb{x} ( u , v ) } \u0026amp;{ = ( 1 - u ) ( 1 - v ) \\boldsymbol { b } _ { 00 } ^ { 1 } + u ( 1 - v ) \\boldsymbol { b } _ { 10 } ^ { 1 } + ( 1 - u ) v \\boldsymbol { b } _ { 01 } ^ { 1 } + u v \\boldsymbol { b } _ { 11 } ^ { 1 } } \\\\\\\\ \u0026amp;{ = \\sum _ { i = 0 } ^ { 2 } \\sum _ { j = 0 } ^ { 2 } B _ { i } ^ { 2 } ( u ) B _ { j } ^ { 2 } ( v ) \\boldsymbol { b } _ { i , j } } \\end{aligned}\n$$\n2.2.2. Bézier块 使用Bernstein张量积作为基函数：\n$$\n\\boldsymbol { f } ( u , v ) = \\sum _ { i = 0 } ^ { d } \\sum _ { j = 0 } ^ { d } B _ { i } ^ { ( d ) } ( u ) B _ { j } ^ { ( d ) } ( v ) \\boldsymbol { p } _ { i , j }\n$$\n性质：\n 仿射不变性 凸包性 端点插值 边界曲线为边界控制点生成的Bézier曲线  边界的切向量：\n$$\n\\begin{aligned} \\left. \\frac { \\partial } { \\partial u } f ( u , v ) \\right| _ { u = 0 } \u0026amp; = \\sum _ { i = 0 } ^ { d } \\sum _ { j = 0 } ^ { d } B _ { i } ^ { ( d ) } ( v ) B _ { j } ^ { \\prime } ( 0 ) \\boldsymbol { p } _ { i , j } \\\\\\\\ \u0026amp; = d \\sum _ { j = 0 } ^ { d } B _ { j } ^ { ( d ) } ( v ) \\left( \\boldsymbol { p } _ { 1 , j } - \\boldsymbol { p } _ { 0 , j } \\right) \\\\\\\\ \\left. \\frac { \\partial } { \\partial u } \\boldsymbol { f } ( u , v ) \\right| _ { u = 1 } \u0026amp; = d \\sum _ { j = 0 } ^ { d } B _ { j } ^ { ( d ) } ( v ) \\left( \\boldsymbol { p } _ { d , j } - \\boldsymbol { p } _ { d - 1 , j } \\right) \\end{aligned}\n$$\n2.2.3. 连续性   $C^0$：边界控制点匹配\n  $C^1$：边界差值向量匹配\n  2.2.4. 极形式 曲面函数 $F$ 和极形式 $\\pmb{f}$ 分别为：\n$$\n\\begin{array}{ll}\nF:\\mathbb{R}\\times \\mathbb{R} \\to \\mathbb{R}^n \u0026amp; F(u,v)\\\\\\\\\n\\pmb{f}:\\mathbb{R}^d\\times \\mathbb{R}^d \\to \\mathbb{R}^n\n\\end{array}\n$$\n性质：\n  对角性：$\\pmb{f}(u,\\dots,u;v,\\dots,v)=F(u,v)$\n  对称性：$\\pmb{f}(u_1,\\dots,u_n;v_1,\\dots,v_m)=\\pmb{f}(u_{\\pi(1)},\\dots,u_{\\pi(n)};v_1,\\dots,v_{\\pi(m)})$，其中 $\\pi$ 和 $\\mu$ 为任意置换\n  多重仿射性\n$$\n\\begin{aligned}\n\\pmb{f}(u_1,\\dots,\\sum\\alpha_k u_i^{(k)},\\dots,u_n;v_1,\\dots,v_m)\u0026amp;=\\sum \\alpha_k\\pmb{f}(u_1,\\dots,u_i^{(k)},\\dots,u_n;v_1,\\dots,v_m)\\\\\\\\\n\\pmb{f}(u_1,\\dots,u_n;v_1,\\dots,\\sum\\alpha_k v_i^{(k)},\\dots,v_m)\u0026amp;=\\sum \\alpha_k\\pmb{f}(u_1,\\dots,u_n;v_1,\\dots,v_i^{(k)},\\dots,v_m)\\\n\\end{aligned}\n$$\n其中$\\sum \\alpha_k=1$\n  极形式分离$u$和$v$，能用于推导一些性质和算法，类似于曲线情形\nBézier控制点的极形式表示\nde Casteljau算法的极形式表示\n2.3. 张量积B样条曲面 2.3.1. B样条块   比Bézier块更具一般性\n  给定阶数$k$\n  给定在$u$、$v$方向上的结序列$(u_0,\\dots,u_{n+k})$、$(v_0,\\dots,v_{m+k})$\n  控制点阵：\n$$\n\\begin{array} { c c c } { d _ { 0,0 } } \u0026amp; { \\dots } \u0026amp; { d _ { n,0 } } \\\\\\\\ { \\dots } \u0026amp; { } \u0026amp; { \\dots } \\\\\\\\ { d _ { 0 , m } } \u0026amp; { \\dots } \u0026amp; { d _ { n , m } } \\end{array}\n$$\n  ","description":"张量积曲面与全度曲面介绍","id":5,"section":"posts","tags":["Geometry"],"title":"几何造型(6)：样条曲面","uri":"https://chaphlagical.github.io/zh/posts/geometry/spline_surface/"},{"content":"Bézier曲线和B样条曲线均不能用于表示圆锥曲线（如圆、椭圆、双曲线），我们需要一种更强大的样条曲线表示方法。\n1. 二次曲面与圆锥曲线 1.1. 定义 圆锥曲线可以表示为二次函数的零集：\n$$\n\\begin{aligned}\nax^2+bxy+cy^2+dx+ey+f\u0026amp;=0\\\\\\\\\n\\pmb{x}^\\top\\left[\\begin{matrix}\na \u0026amp; \\frac{b}{2}\\\\\\\\\n\\frac{b}{2} \u0026amp; c\n\\end{matrix}\\right]\n\\pmb{x}\n+\n\\left[\\begin{matrix}\nd \u0026amp; e\n\\end{matrix}\\right]\n\\pmb{x}\n+f=0\n\\end{aligned}\n$$\n 示例：\n圆锥的隐式表示 $Ax^2+By^2=z^2$\n平面的隐式表示 $z=Dx+Ey+F$\n圆锥曲线 $Ax^2+By^2=(Dx+Ey+F)^2$\n 二次曲线是二次方程（任意维数）的零集：\n$$\n\\{\\pmb{x}\\in \\mathbb{R}^d|\\pmb{x}^\\top M \\pmb{x}+\\pmb{b}^\\top \\pmb{x}+\\pmb{c}=0\\}\n$$\n 圆锥曲线是$d=2$时的二次曲线  1.2. 圆锥曲线的类型 记\n$$\nM:= \\left[\\begin{matrix}\na \u0026amp; \\frac{b}{2} \\\\\\\\\n\\frac{b}{2} \u0026amp; c\n\\end{matrix}\\right]\n$$\n$M$的特征值为：\n$$\n\\lambda_{1,2}=\\frac{a+c \\pm \\sqrt{(a-c)^2+b^2}}{2}\n$$\n则：\n 椭圆：$b^2\u0026lt;4ac$，$\\lambda_2\u0026gt;0$  圆：$b=0$，$a=c$   抛物线：$b^2=4ac$，$\\lambda_2=0$ 双曲线：$b^2\u0026gt;4ac$，$\\lambda\u0026lt;0$  1.3. 二次曲线投影 定义：\n 给定一条三维空间中的二次曲线 将$z$坐标设为齐次项$\\omega$，将曲线投影到平面$\\omega=1$说  齐次空间（Homogeneous）二次曲线为：\n$$\n\\pmb{f} ^ { ( h o m ) } ( t ) = \\pmb{p} _ { 0 } + t \\pmb{p} _ { 1 } + t ^ { 2 } \\pmb{p} _ { 2 } = \\left( \\begin{array} { c } { \\pmb{p} _ { 0 } \\cdot x } \\\\\\ { \\pmb{p} _ { 0 } \\cdot y } \\\\\\ { \\pmb{p} _ { 0 } \\cdot \\omega } \\end{array} \\right) + t \\left( \\begin{array} { c } { \\pmb{p} _ { 1 } \\cdot x } \\\\\\ { \\pmb{p} _ { 1 } \\cdot y } \\\\\\ { \\pmb{p} _ { 1 } \\cdot \\omega } \\end{array} \\right) + t ^ { 2 } \\left( \\begin{array} { c } { \\pmb{p} _ { 2 } \\cdot x } \\\\\\ { \\pmb{p} _ { 2 } \\cdot y } \\\\\\ { \\pmb{p} _ { 2 } \\cdot \\omega } \\end{array} \\right)\n$$\n欧氏空间（Euclidean）投影曲线：\n$$\n\\pmb{f} ^ { ( e u c l ) } ( t ) = \\frac { \\left( \\begin{array} { c } { \\pmb{p} _ { 0 } \\cdot x } \\\\\\\\ { \\pmb{p} _ { 0 } \\cdot y } \\end{array} \\right) + t \\left( \\begin{array} { c } { \\pmb{p} _ { 1 } \\cdot x } \\\\\\\\ { \\pmb{p} _ { 1 } \\cdot y } \\end{array} \\right) + t ^ { 2 } \\left( \\begin{array} { c } { \\pmb{p} _ { 2 } \\cdot x } \\\\\\\\ { \\pmb{p} _ { 2 } \\cdot y } \\end{array} \\right) } { \\pmb{p} _ { 0 } \\cdot \\omega + t \\pmb{p} _ { 1 } \\cdot \\omega + t ^ { 2 } \\pmb{p} _ { 2 } \\cdot \\omega }\n$$\n1.3.1. 抛物线 对于抛物线方程\n$$\ny=ax^2\n$$\n参数化为\n$$\n\\begin{cases}\nx=t\\\\\\\\\ny=at^2\n\\end{cases}\n$$\n则齐次空间方程：\n$$\n\\pmb f^{(hom)}(t)=\n\\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix}+\n\\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix}t+\n\\begin{pmatrix}0\\\\a\\\\0\\end{pmatrix}t^2\n$$\n因此投影曲线为：\n$$\n\\pmb f^{(eucl)}=\\frac{\n\\begin{pmatrix}0\\\\0\\end{pmatrix}+\n\\begin{pmatrix}1\\\\0\\end{pmatrix}t+\n\\begin{pmatrix}0\\\\a\\end{pmatrix}t^2\n}{1+0t+0t^2}\n$$\n1.3.2. 椭圆 对椭圆方程：\n$$\n\\frac{x^2}{a^2}+\\frac{y^2}{b^2}=1\n$$\n参数化为：\n$$\n\\begin{cases}\nx=a\\cos\\theta\\\\\\\\\ny=b\\cos\\theta\n\\end{cases}\n$$\n令$t=\\tan\\frac{\\theta}{2}$，当$t\\in[0,1]$时，$\\theta\\in[0,\\frac{\\pi}{4}]$，为四分之一圆，先考虑这四分之一的部分\n则参数方程可化为：\n$$\n\\begin{cases}\nx=\\dfrac{a(1-t^2)}{1+t^2}\\\\\\\\\ny=\\dfrac{2bt}{1+t^2}\n\\end{cases}\n$$\n则齐次空间方程：\n$$\n\\pmb f^{(hom)}(t)=\n\\begin{pmatrix}a\\\\0\\\\1\\end{pmatrix}+\n\\begin{pmatrix}0\\\\2b\\\\0\\end{pmatrix}t+\n\\begin{pmatrix}-a\\\\0\\\\1\\end{pmatrix}t^2\n$$\n因此投影曲线为：\n$$\n\\pmb f^{(eucl)}=\\frac{\n\\begin{pmatrix}a\\\\0\\end{pmatrix}+\n\\begin{pmatrix}0\\\\2b\\end{pmatrix}t+\n\\begin{pmatrix}-a\\\\0\\end{pmatrix}t^2\n}{1+0t+1t^2}\n$$\n1.3.3. 双曲线 对双曲线方程：\n$$\n\\frac{x^2}{a^2}-\\frac{y^2}{b^2}=1\n$$\n参数化为：\n$$\n\\begin{cases}\nx=\\dfrac{a}{\\cos\\theta}\\\\\\\\\ny=b\\tan\\theta\n\\end{cases}\n$$\n令$t=\\tan\\frac{\\theta}{2}$，当$t\\in[0,1]$时，$\\theta\\in[0,\\frac{\\pi}{4}]$，为四分之一圆，先考虑这四分之一的部分\n则参数方程可化为：\n$$\n\\begin{cases}\nx=\\dfrac{a(1+t^2)}{1-t^2}\\\\\\\\\ny=\\dfrac{2bt}{1-t^2}\n\\end{cases}\n$$\n则齐次空间方程：\n$$\n\\pmb f^{(hom)}(t)=\n\\begin{pmatrix}a\\\\0\\\\1\\end{pmatrix}+\n\\begin{pmatrix}0\\\\2b\\\\0\\end{pmatrix}t+\n\\begin{pmatrix}a\\\\0\\\\-1\\end{pmatrix}t^2\n$$\n因此投影曲线为：\n$$\n\\pmb f^{(eucl)}=\\frac{\n\\begin{pmatrix}a\\\\0\\end{pmatrix}+\n\\begin{pmatrix}0\\\\2b\\end{pmatrix}t+\n\\begin{pmatrix}a\\\\0\\end{pmatrix}t^2\n}{1+0t-1t^2}\n$$\n2. 有理Bézier曲线 2.1. 定义 $\\mathbb R^n$上定义的$d$阶有理Bézier曲线：\n 构成$n+1$维上的$d$阶Bézier曲线 最后一维视为齐次项 欧式坐标由投影变换得到  $$\n\\begin{aligned}\n\\pmb f^{(hom)}(t)\u0026amp;=\\sum_{i=0}^nB_i^{(d)}(t)\\pmb p_i,\\quad \\pmb p_i\\in\\mathbb{R}^{n+1}\\\\\\\\\n\\pmb f^{(eucl)}(t)\u0026amp;=\\dfrac{\\sum_{i=0}^nB_i^{(d)}(t)\\begin{pmatrix}p_i^{(1)}\\\\\\vdots\\\\p_i^{(n)}\\end{pmatrix}}{\\sum_{i=0}^nB_i^{(d)}(t)p_i^{(n+1)}}\n\\end{aligned}\n$$\n等价地可写为权重形式：\n$$\n\\begin{aligned}\n\\pmb f^{(eucl)}(t)\u0026amp;=\\dfrac{\\sum_{i=0}^nB_i^{(d)}(t)\\omega_i\\begin{pmatrix}p_i^{(1)}\\\\\\vdots\\\\p_i^{(n)}\\end{pmatrix}}{\\sum_{i=0}^nB_i^{(d)}(t)\\omega_i}\\\\\\\\\n\u0026amp;=\\sum_{i=0}^nq_i(t)\\pmb p_i\n\\end{aligned}\n$$\n其中，\n$$\nq_i(t)=\\dfrac{B_i^{(d)}(t)\\omega_i}{\\sum_{i=0}^nB_i^{(d)}(t)\\omega_i}\n$$\n满足：$\\sum_{i=0}^nq_i(t)=1$\n 几何解释：\n普通的Bézier曲线通过中心投影变换得到有理Bézier曲线\n 2.2. 有理de Casteljau算法 三种计算方法：\n  在$n+1$维上进行计算，最后再投影：$\\boldsymbol { b } _ { i } ^ { ( r ) } ( t ) = ( 1 - t ) \\boldsymbol { b } _ { i } ^ { ( r - 1 ) } ( t ) + t \\boldsymbol { b } _ { i + 1 } ^ { ( r - 1 ) } ( t )$\n  分别计算分子和分母，最后进行除法，类似于第一种\n  每一步都作投影除法：\n$$\n\\begin{aligned}\n\\pmb b_i^{(r)}(t)=(1-t)\\frac{\\omega_i^{(r-1)}(t)}{\\omega_i^{(r)}(t)}\\pmb b_i^{(r-1)}(t)+t\\frac{\\omega_{i+1}^{(r-1)}(t)}{\\omega_i^{(r)}(t)}\\pmb b_{i+1}^{(r-1)}(t)\n\\end{aligned}\n$$\n其中，\n$$\n\\omega_i^{(r)}(t)=(1-t)\\omega_i^{(r-1)}(t)+t\\omega_{i+1}^{(r-1)}(t)\n$$\n  3. 二次有理Bézier曲线 3.1. 二次有理Bézier曲线的标准型 二次有理曲线能够充要地表达圆锥曲线，二次有理Bézier曲线形式如下：\n$$\n\\begin{aligned}\n\\pmb{f} ^ { ( e u c l ) } ( t )\n\u0026amp;= \\frac { B _ { 0 } ^ { ( 2 ) } ( t ) \\omega _ { 0 } \\boldsymbol { p } _ { 0 } + B _ { 1 } ^ { ( 2 ) } ( t ) \\omega _ { 1 } \\boldsymbol { p } _ { 1 } + B _ { 2 } ^ { ( 2 ) } ( t ) \\omega _ { 2 } \\boldsymbol { p } _ { 2 } } { B _ { 0 } ^ { ( 2 ) } ( t ) \\omega _ { 0 } + B _ { 1 } ^ { ( 2 ) } ( t ) \\omega _ { 1 } + B _ { 2 } ^ { ( 2 ) } ( t ) \\omega _ { 2 } }\\\\\\\\\n\u0026amp;=\\frac { (1-t)^2 \\omega _ { 0 } \\boldsymbol { p } _ { 0 } + 2t(1-t) \\omega _ { 1 } \\boldsymbol { p } _ { 1 } + t^2 \\omega _ { 2 } \\boldsymbol { p } _ { 2 } } { (1-t)^2 \\omega _ { 0 } + 2t(1-t) \\omega _ { 1 } + t^2 \\omega _ { 2 } }\n\\end{aligned}\n$$\n只考虑曲线的形状，进行重参数化：\n$$\nt=\\frac{\\tilde{t}}{\\alpha(1-\\tilde{t})+\\tilde{t}}\n$$\n这样一来形状仅与参数$\\alpha$有关\n代入二次有理Bézier曲线形式：\n$$\n\\begin{aligned} f ^ { ( e u c l ) } ( t )\n=\u0026amp; \\frac {\n\\left( \\frac { \\alpha ( 1 - \\tilde { t } ) } { \\alpha ( 1 - \\tilde { t } ) + \\tilde { t } } \\right) ^ { 2 } \\omega _ { 0 } \\boldsymbol { p } _ { 0 }\n+ 2 \\left( \\frac { \\alpha ( 1 - \\tilde { t } ) } { \\alpha ( 1 - \\tilde { t } ) + \\tilde { t } } \\right) \\left( \\frac { \\tilde { t } } { \\alpha ( 1 - \\tilde { t } ) + \\tilde { t } } \\right) \\omega _ { 1 } \\boldsymbol { p } _ { 1 }\n+ \\left( \\frac { \\tilde { t } } { \\alpha ( 1 - \\tilde { t } ) + \\tilde { t } } \\right) ^ { 2 } \\omega _ { 2 } \\boldsymbol { p } _ { 2 }\n}{\n\\left( \\frac { \\alpha ( 1 - \\tilde { t } )} { \\alpha ( 1 - \\tilde { t } ) + \\tilde { t } } \\right) ^ { 2 } \\omega _ { 0 }\n+ 2 \\left( \\frac { \\alpha ( 1 - \\tilde { t } ) } { \\alpha ( 1 - \\tilde { t } ) + \\tilde { t } } \\right) \\left( \\frac { \\tilde { t } } { \\alpha ( 1 - \\tilde { t } ) + \\tilde { t } } \\right) \\omega _ { 1 }\n+ \\left( \\frac { \\tilde { t } } { \\alpha ( 1 - \\tilde { t } ) + \\tilde { t } } \\right) ^ { 2 } \\omega _ { 2 }\n}\\\\\\\\\n= \u0026amp;\\frac { \\alpha ^ { 2 } ( 1 - \\tilde { t } ) ^ { 2 } \\omega _ { 0 } \\boldsymbol { p } _ { 0 } + 2 \\alpha ( 1 - \\tilde { t } ) \\tilde { t } \\omega _ { 1 } \\boldsymbol { p } _ { 1 } + \\tilde { t } ^ { 2 } \\omega _ { 2 } \\boldsymbol { p } _ { 2 } } { \\alpha ^ { 2 } ( 1 - \\tilde { t } ) ^ { 2 } \\omega _ { 0 } + 2 \\alpha ( 1 - \\tilde { t } ) \\tilde { t } \\omega _ { 1 } + \\tilde { t } ^ { 2 } \\omega _ { 2 } }\\\\\\\\\n= \u0026amp;\\frac { \\alpha ^ { 2 } B_0^{(2)}(\\tilde{t}) \\omega _ { 0 } \\boldsymbol { p } _ { 0 } + \\alpha B_1^{(2)}(\\tilde{t}) \\omega _ { 1 } \\boldsymbol { p } _ { 1 } + B_2^{(2)}(\\tilde{t}) \\omega _ { 2 } \\boldsymbol { p } _ { 2 } } { \\alpha ^ { 2 } B_0^{(2)}(\\tilde{t}) \\omega _ { 0 } + \\alpha B_1^{(2)}(\\tilde{t}) \\omega _ { 1 } + B_2^{(2)}(\\tilde{t}) \\omega _ { 2 } }\\\\\\\\\n\\xlongequal{\\alpha=\\sqrt{\\frac{\\omega_2}{\\omega_0}}}\u0026amp;\\frac { B_0^{(2)}(\\tilde{t}) \\omega _ { 2 } \\boldsymbol { p } _ { 0 } + B_1^{(2)}(\\tilde{t}) \\sqrt{\\frac{\\omega_2}{\\omega_0}} \\omega _ { 1 } \\boldsymbol { p } _ { 1 } + B_2^{(2)}(\\tilde{t}) \\omega _ { 2 } \\boldsymbol { p } _ { 2 } } { B_0^{(2)}(\\tilde{t}) \\omega _ { 2 } + B_1^{(2)}(\\tilde{t}) \\sqrt{\\frac{\\omega_2}{\\omega_0}} \\omega _ { 1 } + B_2^{(2)}(\\tilde{t}) \\omega _ { 2 } }\\\\\\\\\n=\u0026amp;\\frac { B_0^{(2)}(\\tilde{t})\\boldsymbol { p } _ { 0 } + B_1^{(2)}(\\tilde{t}) \\sqrt{\\frac{1}{\\omega_0\\omega_2}} \\omega _ { 1 } \\boldsymbol { p } _ { 1 } + B_2^{(2)}(\\tilde{t}) \\boldsymbol { p } _ { 2 } } { B_0^{(2)}(\\tilde{t}) + B_1^{(2)}(\\tilde{t}) \\sqrt{\\frac{1}{\\omega_0\\omega_2}} \\omega _ { 1 } + B_2^{(2)}(\\tilde{t}) }\\\\\\\\\n\\xlongequal{\\omega=\\sqrt{\\frac{1}{\\omega_0\\omega_2}}\\omega_1}\u0026amp;\\frac { B_0^{(2)}(\\tilde{t})\\boldsymbol { p } _ { 0 } + B_1^{(2)}(\\tilde{t}) \\omega \\boldsymbol { p } _ { 1 } + B_2^{(2)}(\\tilde{t}) \\boldsymbol { p } _ { 2 } } { B_0^{(2)}(\\tilde{t}) + B_1^{(2)}(\\tilde{t}) \\omega + B_2^{(2)}(\\tilde{t}) }\n\\end{aligned}\n$$\n得到二次有理Bézier曲线的标准形式\n3.2. 分类 从标准形式出发，设$\\omega_0=\\omega_2=1$，$\\omega_1=\\omega$\n则有：\n $\\omega\u0026lt;1$：椭圆曲线段 $\\omega=1$：抛物线曲线段 $\\omega\u0026gt;1$：双曲线曲线段   证明：\n将参数形式转化为隐式形式，将曲线表示为重心坐标：\n$$\n\\pmb{f}(t)=\\tau_0(t)\\pmb{p}_0+\\tau_1(t)\\pmb{p}_1+\\tau_2(t)\\pmb{p}_2\n$$\n对比有理二次Bézier曲线的标准形式有：\n$$\n\\begin{array}{lll}\n\\tau_0(t) \u0026amp;= \\frac{(1-t)^2\\omega_0}{\\omega(t)}\n\u0026amp;\\Rightarrow 1-t=\\sqrt{\\frac{\\tau_0(t)\\omega(t)}{\\omega_0}}\\\\\\\\\n\\tau_1(t) \u0026amp;= \\frac{2t(1-t)\\omega_1}{\\omega(t)}\\\\\\\\\n\\tau_2(t) \u0026amp;= \\frac{t^2\\omega_2}{\\omega(t)}\n\u0026amp;\\Rightarrow t=\\sqrt{\\frac{\\tau_2(t)\\omega(t)}{\\omega_2}}\\\n\\end{array}\n$$\n其中，\n$$\n\\omega(t)=(1-t)^2\\omega_0+2t(1-t)\\omega_1+t^2\\omega_2\n$$\n则有：\n$$\n\\tau_1(t)\n=2\\frac{\\omega_1}{\\omega(t)}\\sqrt{\\frac{\\tau_0(t)\\omega(t)}{\\omega_0}\\frac{\\tau_2(t)\\omega(t)}{\\omega_2}}\n=2\\omega_1\\sqrt{\\frac{\\tau_0(t)\\tau_2(t)}{\\omega_0\\omega_2}}\n$$\n利用：\n$$\n\\tau_2(t)=1-\\tau_0(t)-\\tau_1(t)\n$$\n整理得到：\n$$\n4\\omega_1^2\\tau_0^2(t)+4\\omega_1^2\\tau_0(t)\\tau_1(t)+\\omega_0\\omega_2\\tau_1^2(t)-4\\omega_1^2\\tau_0(t)=0\n$$\n对于标准形式 $\\omega_0=\\omega_2=1$，$\\omega_1=\\omega$，则\n$$\n4\\omega^2\\tau_0^2(t)+4\\omega^2\\tau_0(t)\\tau_1(t)+\\tau_1^2(t)-4\\omega^2\\tau_0(t)=0\n$$\n这里$\\tau_0$ 和 $\\tau_1$ 就相当于 $x$ 和 $y$，因此，由圆锥曲线的隐式表达可知：\n$$\n\\lambda_{1,2}=\\frac{4\\omega^2+1\\pm\\sqrt{(4\\omega^2-1)^2+16\\omega^4}}{2}\n$$\n得到：\n $\\omega=1$：抛物线 $\\omega\u0026lt;1$：椭圆 $\\omega\u0026gt;1$：双曲线   3.3. 对偶 对于二次有理曲线的一般形式，$t\\in[0,1]$：\n$$\n\\pmb x(t)=\\frac{(1-t)^2\\pmb b_0+2t(1-t)\\omega\\pmb b_1+t^2\\pmb b_2}{(1-t)^2+2t(1-t)\\omega+t^2}\n$$\n对偶段为$t\\in\\mathbb R\\backslash [0,1]$，则可用参数化\n$$\n\\hat t=\\frac{t}{2t-1}\n$$\n当$t\\in(0,\\frac{1}{2})$时，$\\hat t\\in(0,-\\infty)$；当$t\\in(\\frac{1}{2},1)$时，$\\hat t\\in(+\\infty，1)$\n代入二次有理曲线的一般形式可得：\n$$\n\\begin{aligned}\n\\pmb{x}(\\hat{t})\u0026amp;= \\frac { ( 1 - \\hat { t } ) ^ { 2 } \\pmb{p} _ { 0 } + 2 \\hat { t } ( 1 - \\hat { t } ) \\omega \\pmb{p} _ { 1 } + \\hat { t } ^ { 2 } \\pmb{p} _ { 2 } } { ( 1 - \\hat { t } ) ^ { 2 } + 2 \\hat { t } ( 1 - \\hat { t } ) \\omega + \\hat { t } ^ { 2 } }\\\\\\\\\n\u0026amp;= \\frac { ( 1 - t ) ^ { 2 } \\pmb{p} _ { 0 } - 2 t ( 1 - t ) \\omega \\pmb{p} _ { 1 } + t ^ { 2 } \\pmb{p} _ { 2 } } { ( 1 - t ) ^ { 2 } - 2 t ( 1 - t ) \\omega + t ^ { 2 } }\\end{aligned}\n$$\n区别在于$\\omega$取反\n 示例：\n 考虑分母\n$$\n\\omega(t)=(1-t)^2-2t(1-t)\\omega+t^2\n$$\n为一个图像如下的抛物线：\n可推得：\n $\\omega\u0026lt;1$：没有奇异点，椭圆 $\\omega=1$：有一个奇异点，抛物线 $\\omega\u0026gt;1$：有两个奇异点，双曲线  3.4. 圆锥曲线的绘制   先将圆锥曲线的隐式表示转为参数表示：\n$$\n\\begin{cases}\nx=x(t)\\\\\\\\\ny=y(t)\n\\end{cases}\n$$\n  计算二次有理曲线形式：\n$$\n\\pmb f(t)=\\frac{(1-t)^2\\pmb b_0+2t(1-t)\\omega\\pmb b_1+t^2\\pmb b_2}{(1-t)^2+2t(1-t)\\omega+t^2}\n$$\n  求得控制点$\\pmb b_0$，$\\pmb b_1$，$\\pmb b_2$，构成矩阵$P$：\n$$\nP=(\\pmb b_0,\\pmb b_1,\\pmb b_2)\n$$\n  对于采样点$0=t_0=t_1=\\cdots=t_n=1$，构成矩阵：\n$$\nT=\\begin{pmatrix}\n(1-t_0)^2\u0026amp;(1-t_1)^2\u0026amp;\\cdots\u0026amp;(1-t_n)^2\\\\\n2t_0(1-t_0)\u0026amp;2t_1(1-t_1)\u0026amp;\\cdots\u0026amp;2t_n(1-t_n)\\\\\nt_0^2\u0026amp;t_1^2\u0026amp;\\cdots\u0026amp;t_n^2\n\\end{pmatrix}\n$$\n  曲线点由$X=PT$进行计算\n  对于对偶曲线，控制点矩阵为：\n$$\n\\tilde P=(\\pmb b_0,-\\pmb b_1,\\pmb b_2)\n$$\n  对偶曲线由$X=\\tilde PT$进行计算\n  3.5. Farin点 $$\n\\begin{aligned}\n\\overline{\\pmb{f}_ i}\n\u0026amp;=\\frac{1}{2}(\\overline{\\pmb{b}_ i}+\\overline{\\pmb{b}_ {i+1}})\\\\\\\\\n\\pmb{f}_ i\u0026amp;=\\frac{\\omega_ ib_ i+\\omega_{i+1}b_ {i+1}}{\\omega_ i+\\omega_ {i+1}}\n\\end{aligned}\n$$\n满足关系\n$$\n\\frac { \\omega _ { i + 1 } } { \\omega _ { i } } = \\frac { \\left\\| \\pmb{b} _ { i } - \\pmb{f} _ { i } \\right\\| } { \\left\\| \\pmb{b} _ { i + 1 } - \\pmb{f} _ { i } \\right\\| }\n$$\n对于标准形式，有\n$$\n\\pmb{q} _ { 0 } = \\frac { \\pmb{p} _ { 0 } + \\omega _ { 1 } \\pmb{p} _ { 1 } } { 1 + \\omega _ { 1 } } , \\pmb{q} _ { 1 } = \\frac { \\pmb{p} _ { 1 } + \\omega _ { 1 } \\pmb{p} _ { 2 } } { 1 + \\omega _ { 1 } }\n$$\n3.6. 二次有理Bézier曲线的性质 3.6.1. 端点插值 $$\n\\begin{align}\n\\pmb f(0)\u0026amp;=\\pmb b_0\\\\\\\\\n\\pmb f(1)\u0026amp;=\\pmb b_2\n\\end{align}\n$$\n3.6.2. 凸包性质 曲线位于凸包$(\\pmb{b}_ 0,\\pmb{f}_ 0,\\dots,\\pmb{f}_ {n-1},\\pmb{b}_ n)$内\n3.6.3. 导数性质 令：\n$$\n\\pmb f(t)=\\frac{\\sum_{i=0}^nB_i^{(d)}(t)\\omega_i\\pmb p_i}{\\sum_{i=0}^nB_i^{(d)}(t)\\omega_i}=:\\frac{\\pmb p(t)}{\\omega(t)}\n$$\n因此，有\n$$\n\\begin{aligned}\n\\pmb f(t)=\\frac{\\pmb p(t)}{\\omega(t)}\u0026amp;\\Rightarrow\\pmb p(t)=\\pmb f(t)\\omega(t)\\\\\\\\\n\u0026amp;\\Rightarrow \\pmb p'(t)=\\pmb f'(t)\\omega(t)+\\pmb f(t)\\omega'(t)\\\\\\\\\n\u0026amp;\\Rightarrow \\pmb f'(t)=\\frac{\\pmb p'(t)-\\pmb f(t)\\omega'(t)}{\\omega(t)}\n\\end{aligned}\n$$\n对于边界点，有：\n$$\n\\begin{aligned}\n\\pmb{f}^\\prime(0)\u0026amp;=\\frac{d(\\omega_1\\pmb{p}_1-\\omega_0\\pmb{p}_0)-d(\\omega_1-\\omega_0)\\pmb{p}_0}{\\omega_0}=d\\frac{\\omega_1}{\\omega_0}(\\pmb{p}_1-\\pmb{p}_0)\\\\\\\\\n\\pmb{f}^\\prime(1)\u0026amp;=\\frac{d(\\omega_{d}\\pmb{p}_{d}-\\omega_{d-1}\\pmb{p}_{d-1})-d(\\omega_{d}-\\omega_{d-1})\\pmb{p}_{d}}{\\omega_d}=d\\frac{\\omega_{d-1}}{\\omega_d}(\\pmb{p}_d-\\pmb{p}_{d-1})\n\\end{aligned}\n$$\n","description":"有理样条曲线的原理与实现","id":6,"section":"posts","tags":["Geometry"],"title":"几何造型(5)：有理样条曲线","uri":"https://chaphlagical.github.io/zh/posts/geometry/rational/"},{"content":"1. 基本思想 1.1. 仿射组合(Affine Combinations) $n$点的仿射组合为：\n$$\np_{\\pmb\\alpha}=\\sum_{i=1}^n\\alpha_i\\pmb{p}_i\n$$\n其中，$\\sum_{i=1}^n\\alpha_i=1$\n函数 $f$ 对参数 $x_i$ 是仿射的是指：\n$$\nf \\left( x _ { 1 } , \\ldots , \\sum _ { k = 1 } ^ { n } \\alpha _ { k } x _ { i } ^ { ( k ) } , \\ldots , x _ { m } \\right) = \\sum _ { k = 1 } ^ { n } \\alpha _ { k } f \\left( x _ { 1 } , \\ldots , x _ { i } ^ { ( k ) } , \\ldots , x _ { m } \\right)\n$$\n其中，$\\sum_{i=1}^n\\alpha_i=1$\n示例：\n   两点间的仿射插值为：\n$$\n\\pmb{p}_\\alpha = (1-\\alpha)\\pmb{p}_1+\\alpha\\pmb{p}_2\n$$\n  三点间的仿射组合（亦为重心坐标）为：\n$$\n\\pmb{p}=\\alpha\\pmb{p}_1+\\beta\\pmb{p}_2+\\gamma\\pmb{p}_3\n$$\n其中，$\\alpha+\\beta+\\gamma=1$\n系数可用坐标表示：\n$$\n\\alpha = \\frac { \\operatorname { area } \\left( \\Delta \\left( p _ { 2 } , p _ { 3 } , p \\right) \\right) } { \\operatorname { area } \\left( \\Delta \\left( p _ { 1 } , p _ { 2 } , p _ { 3 } \\right) \\right) } ,\n\\beta = \\frac { \\operatorname { area } \\left( \\Delta \\left( p _ { 1 } , p _ { 3 } , p \\right) \\right) } { \\operatorname { area } \\left( \\Delta \\left( p _ { 1 } , p _ { 2 } , p _ { 3 } \\right) \\right) } ,\n\\gamma = \\frac { \\operatorname { area } \\left( \\Delta \\left( p _ { 1 } , p _ { 2 } , p \\right) \\right) } { \\operatorname { area } \\left( \\Delta \\left( p _ { 1 } , p _ { 2 } , p _ { 3 } \\right) \\right) }\n$$\n   1.2. 动机 我们希望：将（分段）多项式曲线表示为迭代线性（仿射）插值的形式\n例如：\n  对于一个多项式：$p(t)=at^3+bt^2+ct+d$\n  能够写为$p(t)=a\\cdot t\\cdot t\\cdot t+b\\cdot t\\cdot t+c\\cdot t+d$\n  将每个变量t解释为单独的参数：\n$$\n\\pmb p(t_1,t_2,t_3)=\\pmb at_1t_2t_3+\\pmb bt_1t_2+\\pmb ct_1+\\pmb d\n$$\n $t_1$控制$\\pmb a+\\pmb b+\\pmb c$方向上的移动 $t_2$控制$\\pmb a+\\pmb b$方向上的移动 $t_3$控制$\\pmb a$方向上的移动    上述方法存在的问题：固定方向，多种表示形式\n  2. 极形式 2.1. 定义 将（分段）多项式曲线表示为迭代线性（仿射）插值的形式的升级版解决方法：极形式/开花\n$n$次多项式$F:\\mathbb{R}\\to\\mathbb{R}$ 的极形式/开花$f:\\mathbb{R}^n\\to\\mathbb{R}$ 是一个满足以下性质的$ d $维函数：\n 对角性Diagonality：$f(t,\\dots,t)=F(t)$ 对称性Symmetry：对任意置换 $\\pi$，$f(t_1,\\dots,t_d)=f(t_{\\pi(1)},\\dots,t_{\\pi(d)})$ 多仿射Multi-affine：$f(t_1,\\dots,\\sum_\\limits{k=1}^n\\alpha_kt_i^{(k)},\\dots,t_d)=\\sum_{k=1}^n\\alpha_k f(t_1,\\dots,t_i^{(k)},\\dots,t_d)$  2.2. 唯一性 多项式 $F(t)$ 与极形式 $f(t_1,\\dots,t_n)$ 是一一对应的，常用多项式的极形式如下：\n 0 次：$f=c_0$ 1 次：$f(t_1)=c_0+c_1t_1$ 2 次：$f(t_1,t_2)=c_0+c_1\\frac{t_1+t_2}{2} + c_2t_1t_2$ 3 次：$f(t_1,t_2,t_3)=c_0+c_1\\frac{t_1+t_2+t_3}{3}+c_2\\frac{t_1t_2+t_2t_3+t_1t_3}{3}+c_3t_1t_2t_3$  一般形式：\n$$\n\\begin{aligned}\nF(t)\u0026amp;=\\sum_{i=0}^n c_i t^i\\\\\\\\\nf(t_1,\\cdots,t_n)\u0026amp;=\\sum_{i=0}^n c_i \\begin{pmatrix}n\\\\\\\\i\\end{pmatrix}^{-1}\\sum_{S\\subseteq\\{1,\\cdots,n\\},|S|=i}\\prod_{j\\in S}t_i\n\\end{aligned}\n$$\n2.3. 泛化 对于高维情况：\n$$\n\\begin{aligned}\nF\u0026amp;:\\mathbb{R}^m\\to \\mathbb{R}^n\\\nf\u0026amp;:\\mathbb{R}^{d\\times m}\\to \\mathbb{R}^n\n\\end{aligned}\n$$\n满足性质\n 对角性 diagonality：$f(\\pmb{t},\\dots,\\pmb{t})=F(\\pmb{t})$ 对称性 symmetry：对任意置换 $\\pi$，$f(\\pmb t_1,\\cdots \\pmb t_d)=f(\\pmb t_ {\\pi(1)},\\cdots,\\pmb t_ {\\pi(d)})$ 多仿射 multi-affine：$f(\\pmb t_1,\\cdots,\\sum_{k=1}^n\\alpha_k\\pmb t_i^{(k)},\\cdots,\\pmb t_d)=\\sum_{k=1}^n\\alpha_kf(\\pmb t_1,\\cdots,\\pmb t_i^{(k)},\\cdots,\\pmb t_d)$  对于参数向量：\n  需要区分点 point 和向量 vectors（点的差值）\n  使用“帽子”记号 $\\hat{v}=p-q$ 来表示向量\n  1向量：$\\hat{1}=1-0,\\hat{\\pmb{1}}=[1,\\dots,1]^\\top-\\pmb{0}$\n  极形式中向量的递归定义：\n$$\n\\begin{aligned}\nf(\\underbrace{t_1,\\dots,t_{n-k}}_{n-k},\\underbrace{\\hat{v}_1,\\dots,\\hat{v}_k}_k)\u0026amp;:=\\\\\\\\\nf(\\underbrace{t_1,\\dots,t_{n-k}}_{n-k},p_1,\\underbrace{\\hat{v}_2,\\dots,\\hat{v}_{k-1}}_{k-1})\u0026amp;-f(\\underbrace{t_1,\\dots,t_{n-k}}_{n-k},q_1,\\underbrace{\\hat{v}_2,\\dots,\\hat{v}_{k-1}}_{k-1})\n\\end{aligned}\n$$\n其中 $\\hat{v}_i=p_i-q_i(i=1,\\dots,k)$\n  2.4. 导数 $$\nf(t_1,\\cdots,t_n)=\\sum_{i=0}^n c_i \\begin{pmatrix}n\\\\\\\\i\\end{pmatrix}^{-1}\\sum_{S\\subseteq\\{1,\\cdots,n\\},|S|=i}\\prod_{j\\in S}t_i\n$$\n  $c_i$与$t=0$处的导数值相关\n  因此有：\n$$\nc_k=\\frac{1}{k!}\\frac{\\mathrm d^k}{\\mathrm dt^k}F(0)=\\begin{pmatrix}n\\\\\\\\k\\end{pmatrix}^{-1}f(\\underbrace{0,\\dots,0}_{n-k},\\underbrace{\\hat{1},\\dots,\\hat{1}}_k)\n$$\n  一般情况：\n$$\n\\frac{\\mathrm d^k}{\\mathrm dt^k}F(t)=\\frac{n!}{(n-k)!}f(\\underbrace{t,\\dots,t}_{n-k},\\underbrace{\\hat{1},\\dots,\\hat{1}}_k)\n$$\n  示例：\n $$\n\\begin{aligned}\nF(t)\u0026amp;=c_0+c_1t+c_2t^2+c_3t^3\\\\\\\\\nf \\left( t _ { 1 } , t _ { 2 } , t _ { 3 } \\right) \u0026amp;= c _ { 0 } + c _ { 1 } \\frac { t _ { 1 } + t _ { 2 } + t _ { 3 } } { 3 } + c _ { 1 } \\frac { t _ { 1 } t _ { 2 } + t _ { 1 } t _ { 3 } + t _ { 2 } t _ { 3 } } { 3 } + c _ { 3 } t _ { 1 } t _ { 2 } t _ { 3 }\\\\\\\\\nF ^ { \\prime } ( t )\n\u0026amp;= 3f(t,t,\\hat{1})\\\\\\\\\n\u0026amp;= 3 \\left[f(t,t,1)-f(t,t,0)\\right]\\\\\\\\\n\u0026amp;= 3 \\left[ \\left( c _ { 0 } + c_1\\frac { 1 + t + t } { 3 } + c _ { 2 } \\frac { 1 t + t t + 1 t } { 3 } + c _ { 3 } 1 t t \\right) - \\left( c _ { 0 } + c_1\\frac { 0 + t + t } { 3 } + c _ { 2 } \\frac { t t } { 3 } \\right) \\right]\\\\\\\\\n\u0026amp;= 3 \\left( c _ { 1 } \\frac { 1 } { 3 } + c _ { 2 } \\frac { 2 t } { 3 } + c _ { 3 } t t \\right)\\\\\\\\\n\u0026amp;= 3 c _ { 3 } t ^ { 2 } + 2 c _ { 2 } t + c _ { 1 }\n\\end{aligned}\n$$\n 2.5. 连续性条件 下列三个条件分别等价\n $F$ 和 $G$ 在 $t$ 点 $C^k$ 连续 $\\forall t_1,\\dots,t_k, f(t,\\dots,t,t_1,\\dots,t_k)=g(t,\\dots,t,t_1,\\dots,t_k)$ $f ( t , \\ldots , t , \\underbrace{\\hat { 1 } , \\ldots , \\hat { 1 }}_k ) = g ( t , \\ldots , t , \\underbrace{\\hat { 1 } , \\ldots , \\hat { 1 }}_k )$   2$\\Leftrightarrow$3证明：\n$$\n\\begin{aligned}\nf(t,\\cdots,t,t_1)\u0026amp;=f(t,\\cdots,t,(t_1-0))\\\\\\\\\n\u0026amp;=t_1f(t,\\cdots,t,1)-f(t,\\cdots,t,0)\\\\\\\\\n\u0026amp;=t_1f(t,\\cdots,t,\\hat 1)\n\\end{aligned}\n$$\n 举例：\n  $\\forall t_1,t_2,t_3$：$f(t_1,t_2,t_3)=g(t_1,t_2,t_3)\\Rightarrow$同一条曲线 $\\forall t_1,t_2$：$f(t_1,t_2,t)=g(t_1,t_2,t)\\Rightarrow$在$t$处$C^2$连续 $\\forall t_1$：$f(t_1,t,t)=g(t_1,t,t)\\Rightarrow$在$t$处$C^1$连续 $f(t,t,t)=g(t,t,t)\\Rightarrow$在$t$处$C^0$连续   2.6. 升阶 给定$ d $次函数 $f(t_1,\\dots,t_d)$，升阶得：\n$$\nf ^ { ( + 1 ) } \\left( t _ { 1 } , \\ldots , t _ { d + 1 } \\right) = \\frac { 1 } { d + 1 } \\sum _ { i = 1 } ^ { d + 1 } f \\left( t _ { 1 } , \\ldots , t _ { i - 1 } , t _ { i + 1 } , \\ldots , t _ { d + 1 } \\right)\n$$\n 注意：$t_i$没了   证明$F^{(+1)}(t)=F(t)$：\n$$\n\\begin{aligned} \\forall t : f ^ { ( + 1 ) } ( t , \\ldots , t ) \u0026amp; = \\left. \\frac { 1 } { d + 1 } \\sum _ { i = 1 } ^ { d + 1 } f \\left( t _ { 1 } , \\ldots , t _ { i - 1 } , t _ { i + 1 } , \\ldots , t _ { d + 1 } \\right) \\right| _ { t _ { 1 } = \\cdots t _ { d + 1 } = t } \\\\\\\\ \u0026amp; = \\frac { 1 } { d + 1 } \\sum _ { i = 1 } ^ { d + 1 } f ( t , \\ldots , t ) \\\\\\\\ \u0026amp; = f ( t , \\ldots , t ) \\end{aligned}\n$$\n 3. Bézier样条的极形式应用 3.1. 回顾De Casteljau算法 之前我们已经推导过构造Bézier曲线的De Casteljau算法：\n$$\n\\pmb b_i^{(r)}=(1-t)\\pmb b_i^{(r-1)}+t\\pmb b_{i+1}^{(r-1)}\n$$\n三次Bézier曲线的构造过程如下图所示：\n3.2. Bézier样条的极形式 根据极形式的仿射组合性质，导出Bernstein基函数的组合形式：\n$$\n\\begin{aligned}\nf(t,\\cdots,t)\n\u0026amp;=(1-t)f(t,\\cdots,t,0)+tf(t,\\cdots,t,1)\\\\\\\\\n\u0026amp;=(1-t)[(1-t)f(t,\\cdots,t,0,0)+tf(t,\\cdots,t,0,1)]+\nt[(1-t)f(t,\\cdots,t,1,0)+tf(t,\\cdots,t,1,1)]\\\\\\\\\n\u0026amp;=(1-t)^2f(t,\\cdots,t,0,0)+2t(1-t)f(t,\\cdots,0,1)+t^2f(t,\\cdots,t,1,1)\\\\\\\\\n\u0026amp;=\\cdots\\\\\\\\\n\u0026amp;=\\sum_{i=0}^n\\begin{pmatrix}n\\\\\\\\i\\end{pmatrix}t^i(1-t)^{n-i}f(\\underbrace{0,\\dots,0}_{n-i},\\underbrace{1,\\dots,1}_i)\\\\\\\\\n\u0026amp;=\\sum_{i=0}^nB_n^i(t)f(\\underbrace{0,\\dots,0}_{n-i},\\underbrace{1,\\dots,1}_i)\n\\end{aligned}\n$$\n因此，我们可以看到：\n  Bézier点为：$\\pmb b_i^{(0)}(t)=f(\\underbrace{0,\\dots,0}_{n-i},\\underbrace{1,\\dots,1}_i)$\n  中间的生成点为：$\\pmb b_i^{(j)}(t)=f(\\underbrace{0,\\dots,0}_{n-i-j},\\underbrace{1,\\dots,1}_i,\\underbrace{t,\\dots,t}_j)$\n  De Casteljau算法递归计算：\n$$\n\\begin{aligned}\n\\pmb b_i^{(j)}(t)\u0026amp;=f(\\underbrace{0,\\dots,0}_ {n-i-j},\\underbrace{1,\\dots,1}_i,\\underbrace{t,\\dots,t}_j)\\\\\\\\\n\u0026amp;=(1-t)f(\\underbrace{0,\\dots,0}_ {n-i-j+1},\\underbrace{1,\\dots,1}_i,\\underbrace{t,\\dots,t}_ {j-1})+tf(\\underbrace{0,\\dots,0}_ {n-i-j},\\underbrace{1,\\dots,1}_ {i+1},\\underbrace{t,\\dots,t}_ {j-1})\\\\\\\\\n\u0026amp;=(1-t)\\pmb b_i^{(j-1)}+t\\pmb b_ {i+1}^{(j-1)}(t)\n\\end{aligned}\n$$\n  示例：\n 仿射组合：\n$$\n\\begin{align}\nb(0,t,1)\u0026amp;=b(0,0(1-t)+1t,1(1-t)+1t)\\\\\\\\\n\u0026amp;=(1-t)b(0,0,1)+tb(0,1,1)\n\\end{align}\n$$\n 3.3. 泛化情况 $f(t)$是$t\\in [u,v]$的$d$阶 Bezier 曲线，$\\pmb{p}$是$f$的极形式，则Bézier点用极形式表示为：\n$$\n\\pmb b_i=p(u,\\cdots,u,v,\\cdots,v)\n$$\n示例：\n 三次Bézier曲线控制点为：\n$\\pmb{p}(u,u,u),\\pmb{p}(u,u,v),\\pmb{p}(u,v,v),\\pmb{p}(v,v,v)$\n 3.4. 换基 给定$n$次多项式$\\pmb p(t)$，反求Bézier控制点${\\pmb b_i}^n_{i=0}$\n计算方法：\n 求出极形式：$\\pmb p(t)\\Rightarrow\\pmb b(t_1,\\cdots,t_n)$ 求出控制点：$\\pmb{b}_ i=\\pmb{b}(\\underbrace{0,\\dots,0}_ {n-i},\\underbrace{1,\\dots,1}_ i)$，其中$i=0,\\cdots,n$  示例：\n $p(t)=1+2t+3t^2-t^3$\n极形式表示：\n$$\n\\pmb{b} \\left( t _ { 0 } , t _ { 1 } , t _ { 2 } \\right) = 1 + 2 \\frac { t _ { 0 } + t _ { 1 } + t _ { 2 } } { 3 } + 3 \\frac { t _ { 0 } t _ { 1 } + t _ { 1 } t _ { 2 } + t _ { 0 } t _ { 2 } } { 3 } - t _ { 0 } t _ { 1 } t _ { 2 }\n$$\n则有\n$$\n\\begin{aligned}\n\\pmb{b}(0,0,0)\u0026amp;=1\\\n\\pmb{b}(0,0,1)\u0026amp;=\\frac{5}{3}\\\n\\pmb{b}(0,1,1)\u0026amp;=\\frac{10}{3}\\\n\\pmb{b}(1,1,1)\u0026amp;=5\\\n\\end{aligned}\n$$\n 3.5. 分段曲线 两条曲线段\n$$\n\\{ \\boldsymbol { p } ( 0,0,0 ) , \\boldsymbol { p } ( 0,0,1 ) , \\boldsymbol { p } ( 0,1,1 ) , \\boldsymbol { p } ( 1,1,1 ) \\} , \\{ p ( 1,1,1 ) , \\boldsymbol { p } ( 1,1,2 ) , \\boldsymbol { p } ( 1,2,2 ) , \\boldsymbol { p } ( 2,2,2 ) \\}\n$$\n3.6. 导数 $$\n\\frac { \\mathrm{d} } { \\mathrm{d} t } F ( t ) = n f ( t , \\ldots , t , \\hat { 1 } ) = n ( f ( t , \\ldots , t , 1 ) - f ( t , \\ldots , t , 0 ) )\n$$\n3.7. 细分  每一次de Casteljau迭代都会产生两个新的控制多边形，分别描述Bézier曲线$f(t)$的左侧和右侧 利用这两个新的控制多边形，可以将该Bézier曲线分割成两条，实现细分  3.8. 升阶 对Bézier曲线$\\pmb b(t_1,\\cdots,t_n)$进行升阶得到：\n$$\n\\pmb{b} ^ { ( + 1 ) } \\left( t _ { 1 } , \\ldots , t _ { n + 1 } \\right) = \\frac { 1 } { n + 1 } \\sum _ { i = 1 } ^ { n + 1 } \\pmb{b} \\left( t _ { 1 } , \\ldots , t _ { i - 1 } , t _ { i + 1 } , \\ldots , t _ { n + 1 } \\right)\n$$\n升阶后曲线 $\\pmb{b}^{(+1)}$ 的 $n+2$ 个控制点 $\\pmb{b}^{(+1)}_ 0,\\dots,\\pmb{b}^{(+1)}_ {n+1}$ 为：\n$$\n\\begin{aligned}\n\\pmb b_i^{(+1)}\u0026amp;=\\pmb b^{(+1)}(\\underbrace{0,\\dots,0}_{n+1-i},\\underbrace{1,\\dots,1}_i)\\\\\\\\\n\u0026amp;=\\frac{i}{n+i}\\pmb b(\\underbrace{0,\\dots,0}_{d+1-i},\\underbrace{1,\\dots,1}_{i-1})+\\left(1-\\frac{i}{n+1}\\right)\\pmb{b}(\\underbrace{0,\\dots,0}_{n-i},\\underbrace{1,\\dots,1}_i)\\\\\\\\\n\u0026amp;=\\frac{i}{n+1}\\pmb b_{i-1}+\\left(1-\\frac{i}{n+1}\\right)\\pmb b_i\n\\end{aligned}\n$$\n特别地，\n$$\n\\begin{aligned}\n\\pmb{b}_0^{(+1)}\u0026amp;=\\pmb{b}_0\\\\\\\\\n\\pmb{b}_{n+1}^{(+1)}\u0026amp;=\\pmb{b}_n\\\n\\end{aligned}\n$$\n4. B样条的极形式应用 4.1. B样条的极形式 分段线性多项式曲线的极形式是存在且唯一的\n给定$k$阶（$k-1$次）B样条曲线$\\pmb x$\n 结向量：$T=(t_0,\\dots,t_{n+k})$ de Boor 点 $\\pmb{d}_0,\\dots,\\pmb{d}_n$  设$\\underline { \\pmb{x} }(u_1,\\dots,u_{k-1})$是$\\pmb{x}(t)$的极形式，则de Boor点可表示为：\n$$\n\\pmb{d}_i=\\underline{\\pmb{x}}(t_{i+1},\\dots,t_{i+k-1})\n$$\n 示例：\n$k=4,n=5$\n 4.2. de Boor算法的极形式 要确定$t$处B样条曲线的值，确定出$t$前后的$k-1$个结：\n$$\nr_{k-1}\\leq\\cdots\\leq r_1\\leq t\\leq s_1\\leq\\cdots\\leq s_{k-1}\n$$\n其中，$r_1\\leq t\u0026lt;s_1$，则中间结点为：\n$$\n\\pmb d_j^l(t)=\\underline {\\pmb x}(r_1,\\cdots,r_{k-1-l-j},\\underbrace{t,\\cdots,t}_l,s_1,\\cdots,s_j)\n$$\n最终的曲线为：\n$$\n\\pmb x(t)=\\pmb d_0^{(k-1)}(t)=\\underline{\\pmb x}(\\underbrace{t,\\cdots,t}_{k-1})\n$$\n 示例：\n$k=4$\n仿射组合：\n对于$t_2\\leq t\u0026lt;t_4$，进行如下迭代：\n ","description":"多项式曲线的极形式应用","id":7,"section":"posts","tags":["Geometry"],"title":"几何造型(4)：极形式和开花算法","uri":"https://chaphlagical.github.io/zh/posts/geometry/polar_form/"},{"content":"事实上，从IlumEngine能够显示东西之初，我就已经搭建了一套基于金属工作流的延迟PBR渲染管线，但之前对于PBR材质模型的理解还不够深入，很多情况下都是以抄公式为主，这次借实现Kulla-Conty对微表面模型能量不守恒的修正，从理论上来深入理解实时PBR着色方法。\n1. 渲染着色的物理原理 从物理角度上看，渲染着色即光与物体的材质表面、材质介质的相互作用后，射入摄像机的结果。\n1.1. 光的物理本质 光是具有一定波长的电磁波，限定自由电荷密度$\\rho$和自由电流密度$\\pmb J$，根据欧姆定律有电流密度正比于电场：\n$$\n\\pmb J=\\sigma \\pmb E\n$$\n对于光在线性介质中的传播，满足麦克斯韦方程组：\n$$\n\\begin{aligned}\n\\nabla \\cdot\\pmb E \u0026amp;= \\frac{1}{\\varepsilon}\\pmb \\rho\\\\\\\\\n\\nabla\\cdot\\pmb B\u0026amp;=0\\\\\\\\\n\\nabla\\times \\pmb E\u0026amp;=-\\frac{\\partial \\pmb B}{\\partial t}\\\\\\\\\n\\nabla\\times \\pmb B\u0026amp;=\\mu\\sigma\\pmb E+ \\mu_0\\varepsilon_0\\frac{\\partial \\pmb E}{\\partial t}\n\\end{aligned}\n$$\n由自由电荷的连续性方程：\n$$\n\\nabla\\cdot\\pmb J=-\\frac{\\partial \\rho}{\\partial t}\n$$\n有：\n$$\n\\frac{\\partial \\rho}{\\partial t}=-\\sigma(\\nabla\\cdot\\pmb E)=-\\frac{\\sigma}{\\varepsilon}\\rho\n$$\n可以解出：\n$$\n\\rho(t)=\\rho(0)e^{-(\\sigma/\\varepsilon)t}\n$$\n看到自由电荷密度$\\rho$以特征时间$\\tau\\equiv \\varepsilon/\\sigma$耗散，\n 对于理想导体，$\\sigma =\\infty$，$\\tau=0$ 对于良导体，$\\tau$比电磁波的角周期小得多：$\\tau\\ll1/\\omega$ 对于不良导体，则$\\tau$比电磁波的角周期大得多：$\\tau\\gg 1/\\omega$  对电场与磁场的旋度再取其旋度，有：\n$$\n\\begin{align}\n\\nabla\\times(\\nabla\\times \\pmb E)\u0026amp;=\\nabla(\\nabla\\cdot\\pmb E)-\\nabla^2\\pmb E=\\nabla\\times(-\\frac{\\partial \\pmb B}{\\partial t})\\\\\\\\\n\u0026amp;=-\\frac{\\partial}{\\partial t}(\\nabla\\times\\pmb B)=-\\mu\\sigma\\frac{\\partial \\pmb E}{\\partial t}-\\mu_0\\varepsilon_0\\frac{\\partial^2\\pmb E}{\\partial t^2}\\\\\\\\\n\\nabla\\times(\\nabla\\times \\pmb B)\u0026amp;=\\nabla(\\nabla\\cdot\\pmb B)-\\nabla^2\\pmb B=\\nabla\\times(\\mu\\sigma\\pmb E+\\mu_0\\varepsilon_0\\frac{\\partial \\pmb E}{\\partial t})\\\\\\\\\n\u0026amp;=\\mu\\sigma(\\nabla\\times\\pmb E) +\\mu_0\\varepsilon_0\\frac{\\partial}{\\partial t}(\\nabla\\times\\pmb E)=-\\mu\\sigma\\frac{\\partial B}{\\partial t}-\\mu_0\\varepsilon_0\\frac{\\partial^2\\pmb B}{\\partial t^2}\n\\end{align}\n$$\n忽略电磁波在线性介质中的瞬态效应，即自由电荷消失，$\\rho=0$，则有：\n$$\n\\begin{align}\n\u0026amp;\\begin{matrix}\n\\nabla \\cdot \\pmb E=0\u0026amp;\\nabla\\cdot \\pmb B=0\n\\end{matrix}\\\\\\\\\n\\Rightarrow\\ \\ \\ \u0026amp;\n\\begin{matrix}\n\\nabla^2\\pmb E=\\mu\\sigma\\dfrac{\\partial \\pmb E}{\\partial t}+\\mu_0\\varepsilon_0\\dfrac{\\partial^2\\pmb E}{\\partial t^2}\n\\\\\\\n\\nabla^2\\pmb B=\\mu\\sigma\\dfrac{\\partial B}{\\partial t}+\\mu_0\\varepsilon_0\\dfrac{\\partial^2\\pmb B}{\\partial t^2}\n\\end{matrix}\n\\end{align}\n$$\n可以得到平面波解：\n$$\n\\begin{aligned}\n\\tilde {\\pmb E}(z,t)=\\tilde{\\pmb E}_0e^{i(\\tilde k z-\\omega t)}\\\\\\\\\n\\tilde {\\pmb B}(z,t)=\\tilde{\\pmb B}_0e^{i(\\tilde k z-\\omega t)}\n\\end{aligned}\n$$\n其中，波数$\\tilde k$为复数：\n$$\n\\tilde k^2=\\mu\\varepsilon\\omega^2+i\\mu\\sigma\\omega\n$$\n取平方根得：\n$$\n\\tilde k=k+i\\kappa\n$$\n其中，\n$$\n\\begin{align}\nk\u0026amp;\\equiv \\omega\\sqrt{\\frac{\\mu\\varepsilon}{2}}\\left[\\sqrt{1+\\left(\\frac{\\sigma}{\\varepsilon\\omega}\\right)^2}+1 \\right]^{1/2}\\\\\\\\\n\\kappa\u0026amp;\\equiv \\omega\\sqrt{\\frac{\\mu\\varepsilon}{2}}\\left[\\sqrt{1+\\left(\\frac{\\sigma}{\\varepsilon\\omega}\\right)^2}-1 \\right]^{1/2}\n\\end{align}\n$$\n提取虚部：\n$$\n\\begin{aligned}\n\\tilde {\\pmb E}(z,t)=\\tilde{\\pmb E}_0e^{-\\kappa z} e^{i(k z-\\omega t)}\\\\\\\\\n\\tilde {\\pmb B}(z,t)=\\tilde{\\pmb E}_0e^{-\\kappa z} e^{i(k z-\\omega t)}\n\\end{aligned}\n$$\n可以看到：\n $\\tilde k$的虚部导致波的衰减，振幅随着$z$的增大而减小，度量了波进入导体的深度，也度量了导体阻尼对波能量的吸收（吸收系数$\\alpha\\equiv 2\\kappa$） $\\tilde k$的实部定义了波的属性，如波长$\\lambda = \\frac{2\\pi}{k}$，波速$v=\\frac{\\omega}{k}$，折射率$n=\\frac{ck}{\\omega}$  综合起来，材质通过影响光的$\\tilde k$，对光的传播效应造成影响，从而带来不同的光照效果。\n在成像理论中，光的吸收对视觉效果有直接影响，将降低光的强度，对特定可见波长的吸收将改变光的颜色。\n在渲染中，通常将材质与光的相互作用归结为散射和吸收两类：\n 散射：决定介质的浑浊程度（下图右） 吸收：决定材质的外观颜色（下图左）  每种介质外观均为散射和吸收两种现象的综合结果：\n1.2. 渲染中的光学模型 从电磁波角度出发可以很方便我们理解光、物质和成像之间的相互关系，但在渲染领域尤其是实时渲染领域，我们常常对问题进行简化，现在，我们只考虑物体的表面着色以及几何光学模型。\n1.2.1. 光与物体表面的交互 当一种介质进入到另一种介质，光线将发生反射、折射及其各种衍生现象：\n 镜面反射：光线在两种介质交界处发生直接反射，满足反射定律 折射：从表面进入介质的光由于介质折射率的变化，传播方向发生改变，出现折射现象，介质中的光将发生吸收和散射 吸收：由前推导，当介质中的吸收系数$\\alpha\u0026gt;0$时，在光传播过程中部分能量将会被介质所吸收 散射：光的传播方向由于折射率的剧烈变化发生改变，分裂为多个方向，但光的总能量保持不变  次表面散射：观察像素小于散射距离  透射：入射光进入介质后又穿过该介质出射   漫反射：观察像素大于散射距离    1.2.2. 不同物质与光的交互 不同物质对光的反射、折射效应有所不同，根据光学特性大致分为金属与非金属两大类：\n 金属：金属的外观取决于材质表面的镜面反射，且入射金属的光不存在散射，会被自由粒子完全吸收 非金属：非金属又称电介质，非金属外观取决于吸收和散射特性：  均匀介质：主要为透明介质，无折射率变化，光总以直线传播，不存在散射，但存在吸收 非均匀介质：通常可建模为具有嵌入散射粒子的均匀介质，具有折射率的变化  浑浊介质：具有弱散射 半透明介质：具有强散射 不透明介质：与半透明介质类似，具有强散射      2. 光线传输基础 2.1. 反射方程 所有的渲染方法其实就是在干一件事，求解渲染方程：\n$$\nL_o(\\pmb p,\\pmb \\omega_o)=L_e(\\pmb p,\\pmb \\omega_o)+\\int_\\Omega f_r(\\pmb p,\\pmb \\omega_i\\rightarrow\\pmb \\omega_o)L_i(\\pmb p,\\pmb \\omega_i)\\cdot(\\pmb \\omega_i\\cdot\\pmb n)\\cdot\\mathrm d\\pmb \\omega_i\n$$\n这里我们不考虑物体的自发光，因此$L_e$项恒为0，渲染方程退化为反射方程：\n$$\nL_o(\\pmb p,\\pmb \\omega_o)=\\int_\\Omega f_r(\\pmb p,\\pmb \\omega_i\\rightarrow\\pmb \\omega_o)L_i(\\pmb p,\\pmb \\omega_i)\\cdot(\\pmb \\omega_i\\cdot\\pmb n)\\cdot\\mathrm d\\pmb \\omega_i\n$$\n其中$f_r(\\pmb p,\\pmb \\omega_i\\rightarrow\\pmb \\omega_o)$定义了入射光与出射光的反射比例，称为BxDF，通常为双向反射分布函数BRDF，在离线渲染中我们还常用到BSDF(=BTDF+BRDF)等：\n2.2. BRDF 2.2.1. 辐射度量学的基本概念 BRDF是定义在辐射度量学上的，简单介绍相关概念：\n辐射能\n光的能量可以由光子动能定义：\n$$\nQ=hv\n$$\n其中$h$为普朗克常量，$v$为光子振动频率，由光的波动性，有：\n$$\nc=\\lambda v\n$$\n因此光的能量也可表示为：\n$$\nQ=\\frac{hc}{\\lambda}\n$$\n其中$\\lambda$为光的波长，$c$为光速，能量的量纲为[$J$]，即Joule\n辐射通量\n辐射通量是单位时间内发射、接收或传输的能量，定义为：\n$$\n\\Phi=\\frac{\\mathrm dQ}{\\mathrm dt}\n$$\n功率的量纲为[$lm$]即Lumen，\n辐射强度Radiant Intensity\n定义为单位立体角的光通量：\n$$\nI=\\frac{\\mathrm d\\Phi}{\\mathrm d\\Omega}\n$$\n辐射强度量纲为$[cd]$即candela\n辐照度Irradiance\n辐照度定义为单位面积的辐射通量：\n$$\nE=\\frac{\\mathrm d\\Phi}{\\mathrm d A}\n$$\n辐照度量纲为$[lx]$即lux\n辐射通量为$\\Phi$的点光源在距离$r$处的球面上的辐照度为：\n$$\nE_e=\\frac{\\Phi}{4\\pi r^2}\n$$\n辐亮度Radiance\n辐亮度定义为单位面积和单位立体角的辐射通量\n$$\nL=\\frac{\\mathrm d^2\\Phi}{\\mathrm d\\Omega\\mathrm dA^\\perp}=\\frac{\\mathrm d^2\\Phi}{\\mathrm d\\Omega\\mathrm dA\\cos\\theta}\n$$\n辐亮度的量纲为$[cd/m^2]$或nits\n辐亮度是成像理论中最经常使用的物理量，因为它最符合人和摄像机成像的辐射度量。\n2.2.2. 双向反射分布函数 对于入射光$L_i(\\pmb p,\\pmb \\omega_i)$，计算它在半球上的辐照度$E$：\n$$\nE(\\pmb p)=\\int_\\Omega L_i(\\pmb p,\\pmb \\omega_i)\\cos\\theta_i\\mathrm d\\pmb \\omega_i\n$$\n即：\n$$\n\\mathrm dE(\\pmb p,\\pmb \\omega_i)=L_i(\\pmb p,\\pmb \\omega_i)\\cos\\theta_i\\mathrm d\\pmb \\omega_i\n$$\n而任意方向上，出射光的辐亮度微分应与入射光辐照度成正比，即：\n$$\n\\mathrm dL_o(\\pmb p,\\pmb \\omega_o)\\propto\\mathrm d E(\\pmb p,\\pmb \\omega_i)\n$$\n该比例定义为关于$\\pmb\\omega_i$和$\\pmb \\omega_o$的双向反射分布函数即BRDF：\n$$\nf_r(\\pmb p, \\pmb \\omega_o,\\pmb \\omega_i)=\\frac{\\mathrm dL_o(\\pmb p,\\pmb \\omega_o)}{\\mathrm d E(\\pmb p,\\pmb \\omega_i)}=\\frac{\\mathrm dL_o(\\pmb p,\\pmb \\omega_o)}{L_i(\\pmb p,\\pmb \\omega_i)\\cos\\theta_i\\mathrm d\\pmb \\omega_i}\n$$\n因此在半球上积分有：\n$$\nL_o(\\pmb p,\\pmb \\omega_o,\\pmb \\omega_i)=\\int_\\Omega f_r(\\pmb p, \\pmb \\omega_o,\\pmb \\omega_i)L_i(\\pmb p,\\pmb \\omega_i)\\cos\\theta_i\\mathrm d\\pmb \\omega_i\n$$\nBRDF的性质：\n 交换律：$f_r(\\pmb p,\\pmb \\omega_o,\\pmb \\omega_i)=f_r(\\pmb p,\\pmb \\omega_i,\\pmb \\omega_o)$ 能量守恒：$\\int_\\Omega f_r(\\pmb p,\\pmb \\omega_o,\\pmb \\omega_i)\\cos\\theta\\mathrm d\\omega\\leq 1$  2.2.3. Cook-Torrance BRDF 本文将主要介绍目前主流的Cook-Torrance BRDF模型，Cook-Torrance BRDF由漫反射项和镜面反射项组成：\n$$\nf_r=k_d\\cdot f_{\\mathrm{diffuse}} +k_s\\cdot f_{\\mathrm{specular}}\n$$\n其中漫反射项使用Lambertian光照模型，镜面反射项使用微表面模型进行建模，随后将具体介绍。\n3. Lambertian漫反射材质模型 Lambertian漫反射模型假定出射光线在各个方向上都是均匀的（强度相等），由反射方程：\n$$\n\\begin{aligned}\nL_o(\\pmb\\omega_o)\u0026amp;=\\int_\\Omega f_rL_i(\\pmb\\omega_i)\\cos\\theta_i\\mathrm d\\pmb \\omega_i\\\\\\\\\n\u0026amp;=f_rL_i\\int_\\Omega \\cos\\theta_i\\mathrm d\\pmb \\omega_i\\\\\\\\\n\u0026amp;=\\pi f_rL_i\n\\end{aligned}\n$$\n为了保证能量守恒，BRDF选择：\n$$\nf_r=\\frac{\\rho}{\\pi}\n$$\n其中$\\rho$为材质颜色Albedo参数，通常有RGB三个分量，当$\\rho=(1,1,1)$时，说明材质为白色，没有吸收任何色光，此时$L_o=L_i$。\n4. 镜面反射模型 4.1. 微表面理论 真实世界中不存在绝对光滑的物体表面，即使是看起来很光滑的表面也具有比光的波长大得多的微尺度不规则性。这种微表面现象将导致每个表面点反射和折射不同方向的光，带来不同的材质外观。\n同时，在微表面作用的光还会因为自遮挡带来阴影和遮罩：\n微表面BRDF很大程度由材质的粗糙度所影响，粗糙度度量了微表面材质表面的粗糙程度，如下图从左到右粗糙度依次降低：\n4.2. 法线分布函数（Normal Distribution Function） 法线分布是描述微表面的一个重要几何性质，通常物体表面会有一个法向量$\\pmb n$，可以认为是物体表面绝对光滑时具有的法向量，但由于微表面具有的各种微小几何结构，局部的表面法向量可能与法向量$\\pmb n$不同，这种局部法向量称为微表面法向量$\\pmb m$，而法线分布函数$D(\\pmb m)$则是描述了微表面法线的分布概率密度。\n在渲染中，常用宏观表面的半矢量$\\pmb h$来表示微表面法向，因为只有$\\pmb m=\\pmb h$的表面点能够将入射光反射到视线方向，而其他朝向的表面点对最终的渲染结果没有贡献\n在整个微表面法线上积分$D(\\pmb m)$将得到微表面的面积，不过更常用的是对$D(\\pmb m)(\\pmb n\\cdot\\pmb m)$进行积分，将$D(\\pmb m)$投影到宏观表面平面上，将得到宏观表面的元面积，规定为1，如下图所示：\n又称为投影$D(\\pmb m)(\\pmb n\\cdot\\pmb m)$的归一化：\n$$\n\\int_{\\pmb m\\in\\Theta}D(\\pmb m)(\\pmb n\\cdot\\pmb m)\\mathrm d{\\pmb m}=1\n$$\n上式中的$\\Theta$表示在整个球体上进行积分，虽然在图形学中的微结构模型多为高度场，即在以$\\pmb n$为中心的半球$\\Omega$以外的所有方向有$D(\\pmb m)\\equiv 0$。\n更一般地，微表面和宏观表面在垂直于任何视图方向$\\pmb v$的平面上的投影总是相等的：\n即：\n$$\n\\int_{\\pmb m\\in\\Theta}D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d{\\pmb m}=\\pmb v\\cdot\\pmb n\n$$\n上式定义了一个合理的法线分布函数应当具有的约束性质，一种直观的理解是一片宏观表面的法向等于其微表面所有法向的均值，至于实际法线分布函数应长什么样，那就有特别多的建模手段得到了，例如，对于绝对光滑的表面，显然$\\pmb m$与$\\pmb n$恒相等，法线分布函数则可以由一个冲激函数进行表示：\n$$\nD(\\pmb m)=\\delta(\\pmb m-\\pmb n)\n$$\n注意到式子$\\int_{\\pmb m\\in\\Theta}D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d{\\pmb m}=\\pmb v\\cdot\\pmb n$中，$\\pmb v\\cdot\\pmb m$的正负不受限制，这是由于投影会产生正负造成抵消，如前图所示，但在实际渲染中，我们常常只关注可见的微表面，即离相机最近的那个微表面，可以通过定义几何函数$G_1(\\pmb m,\\pmb v)$来给出沿着视图向量$\\pmb v$可见的具有法向$\\pmb m$的微平面比例，则原式可改写为：\n$$\n\\int_{m\\in\\Theta}G_1(\\pmb m, \\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)^+\\mathrm d\\pmb m=\\pmb v\\cdot \\pmb m\n$$\n如下图所示，而几何遮蔽函数的具体内容待会将作介绍。\n4.2.1. 法线分布函数的基本性质 法线分布函数是一种概率密度函数，很自然地有如下性质：\n  非负性\n$$\n0\\leq D(\\pmb m)\\leq \\infty\n$$\n  法线分布函数的积分表征了微表面的面积，显然微表面面积应大于等于宏观表面面积\n$$\n\\int_{\\pmb m\\in \\Theta}D(\\pmb m)\\mathrm d\\pmb m\\geq 1\n$$\n  微表面和宏观表面在垂直于任何视图方向$\\pmb v$的平面上的投影总是相等的\n$$\n\\int_{\\pmb m\\in\\Theta}D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d{\\pmb m}=\\pmb v\\cdot\\pmb n\n$$\n  特别地，当视图法向沿着宏观法向时，积分归一化\n$$\n\\int_{\\pmb m\\in\\Theta}D(\\pmb m)(\\pmb n\\cdot\\pmb m)\\mathrm d{\\pmb m}=1\n$$\n  4.2.2. 法线分布函数的形状不变性 形状不变性（shape-invariant）是设计合理法线分布函数的一个重要依据，具有形状不变性的法线分布函数，能够推导该函数归一化的各向异性版本，且可以很方便地推导相应的几何函数项$G$\nHeitz定义各向同性的法线分布函数具有形状不变性即材质粗糙度的影响等价于微表面的拉伸，具有形状不变性的微表面法线分布函数可以表示为以下形式：\n$$\nD(\\pmb m)=\\frac{\\chi^+(\\pmb n\\cdot\\pmb m)}{\\alpha^2(\\pmb n\\cdot\\pmb m)^4}g\\left(\\frac{\\sqrt{1-(\\pmb n\\cdot\\pmb m)^2}}{\\alpha(\\pmb n\\cdot\\pmb m)}\\right)\n$$\n其中$g(\\cdot)$代表一个表示法线分布函数形状的一维函数\n4.2.3. 常用的法线分布函数 Blinn-Phong分布\nBlinn-Phong分布函数具有如下形式：\n$$\nD(\\pmb m)=\\frac{\\alpha_p+2}{2\\pi}(\\pmb n\\cdot\\pmb m)^{\\alpha_p}\n$$\n其中，幂$\\alpha_p$为Blinn-Phong法线分布函数的粗糙度参数，$\\alpha_p$越高，表示表面越光滑，$\\alpha_p$的取值可以是$[0,\\infty)$，$\\alpha_p$参数不便于艺术家进行调节，UE4中采用映射$\\alpha_p=2\\alpha^{-2}-2$，使用材质粗糙度$\\alpha$进行控制，得到的Blinn-Phong法线分布函数如下：\n$$\nD(\\pmb m)=\\frac{1}{\\pi\\alpha^2}(\\pmb n\\cdot\\pmb m)^{(\\frac{2}{\\alpha^2}-2)}\n$$\nBlinn-Phong分布函数不具有形状不变性。\nBeckmann分布\nBeckmann分布函数具有如下形式：\n$$\nD(\\pmb m)=\\frac{1}{\\pi\\alpha^2(\\pmb n\\cdot\\pmb m)^4}\\exp(\\frac{(\\pmb n\\cdot\\pmb m)^2-1}{\\alpha^2(\\pmb n\\cdot\\pmb m)^2})\n$$\n Beckmann分布函数呈高斯函数形态，在对称轴$\\pmb n\\cdot\\pmb m$处取得最值，如下图所示呈现一种中间亮两边暗的渲染效果。  Beckmann分布与Blinn-Phong分布可以通过关系式$\\alpha_p=2\\alpha_b^{-2}-2$进行等效，如下图所示，蓝色虚线为Blinn-Phong分布、绿色实线为Beckmann分布：\nBeckmann分布函数具有形状不变性。\nGGX（Trowbridge-Reitz）分布\nGGX分布函数具有如下形式：\n$$\nD(\\pmb m)=\\frac{\\alpha^2}{\\pi((\\pmb n\\cdot \\pmb m)^2(\\alpha^2-1)+1)^2}\n$$\nGGX是目前业界最流行的微表面法线分布函数模型，因为它在主流模型中拥有最长的尾部，如下图所示，Beckmann分布函数会很快地逼近于0，而GGX能维持较长的一段尾部：\nGGX分布函数具有形状不变性。\nGTR（Generalized-Trowbridge-Reitz）分布\n广义的Trowbridge-Reitz分布，具有如下形式：\n$$\nD(\\pmb m)=\\frac{c}{(1+(\\pmb n\\cdot\\pmb m)^2(\\alpha^2-1))^\\gamma}\n$$\n其中，参数$\\gamma$用于控制函数的尾部形状，当$\\gamma=2$时，则退化为GGX分布。各个$\\gamma$取值与GTR分布曲线的关系如下：\nGTR分布函数不具有形状不变性。\n4.2.4. 各项异性的法线分布函数 我们已知对于一个各向同性的具有形状不变性的法线分布函数，可以用下述形式所表示（考虑定义在正半球上）：\n$$\nD(\\pmb m)=\\frac{1}{\\alpha^2(\\pmb n\\cdot\\pmb m)^4}g\\left(\\frac{\\sqrt{1-(\\pmb n\\cdot\\pmb m)^2}}{\\alpha(\\pmb n\\cdot\\pmb m)}\\right)\n$$\n则对应的各项异性法线分布函数则为：\n$$\nD(\\pmb m)=\\frac{1}{\\alpha_x\\alpha_y(\\pmb n\\cdot\\pmb m)^4}g\\left(\\frac{\n\\sqrt{\\frac{(\\pmb t\\cdot\\pmb m)^2}{\\alpha_x^2}+\\frac{(\\pmb b\\cdot\\pmb m)^2}{\\alpha_y^2}}}{\\pmb n\\cdot\\pmb m}\\right)\n$$\n其中，$\\alpha_x$和$\\alpha_y$分别表示沿切线$\\pmb t$方向和副法线$\\pmb b$方向的粗糙度，当$\\alpha_x=\\alpha_y$时，则退化为各向同性的形式。\n各向异性的Beckmann分布\n$$\nD(\\pmb m)=\\frac{1}{\\pi\\alpha_x\\alpha_y(\\pmb n\\cdot\\pmb m)^4}\\exp\\left(\n-\\frac{\\frac{(\\pmb t\\cdot\\pmb m)^2}{\\alpha_x^2}+\\frac{(\\pmb b\\cdot\\pmb m)^2}{\\alpha_y^2}}{(\\pmb n\\cdot\\pmb m)^2}\\right)\n$$\n各项异性的GGX分布\n$$\nD(\\pmb m)=\\frac{1}{\\pi\\alpha_x\\alpha_y}\\frac{1}{\\left(\\frac{(\\pmb t\\cdot\\pmb m)^2}{\\alpha_x^2}+\\frac{(\\pmb b\\cdot\\pmb m)^2}{\\alpha_y^2}+(\\pmb n\\cdot\\pmb m)^2\\right)^2}\n$$\n4.2.5. Beckmann与GGX法线分布函数效果比较 各向同性比较：\n各向异性比较（上一行为Beckmann分布，下一行为GGX分布，$\\alpha_x$从左到右依次递增，$\\alpha_y$保持不变）：\n4.3. 几何函数（Geometry Function） 从法线分布函数一节中我们从微表面模型导出了几何函数的基本概念：\n$$\n\\int_{m\\in\\Theta}G_1(\\pmb m, \\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)^+\\mathrm d\\pmb m=\\pmb v\\cdot \\pmb m\n$$\n几何函数$G$作为一个取值范围为$[0,1]$的标量，描述了微表面的自阴影的属性，表示了具有半矢量的微表面中，同时被入射方向和反射方向可见的比例\n几何函数具有两种主要的形式：\n $G_1$：微表面在单个方向（光照方向或观察方向）上的可见比例，一般表示阴影函数或遮蔽函数 $G_2$：微表面在光照方向和观察方向上均可见的比例，一般表示联合遮蔽阴影函数  一般默认情况下，几何函数指代$G_2$。\n几何函数的设计也有很多，其中基于物理的相对经典的模型为Smith遮蔽函数和V-cavity遮蔽函数\nSmith模型具有不相关的表面，即每个微表面与其邻域不相关，与真实世界的连续微表面对比如下（右图为Smith模型）：\nV-cavity遮蔽函数计算单独微表面上的散射并混合计算结果：\nHeitz证明了Smith遮蔽函数是唯一既遵循公式：\n$$\n\\int_{m\\in\\Theta}G_1(\\pmb m, \\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)^+\\mathrm d\\pmb m=\\pmb v\\cdot \\pmb m\n$$\n又具有法线遮蔽独立性的便利特性的函数，因此业界更青睐于使用Smith模型，Smith模型也比V-cavity模型能够更好地拟合真实世界的反射现象：\n4.3.1. Smith遮蔽函数 下面我们将从各项同性的法线分布函数出发，详细推导Smith几何函数模型。\n在前面的介绍中我们已经得到微表面模型的基本方程：\n$$\n\\int_{m\\in\\Theta}G_1(\\pmb m, \\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)^+\\mathrm d\\pmb m=\\pmb v\\cdot \\pmb m\n$$\n其中的$G_1(\\pmb m,\\pmb v)$项则是我们要求的几何函数项，这里我们仅考虑以高度场建模的微表面，由于几何函数$G_1$将筛选出在单个方向上（即$\\pmb m\\cdot\\pmb v\u0026gt;0$）可见的光，我们可以将$G_1$项分离为：\n$$\nG_1(\\pmb m,\\pmb v)=\\chi^+(\\pmb m,\\pmb v)G_1'(\\pmb v)\n$$\n原方程可化为：\n$$\n\\int_{m\\in\\Theta}\\chi^+(\\pmb m,\\pmb v)G_1'(\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m=\\pmb v\\cdot \\pmb m\n$$\n提取出与$\\pmb m$无关的$G'(\\pmb v)$，有：\n$$\n\\pmb v\\cdot \\pmb m=G_1'(\\pmb v)\\int_{m\\in\\Theta}\\chi^+(\\pmb m,\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m\n$$\n定义与微表面法向$\\pmb m(x_m,y_m,z_m)$相关的微表面坡度：\n$$\n\\tilde m(\\pmb m)=(x_{\\tilde m}, y_{\\tilde m})=(-x_m/z_m,-y_m/z_m)\n$$\n反过来，微表面法向也可表示为：\n$$\n\\pmb m(\\tilde m)=(x_m,y_m,z_m)=\\frac{1}{\\sqrt{x_{\\tilde m}^2+ y_{\\tilde m}^2+1}}(-x_{\\tilde m}, -y_{\\tilde m},1)\n$$\n定义微表面坡度的分布函数$P^{22}$，由$P^{22}$所应满足的归一性：\n$$\n\\int_{-\\infty}^\\infty\\int_{-\\infty}^\\infty P^{22}(\\tilde m)\\mathrm d\\tilde m=1\n$$\n以及法线分布函数的归一性（高度场，仅考虑半球）：\n$$\n\\int_{\\Omega}D(\\pmb m)(\\pmb n\\cdot\\pmb m)\\mathrm d{\\pmb m}=1\n$$\n建立关联：\n$$\nP^{22}(\\tilde m)\\mathrm d\\tilde m=D(\\pmb m)(\\pmb n\\cdot\\pmb m)\\mathrm d{\\pmb m}\n$$\n整理后积分有：\n$$\n\\int_{\\Omega}\\chi^+(\\pmb m,\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m=\\int_{-\\infty}^\\infty\\int_{-\\infty}^\\infty \\chi^+(\\pmb m,\\pmb v)\\frac{\\pmb v\\cdot\\pmb m(\\tilde m)}{\\pmb n\\cdot\\pmb m(\\tilde m)}P^{22}(\\tilde m) \\mathrm d\\tilde m\n$$\n由于$\\pmb n=(0,0,1)$，因此\n$$\n\\pmb n\\cdot\\pmb m(\\tilde m)=\\frac{1}{\\sqrt{x_{\\tilde m}^2+ y_{\\tilde m}^2+1}}\n$$\n与$\\chi^+(\\pmb m,\\pmb v)$项结合起来有：\n$$\n\\chi^+(\\pmb m,\\pmb v)\\pmb v\\cdot\\pmb m(\\tilde m)=\\frac{\\chi^+(-x_0x_{\\tilde m}-y_0y_{\\tilde m}+z_0)(-x_0x_{\\tilde m}-y_0y_{\\tilde m}+z_0)}{\\sqrt{x_{\\tilde m}^2+ y_{\\tilde m}^2+1}}\n$$\n因此积分可以写为：\n$$\n\\int_{\\Omega}\\chi^+(\\pmb m,\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m=\n\\int_{-\\infty}^\\infty\\int_{-\\infty}^\\infty \\chi^+(-x_0x_{\\tilde m}-y_0y_{\\tilde m}+z_0)(-x_0x_{\\tilde m}-y_0y_{\\tilde m}+z_0) P^{22}(x_{\\tilde m},y_{\\tilde m})\\mathrm dx_{\\tilde m}\\mathrm dy_{\\tilde m}\n$$\n不失一般性地，我们可以假设视角方向与$x$轴对齐，即$\\pmb v=(\\sin\\theta_o,0,\\cos\\theta_o)$，则积分表示为：\n$$\n\\begin{align}\n\u0026amp;\\int_{\\Omega}\\chi^+(\\pmb m,\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m\\\\\\\\\n=\u0026amp;\\int_{-\\infty}^\\infty\\int_{-\\infty}^\\infty\\chi^+(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)P^{22}(x_{\\tilde m},y_{\\tilde m})\\mathrm dx_{\\tilde m}\\mathrm dy_{\\tilde m}\\\\\\\\\n=\u0026amp;\\int_{-\\infty}^\\infty\\chi^+(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)\\left(\\int_{-\\infty}^\\infty P^{22}(x_{\\tilde m},y_{\\tilde m})\\mathrm dy_{\\tilde m}\\right)\\mathrm dx_{\\tilde m}\\\\\\\\\n=\u0026amp;\\int_{-\\infty}^\\infty \\chi^+(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n\\end{align}\n$$\n其中，$P^2(x_{\\tilde m})$为沿着视角法向的一维坡度分布函数，定义为：\n$$\nP^2(x_{\\tilde m})=\\int_{-\\infty}^{+\\infty}P^{22}(x_{\\tilde m},y_{\\tilde m})\\mathrm dy_{\\tilde m}\n$$\n又：\n$$\n-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o\u0026gt;0\\Rightarrow x_{\\tilde m}\u0026lt;\\cot\\theta_o\n$$\n因此原积分又可化为：\n$$\n\\int_{-\\infty}^\\infty \\chi^+(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}=\n\\int_{-\\infty}^{\\cot\\theta_o} (-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n代入到方程：\n$$\n\\pmb v\\cdot \\pmb m=G_1'(\\pmb v)\\int_{m\\in\\Theta}\\chi^+(\\pmb m,\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m\n$$\n可以得到：\n$$\n\\cos\\theta_o=G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n两边同除以$\\sin\\theta_o$可得：\n$$\n\\cot\\theta_o=G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-x_{\\tilde m}+\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n由于微表面分布是中心对称的，且任意方向的平均坡度为零（正负抵消，分布的均值为0），即\n$$\n\\int_{-\\infty}^{+\\infty} x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}=0\n$$\n引入该项有：\n$$\n\\cot\\theta_o=G_1'(\\pmb v)\\int_{-\\infty}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}+ G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-x_{\\tilde m}+\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n利用$\\cot\\theta_o=(1-G_1'(\\pmb v))\\cot\\theta_o+G_1'(\\pmb v)\\cot\\theta_o$，代入有：\n$$\n\\begin{align}\n(1-G_1'(\\pmb v))\\cot\\theta_o+G_1'(\\pmb v)\\cot\\theta_o\n=\u0026amp;G_1'(\\pmb v)\\int_{-\\infty}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}+ G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-x_{\\tilde m}+\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\\\\\\\\n(1-G_1'(\\pmb v))\\cot\\theta_o\n=\u0026amp;G_1'(\\pmb v)\\int_{-\\infty}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}+ G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-x_{\\tilde m}+\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\\\\\\\\n\u0026amp;-G_1'(\\pmb v)\\cot\\theta_o\n\\end{align}\n$$\n由于概率密度函数的归一性：\n$$\n\\int_{-\\infty}^{+\\infty} P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}=1\n$$\n因此有\n$$\nG_1'(\\pmb v)\\cot\\theta_o=G_1'(\\pmb v) \\int_{-\\infty}^{+\\infty} \\cot\\theta_oP^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n代入得：\n$$\n\\begin{align}\n(1-G_1'(\\pmb v))\\cot\\theta_o=\u0026amp;G_1'(\\pmb v)\\int_{-\\infty}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}+ G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-x_{\\tilde m}+\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\\\\\\\\n\u0026amp;-G_1'(\\pmb v) \\int_{-\\infty}^{+\\infty} \\cot\\theta_oP^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\\\\\\\\n=\u0026amp;G_1'(\\pmb v)\\left(\\int_{-\\infty}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}-\\int_{-\\infty}^{\\cot\\theta_o} x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\right)\\\\\\\\\n\u0026amp;+G_1'(\\pmb v)\\left(\\int_{-\\infty}^{\\cot\\theta_o}\\cot\\theta_oP^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}-\\int_{-\\infty}^{\\infty}\\cot\\theta_oP^2(x_{\\tilde m})\\mathrm dx_{\\tilde m} \\right)\\\\\\\\\n=\u0026amp;G_1'(\\pmb v)\\int_{\\cot\\theta_o}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}-G_1'(\\pmb v)\\int_{\\cot\\theta_o}^{+\\infty}\\cot\\theta_oP^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\\\\\\\\n=\u0026amp;G_1'(\\pmb v)\\int_{\\cot\\theta_o}^{+\\infty}(x_{\\tilde m}-\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n\\end{align}\n$$\n等式变换一下有：\n$$\n\\frac{1-G'_1(\\pmb v)}{G'_1(\\pmb v)}=\\frac{1}{\\cot\\theta_o}\\int_{\\cot\\theta_o}^{+\\infty}(x_{\\tilde m}-\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n于是得到最终形式：\n$$\nG_1'(\\pmb v)=\\frac{1}{1+\\Lambda(\\pmb v)}\n$$\n其中，$\\Lambda(\\cdot)$定义为：\n$$\n\\Lambda(\\pmb v)=\\frac{1}{\\cot\\theta_o}\\int_{\\cot\\theta_o}^{+\\infty}(x_{\\tilde m}-\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n这是一个与法线分布函数$D(\\pmb m)$相关的函数，每个$D(\\pmb m)$都有唯一的$\\Lambda(\\pmb v)$与之对应。\n综合起来可得Smith几何函数$G_1$的具体形式：\n$$\nG_1(\\pmb m, \\pmb v)=\\frac{\\chi^+(\\pmb m\\cdot\\pmb v)}{1+\\Lambda(\\pmb v)}\n$$\n具有形状不变性的法线分布函数能够得到$\\Lambda(\\pmb v)$的解析解，如：\nBeckmann分布函数\n$$\n\\begin{align}\nP^{22}(x_{\\tilde m},y_{\\tilde m})\u0026amp;=\\frac{1}{\\pi\\alpha^2}\\exp\\left(-\\frac{x^2_{\\tilde m}+y^2_{\\tilde m}}{\\alpha^2}\\right)\\\\\\\\\nD(\\pmb m)\u0026amp;=\\frac{1}{\\pi\\alpha^2(\\pmb n\\cdot\\pmb m)^4}\\exp(\\frac{(\\pmb n\\cdot\\pmb m)^2-1}{\\alpha^2(\\pmb n\\cdot\\pmb m)^2})\\\\\\\\\n\\Lambda(a)\u0026amp;=\\frac{\\mathrm{erf}(a)-1}{2}+\\frac{1}{2a\\sqrt{\\pi}}\\exp(-a^2)\n\\end{align}\n$$\n其中，\n$$\n\\begin{align}\na\u0026amp;=\\frac{\\pmb n\\cdot \\pmb v}{a\\sqrt{1-(\\pmb n\\cdot\\pmb v)^2}}\\\\\\\\\n\\mathrm{erf}(x)\u0026amp;=\\frac{2}{\\sqrt{\\pi}}\\int_0^xe^{-x'^2}\\mathrm dx'^2\n\\end{align}\n$$\n当然上述公式的计算开销很大，Walter等人给出一种近似逼近：\n$$\n\\Lambda(a)=\\begin{cases}\n\\frac{1-1.259a+0.396a^2}{3.535a+2.181a^2},\u0026amp;a\u0026lt;1.6\\\\\\\\\n0,\u0026amp;a\\geq 1.6\n\\end{cases}\n$$\n**GGX分布函数**\n$$\n\\begin{aligned}\nP^{22}(x_{\\tilde m},y_{\\tilde m})\u0026amp;=\\frac{1}{\\pi\\alpha^2\\left(1+\\frac{x^2_{\\tilde m}+y_{\\tilde m}^2}{\\alpha^2}\\right)^2}\\\\\\\\\nD(\\pmb m)\u0026amp;=\\frac{\\alpha^2}{\\pi((\\pmb n\\cdot \\pmb m)^2(\\alpha^2-1)+1)^2}\\\\\\\\\n\\Lambda(a)\u0026amp;=\\frac{-1+\\sqrt{1+\\frac{1}{a^2}}}{2}\n\\end{aligned}\n$$\n其中，\n$$\na=\\frac{\\pmb n\\cdot \\pmb v}{a\\sqrt{1-(\\pmb n\\cdot\\pmb v)^2}}\n$$\n同时，Karis也给出了GGX的Smith $G_1$计算近似公式：\n$$\nG_1(\\pmb v)\\approx \\frac{2(\\pmb n\\cdot\\pmb v)}{(\\pmb n\\cdot\\pmb v)(2-\\alpha)+\\alpha}\n$$\n可以很方便地用在实时渲染中。\n对于各向异性的法线分布函数，可以证明$\\Lambda(\\cdot)$与各向同性版本的一致。\n4.3.2. Smith联合遮蔽函数-阴影函数 分离的遮蔽阴影函数\n最简单和广泛使用的遮蔽阴影函数，认为遮蔽和阴影是独立的，可以分别计算并进行相乘：\n$$\n\\begin{align}\nG_2(\\pmb v,\\pmb l,\\pmb m)\u0026amp;=G_1(\\pmb v,\\pmb m)G_1(\\pmb l,\\pmb m)\\\\\\\\\n\u0026amp;=\\frac{\\chi^+(\\pmb v\\cdot\\pmb m)}{1+\\Lambda(\\pmb v)}\\frac{\\chi^+(\\pmb l\\cdot\\pmb m)}{1+\\Lambda(\\pmb l)}\n\\end{align}\n$$\n这种形式不模拟遮蔽和阴影之间的相关性，因此总会多估算阴影，因为一些相关性总是存在的\n高度相关的遮蔽阴影函数\n这种形式的遮蔽阴影函数更好地模拟了由于微表面高度引起的遮蔽和阴影之间的相关性。直观地说，微平面在微表面升高得越多，对于出射方向未被遮蔽和入射方向未被掩蔽的可见概率会同时增加，形式如下：\n$$\nG_2(\\pmb v,\\pmb l,\\pmb m)=\\frac{\\chi^+(\\pmb v\\cdot\\pmb m)\\chi^+(\\pmb l\\cdot\\pmb m)}{1+\\Lambda(\\pmb v)+\\Lambda(\\pmb l)}\n$$\n方向相关的遮蔽阴影函数\n通过混合可分离的遮蔽阴影函数与两个方向完全相关的情形来表达方向相关：\n$$\nG_2(\\pmb v,\\pmb l,\\pmb m)=\\lambda(\\phi)G_1(\\pmb v,\\pmb m)G_1(\\pmb l,\\pmb m)+(1-\\lambda(\\phi))\\min(G_1(\\pmb v,\\pmb m),G_1(\\pmb l,\\pmb m))\n$$\n其中$\\lambda(\\phi)$是一个经验公式，随着角度$\\phi$的增大，$\\lambda$从0增大到1，Ashikhmin等人建议使用一个高斯函数进行处理：\n$$\n\\lambda(\\phi)=1-e^{-7.3\\phi^2}\n$$\nvan Ginneken则提出另外一种计算方法：\n$$\n\\lambda(\\phi)=\\frac{4.41\\phi}{4.41\\phi+1}\n$$\n高度方向相关的遮蔽阴影函数\n结合高度相关形式和方向相关形式，可以得到：\n$$\nG_2(\\pmb v, \\pmb l,\\pmb m)=\\frac{\\chi^+(\\pmb v\\cdot\\pmb m)\\chi^+(\\pmb l\\cdot\\pmb m)}{1+\\max(\\Lambda(\\pmb v),\\Lambda(\\pmb l))+\\lambda(\\pmb v\\cdot\\pmb l)\\min(\\Lambda(\\pmb v),\\Lambda(\\pmb l))}\n$$\n  当出射方向与入射方向平行且$\\lambda=0$时，遮蔽和阴影完全相关\n  相关性随着方向之间的夹角增加而减小，当$\\lambda=1$时，遮蔽和阴影不再方向相关，而是退化为高度相关的形式\n  $\\lambda$的计算同样可以通过：\n$$\n\\lambda(\\phi)=\\frac{4.41\\phi}{4.41\\phi+1}\n$$\n$\\phi$为$\\pmb v$和$\\pmb l$之间的方位角\n  4.4. 菲涅尔反射 我们已经知道光在两介质的交界表面会发生反射和折射现象，在不考虑次表面散射和透射的情况下我们常常只关注反射光（只有反射光对BRDF有贡献），由费马原理（光路最短原理）我们能够从几何上求出入射角和折射角的关系，但无法确定入射光和折射光、反射光的比例关系。而菲涅尔方程则能够描述了光在介质表面传播的能量关系。\n4.4.1. 菲涅尔方程的推导 要推导出菲涅尔方程，我们需要重新回到麦克斯韦方程组，假设在均匀线性物质中，不存在自由电荷和电流，则麦克斯韦方程组变为：\n$$\n\\begin{aligned}\n\\nabla \\cdot\\pmb E \u0026amp;= 0\\\\\\\\\n\\nabla\\cdot\\pmb B\u0026amp;=0\\\\\\\\\n\\nabla\\times \\pmb E\u0026amp;=-\\frac{\\partial \\pmb B}{\\partial t}\\\\\\\\\n\\nabla\\times \\pmb B\u0026amp;=\\varepsilon\\mu\\frac{\\partial \\pmb E}{\\partial t}\n\\end{aligned}\n$$\n由前述推导中，我们可以很容易求得：\n$$\n\\begin{matrix}\n\\nabla^2\\pmb E=\\mu\\varepsilon\\dfrac{\\partial^2\\pmb E}{\\partial t^2}\u0026amp;\\nabla^2\\pmb B=\\mu\\varepsilon\\dfrac{\\partial^2\\pmb B}{\\partial t^2}\n\\end{matrix}\n$$\n可以看到$\\pmb E$和$\\pmb B$的每个直角坐标分量都满足三维波方程的形式：\n$$\n\\nabla^2f=\\frac{1}{v^2}\\frac{\\partial^2 f}{\\partial t^2}\n$$\n波速：\n$$\nv=\\frac{1}{\\sqrt{\\mu\\varepsilon}}\n$$\n这个波速也为光速，在真空中$v=1/\\sqrt{\\mu_0\\varepsilon_0}=3.00\\times 10^8m/s$\n定义折射率\n$$\nn=\\sqrt{\\frac{\\varepsilon\\mu}{\\varepsilon_0\\mu_0}}\n$$\n则均匀线性物质中的光速为$v=c/n$\n能量密度为：\n$$\nu=\\frac{1}{2}\\left(\\varepsilon E^2+\\frac{1}{\\mu}B^2 \\right)\n$$\n对于单色平面波，波的强度为：\n$$\nI=\\frac{1}{2}\\varepsilon vE_0^2\n$$\n边界条件\n根据麦克斯韦的积分形式，我们可以推导出电磁场在无自由电荷或自由电流的线性介质的边界条件：\n$$\n\\begin{aligned}\n\\varepsilon_1\\pmb E_1^\\perp-\\varepsilon_2\\pmb E_2^\\perp\u0026amp;=0\\\\\\\\\n\\pmb E_1^{\\parallel}-\\pmb E_2^{\\parallel}\u0026amp;=0\\\\\\\\\n\\pmb B_1^\\perp-\\pmb B_2^\\perp\u0026amp;=0\\\\\\\\\n\\frac{1}{\\mu_1}\\pmb B_1^\\parallel-\\frac{1}{\\mu_2}\\pmb B_2^\\parallel\u0026amp;=0\n\\end{aligned}\n$$\n垂直入射的反射与折射\n如上图所示，假设$xy$平面为两线性介质的界面，角频率为$\\omega$，沿$z$方向传播和沿$x$方向偏振的平面波从左边入射到界面：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ I(z,t)\u0026amp;=\\tilde E_{0I}e^{i(k_1z-\\omega t)}\\hat{\\pmb x}\\\\\\\\\n\\tilde{\\pmb B}_ I(z,t)\u0026amp;=\\frac{1}{v_I}\\tilde E_{0I}e^{i(k_1z-\\omega t)}\\hat{\\pmb y}\n\\end{align}\n$$\n它将产生一个反射波：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ R(z,t)\u0026amp;=\\tilde E_{0R}e^{i(-k_1z-\\omega t)}\\hat{\\pmb x}\\\\\\\\\n\\tilde{\\pmb B}_ R(z,t)\u0026amp;=-\\frac{1}{v_1}\\tilde E_{0R}e^{i(-k_1z-\\omega t)}\\hat{\\pmb y}\n\\end{align}\n$$\n和一个透射波：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ T(z,t)\u0026amp;=\\tilde E_{0T}e^{i(k_2z-\\omega t)}\\hat{\\pmb x}\\\\\\\\\n\\tilde{\\pmb B}_ T(z,t)\u0026amp;=\\frac{1}{v_2}\\tilde E_{0T}e^{i(k_2z-\\omega t)}\\hat{\\pmb y}\n\\end{align}\n$$\n由边界条件可以得到：\n$$\n\\begin{align}\n\\tilde E_{0I}+\\tilde E_{0R}\u0026amp;=\\tilde E_{0T}\\\\\\\\\n\\frac{1}{\\mu_1}\\left(\\frac{1}{v_1}\\tilde E_{0I}-\\frac{1}{v_1}\\tilde E_{0R} \\right)\u0026amp;=\\frac{1}{\\mu_2}\\left(\\frac{1}{v_2}\\tilde E_{0T}\\right)\n\\end{align}\n$$\n解得：\n$$\n\\begin{aligned}\n\\tilde E_{0R}=\\left(\\frac{1-\\beta}{1+\\beta}\\right)\\tilde E_{0I}\\\\\\\\\n\\tilde E_{0T}=\\left(\\frac{2}{1+\\beta}\\right)\\tilde E_{0I}\n\\end{aligned}\n$$\n其中，\n$$\n\\beta\\equiv \\frac{\\mu_1v_1}{\\mu_2v_2}=\\frac{\\mu_1n_2}{\\mu_2n_1}\n$$\n若介质的磁导率$\\mu$与真空中的接近（大多数介质是这样），则$\\beta\\approx v_1/v_2$，有：\n$$\n\\begin{aligned}\n\\tilde E_{0R}=\\left(\\frac{v_2-v_1}{v_2+v_1}\\right)\\tilde E_{0I}\\\\\\\\\n\\tilde E_{0T}=\\left(\\frac{2v_2}{v_2+v_1}\\right)\\tilde E_{0I}\n\\end{aligned}\n$$\n实振幅间有以下关系：\n$$\n\\begin{aligned}\nE_{0R}=\\left|\\frac{v_2-v_1}{v_2+v_1}\\right|E_{0I}=\\left|\\frac{n_1-n_2}{n_1+n_2}\\right|E_{0I}\\\\\\\\\nE_{0T}=\\left|\\frac{2v_2}{v_2+v_1}\\right|E_{0I}=\\left|\\frac{2n_1}{n_1+n_2}\\right|E_{0I}\n\\end{aligned}\n$$\n从能量角度看，反射波与入射波强度之比为：\n$$\nR\\equiv\\frac{I_R}{I_I}=\\left(\\frac{E_{0R}}{E_{0I}}\\right)^2=\\left(\\frac{n_1-n_2}{n_1+n_2}\\right)^2\n$$\n透射波与入射波强度之比为：\n$$\nT\\equiv\\frac{I_T}{I_I}=\\frac{\\varepsilon_2v_2}{\\varepsilon_1v_1}\\left(\\frac{E_{0T}}{E_{0I}}\\right)^2=\\frac{4n_1n_2}{(n_1+n_2)^2}\n$$\n其中，$R$称为反射系数，$T$称为透射系数，注意到，$R+T=1$，也是一种能量守恒。\n倾斜入射的反射与折射\n如上图所示，考虑更一般的入射情况，入射角度为$\\theta_I$，假设一个单色平面波：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ I(\\pmb r,t)\u0026amp;=\\tilde E_{0I}e^{i(\\pmb k_I\\cdot\\pmb r-\\omega t)}\\\\\\\\\n\\tilde{\\pmb B}_ I(\\pmb r,t)\u0026amp;=\\frac{1}{v_1}(\\tilde{\\pmb k_I}\\times\\tilde{\\pmb E_I})\n\\end{align}\n$$\n从左边入射，得到一个反射波：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ R(\\pmb r,t)\u0026amp;=\\tilde {\\pmb E}_{0R}e^{i(\\pmb k_R\\cdot\\pmb r-\\omega t)}\\\\\\\\\n\\tilde{\\pmb B}_ R(\\pmb r,t)\u0026amp;=\\frac{1}{v_1}(\\tilde{\\pmb k_R}\\times\\tilde{\\pmb E_R})\n\\end{align}\n$$\n和一个透射波：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ T(\\pmb r,t)\u0026amp;=\\tilde {\\pmb E}_{0T}e^{i(\\pmb k_T\\cdot\\pmb r-\\omega t)}\\\\\\\\\n\\tilde{\\pmb B}_ T(\\pmb r,t)\u0026amp;=\\frac{1}{v_2}(\\tilde{\\pmb k_T}\\times\\tilde{\\pmb E_T})\n\\end{align}\n$$\n所有三个波具有相同的频率$\\omega$，该物理量由光源所决定，因此三个波的波数之间存在关系：\n$$\nk_Iv_1=k_Rv_1=k_Tv_2=\\omega\n$$\n由边界条件，介质(1)中的合场强$\\tilde{\\pmb E}_I+\\tilde{\\pmb E}_R$和$\\tilde{\\pmb B}_I+\\tilde{\\pmb B}_R$必须拟合介质(2)中的合场强$\\tilde{\\pmb E_T}+\\tilde{\\pmb B}_T$，因此当$z=0$时，应有：\n$$\n\\pmb k_I\\cdot \\pmb r=\\pmb k_R\\cdot\\pmb r=\\pmb k_T\\cdot\\pmb r\n$$\n保证指数项相等，因此，对所有的$x$和$y$有：\n$$\nx(k_I)_x+y(k_I)_y=\nx(k_R)_x+y(k_R)_y=\nx(k_T)_x+y(k_T)_y\n$$\n对$x=0$，有\n$$\n(k_I)_y=(k_R)_y=(k_T)_y\n$$\n对$y=0$，有\n$$\n(k_I)_x=(k_R)_x=(k_T)_x\n$$\n因此，通过改变坐标轴的方向，我们可以使得$\\pmb k_I$、$\\pmb k_R$和$\\pmb k_T$均在xz平面内，至此，我们可以得出几何光学的三个基本定律：\n  入射光、反射光和折射光矢量在同一个平面内（称为入射面），入射面法线也在入射面内，同时满足：\n$$\nk_I\\sin\\theta_I=k_R\\sin\\theta_R=k_T\\sin\\theta_T\n$$\n式中，$\\theta_I$为入射角，$\\theta_R$为反射角，$\\theta_T$为折射角，都是相对于法线方向考虑\n  由于$k_1v_1=k_Rv_1=\\omega$，因此$k_I=k_R$，于是有入射角等于反射角：\n$$\n\\theta_I=\\theta_R\n$$\n即反射定律\n  由$k_Iv_1=k_Tv_2=\\omega$，可得\n$$\nk_I=\\frac{n_1}{n_2}k_T\n$$\n因此有\n$$\n\\frac{\\sin\\theta_T}{\\sin\\theta_I}=\\frac{n_1}{n_2}\n$$\n即折射定律，又称斯涅尔定律\n  回到边界条件问题，我们已经可以将指数项进行抵消，则可以得到下述新的边界条件方程：\n$$\n\\begin{aligned}\n\\varepsilon_1(\\tilde {\\pmb E}_ {0I}+\\tilde{\\pmb E}_ {0R})_z\u0026amp;=\\varepsilon_2(\\tilde {\\pmb E}_ {0T})_z\\\\\\\\\n(\\tilde {\\pmb B}_{0I}+\\tilde{\\pmb B}_ {0R})_z\u0026amp;=(\\tilde {\\pmb B}_ {0T})_z\\\\\\\\\n(\\tilde{\\pmb E}_{0T}+\\tilde {\\pmb E}_ {0R})_{x,y}\u0026amp;=(\\tilde {\\pmb E}_ {0T})_{x,y}\\\\\\\\\n\\frac{1}{\\mu_1}(\\tilde{\\pmb B}_ {0T}+\\tilde {\\pmb B}_ {0R})_{x,y}\u0026amp;=\\frac{1}{\\mu_2}(\\tilde {\\pmb B}_ {0T})_{x,y}\n\\end{aligned}\n$$\n其中，$\\tilde{\\pmb B}_0=(1/v)\\hat{\\pmb k}\\times\\tilde{\\pmb E}_0$\n为了简化问题，假设入射波的电场的偏振方向平行于入射面，即图中的$xz$平面，这样一来反射和透射波的电场的偏振方向也在这个面内，则边界条件方程可表示为：\n$$\n\\begin{align}\n\\varepsilon_1(-\\tilde E_{0I}\\sin\\theta_I+\\tilde E_{0R}\\sin\\theta_R)\u0026amp;=\\varepsilon_2(-\\tilde E_{0T}\\sin\\theta_T)\\\\\\\\\n\\tilde E_{0I}\\cos\\theta_I+\\tilde E_{0R}\\cos\\theta_R\u0026amp;=\\tilde{E}_{0T}\\cos\\theta_T\\\\\\\\\n\\frac{1}{\\mu_1v_1}(\\tilde E_{0I}-\\tilde E_{0R})\u0026amp;=\\frac{1}{\\mu_2v_2}\\tilde E_{0T}\n\\end{align}\n$$\n由反射定律和折射定律，上式可简化为：\n$$\n\\begin{aligned}\n\\tilde E_{0I}-\\tilde E_{0R}\u0026amp;=\\beta\\tilde E_{0T}\\\\\\\\\n\\tilde E_{0I}+\\tilde E_{0R}\u0026amp;=\\alpha\\tilde E_{0T}\n\\end{aligned}\n$$\n其中，\n$$\n\\begin{align}\n\\alpha\u0026amp;\\equiv\\frac{\\cos\\theta_T}{\\cos\\theta_I}\\\\\\\\\n\\beta\u0026amp;\\equiv\\frac{\\mu_1v_1}{\\mu_2v_2}=\\frac{\\mu_1n_2}{\\mu_2n_1}\n\\end{align}\n$$\n解得：\n$$\n\\begin{aligned}\n\\tilde E_{0R}\u0026amp;=\\left(\\frac{\\alpha-\\beta}{\\alpha+\\beta}\\right)\\tilde E_{0I}\\\\\\\\\n\\tilde E_{0T}\u0026amp;=\\left(\\frac{2}{\\alpha+\\beta}\\right)\\tilde E_{0I}\n\\end{aligned}\n$$\n上式则是大名鼎鼎的菲涅尔方程了，可以看到透射波和反射波的振幅受入射角度影响，因为$\\alpha$是关于$\\theta_I$的函数：\n$$\n\\alpha=\\frac{\\sqrt{1-\\sin^2\\theta_T}}{\\cos\\theta_I}=\\frac{\\sqrt{1-[(n_1/n_2)\\sin\\theta_I]^2}}{\\cos\\theta_I}\n$$\n反射率和透射率随入射角度的变化如下图所示：\n而且可以看到，当$\\alpha=\\beta$时，即\n$$\n\\sin^2\\theta_B=\\frac{1-\\beta^2}{(n_1/n_2)^2-\\beta^2}\n$$\n反射波完全消失，$\\theta_B$成为布鲁斯特角。而当入射角$\\theta_I=90°$时，$\\tilde E_{0R}=\\tilde E_{0I}$，入射光全部反射，因此当光打在一个球体上，球面掠角方向应会有反光现象：\n再从能量角度看，单位入射面上的功率为$\\pmb S\\cdot\\hat{\\pmb z}$，入射强度为：\n$$\nI_I=\\frac{1}{2}\\varepsilon_1v_1E_{0I}^2\\cos\\theta_I\n$$\n反射和折射强度分别为：\n$$\n\\begin{align}\nI_R\u0026amp;=\\frac{1}{2}\\varepsilon_1v_1E_ {0R}^2\\cos\\theta_R\\\\\\\\\nI_T\u0026amp;=\\frac{1}{2}\\varepsilon_2v_2E_ {0T}^2\\cos\\theta_T\n\\end{align}\n$$\n反射系数和透射系数为：\n$$\n\\begin{aligned}\nR\u0026amp;\\equiv\\frac{I_R}{I_I}=\\left(\\frac{E_{0R}}{E_{0I}}\\right)^2=\\left(\\frac{\\alpha-\\beta}{\\alpha+\\beta}\\right)^2\\\\\\\\\nI_T\u0026amp;\\equiv\\frac{I_T}{I_I}=\\frac{\\varepsilon_2v_2}{\\varepsilon_1v_1}\\left(\\frac{E_{0T}}{E_{0I}}\\right)^2\\frac{\\cos\\theta_T}{\\cos\\theta_I}=\\alpha\\beta\\left(\\frac{2}{\\alpha+\\beta}\\right)^2\n\\end{aligned}\n$$\n4.4.2. Schlick近似 在实际渲染中，对菲涅尔项的处理经常采用Schlick近似方法进行逼近：\n$$\nR(\\theta)=R_0+(1-R_0)(1-\\cos\\theta)^5\n$$\n其中，\n$$\nR_0=\\left(\\frac{n_1-n_2}{n_1+n_2}\\right)^2\n$$\n4.5. 镜面反射项 至此，我们已经详细推导了基于物理的BRDF中镜面反射项的三个重要组成部分：\n 法线分布函数$D(\\pmb m)$ 几何函数$G(\\pmb m,\\pmb v)$ 菲涅尔项$F(\\pmb v,\\pmb m)$  现在来研究如何将这三项整合到我们的PBR着色模型中。\n4.5.1. 半矢量 前面已经简单介绍过半矢量$\\pmb h$的概念，这里再提一下。如上图所示，只有当入射光通过微表面反射后能够沿着视角方向的反射光才能对BRDF有贡献，因此我们定义使得反射光能够沿视角方向的法向量为半矢量：\n$$\n\\pmb h=\\widehat{\\pmb v+\\pmb l}\n$$\n在渲染中，我们常用半矢量$\\pmb h$代替微表面法向$\\pmb m$。\n下面推导中，我们采用的符号意义如上图所示\n4.5.2. Torrance-Sparrow模型 Torrance-Sparrow模型是微表面BRDF的一个经典模型，其镜面反射项与IlumEngine中所用的Cook-Torrance BRDF几乎一致，这里以Torrance-Sparrow模型为例推导从微表面模型到基于物理的BRDF。\n微表面上方向为$\\pmb \\omega_h$的微元面积为：\n$$\n\\mathrm dA(\\pmb \\omega_h)=D(\\pmb \\omega_h)\\mathrm d\\pmb \\omega_h\\mathrm dA\n$$\n因此微元面积上的辐射通量为：\n$$\n\\begin{align}\n\\mathrm d\\Phi_h\u0026amp;=L_i(\\pmb \\omega_i)\\mathrm d\\pmb \\omega_i\\mathrm dA^\\perp(\\pmb \\omega_h)\\\\\\\\\n\u0026amp;=L_i(\\pmb \\omega_i)\\mathrm d\\pmb \\omega_i\\cos\\theta_h\\mathrm dA(\\pmb \\omega_h)\\\\\\\\\n\u0026amp;=L_i(\\pmb \\omega_i)\\mathrm d\\pmb \\omega_i\\cos\\theta_hD(\\pmb \\omega_h)\\mathrm d\\pmb \\omega_h\\mathrm dA\n\\end{align}\n$$\n又由菲涅尔定律，出射辐射通量有：\n$$\n\\mathrm d\\Phi_o=F(\\pmb \\omega_o)\\mathrm d\\Phi_h\n$$\n又根据辐亮度定义：\n$$\nL(\\pmb \\omega_o)=\\frac{\\mathrm d\\Phi_o}{\\mathrm d\\pmb \\omega_o\\cos\\theta_o\\mathrm dA}\n$$\n联立有：\n$$\nL(\\pmb \\omega_o)=\\frac{F(\\pmb \\omega_o)L_i(\\pmb \\omega_i)\\mathrm d\\pmb \\omega_iD(\\pmb \\omega_h)\\mathrm d\\pmb \\omega_h\\mathrm dA\\cos\\theta_h}{\\mathrm d\\pmb \\omega_o\\mathrm dA\\cos\\theta_o}\n$$\n但是对半矢量$\\pmb \\omega_h$是困难的，我们将其转化为简单地对$\\pmb \\omega_o$采样，由立体角公式，我们有：\n$$\n\\frac{\\mathrm d\\pmb \\omega_h}{\\mathrm d\\pmb \\omega_i}=\\frac{\\sin\\theta_h\\mathrm d\\theta_h\\mathrm d\\phi_h}{\\sin\\theta_i\\mathrm d\\theta_i\\mathrm d\\phi_i}\n$$\n如下图所示，\n由反射定律，显然有$\\theta_i=2\\theta_h$，又由反射面性质，有$\\phi_i=\\phi_h$，因此，\n$$\n\\begin{align}\n\\frac{\\mathrm d\\pmb \\omega_h}{\\mathrm d\\pmb \\omega_i}=\\frac{\\mathrm d\\pmb \\omega_h}{\\mathrm d\\pmb \\omega_o}\n\u0026amp;=\\frac{\\sin\\theta_h\\mathrm d\\theta_h\\mathrm d\\phi_h}{\\sin\\theta_i\\mathrm d\\theta_i\\mathrm d\\phi_i}\\\\\\\\\n\u0026amp;=\\frac{\\sin\\theta_h\\mathrm d\\theta_h\\mathrm d\\phi_h}{2\\sin2\\theta_h\\mathrm d\\theta_h\\mathrm d\\phi_h}\\\\\\\\\n\u0026amp;=\\frac{1}{4\\cos\\theta_h}\\\\\\\\\n\u0026amp;=\\frac{1}{4(\\pmb \\omega_i\\cdot\\pmb \\omega_h)}=\\frac{1}{4(\\pmb \\omega_o\\cdot\\pmb \\omega_h)}\n\\end{align}\n$$\n代入到辐亮度求算公式，有：\n$$\nL(\\pmb \\omega_o)=\\frac{F(\\pmb \\omega_o)L_i(\\pmb \\omega_i)D(\\pmb \\omega_h)\\mathrm d\\pmb \\omega_i}{4\\cos\\theta_o}\n$$\n进一步考虑几何函数，则BRDF可以写为：\n$$\nf_r(\\pmb \\omega_o,\\pmb \\omega_i)=\\frac{F(\\pmb \\omega_o)G(\\pmb \\omega_o,\\pmb \\omega_i)D(\\pmb \\omega_h)}{4\\cos\\theta_o\\cos\\theta_i}=\\frac{F(\\pmb \\omega_o)G(\\pmb \\omega_o,\\pmb \\omega_i)D(\\pmb \\omega_h)}{4(\\pmb \\omega_o\\cdot \\pmb n)(\\pmb \\omega_i\\cdot \\pmb n)}\n$$\n至此，我们的基于物理BRDF的镜面反射项推导完成。\n5. PBR着色模型 5.1. Cook-Torrance BRDF 综合前述推导，我们得到Cook-Torrance BRDF的最终形式：\n$$\nf_r(\\pmb \\omega_o,\\pmb \\omega_i)=(1-F(\\pmb\\omega_o))\\frac{\\rho}{\\pi}+\\frac{F(\\pmb \\omega_o)G(\\pmb \\omega_o,\\pmb \\omega_i)D(\\pmb \\omega_h)}{4(\\pmb \\omega_o\\cdot \\pmb n)(\\pmb \\omega_i\\cdot \\pmb n)}\n$$\n其中，\n  $\\rho$为Albedo，材质的颜色\n  $F(\\pmb\\omega_o)$为菲涅尔系数，选用Schlick近似\n$$\n\\begin{align}\nF(\\theta)\u0026amp;=F_0+(1-F_0)(1-\\cos\\theta)^5\\\\\\\\\nF_0\u0026amp;=\\left(\\frac{n_1-n_2}{n_1+n_2}\\right)^2\n\\end{align}\n$$\n  $D(\\pmb \\omega_h)$为法线分布函数，选用GGX分布\n$$\nD(\\pmb \\omega_h)=\\frac{\\alpha^2}{\\pi((\\pmb n\\cdot \\pmb \\omega_h)^2(\\alpha^2-1)+1)^2}\n$$\n  $G(\\pmb\\omega_o,\\pmb\\omega_i)$为几何函数，选用Smith分布的Schlick近似\n$$\nG(\\pmb \\omega_o,\\pmb\\omega_i)=\\frac{\\pmb \\omega_o\\cdot\\pmb\\omega_h}{(\\pmb \\omega_o\\cdot\\pmb\\omega_h)(1-k)+k}\n$$\n其中，$k=\\frac{(\\alpha+1)^2}{8}$\n  5.2. 金属工作流 Cook-Torrance BRDF中的Schlick近似的菲涅尔公式只能用于描述电介质材质（水、玻璃），对于导体（如金属）则需要使用另外一个菲涅尔公式，对材质设计造成不变，金属工作流则使用金属度参数进行插值金属属性，使得菲涅尔公式同时可以用于描述电介质和导体，非金属的$F_0$默认为0.04，而金属的$F_0$则为表面颜色，通过金属度插值$F_0$的GLSL代码如下：\n1 2  vec3 F0 = vec3(0.04); F0 = mix(F0, albedo, metallic);   不同金属度和粗糙度的着色结果：\n    Roughness = 0.1 Roughness = 0.4 Roughness = 0.7 Roughness = 1.0     Metallic = 0.1       Metallic = 0.4       Metallic = 0.7       Metallic = 1.0        5.3. 多次弹射Kulla-Conty能量补偿 前述的微表面模型仅考虑光线与微表面的单次反射，而不考虑光线多次弹射的结果，这将带来能量损失的问题，具体表现为当材质粗糙度越大时，物体的亮度越低，如下图所示：\nHeitz于2016年给出了能量补偿问题的精确解，但由于计算量过大并不适合于实时渲染，Kulla和Conty则给出了一种近似的能量补偿算法。\n首先，定义给定出射方向$\\mu_o$二维BRDF lobe的总能量，这个能量表示了单次弹射的能量占比：\n$$\nE(\\mu_o)=\\int_0^{2\\pi}\\int_0^1f(\\mu_o,\\mu_i,\\phi)\\mu_i\\mathrm d\\mu_i\\mathrm d\\phi\n$$\n在半球上进行积分，其中$\\mu=\\sin\\theta$\nKulla-Conty方法的核心思想是设计另外一个BRDF，满足积分为$1-E(\\mu_0)$，则这个能量将作为能量补偿项。\n通过经验性的拼凑，凑出了一个满足要求的BRDF函数：\n$$\nf_{ms}(\\mu_o,\\mu_i)=\\frac{(1-E(\\mu_o))(1-E(\\mu_i))}{\\pi(1-E_{avg})}\n$$\n其中，\n$$\nE_{\\mathrm{avg}}=2\\int_0^1E(\\mu)\\mu\\mathrm d\\mu\n$$\n验证一下$f_{ms}(\\mu_o,\\mu_i)$是否满足要求：\n$$\n\\begin{align}\nE_{ms}(\\mu_o)\n\u0026amp;=\\int_0^{2\\pi}\\int_0^1f_{ms}(\\mu_o,\\mu_i,\\phi)\\mu_i\\mathrm d\\mu_i\\mathrm d\\phi\\\\\\\\\n\u0026amp;=2\\pi\\int_0^1\\frac{(1-E(\\mu_o))(1-E(\\mu_i))}{\\pi(1-E_{\\mathrm{avg}})}\\mu_i\\mathrm d\\mu_i\\\\\\\\\n\u0026amp;=2\\frac{1-E(\\mu_o)}{1-E_{\\mathrm {avg}}}\\int_0^1(1-E(\\mu_i))\\mu_i\\mathrm d\\mu_i\\\\\\\\\n\u0026amp;=\\frac{1-E(\\mu_o)}{1-E_{\\mathrm {avg}}}(1-E_{\\mathrm {avg}})\\\\\\\\\n\u0026amp;=1-E(\\mu_o)\n\\end{align}\n$$\n确实是可以的。\n然而$E(\\mu)$和$E_{\\mathrm {avg}}$都没有解析表达，因此在实际开发中应使用预计算的方法，用贴图预存积分结果。\n对于$E(\\mu)$，采用一张单通道二维贴图进行存储，从上到下粗糙度依次增加，从左到右$\\mu$依次增加\n对于$E_{\\mathrm{avg}}$，采用一张单通道一维贴图进行存储，为了可视化方便，这里仍采用二维贴图进行展示，从上到下粗糙度依次增加\n从上图中可以看到的能量，在粗糙度低时微表面能量损失少，能量多存储结果较大；在粗糙度高时微表面能量损失多，能量少结果偏黑，与我们的认知是一致的。\n截至目前，我们仅讨论没有颜色的BRDF的能量补偿情况，对于具有颜色的BRDF，意味着会发生能量的吸收，能量将发生损失，因此我们仍需要计算损失的能量。\n定义平均菲涅尔系数（表示了被反射的能量的多少）：\n$$\nE_{\\mathrm{avg}}=\\frac{\\int_0^1F(\\mu)\\mu\\mathrm d\\mu}{\\int_0^1\\mu\\mathrm d\\mu}=2\\int_0^1F(\\mu)\\mu\\mathrm d\\mu\n$$\n因此带有颜色的反射能量为：$F_{\\mathrm{avg}}E_{\\mathrm{avg}}$\n 一次弹射之后：$F_{\\mathrm{avg}}(1-E_{\\mathrm{avg}})\\cdot F_{\\mathrm{avg}}E_{\\mathrm{avg}}$ …… $k$次弹射之后：$F_{\\mathrm{avg}}^k(1-E_{\\mathrm{avg}})^k\\cdot F_{\\mathrm{avg}}E_{\\mathrm{avg}}$  等比数列求和得到颜色项：\n$$\n\\sum_{k=0}^\\infty F_{\\mathrm{avg}}^k(1-E_{\\mathrm{avg}})^k\\cdot F_{\\mathrm{avg}}E_{\\mathrm{avg}}=\\frac{F_{\\mathrm{avg}}E_{\\mathrm{avg}}}{1-F_{\\mathrm{avg}}(1-E_{\\mathrm{avg}})}\n$$\n其中$F_{\\mathrm{avg}}$也没有很好求，不过有一种近似的计算方法：\n$$\n\\begin{aligned}\nF_{\\mathrm{avg}}(r,g)\u0026amp;\\approx 0.087237 + 0.0230685g - 0.0864902g^2 + 0.0774594g^3\\\\\\\\\n\u0026amp;+ 0.782654r - 0.136432r^2 + 0.278708r^3\\\\\\\\\n\u0026amp;+ 0.19744gr + 0.0360605g^2r - 0.2586gr^2;\n\\end{aligned}\n$$\n其中$r$为反射率，$g$为边缘色调，通常取$r$为Albedo颜色，$g=(0.827, 0.792, 0.678)$即可\n下图展示了Kulla-Conty能量补偿的结果，其中上面一行为进行能量补偿的结果，下一行为未进行能量补偿的结果\n6. 参考资料 【基于物理的渲染（PBR）白皮书】（一） 开篇：PBR核心知识体系总结与概览\n【基于物理的渲染（PBR）白皮书】（二） PBR核心理论与渲染光学原理总结\n【基于物理的渲染（PBR）白皮书】（四）法线分布函数相关总结\n【基于物理的渲染（PBR）白皮书】（五）几何函数相关总结\nAkenine-Moller, Tomas, Eric Haines, and Naty Hoffman. Real-time rendering. AK Peters/crc Press, 2019.\nPharr, Matt, Wenzel Jakob, and Greg Humphreys. Physically based rendering: From theory to implementation. Morgan Kaufmann, 2016.\nGAMES202:高质量实时渲染\nGriffiths, David J. \u0026ldquo;Introduction to electrodynamics.\u0026rdquo; (2005): 574-574.\n","description":"PBR着色的相关理论推导与实现","id":8,"section":"posts","tags":["Real-time Rendering"],"title":"基于物理的实时渲染着色方法","uri":"https://chaphlagical.github.io/zh/posts/rendering/pbr/"},{"content":"1. B样条基函数 为解决Bézier曲线的全局性、端点性等问题，我们引入了Bézier样条来实现曲线的局部编辑，但由于Bézier样条曲线本质上是分段Bézier曲线，数学表达不够优美，在构造、求交等计算上较为麻烦，为此我们又引入B样条基函数的工具，能够精确表达分段Bézier曲线。\n1.1. 单位B样条基函数 B样条基函数通过不同连续阶性的简单基函数进行混合得到连续性更强的高阶基函数，例如一阶单位B样条基函数定义为：\n$$\nN_i^1(t)=\\begin{cases}\n1,\u0026amp;\\mathrm {if}\\ i\\leq t\u0026lt; i+1\\\\\\\\\n0,\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n$$\n$N_i^1(t)$为$C^{-1}$连续，函数图像如下：\n通过平移与混合：\n可以得到$C^0$连续的基函数$N_i^2(t)$：\n$$\n\\begin{aligned}\nN_i^2(t)\u0026amp;=(t-i)N_i^1(t)+(i+2-t)N_{i+1}^1(t)\\\\\\\\\n\u0026amp;=\\begin{cases}\nt-i,\u0026amp;\\mathrm{if}\\ i\\leq t\\leq i+1\\\\\\\\\ni+2-t,\u0026amp;\\mathrm{if}\\ i+1\\leq t\\leq i+2\\\\\\\\\n0,\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n\\end{aligned}\n$$\n依次类推，继续混合：\n这样一来，可以定义$k$阶的单位均匀B样条基函数$N_i^k(t)$定义为：\n$$\n\\begin{aligned}\nN_i^1(t)\u0026amp;=\\begin{cases}\n1,\u0026amp;\\mathrm {if}\\ i\\leq t\u0026lt; i+1\\\\\\\\\n0,\u0026amp;\\mathrm{otherwise}\n\\end{cases}\\\\\\\\\nN_i^k(t)\u0026amp;=\\frac{t-i}{(i+k-1)-i}N_i^{k-1}(t)+\\frac{(i+k)-t}{(i+k)-(i+1)}N_{i+1}^{k-1}(t)\\\\\\\\\n\u0026amp;=\\frac{t-i}{k-1}N_i^{k-1}(t)+\\frac{i+k-t}{k-1}N_{i+1}^{k-1}(t)\n\\end{aligned}\n$$\n**$k$阶单位B样条基函数的性质**\n $N_i^k(t)\u0026gt;0$，$i\u0026lt;t\u0026lt;i+k$ $N_i^k(t)=0$，$t\\in(-\\infty,i]\\cup [i+k,+\\infty)$ $N_i^k(t)$为$C^{k-2}$阶连续 $N_i^k(t)$为分段$k-1$次多项式函数组成  1.2. 一般的B样条基函数 给定结序列$t_0\u0026lt;t_1\u0026lt;\\cdots\u0026lt;t_n\u0026lt;\\cdots\u0026lt;t_{n+k}$，$(t_0,t_1,\\cdots,t_{n+k})$称为结向量\n归一化的$k$阶（即$k-1$度）的单位B样条基函数$N_{i,k}(t)$定义为：\n$$\n\\begin{align}\nN_{i,1}(t)\u0026amp;=\\begin{cases}\n1,\u0026amp;t_i\\leq t\u0026lt;t_{i+1}\\\\0,\u0026amp;\\mathrm{otherwise}\n\\end{cases}\\\\\\\\\nN_{i,k}(t)\u0026amp;=\\dfrac{t-t_i}{t_{i+k-1}-t_i}N_{i,k-1}(t)+\\dfrac{t_{i+k}-t}{t_{i+k}-t_{i+1}}N_{i+1,k-1}(t)\n\\end{align}\n$$\n$k$阶B样条基函数的性质\n $i=0,1,\\cdots,n$，$k\\in\\mathbb Z^+$ 对$t\\in(t_i,t_{i+k})$，有$N_{i,k}(t)\u0026gt;0$ 对$t\\in(-\\infty,t_i]\\cup[t_{i+k},+\\infty)$，有$N_{i,k}(t)=0$ 对$t\\in(t_{k-1},t_{n+1})$，有$\\sum_{i=1}^nN_{i,k}(t)=1$ $N_{i,k}(t)$由分段多项式函数组成，次数为$k-1$，在$[t_i,t_{i+k}]$上$C^{k-2}$阶连续 区间$[t_i,t_{i+k}]$称为$N_{i,k}$的支撑区间  2. B样条曲线 2.1. B样条曲线的定义 给定：\n  $n+1$个控制点$\\pmb d_0,\\pmb d_1,\\cdots,\\pmb d_n\\in\\mathbb R^3$\n  结向量$T=(t_0,\\cdots,t_n,\\cdots,t_{n+k})$\n 这是由于$N_{n,k}$定义在区间$[n,n+k]$上\n   则$k$阶的B样条曲线$\\pmb x(t)$定义为：\n$$\n\\pmb x(t)=\\sum\\limits_{i=0}^nN_{i,k}(t)\\cdot\\pmb d_i\n$$\n其中，点$\\pmb d_i$称为de Boor点\n 注意该定义下，B样条曲线不插值de Boor点$\\pmb d_i$\n 示例：\n重复结向量\nB样条曲线允许重复结向量：$T=(t_0,\\cdots,t_n,\\cdots,t_{n+k})$，$t_0\\leq t_1\\leq \\cdots\\leq t_{n+k}$\n当重复$k$次以上时，函数值视为0，没有贡献。\n当$t_0=t_1=\\cdots=t_{k-1}$且$t_{n+1}=t_{n+2}=\\cdots=t_{n+k}$时，将插值$\\pmb d_0$和$\\pmb d_1$\n示例：\n2.2. B样条曲线的计算——de Boor算法 给定：\n de Boor点：$\\pmb d_0,\\pmb d_1,\\cdots,\\pmb d_n$ 结向量：$(t_0,\\cdots,t_{k-1}=t_0,t_k,t_{k+1},\\cdots,t_n,t_{n+1},\\cdots,t_{n+k}=t_{n+1})$  则B样条曲线的计算流程如下：\n中间系数$\\pmb d_i^j(t)$可以表示为一个下三角矩阵——de Boor图：\n$$\n\\begin{matrix}\n\\pmb d_{r-k+1}=\\pmb d^0_{r-k+1}\\\\\\\\\n\\pmb d_{r-k+2}=\\pmb d^0_{r-k+2}\u0026amp;\\pmb d_{r-k+2}^1\\\\\\\\\n\\vdots\\\\\\\\\n\\pmb d_{r-1}=\\pmb d_{r-1}^0\u0026amp;\\pmb d_{r-1}^1\u0026amp;\\cdots\u0026amp;\\pmb d_{r-1}^{k-2}\\\\\\\\\n\\pmb d_r=\\pmb d_r^0\u0026amp;\\pmb d_r^1\u0026amp;\\cdots\u0026amp;\\pmb d_r^{k-2}\u0026amp;\\pmb d_r^{k-1}=\\pmb x(t)\n\\end{matrix}\n$$\n2.3. B样条曲线的性质 2.3.1. B样条基函数 vs. Bernstein多项式 结向量$T=(t_0,t_1,\\cdots,t_{2k-1})=(\\underbrace{0,\\cdots,0}_k,\\underbrace{1,\\cdots,1}_k)$下的$k$阶B样条函数$N_{i,k}(i=0,\\cdots,k-1)$为$k-1$次Bernstein多项式$B_i^{k-1}$\n2.3.2. 基本性质 给定：\n 结向量：$T=(\\underbrace{t_0,\\cdots,t_0}{k\\ \\mathrm{times}},t_k,\\cdots,t_n,\\underbrace{t{n+1},\\cdots,t_{n+1}}_{k\\ \\mathrm{times}})$ de Boor多边形$\\pmb d_0,\\cdots,\\pmb d_n$  相应的B样条曲线$\\pmb x(t)$有如下性质：\n $\\pmb x(t_{n+1})=\\pmb d_n$，$\\pmb x(t_{n+1})=\\pmb d_n$（边界点插值） $\\dot{\\pmb x}(t_0)=\\dfrac{k-1}{t_k-t_0}(\\pmb d_1-\\pmb d_0)$（$\\pmb d_0$处的切线方向与$\\pmb d_n$处相似） $\\pmb x(t)$由$n-k+2$个$k-1$次多项式曲线段构成 多重内部结$\\Rightarrow$减小了$\\pmb x(t)$的连续阶数，$l$重内部结$(1\\leq l\u0026lt;k)$意味着$C^{k-l-1}$阶连续 de Boor点的局部影响：移动$\\pmb d_i$只会改变曲线的$[t_i,t_{i+k}]$区间部分 插入新的de Boor点不会改变曲线段的多项式阶数  2.4. B样条曲线插值 给定：\n 控制点：$\\pmb k_0,\\pmb k_1,\\cdots,\\pmb k_n$ 结序列：$s_0,s_1,\\cdots,s_n$  目标：\n 分段三次插值B样条曲线$\\pmb x(t)$，满足插值条件：\n$$\n\\pmb x(s_i)=\\pmb k_i,\\ \\ \\ \\ i=0,1,\\cdots,n\n$$  方法：\n  分段三次$\\Rightarrow$$k=4$\n  重复首尾结$k-1=3$，结向量共计$n+2k-1=n+7$个结，对应$n+7-k=n+3$个de Boor点，结向量为：\n$$\n\\begin{align}\nT\u0026amp;=(t_0,t_1,t_2,t_3,t_4,\\cdots,t_{n+2},t_{n+3},t_{n+4},t_{n+5},t_{n+6})\\\\\\\\\n\u0026amp;=(s_0,s_0,s_0,s_0,s_1,\\cdots,s_{n-1},s_n,s_n,s_n,s_n)\n\\end{align}\n$$\n  插值条件（$n+1$个条件）\n$$\n\\begin{align}\n\\pmb x(s_0)\u0026amp;=\\pmb k_0=\\pmb d_0\\\\\\\\\n\\pmb x(s_i)\u0026amp;=\\pmb k_i=N_{i,4}(s_i)\\pmb d_i+N_{i+1,4}(s_i)\\pmb d_{i+1}+N_{i+2,4}(s_i)\\pmb d_{i+2}\\\\\\\\\n\u0026amp;\\mathrm{for}\\ i=1,\\cdots,n-1\\\\\\\\\n\\pmb x(s_n)\u0026amp;=\\pmb k_n=\\pmb d_{n+2}\n\\end{align}\n$$\n  终值条件（2个自然终值条件）\n$$\n\\begin{align}\n\\ddot{\\pmb x}(s_0)\u0026amp;=0\\Leftrightarrow \\dfrac{\\pmb d_2-\\pmb d_1}{s_2-s_0}=\\dfrac{\\pmb d_1-\\pmb d_0}{s_1-s_0}\\\\\\\\\n\\ddot{\\pmb x}(s_n)\u0026amp;=0\\Leftrightarrow \\dfrac{\\pmb d_{n+2}-\\pmb d_{n+1}}{s_n-s_{n-1}}=\\dfrac{\\pmb d_{n+1}-\\pmb d_n}{s_n-s_{n-2}}\n\\end{align}\n$$\n  结果可以表示为求解对角系统方程：\n$$\n\\begin{pmatrix}\n1\\\\\\\\\n\\alpha_0\u0026amp;\\beta_0\u0026amp;\\gamma_0\\\\\\\\\n\u0026amp;\\alpha_1\u0026amp;\\beta_1\u0026amp;\\gamma_1\\\\\\\\\n\u0026amp;\u0026amp;\u0026amp;\\ddots\\\\\\\\\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\alpha_{n-1}\u0026amp;\\beta_{n-1}\u0026amp;\\gamma_{n-1}\\\\\\\\\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\alpha_n\u0026amp;\\beta_n\u0026amp;\\gamma_n\\\\\\\\\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;1\n\\end{pmatrix}\n\\begin{pmatrix}\n\\pmb d_0\\\\\\\\\\pmb d_1\\\\\\\\\\pmb d_2\\\\\\\\\\vdots\\\\\\\\\\pmb d_n\\\\\\\\\n\\pmb d_{n+1}\\\\\\\\\\pmb d_{n+2}\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\pmb k_0\\\\\\\\\\pmb 0\\\\\\\\\\pmb k_1\\\\\\\\\\vdots\\\\\\\\\\pmb k_{n-1}\\\\\\\\\n\\pmb 0\\\\\\\\\\pmb k_{n}\n\\end{pmatrix}\n$$\n其中，\n$$\n\\begin{align}\n\\alpha_0\u0026amp;=s_2-s_0\\\\\\\\\n\\beta_0\u0026amp;=-(s_2-s_0)-(s_1-s_0)\\\\\\\\\n\\gamma_0\u0026amp;=s_1-s_0\\\\\\\\\n\\\\\\\\\n\\alpha_n\u0026amp;=s_n-s_{n-1}\\\\\\\\\n\\beta_n\u0026amp;=-(s_n-s_{n-1})-(s_n-s_{n-2})\\\\\\\\\n\\gamma_n\u0026amp;=s_n-s_{n-2}\\\\\\\\\n\\\\\\\\\n\\alpha_i\u0026amp;=N_{i,4}(s_i)\\\\\\\\\n\\beta_i\u0026amp;=N_{i+1,4}(s_i)\\\\\\\\\n\\gamma_i\u0026amp;=N_{i+2,4}(s_i)\\\\\\\\\n\\mathrm{for}\u0026amp;\\ i=1,\\cdots,n-1\n\\end{align}\n$$\n  求解方法\n 使用Thomas算法——解决对角系统矩阵 仅适用于对角占优矩阵 复杂度$O(n)$     前向消除阶段\n  后向替换阶段\n     2.5. Bézier曲线转B样条曲线 给定：\n 控制点：$\\pmb k_0,\\pmb k_1,\\cdots, \\pmb k_n$ 结序列：$t_0,t_1,\\cdots,t_n$ 2个终值条件 $C^2$连续、插值条件 用于$C^2$连续插值的分段三次Bézier样条曲线的Bézier点$\\pmb b_0,\\pmb b_1,\\cdots,\\pmb b_{3n}$  目标：\n 求取相同曲线的B样条形式  结向量：\n$$\nT=(t_0,t_0,t_0,t_0,t_1,\\cdots,t_{n-1},t_n,t_n,t_n,t_n)\n$$\n 共$n+7$个顶点，$n+3$个de Boor点，即$\\pmb d_0,\\pmb d_1,\\cdots,\\pmb d_{n+2}$\n de Boor点满足：\n$$\n\\begin{align}\n\\pmb d_0\u0026amp;=\\pmb b_0\\\\\\\\\n\\pmb d_1\u0026amp;=\\pmb b_1\\\\\\\\\n\\pmb d_i\u0026amp;=\\pmb b_{3i-4}+\\frac{\\Delta_{i-1}}{\\Delta_{i-2}}(\\pmb b_{3i-4}-\\pmb b_{3i-5})\\ \\mathrm{for}\\ i=2,\\cdots,n\\\\\\\\\n\\pmb d_{n+1}\u0026amp;=\\pmb b_{3n-1}\\\\\\\\\n\\pmb d_{n+2}\u0026amp;=\\pmb b_{3n}\n\\end{align}\n$$\n其中，对于$i=0,\\cdots,n-1$，有$\\Delta_i=t_{i+1}-t_i$\n示例：\n逆问题同样可解\n3. 视频演示 IlumEngine中实现了自然边界条件的4阶（3 次）B曲线的$C^2$连续插值绘制，实际造型与Bézier样条曲线等价\n\n","description":"B样条曲线原理与实现","id":9,"section":"posts","tags":["Geometry"],"title":"几何造型(3)：B样条曲线","uri":"https://chaphlagical.github.io/zh/posts/geometry/b_spline/"},{"content":"因为有了《漫威复仇者联盟》的前车之鉴，许多人是不看好今年这款Crystal Dynamics开发的漫威IP新作，但游戏正式发布后评价却意外的好，趁之前七折赶紧入手冲一把。\n和漫威复联的刷刷刷不同，漫威银护选择走单人线性叙事路线，以星爵作为玩家唯一可操作角色，通过小队作战的战斗机制来使用银河护卫队其他成员的技能。但从玩法上确实没有太多新意，后期技能点满后战斗非常无脑与简单，收集要素很少（均为皮肤和可升级零件），解密难度极低，但是剧本非常扎实，对话量很大，演出效果也很好，很多彩蛋也让我这个漫威迷大呼过瘾，十多小时的大片级体验还是相当不错的。\n以下是我在游戏过程中截取的精彩画面：\n进入新手村前夕\n初遇科斯莫\n理查德·赖德彩蛋，萨姆·亚历山大能在下一部出现吗？\n星爵见老妈\n劝说Worldmind失败，Nova总部溜了\n初遇亚当\n光速跳跃\n全副武装\n封面图，全场最佳\n这个星爵和电影版的还是很不一样\n最终一战\n老板火箭\n","description":"通关了《漫威银河护卫队》，剧情还是相当不错的","id":10,"section":"posts","tags":["Gaming"],"title":"游戏通关：《漫威银河护卫队》","uri":"https://chaphlagical.github.io/zh/posts/gaming/marvel_guardians_of_the_galaxy/"},{"content":"1. 简介 之前我们已经介绍过Bézier曲线的原理与实现方法，但由于Bézier曲线的一些问题，例如：\n 高多项式次数  $n+1$个Bézier控制点将生成一条$n$次多项式表达的Bézier曲线   全局，伪局部性  Bézier曲线在始末两控制点进行插值，在中间控制点进行拟合，当控制点增加时，曲线形态难以控制    因此我们引入的Bézier样条曲线来解决上述两个问题。在了解Bézier样条曲线的工作原理之前，需要弄清楚几何设计中连续性的基本概念。\n1.1. 连续性的基本概念 1.1.1. 参数连续性 给定两条曲线：\n$$\n\\begin{align}\n\u0026amp;\\pmb x_1(t)\\ \\mathrm{over}\\ [t_0,t_1]\\\\\\\\\n\u0026amp;\\pmb x_2(t)\\ \\mathrm{over}\\ [t_1,t_2]\n\\end{align}\n$$\n若$\\pmb x_1$和$\\pmb x_2$在$t_1$处的0阶到$r$阶导数向量均重合，则若$\\pmb x_1$和$\\pmb x_2$在$t_1$处$C^r$连续\n常见的参数连续性有：\n $C^0$：位置变化连续 $C^1$：一阶导数在交界处连续（速度向量相同） $C^2$：二阶导数在交界处连续（加速度向量相同）  1.1.2. 几何连续性 给定两条曲线：\n$$\n\\begin{align}\n\u0026amp;\\pmb x_1(t)\\ \\mathrm{over}\\ [t_0,t_1]\\\\\\\\\n\u0026amp;\\pmb x_2(t)\\ \\mathrm{over}\\ [t_1,t_2]\n\\end{align}\n$$\n若$\\pmb x_1$和$\\pmb x_2$能够以某种方式重新参数化使得在$t_1$处$C^r$连续，则$\\pmb x_1$和$\\pmb x_2$在$t_1$处$G^r$连续\n常见的几何连续性有：\n $G^0=C^0$：位置变化连续性（连接性） $G^1$：切线方向变化连续性（相同切线）  正则化切线变化连续 等价于曲线能够重新参数化到$C^1$ 等价于单位速度参数化为$C^1$   $G^2$：曲率变化连续性（相同切线与曲率）  等价于曲线能够重新参数化到$C^2$ 等价于单位速度参数化为$C^2$    1.1.3. 参数连续性 vs. 几何连续性    参数连续性 几何连续性     在该曲线上运动的粒子是否有光滑的轨迹？（位置、速度、加速度） 曲线本身是否光滑   取决于参数化方式 独立于参数化方式   应用：动画（物体移动、摄像头轨迹） 与建模相关（曲线设计）    1.2. Bézier样条曲线的设计思想 既然Bézier曲线全局性太强、阶次太高，那么优化思路就是降低全局性、降低阶次，一个有效的方法就是进行分段，把一条长的曲线分段成若干条低阶的Bézier曲线，在衔接处满足某种连接性，即可使得曲线满足控制点插值、低次性和局部性等优点，这就是Bézier样条曲线的设计思路。\n设计Bézier样条曲线需要考虑的两个问题是：\n 参数化 连续性  2. Bézier样条参数化 在Bézier曲线的构造中，我们选择的参数为$t\\in[0,1]$，贯穿整条曲线，称之为全局参数。在Bézier样条曲线中，我们通过分段，将曲线分为$[t_0,t_1]$，$[t_1,t_2]$，……，$[t_{n-1},t_n]$的曲线段，每一段对应一条低阶Bézier曲线，这条低阶Bézier曲线使用的参数$u\\in[0,1]$则称为局部参数。当局部参数$u$从0变化到1时，全局参数从$t_i$变化到$t_{i+1}$。\n通常情况下，节序列$t_0,t_1,\\cdots,t_n$可以自定义，选取不同的节序列会得到不同的曲线形态，常用的参数化方法有以下几种：\n  Equidistant (Uniform) Parameterization\n $t_{i+1}-t_i=\\mathrm{const}$ 不考虑数据点之间的几何关系    Chordal Parameterization\n $t_{i+1}-t_i=\\Vert \\pmb k_{i+1}-\\pmb k_i\\Vert$ 参数间隔与相邻控制点的距离成正比    Centripetal Parameterization\n $t_{i+1}-t_i=\\sqrt{\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert}$ 参数间隔与相邻控制点的距离的开方成正比    Foley Parameterization\n 涉及控制多边形的角度  $$\nt_{i+1}-t_i=\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert\\cdot\\Big(1+\\dfrac{3}{2}\\dfrac{\\hat\\alpha_i\\Vert\\pmb k_i-\\pmb k_{i-1}\\Vert}{\\Vert\\pmb k_i-\\pmb k_{i-1}\\Vert+\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert}+\\dfrac{3}{2}\\dfrac{\\hat\\alpha_{i+1}\\Vert \\pmb k_{i+1}-\\pmb k_i\\Vert}{\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert+\\Vert\\pmb k_{i+2}-\\pmb k_{i+1}\\Vert} \\Big)\n$$\n 其中，$\\hat\\alpha_i=\\min\\Big(\\pi-\\alpha_i,\\dfrac{\\pi}{2}\\Big)$，且$\\alpha_i=\\mathrm{angle}(\\pmb k_{i-1},\\pmb k_i,\\pmb k_{i+1})$    3. Bézier样条的连续性 给定\n $\\pmb y(u)$：$[0,1]$上的Bézier曲线 $\\pmb x(u)$：$[t_i,t_{i+1}]$上的Bézier曲线  令$u(t)=\\frac{t-t_i}{t_{i+1}-t_i}$，则$\\pmb x(t)=\\pmb y(u(t))$\n对$\\pmb x(t)$进行求导有：\n$$\n\\begin{align}\n\\dot{\\pmb x}(t)\u0026amp;=\\dot{\\pmb y}(u(t))\\cdot\\dot u(t)=\\dfrac{\\dot{\\pmb y}(u(t))}{t_{i+1}-t_i}\\\\\\\\\n\\ddot{\\pmb x}(t)\u0026amp;=\\ddot{\\pmb y}(u(t))\\cdot(\\dot u(t))^2+\\dot{\\pmb y}(u(t))\\cdot\\ddot u(t)=\\dfrac{\\ddot{\\pmb y}(u(t))}{(t_{i+1}-t_i)^2}\\\\\n\\cdots\\\\\\\\\n\\pmb x^{[n]}(t)\u0026amp;=\\dfrac{\\pmb y^{[n]}(u(t))}{(t_{i+1}-t_i)^n}\n\\end{align}\n$$\n由Bézier曲线解析式：\n$$\n\\pmb f(t)=\\sum_{i=0}^nB_i^n(t)\\pmb b_i\n$$\n其端点值：\n$$\n\\begin{align}\n\\pmb f(0)\u0026amp;=\\pmb b_0\\\\\\\\\n\\pmb f(1)\u0026amp;=\\pmb b_1\n\\end{align}\n$$\n端点一阶导数：\n$$\n\\begin{align}\n\\pmb f'(0)\u0026amp;=n[\\pmb b_1-\\pmb b_0]\\\\\\\\\n\\pmb f'(1)\u0026amp;=n[\\pmb b_n-\\pmb b_{n-1}]\n\\end{align}\n$$\n端点二阶导数：\n$$\n\\begin{align}\n\\pmb f''(0)\u0026amp;=n(n-1)[\\pmb b_2-2\\pmb b_1+\\pmb b_0]\\\\\\\\\n\\pmb f''(1)\u0026amp;=n(n-1)[\\pmb b_n-2\\pmb b_{n-1}+\\pmb b_{n-2}]\n\\end{align}\n$$\n代入到$\\pmb x(t)=\\pmb y(u(t))$中，有：\n$$\n\\begin{align}\n\\pmb x(t_i)\u0026amp;=\\pmb b_0\\\\\\\\\n\\pmb x(t_{i+1})\u0026amp;=\\pmb b_1\\\\\\\\\n\\dot{\\pmb x}(t_i)\u0026amp;=\\dfrac{n(\\pmb b_1-\\pmb b_0)}{t_{i+1}-t_i}\\\\\\\\\n\\dot{\\pmb x}(t_{i+1})\u0026amp;=\\dfrac{n(\\pmb b_n-\\pmb b_{n-1})}{t_{i+1}-t_i}\\\\\\\\\n\\ddot{\\pmb x}(t_i)\u0026amp;=\\dfrac{n(n-1)(\\pmb b_2-2\\pmb b_1+\\pmb b_0)}{(t_{i+1}-t_i)^2}\\\\\\\\\n\\ddot{\\pmb x}(t_{i+1})\u0026amp;=\\dfrac{n(n-1)(\\pmb b_n-2\\pmb b_{n-1}+\\pmb b_{n-2})}{(t_{i+1}-t_i)^2}\\\n\\end{align}\n$$\n现有$m+1$段$n$阶Bézier样条$\\pmb x^{(0)},\\pmb x^{(1)},\\cdots,\\pmb x^{(m)}$构成一条完整曲线$\\pmb x$，Bézier样条$\\pmb x^{(i)}$的控制点为：$\\pmb b_0^{(i)},\\pmb b_1^{(i)},\\cdots,\\pmb b_n^{(i)}$，对应全局参数范围$[t_i,t_{i+1}]$\n$C^0$连续性\n每个样条线段插值两端控制点，因此相邻曲线段两端的控制点必须重合以获得$C^0$连续性，即：\n$$\n\\pmb b^{(i-1)}_{n}=\\pmb b^{(i)}_0\n$$\n$C^1$连续性\n$C^1$连续即该参数化下一阶导数相同，即：\n$$\n\\dot{\\pmb x}^{(i)}(t_{i+1})=\\dot{\\pmb x}^{(i+1)}(t_{i+1})\n$$\n代入表达式有：\n$$\n\\frac{\\pmb b^{(i)}_n-\\pmb b_{n-1}^{(i)}}{t_{i+1}-t_i}=\n\\frac{\\pmb b^{(i)}_{1}-\\pmb b_{0}^{(i)}}{t_{i+2}-t_{i+1}}\n$$\n$C^2$连续性\n$C^1$连续即该参数化下二阶导数相同，即：\n$$\n\\ddot{\\pmb x}^{(i)}(t_{i+1})=\\ddot{\\pmb x}^{(i+1)}(t_{i+1})\n$$\n代入表达式有：\n$$\n\\frac{\\pmb b_n^{(i)}-2\\pmb b_{n-1}^{(i)}+\\pmb b_{n-2}^{(i)}}{(t_{i+1}-t_i)^2}=\n\\frac{\\pmb b_2^{(i+1)}-2\\pmb b_1^{(i+1)}+\\pmb b_0^{(i+1)}}{(t_{i+2}-t_{i+1})^2}\n$$\n令\n$$\n\\pmb d^-=\\pmb b_{n-1}^{(i)}+\\frac{\\Delta_{i+1}}{\\Delta_i}(\\pmb b_{n-1}^{(i)}-\\pmb b_{n-2}^{(i)})\n$$\n和\n$$\n\\pmb d^+=\\pmb b_{1}^{(i+1)}-\\frac{\\Delta_{i}}{\\Delta_{i+1}}(\\pmb b_{2}^{(i+1)}-\\pmb b_{1}^{(i+1)})\n$$\n则有$C^2$连续性等价于$C^1$连续性且$\\pmb d^-=\\pmb d^+$\n$G^1$连续性\n满足在$t=t_i$处$G^1$连续的条件是：\n$$\n\\begin{aligned}\n\u0026amp;\\pmb x^{(i)}(t_i)=\\pmb x^{(i+1)}(t_i)\\\\\\\\\n\u0026amp;\\dot{\\pmb x}^{(i)}(t_i)=\\dot{\\pmb x}^{(i+1)}(t_i)\\\\\\\\\n\u0026amp;\\ddot{\\pmb x}^{(i+1)}(t_i)-\\ddot{\\pmb x}^{(i)}(t_i)\\parallel \\dot{\\pmb x}(t_i)\n\\end{aligned}\n$$\n$G^2$连续性\n满足在$t=t_i$处$G^2$连续的条件是：\n  $G^1$连续\n  $\\pmb b_{n-2}^{(i)},\\pmb b_{n-1}^{(i)},\\pmb b_{n}^{(i)}=\\pmb b_{0}^{(i+1)},\\pmb b_{1}^{(i+1)},\\pmb b_{2}^{(i+1)}$五个向量共面\n  且面积满足：\n$$\n\\dfrac{\\mathrm{area}(\\pmb b_{n-2}^{(i)},\\pmb b_{n-1}^{(i)},\\pmb b_{n}^{(i)})}{\\mathrm {area}(\\pmb b_{0}^{(i+1)},\\pmb b_{1}^{(i+1)},\\pmb b_{2}^{(i+1)})}=\\dfrac{a^3}{b^3}\n$$\n  4. 三次Bézier样条曲线 理论上，只要有足够的边界条件约束，我们可以选用任意阶的Bézier样条进行构造我们的曲线，但一般常用的Bézier样条不会超过三次（某些CAD/CAM软件可能会使用）：\n 零次：分段常数，不光滑 一次：分段线性，不够光滑 二次：二阶导数为常数，不够灵活 三次：图形学应用中最为常用  在IlumEngine中，也选用了三次Bézier样条曲线进行实现。\n对于给定的控制点$\\pmb k_0,\\pmb k_1,\\cdots,\\pmb k_n$，以及参数化节序列$t_0,t_1,\\cdots,t_n$，我们需要生成用于构造连续分段三次Bezier样条曲线的Bézier点$\\pmb b_0,\\cdots,\\pmb b_{3n}$\n该问题中，需要求解：\n $3n+1$个未知点 $C^0$连续：$\\pmb b_{3i}=\\pmb k_i$，$i=0,\\cdots,n$，共$n+1$个方程 $C^1$连续：$\\dfrac{\\pmb b_{3i}-\\pmb b_{3i-1}}{t_i-t_{i-1}}=\\dfrac{\\pmb b_{3i+1}-\\pmb b_{3i}}{t_{i+1}-t_{i}}$，$i=0,\\cdots,n$，共$n-1$个方程 $C^2$连续：$\\dfrac{\\pmb b_{3i}-2\\pmb b_{3i-1}+\\pmb b_{3i-2}}{(t_i-t_{i-1})^2}=\\dfrac{\\pmb b_{3i+2}-2\\pmb b_{3i+1}+\\pmb b_{3i}}{(t_{i+1}-t_{i})^2}$，$i=0,\\cdots,n$，共$n-1$个方程 两个端点条件  端点条件的选取，通常有两种：\n  Bessel End Condition\n  $\\pmb k_0$处的切向量等于插值${\\pmb k_0,\\pmb k_1,\\pmb k_2}$的抛物线在$\\pmb k_0$处的切向量\n  插值${\\pmb k_0,\\pmb k_1,\\pmb k_2}$的抛物线方程：\n$$\n\\pmb p(t)=\n\\dfrac{(t_2-t)(t_1-t)}{(t_2-t_0)(t_1-t_0)}\\pmb k_0+\n\\dfrac{(t_2-t)(t-t_0)}{(t_2-t_1)(t_1-t_0)}\\pmb k_1+\n\\dfrac{(t_0-t)(t_1-t)}{(t_2-t_1)(t_2-t_0)}\\pmb k_2\n$$\n  插值抛物线导数：\n$$\n\\dot{\\pmb p}(t_0)=\n-\\dfrac{(t_2-t_0)+(t_1-t_0)}{(t_2-t_0)(t_1-t_0)}\\pmb k_0+\n\\dfrac{(t_2-t_0)}{(t_2-t_1)(t_1-t_0)}\\pmb k_1-\n\\dfrac{(t_1-t_0)}{(t_2-t_1)(t_2-t_0)}\\pmb k_2\n$$\n  $\\pmb b_1$的位置：\n$$\n\\pmb b_1=\\pmb b_0+\\dfrac{t_1-t_0}{3}\\dot{\\pmb p}(t_0)\n$$\n    Natural End Condition\n$$\n\\begin{align}\n\\ddot {\\pmb x}(t_0)\u0026amp;=0\\Leftrightarrow \\pmb b_1=\\dfrac{\\pmb b_2+\\pmb b_0}{2}\\\\\\\\\n\\ddot{\\pmb x}(t_n)\u0026amp;=0\\Leftrightarrow \\pmb b_{3n-1}=\\dfrac{\\pmb b_{3n-2}+\\pmb b_{3n}}{2}\n\\end{align}\n$$\n  事实上，如果曲线闭合（首尾相连），则可以无需计算端点条件，继续在首尾处计算$C^1$、$C^2$条件即可\n5. 视频演示 IlumEngine中实现了三次Bézier样条曲线，使用Uniform参数化以及Natural端点条件\n\n","description":"Bézier样条曲线原理与实现","id":11,"section":"posts","tags":["Geometry"],"title":"几何造型(2)：Bézier样条曲线","uri":"https://chaphlagical.github.io/zh/posts/geometry/bezier_spline/"},{"content":"1. 基本原理 Bézier曲线于1962年，由法国工程师Pierre Bézier所提出，用于汽车的主体的几何造型设计。\n二阶Bézier曲线如下图所示：\n其几何构造流程如下：\n 依次选定控制点$A$、$B$、$C$ 在$AB$上选定一动点$D$，设参数$t=\\frac{AD}{AB}$，则$t\\in[0,1]$ 在$BC$上构造一点$E$，满足$\\frac{AD}{AB}=\\frac{BE}{BC}=t$ 连接$DE$ 在$DE$上构造一点$F$，满足$\\frac{DF}{DE}=\\frac{AD}{AB}=\\frac{BE}{BC}=t$ 当$t$从0到1变化时，点$F$构成的轨迹即为二阶Bézier曲线  从解析几何角度看，设控制点$A$、$B$、$C$坐标依次为$\\pmb p_1$、$\\pmb p_2$和$\\pmb p_3$，则点$D$可表示为$\\pmb p_4 = (1-t)\\pmb p_1+t\\pmb p_2$，点$E$表示为$\\pmb p_5=(1-t)\\pmb p_2+t\\pmb p_3$，点$F$表示为$\\pmb p_6=(1-t)\\pmb p_4+t\\pmb p_5=(1-t)^2\\pmb p_1+2(1-t)t\\pmb p_2+t^2\\pmb p_3$\n同理我们还可以构造三阶Bézier曲线：\n我们可以从中看出规律，给定$N$个控制点，将生成$N-1$阶的Bézier曲线，几何构造方式都是通过在控制点连线上按比例参数选取新的控制点，然后通过新的控制点再往下生成控制点，直到最终只生成一个控制点，该点则对应参数下Bézier曲线的取值。\n2. De Casteljau算法 2.1. 算法原理 De Casteljau算法是计算给定参数$t$下Bézier曲线上点的坐标的迭代求解方法。\n对于给定控制点$\\pmb b_0,\\pmb b_1,\\cdots,\\pmb b_n\\in\\mathbb R^3$，我们希望得到曲线$\\pmb x(t),t\\in[0,1]$，De Casteljau算法的迭代方程如下：\n$$\n\\begin{align}\n\\pmb b_i^0(t)\u0026amp;=\\pmb b_i,\\ \\ \\ \\ i=0,\\cdots,n\\\\\n\\pmb b_i^r(t)\u0026amp;=(1-t)\\pmb b_i^{r-1}(t)+t\\pmb b_{i+1}^{r-1}(t)\\\\\nr=\u0026amp;1,\\cdots,n\\ \\ \\ \\ i=0,\\cdots,n-r\n\\end{align}\n$$\n最后，$\\pmb b_0^n(t)$为所找的曲线点$\\pmb x(t)$在参数值$t$的取值，C++程序如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  glm::vec3 BezierCurve::value(const std::vector\u0026lt;glm::vec3\u0026gt; \u0026amp;control_points, float t) { size_t n = control_points.size(); std::vector\u0026lt;glm::vec3\u0026gt; br(control_points); std::vector\u0026lt;glm::vec3\u0026gt; br_1(control_points); for (size_t r = 1; r \u0026lt; n; r++) { for (size_t i = 0; i \u0026lt; n - r; i++) { br[i] = (1 - t) * br_1[i] + t * br_1[i + 1]; } br_1 = br; } return br_1[0]; }   2.2. 算法性质  控制点$\\pmb b_0,\\pmb b_1,\\cdots,\\pmb b_n\\in\\mathbb R^3$依次构成的多边形称为Bézier多边形 控制点$\\pmb b_i$也称为Bézier点 只使用凸组合，因此算法数值稳定 算法复杂度  时间复杂度$O(n^2)$ 空间复杂度$O(n)$    3. Bézier曲线的解析表达 3.1. Bernstein基描述 De Casteljau算法提供了一种迭代求解Bézier曲线的方法，同时我们也可以解析地写出Bézier曲线的基函数表达：\n$$\n\\pmb x(t)=\\sum_{i=0}^nC_n^it^i(1-t)^{n-i}\\pmb b_i\n$$\n其中$C_n^i$为组合数$C_n^i=\\frac{n!}{i!(n-i)!}$，Bernstein基定义为：\n$$\nB_i^n(t)=\n\\begin{cases}\nC_n^it^i(1-t)^{n-i}\u0026amp;t\\in[0,1],i\\in[0,n],i\\in\\mathbb N\\\\\\\\\n0\u0026amp;i\u0026lt;0\\ or\\ i\u0026gt;n\\\\\\\\\n1\u0026amp;i=0\\ and \\ n=0\n\\end{cases}\n$$\nBernstein基示例：\n3.2. Bernstein基的性质 光滑性\nBernstein基函数为$n$次多项式，显然光滑\n归一性\n$$\n\\sum\\limits_{i=0}^nB_i^{n}(t)=(t+(1-t))^n=1\n$$\n递推\n$$\nB_i^n(t)=(1-t)B_i^{n-1}(t)+tB^{n-1}_{i-1}(t)\n$$\n 证明：\n$$\n\\begin{align}\n(1-t)B_i^{n-1}(t)+tB^{n-1}_{i-1}(t)\u0026amp;=(1-t)C_{n-1}^{i}t^i(1-t)^{n-1-i}+tC_{n-1}^{i-1}t^{i-1}(1-t)^{n-i}\\\\\\\\\n\u0026amp;=(C_{n-1}^{i}+C_{n-1}^{i-1})t^i(1-t)^{n-i}\\\\\\\\\n\u0026amp;=C_n^it^i(1-t)^{n-i}\\\\\\\\\n\u0026amp;=B_i^n(t)\n\\end{align}\n$$\n 导数\n$$\n\\frac{\\mathrm d}{\\mathrm dt}B_i^{n}(t)=n\\left[B^{n-1}_{i-1}(t)-B_i^{n-1}(t)\\right]\n$$\n 证明：\n$$\n\\begin{align}\n\\frac{\\mathrm d}{\\mathrm dt}B^n_i(t)\u0026amp;=\\frac{\\mathrm d}{\\mathrm dt}\\left( C_n^it^i(1-t)^{n-i}\\right)\\\\\\\\\n\u0026amp;=iC_n^it^{i-1}(1-t)^{n-i}-(n-i)C_n^it^i(1-t)^{n-i-1}\\\\\\\\\n\u0026amp;=\\frac{n!}{(n-i)!i!}it^{i-1}(1-t)^{n-i}-\\frac{n!}{(n-i)!i!}(n-i)t^i(1-t)^{n-i-1}\\\\\\\\\n\u0026amp;=n\\left[\\frac{(n-1)!}{(n-i)!(i-1)!}t^{i-1}(1-t)^{n-i}-\\frac{(n-1)!}{(n-i-1)!i!}t^i(1-t)^{n-i-1} \\right]\\\\\\\\\n\u0026amp;=n\\left[C_{n-1}^{i-1}t^{i-1}(1-t)^{n-i}-C_{n-1}^i t^i(1-t)^{n-i-1} \\right]\\\\\\\\\n\u0026amp;=n\\left[B^{n-1}_{i-1}(t)-B_i^{n-1}\\right]\n\\end{align}\n$$\n 最值\n$B^n_i(t)$在$t=\\frac{i}{n}$处取得最大值\n 证明：\n由导数为0\n$$\n\\frac{\\mathrm d}{\\mathrm dt}B_i^{n}(t)=n\\left[B^{n-1}_{i-1}(t)-B_i^{n-1}(t)\\right]=0\n$$\n可得当$t=\\frac{i}{n}$时取得最大值\n 对称性\n$$\nB_i^n(t)=B_{n-i}^n(1-t)\n$$\n 证明：\n$$\n\\begin{align}\nB_i^n(t)\u0026amp;=C_n^it^i(1-t)^{n-i}\\\\\\\\\n\u0026amp;=\\frac{n!}{(n-i)!i!}t^i(1-t)^{n-i}\\\\\\\\\n\u0026amp;=\\frac{n!}{(n-(n-i))!(n-i)!}(1-t)^{n-i}t^{n-(n-i)}\\\\\\\\\n\u0026amp;=B_{n-i}^n(1-t)\n\\end{align}\n$$\n 非负性\n$$\n\\begin{align}\nB_i^n(t)\u0026amp;\\geq 0,t\\in [0,1]\\\\\\\\\nB_0^{(n)}(0)=1,\u0026amp;\\ \\ \\ \\ B_1^{(n)}(0)=\\cdots=B_n^{(n)}(0)=0\\\\\\\\\nB_0^{(n)}(1)=\u0026amp;\\cdots=B_{n-1}^{(n)}=0,\\ \\ \\ \\ B_n^{(n)}(1)=1\n\\end{align}\n$$\n4. Bézier曲线的性质 聊完Bézier曲线的构造方法以及Bernstein基函数的相关内容，我们再来聊聊Bézier曲线本身具有的几何性质。\n4.1. 仿射不变性 仿射变换定义为：\n$$\n\\pmb x\\rightarrow\\pmb A\\pmb x+\\pmb b\n$$\n包含线性部分和平移部分。\n线性不变性\nBézier曲线的线性不变性是显然的，Bézier曲线表示为基函数的线性组合：\n$$\n\\pmb f(t)=\\sum\\limits_{i=1}^nb_i(t)\\pmb p_i=\\sum\\limits_{i=1}^nb_i(t)\\begin{pmatrix}\np_i^{(x)}\\\\p_i^{(y)}\\\\p_i^{(z)}\n\\end{pmatrix}\n$$\n因此\n$$\nA(\\pmb f(t))=A\\Big(\\sum\\limits_{i=1}^nb_i(t)\\pmb p_i \\Big)=\\sum\\limits_{i=1}^nb_i(t)(A\\pmb p_i)\n$$\n平移不变性\n$$\n\\sum\\limits_{i=1}^nb_i(t)(\\pmb p_i+\\pmb b)=\\sum\\limits_{i=1}^nb_i(t)\\pmb p_i+\\sum\\limits_{i=1}^nb_i(t)\\pmb b=\\pmb f(t)+\\Big(\\sum\\limits_{i=1}^nb_i(t)\\Big)\\pmb b\n$$\n其中，由Bernstein基函数的归一性，$\\sum\\limits_{i=1}^nb_i(t)=1$，满足平移不变性。\n4.2. 凸包性质 点集${\\pmb p_1,\\cdots,\\pmb p_n}$的一个凸组合为如下形式：\n$$\n\\sum\\limits_{i=1}^n\\lambda_i\\pmb p_i\\ \\mathrm{with}\\sum\\limits_{i=1}^n\\lambda_i=1\\ \\mathrm{and}\\ \\forall i=1,\\cdots,n:0\\leq\\lambda_i\\leq 1\n$$\n因此Bézier曲线为Bernstein基函数的凸组合，能够避免不良震荡，将构造的曲线限制在控制点的凸包中。\n4.3. 导数性质 对于Bézier曲线\n$$\n\\pmb x(t)=\\sum_{i=0}^nB_i^n(t)\\pmb p_i\n$$\n一阶导数：\n$$\n\\begin{aligned}\n\\frac{\\mathrm d\\pmb x}{\\mathrm dt}\u0026amp;=n\\sum_{i=0}^{n}\\left[B^{n-1}_{i-1}(t)-B_i^{n-1}(t)\\right]\\pmb p_i\\\\\\\\\n\u0026amp;=n\\sum_{i=0}^nB_{i-1}^{n-1}(t)\\pmb p_i-n\\sum_{i=0}^n B_i^{n-1}(t)\\pmb p_i\\\\\\\\\n\u0026amp;=n\\sum_{i=-1}^{n-1}B_i^{n-1}(t)\\pmb p_{i+1}-n\\sum_{i=0}^nB_i^{n-1}(t)\\pmb p_i\\\\\\\\\n\u0026amp;=n\\sum_{i=0}^{n-1}B_i^{n-1}(t)\\pmb p_{i+1}-n\\sum_{i=0}^nB_i^{n-1}(t)\\pmb p_i\\\\\\\\\n\u0026amp;=n\\sum_{i=0}^{n-1}B_i^{n-1}(\\pmb p_{i+1}-\\pmb p_i)\n\\end{aligned}\n$$\n边界条件：\n$$\n\\begin{cases}\n\\pmb x'(0)=n(\\pmb p_1-\\pmb p_0)\\\\\\\\\n\\pmb x'(1)=n(\\pmb p_n-\\pmb p_{n-1})\n\\end{cases}\n$$\n高阶导数：\n$$\n\\frac{\\mathrm d^r}{\\mathrm dt^r}\\pmb x(t)=\\frac{n!}{(n-r)!}\\sum_{i=0}^{n-r}B_i^{n-r}(t)\\cdot\\Delta^r\\pmb p_i\n$$\n其中，\n一阶差分：$\\Delta \\pmb p_i=\\pmb p_{i+1}-\\pmb p_i$\n二阶差分：$\\Delta^2\\pmb p_i=\\Delta\\pmb p_{i+1}-\\Delta \\pmb p_i=\\pmb p_{i+2}-2\\pmb p_{i+1}+\\pmb p_i$\n高阶差分递推式：$\\Delta^r\\pmb p_i=\\Delta^{r-1} \\pmb p_{i+1}-\\Delta^{r-1} \\pmb p_i$\n归纳法有：$\\Delta^r\\pmb p_i=\\sum_{k=0}^r(-1)^kC_r^k\\pmb p_{i+r-k}$\n4.4. 杂项性质结论 一条 Bézier 曲线的弧长不大于其控制多边形的周长\n 证明：\n设Bézier曲线方程为$\\pmb f(t)$，曲线弧长为$L$，多边形周长为$C$，则Bézier曲线弧长为：\n$$\n\\begin{aligned}\nL\u0026amp;=\\int_0^1\\|\\pmb f'(t)\\|\\mathrm dt\\\\\\\\\n\u0026amp;=\\int_0^1\\left\\|n\\sum_{i=0}^{n-1}B_i^{(n-1)}(t)(\\pmb p_{i+1}-\\pmb p_i)\\right\\|\\mathrm dt\\\\\\\\\n\u0026amp;\\leq n\\sum_{i=0}^{n-1}\\|\\pmb p_{i+1}-\\pmb p_i\\|\\cdot \\int_0^1B_i^{(n-1)}(t)\\mathrm dt\n\\end{aligned}\n$$\n由Bernstein基函数的性质，有：\n$$\n\\frac{\\mathrm d}{\\mathrm dt}B_i^{(n)}(t)=n\\left[B_{i-1}^{(n-1)}(t)-B_i^{(n-1)}(t)\\right]\n$$\n从0到1积分得：\n$$\nB_i^{(n)}(1)-B_i^{(n)}(0)=n\\left[\\int_0^1B_{i-1}^{(n-1)}(t)-\\int_0^1B_i^{(n-1)}(t)\\right]=0\n$$\n依此类推有：\n$$\n\\int_0^1 B_0^{(n-1)}(t)\\mathrm dt=\n\\int_0^1 B_1^{(n-1)}(t)\\mathrm dt=\n\\cdots=\n\\int_0^1 B_{n-1}^{(n-1)}(t)\\mathrm dt=\\frac{1}{n}\n$$\n因此，有：\n$$\nL\\leq \\sum_{i=0}^{n-1}|\\pmb p_{i+1}-\\pmb p_i|=C\n$$\n结论得证\n 圆弧不能用Bézier曲线精确表示\n 设有一圆弧圆心为$\\pmb c$，半径为$r$，假设它能够用一Bézier曲线$\\pmb f(t)$进行表示，则有：\n$$\n\\left|\\pmb f(t)-\\pmb c\\right|\\equiv r\n$$\n其中，\n$$\n\\begin{aligned}\n\\pmb f(t)\u0026amp;=\\sum_{i=1}^{n}B_i^{n}(t)\\pmb p_i\\\\\\\\\n\u0026amp;=\\sum_{i=1}^{n}\\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}\\pmb p_i\n\\end{aligned}\n$$\n又\n$$\n\\left\\|\\sum_{i=1}^{n}\\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}\\pmb p_i-\\pmb c\\right\\|\\not\\equiv\\mathrm{const}\n$$\n因此假设不成立，圆弧不能用Bézier曲线精确表示\n 5. Bézier曲线的升阶(Degree Elevation) 给定$n+1$个Bézier控制点$\\pmb b_0,\\pmb b_1,\\cdots,\\pmb b_n$，生成Bézier曲线$\\pmb x(t)$\nBézier曲线的升阶即希望生成$n+2$个Bézier控制点$\\bar{\\pmb b}_0,\\bar{\\pmb b}_1,\\cdots,\\bar{\\pmb b}_n$，从而得到曲线$\\bar{\\pmb x}(t)$，满足$\\bar{\\pmb x}(t)=\\pmb x(t)$\n解决方法：\n$$\n\\begin{aligned}\n\\bar{\\pmb b}_0\u0026amp;=\\pmb b_0\\\\\\\\\n\\bar{\\pmb b}_{n+1}\u0026amp;=\\pmb b_n\\\\\\\\\n\\bar{\\pmb b}_j\u0026amp;=\\dfrac{j}{n+1}\\pmb b_{j-1}+\\Big(1-\\dfrac{j}{n+1}\\Big)\\pmb b_j\\ \\ \\ \\ \\ \\mathrm{for}\\ j=1,\\cdots,n\n\\end{aligned}\n$$\n 证明：\n$$\n\\begin{aligned}\n(1-t)B_i^n(t)\u0026amp;=(1-t)C_n^it^i(1-t)^{n-i}\\\\\\\\\n\u0026amp;=C_n^it^i(1-t)^{n+1-i}\\\\\\\\\n\u0026amp;=\\frac{n+1-i}{n+1}C_{n+1}^it^i(1-t)^{n+1-i}\\\\\\\\\n\u0026amp;=\\frac{n+1-i}{n+1}B_i^{n+1}(t)\n\\end{aligned}\n$$\n类似地，\n$$\ntB_i^n(t)=\\dfrac{i+1}{n+1}B_i^{n+1}(t)\n$$\n从而有：\n$$\n\\begin{align}\n\\pmb f(t)\u0026amp;=[(1-t)+t]\\pmb f(t)\\\\\\\\\n\u0026amp;=[(1-t)+t]\\sum\\limits_{i=0}^nB_i^n(t)\\pmb P_i\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\Big[(1-t)B_i^n(t)+tB_i^n(t)\\Big]\\pmb P_i\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\Bigg[\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)+\\dfrac{i+1}{n+1}B_{i+1}^{n+1}(t) \\Bigg]\\pmb P_i\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)\\pmb P_i+\\sum\\limits_{i=0}^n\\dfrac{i+1}{n+1}B_{i+1}^{n+1}(t) \\pmb P_i\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)\\pmb P_i+\\sum\\limits_{i=1}^n\\dfrac{i}{n+1}B_{i}^{n+1}(t) \\pmb P_{i-1}\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^{n+1}\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)\\pmb P_i+\\sum\\limits_{i=0}^n\\dfrac{i}{n+1}B_{i}^{n+1}(t) \\pmb P_{i-1}\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^{n+1}B_i^{n+1}(t)\\Bigg[\\dfrac{n+1-i}{n+1}\\pmb P_i+\\dfrac{i}{n+1}\\pmb P_{i-1} \\Bigg]\n\\end{align}\n$$\n 示例：\n6. Bézier曲线的划分(Subdivision) 给定$n+1$个Bézier控制点$\\pmb b_0,\\pmb b_1,\\cdots,\\pmb b_n$，生成Bézier曲线$\\pmb x(t)$\nBézier曲线的划分即希望得到两条曲线：\n $\\pmb{b}_0^{[1]},\\dots,\\pmb{b}_n^{[1]}\\to \\pmb{x}^{[1]}(t)$ $\\pmb{b}_0^{[2]},\\dots,\\pmb{b}_n^{[2]}\\to \\pmb{x}^{[2]}(t)$  且两条曲线合并可得$\\pmb{x}=\\pmb{x}^{[1]}\\cup \\pmb{x}^{[2]}$\n解决方法：\n$$\n\\begin{aligned}\n\\pmb b_i^{(1)}\u0026amp;=\\pmb b_0^i\\\\\\\\\n\\pmb b_i^{(2)}\u0026amp;=\\pmb b_0^{n-i}\\\\\\\\\n\\mathrm{for}\\ i\u0026amp;=0,\\cdots,n\n\\end{aligned}\n$$\n该方法的依据如下图所示：\n7. 视频演示 Bézier曲线已在IlumEngine中实现，使用De Casteljau算法进行构造。\n\n","description":"Bézier曲线原理与实现","id":12,"section":"posts","tags":["Geometry"],"title":"几何造型(1)：Bézier曲线","uri":"https://chaphlagical.github.io/zh/posts/geometry/bezier_curve/"},{"content":"鼠标拾取是引擎场景编辑器的一个非常基础的功能，通过点击屏幕像素选择场景中的物体，能够使用户更加方便地选择物体、编辑场景。利用空闲时间我将IlumEngine场景编辑器的鼠标拾取功能做了一个优化，从原来的基于Ray Casting方法到现在所使用的G-Buffer回读的方法，两种方法各有优劣，下面详细介绍这两种鼠标拾取的方法。\n1. 基于Ray Casting的鼠标拾取方法 基于Ray Casting的鼠标拾取是一种几何方法，其基本原理如下：\n 由鼠标点击的屏幕像素坐标，生成一条从摄像机发射的射线 对场景作求交计算（与Ray Tracing中的相交检测相同） 寻找与光线相交的最近包围盒，其对应的物体即为鼠标将选中的物体  已知我们已从窗口/UI系统中得到鼠标点击的像素坐标click_pos，首先将其转化为屏幕空间坐标：\n1 2  float x = (click_pos.x / scene_view_size.x) * 2.f - 1.f; float y = -((click_pos.y / scene_view_size.y) * 2.f - 1.f);   我们希望利用拾取点的屏幕空间坐标从相机发射一条射线，一种思路是计算拾取点的远近平面投影坐标，然后将它们连起来即可：\n1 2 3 4 5 6 7 8 9 10  glm::mat4 inv = glm::inverse(main_camera.view_projection); glm::vec4 near_point = inv * glm::vec4(x, y, 0.f, 1.f); near_point /= near_point.w; glm::vec4 far_point = inv * glm::vec4(x, y, 1.f, 1.f); far_point /= far_point.w; geometry::Ray ray; ray.origin = main_camera.position; ray.direction = glm::normalize(glm::vec3(far_point - near_point));   最后，用射线做与包围盒的求交，求交的计算也可用BVH、KD-Tree等加速结构进行加速，这里为了快速实现只是简单遍历并对每个包围盒进行求交：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  float distance = std::numeric_limits\u0026lt;float\u0026gt;::infinity(); const auto group = Scene::instance()-\u0026gt;getRegistry().group\u0026lt;\u0026gt;(entt::get\u0026lt;cmpt::MeshRenderer, cmpt::Transform\u0026gt;); group.each([\u0026amp;](const entt::entity \u0026amp;entity, const cmpt::MeshRenderer \u0026amp;mesh_renderer, const cmpt::Transform \u0026amp;transform) { if (!Renderer::instance()-\u0026gt;getResourceCache().hasModel(mesh_renderer.model)) { return; } auto \u0026amp;model = Renderer::instance()-getResourceCache().loadModel(mesh_renderer.model); float hit_distance = ray.hit(model.get().bounding_box.transform(transform.world_transform)); if (distance \u0026gt; hit_distance) { distance = hit_distance; Editor::instance()-\u0026gt;select(Entity(entity)); } }); }   具体求交的计算后续光线追踪模块的开发将会提到，这里不作具体阐述。\n2. 基于G-Buffer回读的鼠标拾取方法 基于G-Buffer的鼠标拾取是一种图像方法，在几何阶段生成G-Buffers时我们顺带生成一张带有场景物体实体ID的G-Buffer，格式为VK_FORMAT_R32_UINT。在得到鼠标响应时，将该G-Buffer的数据回读到CPU中，利用像素坐标查找相应的实体ID，得到拾取到的对象。完整过程的源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  ImageReference entity_id_buffer = Renderer::instance()-\u0026gt;getRenderGraph()-\u0026gt;getAttachment(\u0026#34;debug - entity\u0026#34;); CommandBuffer cmd_buffer; cmd_buffer.begin(); Buffer staging_buffer(static_cast\u0026lt;VkDeviceSize\u0026gt;(entity_id_buffer.get().getWidth() * entity_id_buffer.get().getHeight()) * sizeof(uint32_t), VK_BUFFER_USAGE_TRANSFER_DST_BIT, VMA_MEMORY_USAGE_GPU_TO_CPU); cmd_buffer.transferLayout(entity_id_buffer, VK_IMAGE_USAGE_SAMPLED_BIT, VK_IMAGE_USAGE_TRANSFER_SRC_BIT); cmd_buffer.copyImageToBuffer(ImageInfo{entity_id_buffer, VK_IMAGE_USAGE_TRANSFER_SRC_BIT, 0, 0}, BufferInfo{staging_buffer, 0}); cmd_buffer.transferLayout(entity_id_buffer, VK_IMAGE_USAGE_TRANSFER_SRC_BIT, VK_IMAGE_USAGE_SAMPLED_BIT); cmd_buffer.end(); cmd_buffer.submitIdle(); std::vector\u0026lt;uint32_t\u0026gt; image_data(entity_id_buffer.get().getWidth() * entity_id_buffer.get().getHeight()); std::memcpy(image_data.data(), staging_buffer.map(), image_data.size() * sizeof(uint32_t)); click_pos.x = glm::clamp(click_pos.x, 0.f, static_cast\u0026lt;float\u0026gt;(entity_id_buffer.get().getWidth())); click_pos.y = glm::clamp(click_pos.y, 0.f, static_cast\u0026lt;float\u0026gt;(entity_id_buffer.get().getHeight())); auto entity = Entity(static_cast\u0026lt;entt::entity\u0026gt;(image_data[static_cast\u0026lt;uint32_t\u0026gt;(click_pos.y) * entity_id_buffer.get().getWidth() + static_cast\u0026lt;uint32_t\u0026gt;(click_pos.x)])); Editor::instance()-\u0026gt;select(entity); staging_buffer.unmap();   由于G-Buffer的内存访问方式均为GPU_only的，我们需要使用一块GPU_to_CPU的Buffer进行暂存，最后Map到CPU内存中。\n3. 比较与选择  Ray Casting方法  优点  CPU实现，不依赖于渲染管线，能够很方便地集成   缺点  不够精确，由于是射线与包围盒求交，拾取的实际上是物体对应的包围盒而不是物体本身，有时候会带来误差，在场景复杂时效果不好 性能受场景规模影响较大，而使用加速结构进行求交加速实际上也增加了集成复杂度（需要引擎具有光追或物理模块支持）     G-Buffer方法  优点  精准，由于是直接把实体ID贴到纹理上，因此能够做到像素级的拾取   缺点  需要一张G-Buffer，增加了带宽开销 需要回读GPU数据，不过只有在鼠标点击时才会触发，影响并不大 需要渲染管线支持，需要配合整个渲染系统进行设计      在开发前期，Render Graph还不够完善，渲染管线扩展能力一般，为了简便，我先直接用Ray Casting的方法给IlumEngine加上一个基本能用的拾取方法，后来为了拾取精度的需要，将拾取算法改为了基于G-Buffer方法。\n最终实现效果如下：\n\n","description":"IlumEngine编辑器鼠标拾取原理","id":13,"section":"posts","tags":["IlumEngine"],"title":"场景编辑器：鼠标拾取","uri":"https://chaphlagical.github.io/zh/posts/rendering/mouse_picking/"},{"content":"前段时间初步完成了个人图形引擎IlumEngine的第一次性能优化。此次优化主要集中在几何渲染与纹理系统上，主要内容大致有：\n Vertex/Index Buffer Packing GPU Driven Rendering  GPU Based Culling  Frustum Culling Hierarchy Z Buffer Occlusion Culling Cone Back Face Culling   Multi Draw Indirect Bindless Texture System    利用现代API灵活的可操作性，解决了几何阶段大量DrawCalls带来的CPU压力，以及提高顶点、索引数据的利用率，并且该架构也有利于后续集成实时光线追踪等功能\n1. IlumEngine简介 IlumEngine是我目前正在开发的一个玩具图形引擎，名字取自*《星球大战》*中凯伯水晶的产地伊冷（后传中被第一军团改造为弑星者基地），引擎使用Vulkan作为图形API（后续或重构为RHI层以支持DX12甚至向下兼容OpenGL），目的是锻炼软件系统工程能力和作为学习图形学经典技术复现和前沿技术的实验平台，预期功能：\n  Render Graph高灵活度渲染管线架构\n  基于ImGui的交互友好的编辑器\n  异步资源加载系统（或进化至流式加载系统）\n  集成基本几何造型算法\n Bezier曲线 三次样条曲线 B样条曲线 有理样条曲线 有理样条曲面等    集成基本数字几何处理算法\n 网格参数化 网格简化与细分 网格变形等    集成基本物理模拟算法\n 刚体模拟 布料模拟 柔性体模拟 流体模拟    集成基本光栅渲染算法\n Forward/Deferred/Tile Based渲染管线 实时阴影  PCF、PCSS VSM CSM   环境光照：IBL、PRT 全局光照  DDGI VXGI等   屏幕空间后处理  Blooming SSGI SSR等      集成基本离线渲染算法\n PT PM BDPT等    目前已将基础的架构部分搭建完成，能够支持Disney PBR材质的延迟渲染管线：\n接下来几节将从存储优化、CPU负载优化、GPU负载优化方面来介绍此次引擎优化的主要内容。\n2. 几何缓存优化 在介绍引擎的几何缓存优化之前，先介绍一下目前引擎使用的场景图和几何模型存储结构。\n2.1. 场景图 场景图是渲染引擎中重要的一个部分，通常采用树状结构（有向无环图）进行组织，IlumEngine中使用基于entt的实体组件系统ECS来实现场景图：\n 每个实体（Entity）作为场景图中的一个结点 每个实体可以挂上若干个组件（Component） 实体只是拓扑关系的结点，不存储实际数据 组件仅存储数据，而不存储逻辑（函数、方法） 组件中的数据由系统（System）使用，实现场景图的更新  想让一个实体拥有几何数据，则将该实体挂载上MeshRenderer组件，在渲染循环系统中，将从所有实体的MeshRenderer中获取渲染所需的几何数据，以完成几何阶段的渲染。\n2.2. 几何模型存储结构 组件MeshRenderer定义如下：\n1 2 3 4 5 6  struct MeshRenderer { std::string model; std::vector\u0026lt;scope\u0026lt;IMaterial\u0026gt;\u0026gt; materials; inline static bool update = false; };   其中，\n model为模型数据的索引，这里使用模型文件所在位置的相对路径表示 materials为模型的材质，初始化时将拷贝为模型的默认材质，在编辑器中也可对某个实体的材质进行修改 update为全局静态更新变量，表示在某循环中与MeshRenderer相关的更新  为得到实际的几何数据，我们还需要利用索引model在资源管理器ResourceCache中查询几何模型，ResourceCache实现了模型与贴图的多线程异步加载和缓存查询等功能，这里不作展开。通过查询，将得到实际模型对象的引用ModelReference：\n1  using ModelReference = std::reference_wrapper\u0026lt;Model\u0026gt;;   而Model便是我们实际存储几何数据的对象了，Model中又有如下数据：\n1 2 3 4 5 6 7  struct Model { std::vector\u0026lt;SubMesh\u0026gt; submeshes; geometry::BoundingBox bounding_box; VertexInfo vertex_info; IndexInfo index_info; }   其中，Submesh为模型的子网格，为导入方便以及支持单个模型不同部分使用不同材质，IlumEngine采用了子网格的形式来组织大型模型，每个子网格拥有以下信息：\n1 2 3 4 5 6 7 8 9  struct Submesh { uint32_t index = 0; glm::mat4 pre_transform = glm::mat4(1.f); material::DisneyPBR material; geometry::BoundingBox bounding_box; VertexInfo vertex_info; IndexInfo index_info; }   其实和Model是差不多的，Submesh是目前几何数据渲染的最小独立单位。\n2.3. 几何存储方案 上文已介绍了几何模型的一个存储结构，但是并未涉及具体的几何数据存储方案，所谓的几何数据存储方案，一个是CPU端的存储，即顶点和索引数据的存储；一个是GPU端的存储，即Vertex Buffer与Index Buffer的存储。对于静态网格模型而已，完全可以将几何数据送入GPU后删除CPU端的数据，但由于本引擎后续需要加入几何处理的功能，为了方便起见依旧全部保留CPU端的几何信息。\n2.3.1. 极简方案 最简单的一种也是最直观的一种策略，便是每个子网格存一份位置的几何信息，即：\n1 2 3 4 5 6 7 8 9 10 11  struct Submesh { uint32_t index = 0; glm::mat4 pre_transform = glm::mat4(1.f); material::DisneyPBR material; geometry::BoundingBox bounding_box; std::vector\u0026lt;Vertex\u0026gt; vertices; std::vector\u0026lt;uint32_t\u0026gt; indices; Buffer vertex_buffer; Buffer index_buffer; }   这种方法最为简单直观，也方便编程，但在实际渲染过程中会有渲染状态频繁切换的问题。假设有$N$个模型，第$i$个模型具有$M_i$个子网格，那么在一个渲染循环内需要做以下操作：\n  遍历$N$个模型\n  遍历模型$i$中的$M_i$个子网格\n  绑定子网格对应的GPU资源\n1 2  vkCmdBindVertexBuffers(cmd_buffer, 0, 1, \u0026amp;vertex_buffer, 0); vkCmdBindIndexBuffer(cmd_buffer, index_buffer, 0, VK_INDEX_TYPE_UINT32);     执行渲染绘制操作\n1  vkCmdDrawIndexed(cmd_buffer, index_count, 1, 0, 0, 0);     因此在一个渲染循环中需要切换绑定$N*M$次顶点/索引缓冲，当模型数量增加时会明显影响效率，而且多块小存储空间也不是一种好的存储分配策略，容易带来内存碎片等问题，同时，当模型具有多个重复的子网格时，这种存储策略将造成数据冗余，降低存储资源的利用率\n2.3.2. 基于模型的优化方案 既然子网格存储所有的几何数据不太好，那我就每个模型存储一份几何数据，然后子网格只存偏移和长度咯。基于模型的优化方案也确实是这样的设计思路：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  struct Model { std::vector\u0026lt;SubMesh\u0026gt; submeshes; geometry::BoundingBox bounding_box; std::vector\u0026lt;Vertex\u0026gt; vertices; std::vector\u0026lt;uint32_t\u0026gt; indices; Buffer vertex_buffer; Buffer index_buffer; } struct Submesh { uint32_t index = 0; glm::mat4 pre_transform = glm::mat4(1.f); material::DisneyPBR material; geometry::BoundingBox bounding_box; uint32_t indices_offset; uint32_t indices_count; }   模型中存储了所有子网格的几何数据，通过顶点索引的偏移offset和顶点索引数量count即可绘制出相应的子网格。由于目前的索引均从顶点缓冲的开头开始，因此暂不需要vertex_offset的参与。\n假设有$N$个模型，第$i$个模型具有$M_i$个子网格，那么在一个渲染循环内需要做以下操作：\n  遍历$N$个模型\n  绑定模型对应的GPU资源\n1 2  vkCmdBindVertexBuffers(cmd_buffer, 0, 1, \u0026amp;vertex_buffer, 0); vkCmdBindIndexBuffer(cmd_buffer, index_buffer, 0, VK_INDEX_TYPE_UINT32);     遍历模型$i$中的$M_i$个子网格\n  执行渲染绘制操作\n1  vkCmdDrawIndexed(cmd_buffer, index_count, 1, index_offset, 0, 0);     因此在一个渲染循环中需要切换绑定$N$次顶点/索引缓冲，比前述的极简方案要好不少，同时模型存储也避免了多个重复子网格冗余的问题，相同的子网格只要有相同的索引偏移和数量即可。\n2.3.3. 统一存储的优化方案 基于模型的方案在渲染每个模型时依然需要切换绑定顶点索引缓冲，在模型数量很多时同样可能带来瓶颈，同时也不利于我们后面进行GPU Driven Rendering的single drawcall设计。所以这次一劳永逸，分配一个大块的GPU显存资源来存储所有的顶点和索引缓冲，而CPU端的几何数据则仍按基于模型的方案设计。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  struct Model { std::vector\u0026lt;SubMesh\u0026gt; submeshes; geometry::BoundingBox bounding_box; std::vector\u0026lt;Vertex\u0026gt; vertices; std::vector\u0026lt;uint32_t\u0026gt; indices; uint32_t indices_offset; uint32_t vertices_offset; } struct Submesh { uint32_t index = 0; glm::mat4 pre_transform = glm::mat4(1.f); material::DisneyPBR material; geometry::BoundingBox bounding_box; uint32_t vertex_offset; uint32_t indices_offset; uint32_t indices_count; } class Renderer { Buffer vertex_buffer; Buffer index_buffer; ... }   该方案的麻烦之处在于，每当有模型添加、修改或删除时需要对全局缓冲进行更新，同时也需要更新每个模型的偏移。下图为各个存储索引关系示例：\n现在，假设有$N$个模型，第$i$个模型具有$M_i$个子网格，那么在一个渲染循环内需要做以下操作：\n  绑定几何数据对应的GPU资源\n1 2  vkCmdBindVertexBuffers(cmd_buffer, 0, 1, \u0026amp;vertex_buffer, 0); vkCmdBindIndexBuffer(cmd_buffer, index_buffer, 0, VK_INDEX_TYPE_UINT32);     遍历$N$个模型\n  遍历模型$i$中的$M_i$个子网格\n  执行渲染绘制操作\n1  vkCmdDrawIndexed(cmd_buffer, index_count, 1, index_offset, vertex_offset, 0);     现在，我们彻底地将几何资源绑定次数降低至single bind，无论场景多大，模型数量多少我们均只需单次绑定开销，而在后续的GPU Driven Rendering的管线设计中，我们也会看到这种Vertex/Index Buffer packing的方法具有的巨大优势。\n3. GPU驱动渲染管线 GPU Driven Rendering Pipelien的概念最早在Siggraph2015上由育碧Ubisoft提出[1]，其相应技术也已在《刺客信条：大革命》中得以落地，在当时可以说是相当前卫的一种设计，但由于当年硬件条件所限，《刺客信条：大革命》却因为层出不穷的Bug被当时的玩家所诟病，一度将育碧和刺客信条系列推向低谷，不过回过头看，《刺客信条：大革命》确实在大型场景和复杂建筑、海量NPC、真实感渲染等方面都是前作所不能比拟的，可以算是3A大作进入画质内卷的一个分界线。\n在IlumEngine中，我也尝试了使用GPU Driven Rendering Pipeline的思想，来对引擎进行性能调优。\n3.1. 无绑定纹理 Bindless方法指不通过传统方法将资源通过bindTexture/bindBuffer的方式进行绑定，而是直接将Texture/Buffer等GPU资源的虚拟地址直接存储在Bindless Buffer中，在着色器中可以直接使用索引进行访问。Bindless技术最早来源于Nvidia提出的 AZDO（Approaching Zero Driver Overhead）技术框架，2008年Nvidia的Tesla架构就已经实现了Bindless Buffer，而在2012年的Kepler架构正式加入了Bindless Texture特性。\n对于传统的绑定模型，我们往往需要在着色器中声明所需要的纹理/缓冲资源，并且分配相应的槽位（slot）：\n1 2 3  layout (binding = 0) uniform sampler2D tex0; layout (binding = 1) uniform sampler2D tex1; layout (binding = 2) uniform sampler2D tex2;   在CPU端，需要显式绑定所有纹理资源：\n而使用Bindless绑定模型，在着色器中，我们相当于使用了一个无穷大的纹理数组：\n1  layout (binding = 0) uniform sampler2D textureArray[];   所有的纹理数据可以一次性全部灌入其中，需要用到时，我们只需要一个下标索引即可进行访问，而对于材质而言，也不再像下图那样的贴图绑定：\n1 2 3  layout (binding = 0) uniform sampler2D Albedo; layout (binding = 1) uniform sampler2D Metallic; layout (binding = 2) uniform sampler2D Roughness;   而是使用一个结构体，存储所有的材质贴图索引：\n1 2 3 4 5 6  struct Material { uint Albedo; uint Metallic; uint Roughness; }   访问时只需：\n1  vec4 albedo = texture(textureArray[nonuniformEXT(material.Albedo)], inUV);   即可。对于GLSL，记得开启扩展GL_EXT_nonuniform_qualifier\nBindless访问模型如下：\nBindless对GPU Driven Rendering Pipeline有至关重要的作用，它主要解决了传统API下绑定资源到管线的开销问题，同时突破了着色器的硬件访问限制，进一步降低CPU-GPU的交互，我们不需要在CPU端设置Bindless资源的绑定状态，是之后实现single drawcall for everything的基础。\nVulkan中与Bindless相关的技术叫descriptor_indexing，在Vulkan 1.0属于EXT特性，但在Vulkan 1.2中已升为Core特性。在Logical Device的创建时指定：\n1 2 3 4 5 6 7  VkPhysicalDeviceVulkan12Features vulkan12_features = {}; vulkan12_features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES; vulkan12_features.shaderSampledImageArrayNonUniformIndexing = VK_TRUE; vulkan12_features.runtimeDescriptorArray = VK_TRUE; vulkan12_features.descriptorBindingVariableDescriptorCount = VK_TRUE; vulkan12_features.descriptorBindingPartiallyBound = VK_TRUE;   其中，shaderSampledImageArrayNonUniformIndexing、runtimeDescriptorArray、descriptorBindingVariableDescriptorCount指定开启descriptor_indexing特性，descriptorBindingPartiallyBound解决了缺省绑定的问题。\n在创建Bindless Texture过程中，需要指定Bindless Texture的数组支持的最大容量，通常会指定为一个较大的数（如1024）以避免反复扩容，而大部分情况下场景中的纹理都不会填满最大容量，此时需要开启descriptorBindingPartiallyBound支持缺省绑定，以防止出错。\nBindless Texture可视化：\n至此，我们又将一个费时的操作从CPU端移走了。\n3.2. 多重间接绘制 此前的一章一节中，我们将几何数据资源绑定的CPU开销降至最低，将纹理资源绑定的CPU开销给完全移走了，在本节中，我们将要把绘制开销降至最低，实现心心念念的single drawcall for everything。\n在最开始的设计中，我以一种非常低效的方式进行几何阶段的渲染，流程如下：\n 绑定Pipeline、DescriptorSet、Vertex/Index Buffer 遍历模型 遍历子网格 收集材质信息，使用Push Constant操作将材质数据送往着色器 调用绘制命令  可以看到，每一个子网格都将贡献一次Push Constant开销和一次Drawcall的开销，更不用说其他的逻辑判断操作，结果可想而知，场景复杂度一上去，CPU开销裂开，非常不贴合现代图形API的设计初衷，我们需要更多类似Bindless Texture的低CPU开销设计。\n好在现代图形API已经帮我们考虑好了，多重间接绘制Multi Draw Indirect能够完美地满足我们的需求。不同于显式调用绘制命令，Multi Draw Indirect允许我们实现将绘制命令预存在GPU的显存中，在需要绘制时调用：\n1  vkCmdDrawIndexedIndirect(cmd_buffer, draw_buffer, buffer_size, draw_count, sizeof(VkDrawIndexedIndirectCommand));   一个Drawcall即可完成所有的绘制指令提交。\n下面介绍多重间接绘制相关的技术细节：\n3.2.1. 指令缓冲 前述中，Multi Draw Indirect使用我们预存在GPU显存中的绘制命令进行提交，这些绘制命令存储在指令缓冲。在Vulkan中，有结构体VkDrawIndexedIndirectCommand或VkDrawIndirectCommand帮助我们指定指令缓冲中需要存哪些信息，一般来讲我们使用索引进行绘制，因此用的是VkDrawIndexedIndirectCommand，其数据结构定义为：\n1 2 3 4 5 6 7  typedef struct VkDrawIndexedIndirectCommand { uint32_t indexCount; uint32_t instanceCount; uint32_t firstIndex; int32_t vertexOffset; uint32_t firstInstance; } VkDrawIndexedIndirectCommand;   是不是和我们显式绘制指令的参数不能说很像，只能说一模一样？\n1 2 3 4 5 6 7  void vkCmdDrawIndexed( VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance);   当然用法也一样，就是把之前要在渲染循环里指定的参数一一写入一个std::vector\u0026lt;VkDrawIndexedIndirectCommand\u0026gt;容器里，然后在把里面的数据传到GPU显存中，使用其缓冲句柄即可调用vkCmdDrawIndexedIndirect了。\n3.2.2. 材质缓冲 前文提到过，在一开始的实现中，我们将材质信息使用Push Constant的方法在几何遍历时传到着色器中，而使用多重间接绘制时我们不再需要遍历几何体，没办法使用Push Constant方法传送逐子网格数据，因此我们需要一种新的传送材质数据的方法。\n这里我也采用了一种比较暴力的方法，那就是将所有的材质数据都存在一个大的Storage Buffer，鉴于材质数据结构中只需存各个贴图的索引和一些简单的参数，需要的显存并不算多，在每帧循环时，根据需要进行更新。\n由于材质信息是每个子网格拥有一份（不支持多材质、分层材质等），连同如预变换（Pre-Transform，与模型变换矩阵相乘构成世界变换矩阵）、包围盒等信息组成PerInstanceData：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  struct PerInstanceData { mat4 world_transform; mat4 pre_transform; vec4 base_color; vec3 emissive_color; float metallic_factor; float roughness_factor; float emissive_intensity; uint albedo_map; uint normal_map; uint metallic_map; uint roughness_map; uint emissive_map; uint ao_map; vec3 min_; float displacement_height; vec3 max_; uint displacement_map; };   （变量顺序是为了内存对齐需要）\n在着色器中，通过扩展GL_ARB_shader_draw_parameters，能够获得当前绘制物体的索引gl_DrawIDARB，由此来访问相应的PerInstanceData。\n这样一来，我们也顺利地使用一个DrawCall完成了所有的绘制指令提交，实际实验结果也很让人满意，CPU开销有了显著的降低，耗时仅为原来的十分之一不到，CPU也不再成为了渲染的瓶颈。\n3.3. 基于GPU的剔除 在前面几节中，我们已经彻底完成了CPU端的瓶颈解除，但我们也不应止步于此，接下来将进行GPU端的性能优化。要想在不减少场景规模的前提下减少GPU的计算耗时，一个基本的想法就是告诉GPU哪些东西是需要渲染的、哪些东西是不需要渲染的，也就是本节的主角——剔除技术了。\n剔除的本质是一种可见性测试，最常见的剔除有两种：视锥体剔除和遮挡剔除，这两种剔除方法能够排除大量不可见的可渲染物体，当然还有小片元剔除、背面剔除等其他方法。\n在传统管线中，通常采用CPU进行剔除处理，通过SSIM等硬件加速手段提高求交检测来实现各种剔除技术。但在本GPU Driven Rendering Pipeline中，我们已经将所有渲染数据和参数放在显存上了，很自然地，我们将利用现代GPU的通用计算功能（GPGPU），使用计算着色器来帮助我们完成剔除的操作。\n3.3.1. 视锥剔除 在学习计算机图形学基础时，我们都会接触到相机投影等相关知识，简单来讲，相机投影定义了一个裁剪空间，对于正交相机，其平截头体是一个长方体：\n而对于透视相机，其平截头体是一个台体\n在平截头体（或视锥体）之外的顶点将在裁剪阶段被渲染管线丢弃，尽管这些顶点不会参与最后的光栅化阶段，但还是会在顶点着色器中进行计算处理，造成不必要的性能浪费。通过视锥剔除计算，在不可见物体送入渲染管线前就进行排除，能够提高我们的计算效率和计算资源利用率。\n视锥剔除的检测，即包围盒与视锥平面的求交检测，这里涉及两个步骤：视锥平面的求算与包围盒的求交。\n视锥平面的求算\n在IlumEngine中，视锥平面的计算使用了Gribb-Hartmann方法进行求解，其详细数学推导可参考[2]。\n已知当前场景主摄像机的投影矩阵为$M_{P}$，视图矩阵为$M_V$，定义投影视图矩阵：\n$$\nM_{PV}=M_PM_V=\\begin{bmatrix}\nm_{11}\u0026amp;m_{12}\u0026amp;m_{13}\u0026amp;m_{14}\\\\\nm_{21}\u0026amp;m_{22}\u0026amp;m_{23}\u0026amp;m_{24}\\\\\nm_{31}\u0026amp;m_{32}\u0026amp;m_{33}\u0026amp;m_{34}\\\\\nm_{41}\u0026amp;m_{42}\u0026amp;m_{43}\u0026amp;m_{44}\n\\end{bmatrix}\n$$\n则六个视锥面方程如下：\n$$\n\\begin{aligned}\n\\begin{matrix}\n\\mathrm{Left: }\u0026amp;(m_{41}+m_{11})x+(m_{42}+m_{12})y+(m_{43}+m_{13})z+(m_{44}+m_{14})=0\\\\\n\\mathrm{Right: }\u0026amp;(m_{41}-m_{11})x+(m_{42}-m_{12})y+(m_{43}-m_{13})z+(m_{44}-m_{14})=0\\\\\n\\mathrm{Bottom: }\u0026amp;(m_{41}+m_{21})x+(m_{42}+m_{22})y+(m_{43}+m_{23})z+(m_{44}+m_{24})=0\\\\\n\\mathrm{Top: }\u0026amp;(m_{41}-m_{21})x+(m_{42}-m_{22})y+(m_{43}-m_{23})z+(m_{44}-m_{24})=0\\\\\n\\mathrm{Near: }\u0026amp;(m_{41}+m_{31})x+(m_{42}+m_{32})y+(m_{43}+m_{33})z+(m_{44}+m_{34})=0\\\\\n\\mathrm{Far: }\u0026amp;(m_{41}-m_{31})x+(m_{42}-m_{32})y+(m_{43}-m_{33})z+(m_{44}-m_{34})=0\\\\\n\\end{matrix}\n\\end{aligned}\n$$\n包围盒的求交\nIlumEngine中使用了包围球和AABB包围盒两种包围结构，包围球具有旋转不变性、求交方便等优点，AABB包围盒的紧致性比包围球更胜一筹，可以提高更细粒度的剔除。\n对于点$\\pmb p(\\pmb p_x, \\pmb p_y,\\pmb p_z)$，设视锥平面为$a_ix+b_iy+c_iz+d_i=0$，$(i=0,1,\\cdots,6)$，则点$\\pmb p$处于视锥体内，当且仅当：\n$$\na_i\\pmb p_x+b_i\\pmb p_y+c_i\\pmb p_z+d_i\u0026lt;0,\\forall i=0,1,\\cdots,6\n$$\n成立。\n对于球心坐标为点$\\pmb p(\\pmb p_x, \\pmb p_y,\\pmb p_z)$，半径为$r$的包围球，当且仅当：\n$$\na_i\\pmb p_x+b_i\\pmb p_y+c_i\\pmb p_z+d_i+r\u0026lt;0,\\forall i=0,1,\\cdots,6\n$$\n成立时，物体不会被剔除，代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11  bool checkSphere(vec3 pos, float radius) { for (uint i = 0; i \u0026lt; 6; i++) { if (dot(camera.frustum[i], vec4(pos, 1)) + radius \u0026lt; 0.0) { return false; } } return true; }   对于两端点为$\\pmb p_{max}$和$\\pmb p_{min}$的AABB包围盒，我们可以组合出八个包围盒顶点和视锥体的六个平面分别求交，但这样计算量太大，也没必要，对于每个视锥平面，我们只需挑选出其中离它最远的那个顶点进行判断即可，最远顶点可有下述公式决定：\n$$\n\\begin{matrix}\n\\pmb p_x=\\begin{cases}\np_{min_x}\u0026amp;a_i\u0026lt;0\\\\\np_{max_x}\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n\u0026amp;\n\\pmb p_y=\\begin{cases}\np_{min_y}\u0026amp;b_i\u0026lt;0\\\\\np_{max_y}\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n\u0026amp;\n\\pmb p_z=\\begin{cases}\np_{min_z}\u0026amp;c_i\u0026lt;0\\\\\np_{max_z}\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n\\end{matrix}\n$$\n使用该点进行判断即可。代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  bool checkAABB(vec3 min_val, vec3 max_val) { for (uint i=0; i \u0026lt; 6; i++) { vec4 plane = camera.frustum[i]; vec3 plane_normal = { plane.x, plane.y, plane.z }; float plane_constant = plane.w; vec3 axis_vert = { 0.0, 0.0, 0.0 }; axis_vert.x = plane.x \u0026lt; 0.0 ? min_val.x : max_val.x; axis_vert.y = plane.y \u0026lt; 0.0 ? min_val.y : max_val.y; axis_vert.z = plane.z \u0026lt; 0.0 ? min_val.z : max_val.z; if (dot(axis_vert, plane_normal) + plane_constant \u0026gt; 0.0) { return false; } } return true; }   3.3.2. Hierarchy Z-Buffer遮挡剔除 除了视锥剔除，遮挡剔除也是一种重要的剔除技术，当场景中有大量体积较大的遮挡物时有比较好的性能提升效果。遮挡剔除的实现手段有很多种，有使用硬件的遮挡查询策略，不过开销较大一般不建议使用；有手动指定Occlude和Occluder，使用CPU低分辨率软光栅进行剔除（参考Battlefield 3实现）；也有通过离线烘培的方法来实现遮挡剔除。在IlumEngine中则利用帧间信息连续性的原理，使用前一帧的深度缓冲，利用计算着色器生成层级Mipmap，再通过屏幕空间包围结构在计算着色器中实现遮挡剔除。\nHierarchy Z-Buffer的生成\n有了深度缓冲，要计算某物体是否被遮挡，一个直接的想法就是在深度图中采样该物体所在的像素位置，比较深度图采样值和该物体实际的深度值，若采样值小于深度值，则认为物体在该像素下被遮挡，当然物体的实际深度和像素位置在光栅化之前是很难算出来的，我们可以用简单的几何体例如包围结构来代替实际的物体，但即便如此，进行全分辨率的搜索和比较也是一个相当耗时的操作，这也是我们为什么需要层级深度缓冲的原因：通过包围结构在屏幕空间的投影大小，能够计算出相应的MipLevel，使得在该MipLevel下一个像素刚好能够覆盖全分辨率下包围结构的大小，这样一来，搜索和比较操作从原来的需要对包围结构所占像素逐个比对，优化至只需要搜索相应的MipLevel，通过一次采样即可完成比对。当然下采样也会带来一定的信息量损失，带来剔除精度的损失，但在剔除精度与开销之间的权衡，我们更倾向于后者。\n在每一帧的几何阶段中，我们都将使用一个格式为VK_FORMAT_D32_SFLOAT_S8_UINT的纹理来作为我们的Depth Stencil Buffer，由于深度图格式无法直接进行Mipmap操作，我们需要自己手动生成相应的Mipmap。\n出于框架的局限性，需要在每个渲染流程的结尾将Deth Stencil Buffer拷贝到另外一张深度贴图Last_Frame.depth_buffer中，在HizPass中，首先我们需要准备好Last_Frame.hiz_buffer的各个层级的VkImageView，以方便后续数据的写入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  m_views.resize(Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer-\u0026gt;getMipLevelCount()); VkImageViewCreateInfo image_view_create_info = {}; image_view_create_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; image_view_create_info.viewType = VK_IMAGE_VIEW_TYPE_2D; image_view_create_info.format = VK_FORMAT_R32_SFLOAT; image_view_create_info.components = {VK_COMPONENT_SWIZZLE_R}; image_view_create_info.subresourceRange.layerCount = 1; image_view_create_info.image = *Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer; for (uint32_t i = 0; i \u0026lt; m_views.size(); i++) { image_view_create_info.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; image_view_create_info.subresourceRange.baseArrayLayer = 0; image_view_create_info.subresourceRange.layerCount = 1; image_view_create_info.subresourceRange.baseMipLevel = i; image_view_create_info.subresourceRange.levelCount = 1; vkCreateImageView(GraphicsContext::instance()-\u0026gt;getLogicalDevice(), \u0026amp;image_view_create_info, nullptr, \u0026amp;m_views[i]); }   出于保守剔除策略，在下采样过程中，我们不应使用线性过滤等方法进行处理，而是考虑选择一个$4\\times 4$ Texels中最大的值（不使用反向Z缓冲），在Vulkan中，可以使用Reduction Mode在VkSampler创建时指定VK_SAMPLER_REDUCTION_MODE_MAX：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  VkSamplerCreateInfo createInfo = {VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO}; createInfo.magFilter = VK_FILTER_LINEAR; createInfo.minFilter = VK_FILTER_LINEAR; createInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST; createInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE; createInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE; createInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE; createInfo.minLod = 0; createInfo.maxLod = 16.f; VkSamplerReductionModeCreateInfo createInfoReduction = {VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT}; createInfoReduction.reductionMode = VK_SAMPLER_REDUCTION_MODE_MAX; createInfo.pNext = \u0026amp;createInfoReduction; vkCreateSampler(GraphicsContext::instance()-\u0026gt;getLogicalDevice(), \u0026amp;createInfo, 0, \u0026amp;m_hiz_sampler);   接着生成好需要用到的descriptor_sets：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  for (uint32_t level = 0; level \u0026lt; m_views.size(); level++) { VkDescriptorImageInfo dstTarget; dstTarget.sampler = m_hiz_sampler; dstTarget.imageView = m_views[level]; dstTarget.imageLayout = VK_IMAGE_LAYOUT_GENERAL; VkDescriptorImageInfo srcTarget; srcTarget.sampler = m_hiz_sampler; if (level == 0) { srcTarget.imageView = Renderer::instance()-\u0026gt;Last_Frame.depth_buffer-\u0026gt;getView(ImageViewType::Depth_Only); srcTarget.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL; } else { srcTarget.imageView = m_views[level - 1]; srcTarget.imageLayout = VK_IMAGE_LAYOUT_GENERAL; } std::vector\u0026lt;VkWriteDescriptorSet\u0026gt; write_descriptor_sets(2); write_descriptor_sets[0] = {}; write_descriptor_sets[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET; write_descriptor_sets[0].dstSet = m_descriptor_sets[level]; write_descriptor_sets[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER; write_descriptor_sets[0].dstBinding = 0; write_descriptor_sets[0].pImageInfo = \u0026amp;srcTarget; write_descriptor_sets[0].pBufferInfo = nullptr; write_descriptor_sets[0].pTexelBufferView = nullptr; write_descriptor_sets[0].descriptorCount = 1; write_descriptor_sets[0].pNext = nullptr; write_descriptor_sets[1] = {}; write_descriptor_sets[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET; write_descriptor_sets[1].dstSet = m_descriptor_sets[level]; write_descriptor_sets[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE; write_descriptor_sets[1].dstBinding = 1; write_descriptor_sets[1].pImageInfo = \u0026amp;dstTarget; write_descriptor_sets[1].pBufferInfo = nullptr; write_descriptor_sets[1].pTexelBufferView = nullptr; write_descriptor_sets[1].descriptorCount = 1; write_descriptor_sets[1].pNext = nullptr; m_descriptor_sets[level].update(write_descriptor_sets); }   每个descriptor_set规定了需要读取和写入的数据，在第一轮中，读取的应为上一帧的深度图，写入MipLevel为0的Hi-Z Buffer，而之后的每一轮都是读取MipLevel为$i$的Hi-Z Buffer，写入MipLevel为$i+1$的Hi-Z Buffer。\n至此准备阶段已经结束了，在每一轮渲染循环中，需要进行以下更新：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  for (uint32_t level = 0; level \u0026lt; views.size(); level++) { { VkImageMemoryBarrier read_to_write{}; read_to_write.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER; read_to_write.oldLayout = VK_IMAGE_LAYOUT_GENERAL; read_to_write.newLayout = VK_IMAGE_LAYOUT_GENERAL; read_to_write.srcAccessMask = VK_ACCESS_SHADER_READ_BIT; read_to_write.dstAccessMask = VK_ACCESS_SHADER_WRITE_BIT; read_to_write.image = *Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer; read_to_write.subresourceRange = VkImageSubresourceRange{VK_IMAGE_ASPECT_COLOR_BIT, level, 1, 0, 1}; read_to_write.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; read_to_write.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; vkCmdPipelineBarrier( cmd_buffer, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_DEPENDENCY_BY_REGION_BIT, 0, nullptr, 0, nullptr, 1, \u0026amp;read_to_write); } vkCmdBindDescriptorSets(cmd_buffer, state.pass.bind_point, state.pass.pipeline_layout, 0, 1, \u0026amp;m_descriptor_sets[level].getDescriptorSet(), 0, nullptr); uint32_t level_width = std::max(1u, Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer-\u0026gt;getWidth() \u0026gt;\u0026gt; level); uint32_t level_height = std::max(1u, Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer-\u0026gt;getHeight() \u0026gt;\u0026gt; level); VkExtent2D extent = {level_width, level_height}; vkCmdPushConstants(cmd_buffer, state.pass.pipeline_layout, VK_SHADER_STAGE_COMPUTE_BIT, 0, sizeof(VkExtent2D), \u0026amp;extent); uint32_t group_count_x = (Renderer::instance()-\u0026gt;getRenderTargetExtent().width + 32 - 1) / 32; uint32_t group_count_y = (Renderer::instance()-\u0026gt;getRenderTargetExtent().height + 32 - 1) / 32; vkCmdDispatch(cmd_buffer, group_count_x, group_count_y, 1); { VkImageMemoryBarrier write_to_read{}; write_to_read.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER; write_to_read.oldLayout = VK_IMAGE_LAYOUT_GENERAL; write_to_read.newLayout = VK_IMAGE_LAYOUT_GENERAL; write_to_read.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT; write_to_read.dstAccessMask = VK_ACCESS_SHADER_READ_BIT; write_to_read.image = *Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer; write_to_read.subresourceRange = VkImageSubresourceRange{VK_IMAGE_ASPECT_COLOR_BIT, level, 1, 0, 1}; write_to_read.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; write_to_read.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; vkCmdPipelineBarrier( cmd_buffer, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_DEPENDENCY_BY_REGION_BIT, 0, nullptr, 0, nullptr, 1, \u0026amp;write_to_read); } }   每一次计算循环开始，需要切换相应的读写状态、绑定相应的descriptor_set，进行计算着色器的dispatch，最后再进行下一轮的状态切换准备，直到填满Hi-Z Buffer的所有Mipmap层级为止。\n屏幕空间包围结构的计算\n有了Hi-Z Buffer，现在我们需要得到物体包围结构屏幕空间的投影，为了计算方便，只考虑包围球形式，使用的计算方法参考文献[3]，该算法将世界空间的包围球变换为屏幕空间AABB包围盒。\n首先我们回顾一下图形学基础中视图矩阵和投影矩阵的相关概念，视图矩阵$M_{view}$主要作用是将场景变换到相机空间中，所谓的相机空间，就是以相机为原点所定义的空间，视图矩阵可以由相机的模型矩阵求逆得到：$M_{view}=M_{camera\\_position}^{-1}$，当然一般很少通过这种方法来求取视图矩阵，因为不够直观，而是通过摄像机的朝向和摄像机的位置来进行求取：\n$$\nM_{view}=\\begin{bmatrix}\n\\pmb R_x\u0026amp;\\pmb R_y\u0026amp;\\pmb R_z\u0026amp;0\\\\\n\\pmb U_x\u0026amp;\\pmb U_y\u0026amp;\\pmb U_z\u0026amp;0\\\\\n\\pmb D_x\u0026amp;\\pmb D_y\u0026amp;\\pmb D_z\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;0\u0026amp;1\n\\end{bmatrix}\n\\ast\n\\begin{bmatrix}\n1\u0026amp;0\u0026amp;0\u0026amp;-\\pmb P_x\\\\\n0\u0026amp;1\u0026amp;0\u0026amp;-\\pmb P_y\\\\\n0\u0026amp;0\u0026amp;1\u0026amp;-\\pmb P_z\\\\\n0\u0026amp;0\u0026amp;0\u0026amp;1\n\\end{bmatrix}\n$$\n其中，$\\pmb R$为右向量，$\\pmb U$为上向量，$\\pmb D$为方向向量，$\\pmb P$为摄像机的位置向量。\n而投影矩阵则是实现将三维空间的物体投影到二维屏幕上，投影矩阵将相机空间中的顶点数据变换到裁剪空间中，最后通过透视除法变换到标准化设备坐标，这里以透视投影为例：\n从两个方向观察，由三角形近似可得：\n$$\n\\begin{align}\n\\dfrac{x_p}{x_e}\u0026amp;=\\dfrac{-n}{z_e}\\Rightarrow x_p=\\dfrac{-n\\cdot x_e}{z_e}=\\dfrac{n\\cdot x_e}{-z_e}\\\\\n\\dfrac{y_p}{y_e}\u0026amp;=\\dfrac{-n}{z_e}\\Rightarrow y_p=\\dfrac{-n\\cdot y_e}{z_e}=\\dfrac{n\\cdot y_e}{-z_e}\n\\end{align}\n$$\n注意到$x_p$和$y_p$的计算均需要除以一个$-z_e$，这与裁剪空间到NDC正则化的透视除法相对应：\n$$\n\\begin{align}\n\\begin{pmatrix}\nx_{clip}\\\\y_{clip}\\\\z_{clip}\\\\w_{clip}\n\\end{pmatrix}\n\u0026amp;=\\pmb M_{projection}\\cdot\n\\begin{pmatrix}\nx_{eye}\\\\y_{eye}\\\\z_{eye}\\\\w_{eye}\n\\end{pmatrix}\\\\\n\\begin{pmatrix}\nx_{ndc}\\\\y_{ndc}\\\\z_{ndc}\n\\end{pmatrix}\n\u0026amp;=\n\\begin{pmatrix}\nx_{clip}/w_{clip}\\\\\ny_{clip}/w_{clip}\\\\\nz_{clip}/w_{clip}\n\\end{pmatrix}\n\\end{align}\n$$\n这里的$w_{clip}$便是$-z_e$了，因此透视投影矩阵有如下形式：\n$$\n\\begin{align}\n\\begin{pmatrix}\nx_c\\\\\ny_c\\\\\nz_c\\\\\nw_c\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\cdot \u0026amp; \\cdot \u0026amp; \\cdot \u0026amp; \\cdot\\\\\n\\cdot \u0026amp; \\cdot \u0026amp; \\cdot \u0026amp; \\cdot\\\\\n\\cdot \u0026amp; \\cdot \u0026amp; \\cdot \u0026amp; \\cdot\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\nx_e\\\\\ny_e\\\\\nz_e\\\\\nw_e\n\\end{pmatrix}\n\\end{align}\n$$\n下面我们需要把近平面坐标点$x_p$和$y_p$线性映射到NDC坐标$x_n$和$y_n$：$[l,r]\\Rightarrow [-1,1]$以及$[b,t]\\Rightarrow [-1,1]$\n$$\n\\begin{align}\n\\dfrac{x_n-(-1)}{1-(-1)}\u0026amp;=\\dfrac{x_p-l}{r-l}\\Rightarrow x_n=\\dfrac{2x_p}{r-l}-\\dfrac{r+l}{r-l}\\\\\n\\dfrac{y_n-(-1)}{1-(-1)}\u0026amp;=\\dfrac{y_p-b}{t-b}\\Rightarrow y_n=\\dfrac{2y_p}{t-b}-\\dfrac{t+b}{t-b}\n\\end{align}\n$$\n将$x_p$和$y_p$代入得\n$$\n\\begin{align}\nx_n=\\Big(\\dfrac{2n}{r-l}\\cdot x_e+\\dfrac{r+l}{r-l}\\cdot z_e \\Big)\\Big/-z_e\\\\\ny_n=\\Big(\\dfrac{2n}{t-b}\\cdot y_e+\\dfrac{t+b}{t-b}\\cdot z_e \\Big)\\Big/-z_e\n\\end{align}\n$$\n可填入透视投影矩阵：\n$$\n\\begin{align}\n\\begin{pmatrix}\nx_c\\\\\ny_c\\\\\nz_c\\\\\nw_c\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\frac{2n}{r-l}\u0026amp;0\u0026amp;\\frac{r+l}{r-l}\u0026amp;0\\\\\n0\u0026amp;\\frac{2n}{t-b}\u0026amp;\\frac{t+b}{t-b}\u0026amp;0\\\\\n\\cdot \u0026amp; \\cdot \u0026amp; \\cdot \u0026amp; \\cdot\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\nx_e\\\\\ny_e\\\\\nz_e\\\\\nw_e\n\\end{pmatrix}\n\\end{align}\n$$\n由于$z_c$不依赖于$x_e$与$y_e$且与$z_e$和$w_e$成线性关系，设\n$$\n\\begin{align}\n\\begin{pmatrix}\nx_c\\\\\ny_c\\\\\nz_c\\\\\nw_c\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\frac{2n}{r-l}\u0026amp;0\u0026amp;\\frac{r+l}{r-l}\u0026amp;0\\\\\n0\u0026amp;\\frac{2n}{t-b}\u0026amp;\\frac{t+b}{t-b}\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;A\u0026amp;B\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\nx_e\\\\\ny_e\\\\\nz_e\\\\\nw_e\n\\end{pmatrix}\n\\end{align}\n$$\n即\n$$\nz_n=z_c/w_c=\\dfrac{Az_e+Bw_e}{-z_e}\n$$\n在视角空间中，$w_e=1$，因此$z_n=\\frac{Az_e+B}{-z_e}$，利用边界关系：\n$$\n\\begin{cases}\n\\dfrac{-An+B}{n}=-1\\\\\n\\dfrac{-Af+B}{f}=1\n\\end{cases}\n\\Rightarrow\n\\begin{cases}\nA=-\\dfrac{f+n}{f-n}\\\\\nB=-\\dfrac{2fn}{f-n}\n\\end{cases}\n$$\n因此完整的透视投影矩阵表示为：\n$$\n\\begin{pmatrix}\n\\frac{2n}{r-l}\u0026amp;0\u0026amp;\\frac{r+l}{r-l}\u0026amp;0\\\\\n0\u0026amp;\\frac{2n}{t-b}\u0026amp;\\frac{t+b}{t-b}\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;\\frac{-(f+n)}{f-n}\u0026amp;\\frac{-2fn}{f-n}\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n$$\n如果视锥体对称，即$t=-b$和$l=-r$，则可简化为：\n$$\n\\begin{pmatrix}\n\\frac{n}{r}\u0026amp;0\u0026amp;0\u0026amp;0\\\\\n0\u0026amp;\\frac{n}{t}\u0026amp;0\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;\\frac{-(f+n)}{f-n}\u0026amp;\\frac{-2fn}{f-n}\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n$$\n通常情况下我们会用参数$fovy$（$y$轴方向的视域角）、$aspect$（屏幕宽高比）、$near$（近平面）以及$far$（远平面）来构造透视投影矩阵，相关关系如下：\n$$\n\\begin{align}\nr-l\u0026amp;=width=2*near*aspect*tan(fovy/2)\\\\\nt-b\u0026amp;=height=2*near*tan(fovy/2)\n\\end{align}\n$$\n而对于正交投影，只需对各个方向作正则化即可：\n$$\n\\begin{cases}\n\\dfrac{x_n-(-1)}{1-(-1)}=\\dfrac{x_e-l}{r-l}\\\\\n\\dfrac{y_n-(-1)}{1-(-1)}=\\dfrac{y_e-b}{t-b}\\\\\n\\dfrac{z_n-(-1)}{1-(-1)}=\\dfrac{z_e-n}{f-n}\n\\end{cases}\n$$\n得到正交投影矩阵：\n$$\n\\begin{pmatrix}\n\\frac{2}{r-l}\u0026amp;0\u0026amp;0\u0026amp;-\\frac{r+l}{r-l}\\\\\n0\u0026amp;\\frac{2}{t-b}\u0026amp;0\u0026amp;-\\frac{t+b}{t-b}\\\\\n0\u0026amp;0\u0026amp;\\frac{-2}{f-n}\u0026amp;-\\frac{f+n}{f-n}\\\\\n0\u0026amp;0\u0026amp;0\u0026amp;1\n\\end{pmatrix}\n$$\n复习完视图矩阵和投影矩阵的相关概念后，我们正式计算世界空间中的包围球到屏幕空间AABB包围盒的投影。\n首先，需要将包围球投影到相机空间，这一步简单地乘上一个视图矩阵即可。\n求屏幕空间包围盒，即求包围球在投影面上的最大和最小坐标，从单方向看，如上图所示，若$\\hat a$表示$x$轴，欲求取点$T$的坐标，连线$OT$与圆$C$相切，在该二维平面上，有球心坐标$C(C_x,C_z)$，设$\\vec c=(C_x,C_y)$，$c=\\sqrt{C_x^2+C_y^2}$，则从相机到$T$的单位向量可由旋转得到：\n$$\n\\hat\\omega =\\begin{bmatrix}\\cos\\theta\u0026amp;\\sin\\theta\\\\-\\sin\\theta\u0026amp;\\cos\\theta\\end{bmatrix}\\frac{\\vec c}{|\\vec c|}\n$$\n而$T$到相机的距离也很容易求得：$d=\\sqrt{c^2-r^2}$，且$\\cos\\theta = \\frac{d}{c}$，$\\sin\\theta=\\frac{r}{c}$\n解得$T=O+\\hat \\omega d$，同理可求得点$B$的坐标，令$\\tilde \\theta = -\\theta$即可。\n点$B$和$T$即视图空间中，包围球在$x$轴方向上的最左点和最右点，我们还需要将其变换到裁剪空间中，进行归一化处理。\n由前述推导可知，透视投影过程可表示为如下形式：\n$$\n\\begin{pmatrix}\nP_{00}\u0026amp;0\u0026amp;0\u0026amp;0\\\\\n0\u0026amp;P_{11}\u0026amp;0\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;P_{22}\u0026amp;P_{23}\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\nx_e\\\\y_e\\\\z_e\\\\1\n\\end{pmatrix}=\n\\begin{pmatrix}\nP_{00}x_e\\\\P_{11}y_e\\\\P_{22}z_e+P_{23}\\\\-z_e\n\\end{pmatrix}\n$$\n通过透视除法投影到NDC空间中：\n$$\n\\begin{aligned}\nx_n \u0026amp;= \\frac{Ax_e}{-z_e}\\\\\ny_n \u0026amp;= \\frac{By_e}{-z_e}\n\\end{aligned}\n$$\n最后通过简单的线性变换可以从NDC空间$[-1,1]$变换到UV空间$[0,1]$方便后续处理。\nGLSL实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  bool projectSphere(vec3 C, float r, float znear, float P00, float P11, out vec4 aabb) { if (-C.z \u0026lt; r + znear) return false; vec2 cx = C.xz; vec2 vx = vec2(sqrt(dot(cx, cx) - r * r), r); vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx; vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx; vec2 cy = C.yz; vec2 vy = vec2(sqrt(dot(cy, cy) - r * r), r); vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * cy; vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * cy; aabb = vec4(-minx.x / minx.y * P00, -miny.x / miny.y * P11, -maxx.x / maxx.y * P00, -maxy.x / maxy.y * P11); aabb = aabb.xwzy * vec4(0.5f, -0.5f, 0.5f, -0.5f) + vec4(0.5f); return true; }   深度值搜索与比较\n得到Hi-Z Buffer和屏幕空间包围盒后，便可开始最后的计算环节。首先通过屏幕空间包围盒的大小获得需要索引的MipLevel：\n1 2 3  float width = (aabb.z - aabb.x) * cullData.zbuffer_width; float height = (aabb.w - aabb.y) * cullData.zbuffer_height; float mip_level = floor(log2(max(width, height)));   通过包围盒中心位置来确定需要采样的UV坐标，为了保证不会误剔除，在其周围多采样几个像素：\n1 2 3 4 5  vec2 uv = (aabb.xy + aabb.zw) * 0.5; vec2 uv0 = aabb.xy; vec2 uv1 = aabb.zw; vec2 uv2 = aabb.xw; vec2 uv3 = aabb.zy;   选择深度最大的那个深度值，保守剔除策略：\n1 2 3 4 5  float depth = textureLod(hiz_buffer, uv, mip_level).r; depth = max(depth, textureLod(hiz_buffer, uv0, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv1, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv2, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv3, mip_level).r);   还需要将深度值通过逆透视除法还原到裁剪空间中，以避免浮点精度误差带来的剔除准确性降低，设采样得到的深度值为$z_n$，其裁剪空间对应的深度值为：\n$$\nz_c=\\frac{2f\\cdot n}{(f-n)\\cdot z_n-(f+n)}\n$$\n其中，$f$为远裁剪面距离，$n$为近裁剪面距离，注意这里得到的$z_c$为负，需要取反。\n在实际实验中，在摄像机远离物体的过程中可能会出现误剔除的情况，这是由于我们利用了上一帧的深度信息，而这一帧由于远离物体，深度变大，会导致自遮挡的现象出现，解决办法也很简单，我们需要保留上一帧的相机视图-投影矩阵，在计算用于比较的实际深度值时，应使用上一帧的相机参数，以解决自遮挡问题。\n完整的遮挡剔除代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  float LinearizeDepth(float depth) { return -(2.0 * cullData.zfar * cullData.znear) / (cullData.zfar + cullData.znear - depth * (cullData.zfar - cullData.znear));\t} bool checkOcclusion(vec3 center, float radius) { vec3 dir = normalize(camera.position - center); vec4 sceen_space_center_last = camera.last_view_projection * vec4(center + dir*radius, 1.0); vec3 C = ((cullData.view) * vec4(center,1.0)).xyz; vec4 aabb; if(!projectSphere(C, radius, cullData.znear, cullData.P00, cullData.P11, aabb)) { return true; } float width = (aabb.z - aabb.x) * cullData.zbuffer_width; float height = (aabb.w - aabb.y) * cullData.zbuffer_height; float mip_level = floor(log2(max(width, height))); vec2 uv = (aabb.xy + aabb.zw) * 0.5; vec2 uv0 = aabb.xy; vec2 uv1 = aabb.zw; vec2 uv2 = aabb.xw; vec2 uv3 = aabb.zy; float depth = textureLod(hiz_buffer, uv, mip_level).r; depth = max(depth, textureLod(hiz_buffer, uv0, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv1, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv2, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv3, mip_level).r); float depthSphere = abs(sceen_space_center_last.z); return LinearizeDepth(depth) \u0026gt;= depthSphere; }   3.4. 基于Meshlet的渲染优化 前文中我们已经实现了基本的基于GPU的剔除优化技术，在多数场景下都能带来一定的性能增益，但目前我们还只是以子网格为单位进行的剔除与提交，当子网格较大时仍存在不少计算资源的浪费，由于我们已经使用了GPGPU技术来帮助我们完成剔除与绘制的操作，模型的数量和Drawcall已不再是我们的性能瓶颈，一个很自然的想法便是能否将一个大的网格切分为诸多一定规则的小网格，从而提高剔除的粒度，同时由于我们使用了GPU强大的并行处理能力进行剔除，对它们进行处理也不将成为问题，因此，我们引入了Mesh Shader中Meshlet的概念，只是我们为了平台灵活性，不打算用Mesh Shader进行处理，而是使用计算着色器来帮助我们完成相同的功能。\nMeshlet是网格划分为小块的单位，是Mesh Shader处理的基本单元，传统的顶点着色器是逐顶点处理模型的，而Mesh Shader则支持逐Meshlet处理模型。通常来讲，每个Meshlet具有相同的顶点数以及支持的最大三角形数，NVIDIA建议选取顶点数为64，三角形数为124的Meshlet进行处理，Meshlet的生成需要通过离线工具构建，IlumEngine中使用了开源库meshoptimizer进行处理，meshoptimizer使用非常方便，文档齐全，这里不多讲其使用。如下封面图所示，我们已经成功将整个场景分成了大量小网格块：\n加入了Meshlet支持的模型存储方式与之前也基本一致，区别在于每个Model对象需要维护其所有的Meshlet，每个子网格需要存储其拥有的Meshlet的偏移和数量，Meshlet结构体定义如下：\n1 2 3 4 5 6 7  struct Meshlet { meshopt_Bounds bounds; uint32_t indices_offset; uint32_t indices_count; uint32_t vertices_offset; };   meshopt_Bounds为meshoptimizer的包围体结构，使用的是包围球结构以及用于锥体背面剔除的相关参数。\n现在的Model和Submesh结构体定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  struct Model { public: std::vector\u0026lt;SubMesh\u0026gt; submeshes; uint32_t vertices_count = 0; uint32_t indices_count = 0; uint32_t vertices_offset = 0; uint32_t indices_offset = 0; // Raw geometry, original data  std::vector\u0026lt;Vertex\u0026gt; vertices; std::vector\u0026lt;uint32_t\u0026gt; indices; // Meshlet, for mesh shading \u0026amp; cluster culling  std::vector\u0026lt;Meshlet\u0026gt; meshlets; geometry::BoundingBox bounding_box; } struct SubMesh { public: uint32_t index = 0; glm::mat4 pre_transform = glm::mat4(1.f); uint32_t vertices_count = 0; uint32_t indices_count = 0; uint32_t vertices_offset = 0; uint32_t indices_offset = 0; uint32_t meshlet_offset = 0; uint32_t meshlet_count = 0; material::DisneyPBR material; geometry::BoundingBox bounding_box; }   现在我们已经将最小渲染单位从子网格换成了Meshlet，原先的间接绘制、GPU剔除等操作照样进行。\n3.4.1. Meshlet渲染性能调优1：压缩合批 由于我们将每个网格都分成了众多Meshlet，在提高剔除粒度的同时也增加了渲染物的数量，同时用于间接绘制所需要的Draw_Buffer也会相应的变大，在之前的实现中，我们通过设置VkDrawIndexedIndirectCommand中的instanceCount参数来决定是否进行绘制，设为0时则表示被剔除。但在直接从子网格处理转换到Meshlet处理时，却发现当场景规模很大时，渲染效率反而没有原来的高，经过Profile发现瓶颈出在了几何阶段的GPU开销上，尽管有了一系列CPU优化和GPU剔除，CPU已经基本不需要花什么时间了，但绘制过程中的GPU用时居高不下，经分析是由于Draw_Buffer过大造成，光是遍历里头每一条渲染指令就已经花了GPU很多时间了。这个问题的解决方法也很简单：只提交需要进行绘制的指令。\n在之前的实现中，我们是在CPU端事先设置好所有的VkDrawIndexedIndirectCommand数组，传到GPU中，通过GPU可见性判断来设置instanceCount参数决定是否绘制该物体，这种方法造成了最后进行提交的绘制缓冲中有效指令和无效指令相互混叠，容易产生流水线气泡，如果能够对绘制缓冲中的指令进行排序，将有效指令移至渲染队列的头部，将绘制指令数量设置为有效指令的数量，则可以大幅提升性能。但在着色器中实现排序操作似乎不是一件简单的操作，因此我们另辟蹊径，在剔除管线中不仅设置可见性，我们直接在里头设置整个渲染指令。\n为方便渲染队列的构建和有效指令数量的跟踪，我们使用了一个Count_Buffer来记录有效绘制指令的数量，在计算着色器中，通过原子加法操作，实现类似push_back的功能：\n1 2 3 4 5 6 7 8 9 10  if (visible) { uint dci = atomicAdd(visible_count, 1); indirectDraws[dci].indexCount = meshlet.index_count; indirectDraws[dci].instanceCount = 1; indirectDraws[dci].firstIndex = meshlet.index_offset; indirectDraws[dci].vertexOffset = int(meshlet.vertex_offset); indirectDraws[dci].firstInstance = 0; draw_data[dci] = meshlet.instance_id; }   然而，在开发过程中，又遇到一个问题，如何获取Count_Buffer中的计数数据？使用GPU-CPU回读？那样在 一个渲染循环中只能获取到上一帧的计数结果。通过查阅文档发现，Vulkan开发者已经考虑过这个问题了，提供了vkCmdDrawIndexedIndirectCount函数，让我们能够直接使用Count_Buffer作为参数向GPU指定渲染指令数量。\n至此，Meshlet渲染带来的合批过大问题已被完美解决。\n3.4.2. Meshlet渲染性能调优2：层次剔除 简单使用Meshlet进行渲染，除了有合批过大的问题外，还有剔除开销的问题，当场景面数一多，Meshlet数量一大，剔除阶段的计算量也是不可忽视的。这里IlumEngine采用的解决方案是分层次进行剔除，其实也就是先对实例（子网格）进行剔除，再进行Meshlet进行剔除。已经在实例剔除阶段剔除的实例，其包含的Meshlet也就不用再进行剔除了，减少了剔除用时。事实上，层次剔除还可以更进一步的，通过构建不同层级的Meshlet BVH，进行高效地索引需要剔除的层级，能够实现更加高效的剔除策略，和LOD方法相结合，也就是虚幻引擎5中Nanite虚拟几何体的处理方法了。\n4. 结果 场景总览\n渲染管线\n无优化\n仅视锥剔除\n仅背面剔除\n仅遮挡剔除\n使用所有剔除\n演示Demo\n\n可以看到由于使用了帧间连续性的原因，在某些地方仍会有部分闪烁，后续引入TAA等帧间累积方法可以一定程度上解决这个问题，但在帧率上确实有了实质性的提升。\n参考链接 [1] Haar U, Aaltonen S. Gpu-driven rendering pipelines. Ubisoft, Siggraph 2015: Advances in Real-Time Rendering in Games course, 2015\n[2] Gribb G, Hartmann K. Fast extraction of viewing frustum planes from the worldview-projection matrix. Online document, 2001. \n[3] Mara, Michael, and Morgan McGuire. \u0026ldquo;2D polyhedral bounds of a clipped, perspective-projected 3D sphere.\u0026rdquo; JCGT. in submission 5 (2012).\n","description":"IlumEngine的第一次渲染性能优化","id":14,"section":"posts","tags":["Real-time Rendering"],"title":"实时渲染优化技术(1)","uri":"https://chaphlagical.github.io/zh/posts/rendering/optimization1/"},{"content":"Lazy Snapping是一种基于图的图像分割方法[1]，能够将图像分割为前景和背景，通过用户交互挑选前景和背景种子，利用最大流最小分割的方法对图像进行分割。\n1. 基本方法 文献中利用分水岭算法对图像进行预处理，这里我们直接将图像下采样到原分辨率的八分之一进行处理，然后求解以下优化问题：\n$$\nE(X)=\\sum_{i\\in\\mathcal{V}}E_1(x_i)+\\lambda\\sum_{(i,j)\\in\\mathcal\\varepsilon}E_2(x_i, x_j)\n$$\n其中，$E_1(x_i)$为似然能量，编码结点$x_i$的代价，$E_2(x_i,x_j)$为先验能量，代表邻接结点$x_i$和$x_j$的代价。\n似然能量$E_1(x_i)$定义为：\n$$\n\\begin{cases}\n\\begin{matrix}\nE_1(x_i=1)=0\u0026amp;E_1(x_i=0)=\\infty\u0026amp;\\forall i\\in\\mathcal{F}\n\\end{matrix}\\\\\\\\\n\\begin{matrix}\nE_1(x_i=1)=\\infty\u0026amp;E_1(x_i=0)=0\u0026amp;\\forall i\\in\\mathcal{B}\n\\end{matrix}\\\\\\\\\n\\begin{matrix}\nE_1(x_i=1)=\\frac{d_i^\\mathcal{F}}{d_i^\\mathcal{F}+d_i^\\mathcal{B}}\u0026amp;E_1(x_i=0)=\\frac{d_i^\\mathcal{B}}{d_i^\\mathcal{F}+d_i^\\mathcal{B}}\u0026amp;\\forall i\\in\\mathcal{U}\n\\end{matrix}\n\\end{cases}\n$$\n其中，$\\mathcal{F}$表示前景种子集合，$\\mathcal{B}$为背景种子集合，均由用户输入，而$\\mathcal{U}$为补集。$d_i^\\mathcal{F}$和$d_i^\\mathcal{B}$分别表示当前颜色与前景种子平均值和背景种子平均值的距离平方\n先验能量$E_2(x_i,x_j)$定义为：\n$$\nE_2(x_i,x_j)=\\frac{1}{|C(i)-C(j)|^2+\\varepsilon}\n$$\n实验中，取$\\lambda=100$，$\\epsilon=0.01$。\n然后构建无向图，通过最大流最小割方法分离出前景和背景，提取轮廓得到结果\n实验结果    原图像 交互图像 轮廓                     参考文献 [1] Y. Li, J. Sun, C.-K. Tang, and H.-Y. Shum. Lazy snapping. ACM Transactions on Graphics (ToG), 23(3):303–308, 2004.\n","description":"复现Siggraph2004论文《Lazy snapping》","id":15,"section":"posts","tags":["Digital Image Process"],"title":"Lazy Snapping","uri":"https://chaphlagical.github.io/zh/posts/image_process/lazy_snapping/"},{"content":"Seam Carving算法是一种基于内容的图像缩放方法，在保证图像中“重要区域”不发生形变的前提下，对图像进行缩放。\n一种直观的想法便是找出图像中的“不重要区域”，并将其删除。文献[1]中便是采用这种思想，\n通过定义像素的能量函数，通过动态规划方法对某一方向的像素进行能量累积，最后回溯求出能量最低的一条路径，该路径便是我们要删除的“最不重要”路径。\n1. 基本方法 图像的能量简单地由图像梯度描述：\n$$\ne_1(\\pmb I)=\\left|\\frac{\\partial}{\\partial x}\\pmb I\\right|+\\left|\\frac{\\partial}{\\partial y}\\pmb I\\right|\n$$\n论文中也给出另外一种能量的变体实现：\n$$\ne_{HoG}(\\pmb I)=\\frac{\\left|\\frac{\\partial}{\\partial x}\\pmb I\\right|+\\left|\\frac{\\partial}{\\partial y}\\pmb I\\right|}{\\max(HoG(\\pmb I(x,y)))}\n$$\n实现中，采用Sobel算子提取图像梯度作为能量图：\n1 2 3 4 5 6 7 8 9 10 11  void SeamCarving::genEnergyMap(const cv::Mat\u0026amp; img, cv::Mat\u0026amp; energy) { cv::Mat sobel_x, sobel_y, gray_energy; cv::cvtColor(img, gray_energy, cv::COLOR_BGR2GRAY); cv::Sobel(gray_energy, sobel_x, CV_32F, 1, 0, 3); cv::convertScaleAbs(sobel_x, sobel_x); cv::Sobel(gray_energy, sobel_y, CV_32F, 0, 1, 3); cv::convertScaleAbs(sobel_y, sobel_y); cv::addWeighted(sobel_x, 0.5, sobel_y, 0.5, 0, energy); energy.convertTo(energy, CV_32FC1); }   对于$n\\times m$的图像$\\pmb I$，用于删除的接缝由如下定义：\n水平接缝：\n$$\n\\pmb{s^x}=\\{s_i^x\\}_{i=1}^n=\\{(x(i),i)\\}_{i=1}^n,\\ \\\ns.t.\\ \\ \\forall i,\\ \\ |x(i)-x(i-1)|\\leq 1\n$$\n竖直接缝：\n$$\n\\pmb{s^y}=\\{s_i^y\\}_{j=1}^m=\\{(j, y(j))\\}_{j=1}^m,\\ \\\ns.t.\\ \\ \\forall j,\\ \\ |y(j)-y(j-1)|\\leq 1\n$$\n其中，$x:[1,\\cdots,n]\\rightarrow[1,\\cdots,m]$，$y:[1,\\cdots,m]\\rightarrow[1,\\cdots,n]$\n而我们要寻找最低能量路径即求解最小优化问题：\n$$\ns^\\ast=\\min_{\\pmb s}E(\\pmb s)=\\min_{\\pmb s}\\sum_{i=1}^ne(\\pmb I(s_i))\n$$\n利用动态规划的思想可以很方便地求出上述优化问题，利用能量累积矩阵$M$，转移方程：\n$$\nM(i,j)=e(i,j)+\\min(M(i-1,j-1), M(i-1,j), M(i-1,j+1))\n$$\n从边缘出发按转移方程填充能量累积矩阵，最后寻找能量最低的终点$M(n,x)$（竖直搜索）或$M(x,m)$（水平搜索），回溯即可得到完整的最优路径。\n1.1. 图像缩小任务 对于单方向缩小任务，只需重复上述接缝搜索流程，每次删除一条接缝即可。\n对于多方向缩小任务，文献中也将横向竖向接缝的选择顺序其视为一个优化问题，假设现有$m\\times n$的图像$\\pmb I$欲缩小至$m'\\times n'$，其中$m\u0026gt;m',n\u0026gt;n'$，接缝顺序的选择等价于优化以下能量函数：\n$$\n\\min_{\\pmb{s^x},\\pmb{s^y},\\alpha}\\sum_{i=1}^kE(\\alpha_i\\pmb {s_i^x}+(1-\\alpha_i)\\pmb{s_i^y})\n$$\n其中，$r=m-m'$，$c=n-n'$， $\\alpha_i\\in{0,1}$描述了接缝选择的方向，因此有$\\sum_{i=1}^k\\alpha_i=r$，$\\sum_{i=1}^k(1-\\alpha_i)=c$成立。该问题同样可以利用动态规划的想法进行求解，取能量累积矩阵$\\pmb T$，满足$\\pmb T(0,0)=0$，转移方程：\n$$\n\\pmb T(r,c)=\\min(\\pmb T(r-1,c),E(\\pmb s^x(\\pmb {I_{n-r-1\\times m-c}})),\\pmb T(r,c-1),E(\\pmb s^y(\\pmb {I_{n-r\\times m-c-1}})))\n$$\n$\\pmb {I_{n-r-1\\times m-c}}$表示大小为$n-r-1\\times m-c$的图像（中间量），$E(\\pmb{s^x}(\\pmb I))$和$E(\\pmb{s^y}(\\pmb I))$为相应的方向接缝删除后的能量。\n但上述方法实测速度很慢，因此在实现中选择简单的贪婪策略选择带来当前最低能量的方法。\n1.2. 图像拉伸任务 对于图像拉伸任务，同样可以采用缩小任务相似的处理方法，只是将最优接缝的删除修改为最优接缝邻域的插值，但和缩小任务不同的是，每次对单条最优接缝进行插值，容易导致后续的最优接缝\n搜索会集中在同一区域，因此在图像拉伸任务中，建议一次性选择多条低能量接缝进行插值。\n2. 实验结果 2.1. 图像缩小    原图像 图像能量 结果图像                     2.2. 图像拉伸    原图像 图像能量 最优接缝 结果图像                        3. 总结 从上图中可以看出 Seam Carving 的一些局限性：\n 进行图像拉伸任务时容易造成图像区块重复，可以考虑手动排除部分区域进行优化 在梯度变化不明显的“重要区域”容易造成误处理，比如：《蒙娜丽莎》大片的头发。可以考虑手动划分“重要区域”进行处理  参考文献 [1] S. Avidan and A. Shamir. Seam carving for content-aware image resizing. In ACM SIGGRAPH 2007 papers, pages 10–es. 2007\n","description":"复现Siggraph2007论文《Seam Carving for Content-Aware Image Resizing》","id":16,"section":"posts","tags":["Digital Image Process"],"title":"Seam Carving","uri":"https://chaphlagical.github.io/zh/posts/image_process/seam_carving/"},{"content":"1. 问题描述 给定以下两幅图：\n现我们需要将第一幅图中的女孩搬到第二幅图的海水中，为使得复制粘贴更加逼真自然，我们需要设计算法来满足我们两幅图像融合的需要\n2. 算法描述 Poisson Image Editing算法[1]的基本思想是在尽可能保持原图像内部梯度的前提下，让粘贴后图像的边界值与新的背景图相同，以实现无缝粘贴的效果。从数学上讲，对于原图像$f(x,y)$，新背景$f^(x,y)$和嵌入新背景后的新图像$v(x,y)$，等价于解最优化问题：\n$$\n\\min\\limits_f \\iint \\Omega |\\nabla f-\\boldsymbol v |^2 \\ \\ \\mathrm{with}\\ f|{\\partial \\Omega}=f^|_{\\partial \\Omega}\n$$\n利用变分法，令$F=|\\nabla f-\\boldsymbol v |^2=(\\nabla f_x-\\boldsymbol v_x)^2+(\\nabla f_y-\\boldsymbol v_y)^2$\n代入欧拉-拉格朗日方程：\n$$\nF_f-\\frac{\\mathrm d}{\\mathrm d x}F_{f_x}-\\frac{\\mathrm d}{\\mathrm d y}F_{f_y}=0\n$$\n由于$F$是关于$\\nabla f$的函数，因此$F_f=0$\n所以有：\n$$\n\\begin{align}\n\u0026amp;\\frac{\\partial F}{\\partial f}=\\frac{\\mathrm d}{\\mathrm dx}\\left[\\frac{\\partial F}{\\partial(\\nabla f_x-\\pmb v_x)^2}\\right]+\\frac{\\mathrm d}{\\mathrm dy}\\left[\\frac{\\partial F}{\\partial(\\nabla f_y-\\pmb v_y)^2}\\right]\\\\\\\\\n\u0026amp;\\Rightarrow 0=\\frac{\\mathrm d}{\\mathrm dx}[2(\\nabla f_x-\\pmb v_x)]+\n\\frac{\\mathrm d}{\\mathrm dy}[2(\\nabla f_y-\\pmb v_y)]\\\\\\\\\n\u0026amp;\\Rightarrow 0=\\left(\\frac{\\partial ^2f}{\\partial x^2}-\\frac{\\partial \\pmb v}{\\partial x}\\right)+\\left(\\frac{\\partial ^2f}{\\partial y^2}-\\frac{\\partial \\pmb v}{\\partial y}\\right)\\\\\\\\\n\u0026amp;\\Rightarrow \\Delta f=\\mathrm{div}\\pmb v\n\\end{align}\n$$\n可转化为具有Dirichlet边界条件的Poisson方程：\n$$\n\\Delta f= \\mathrm{div} \\boldsymbol v\\ \\ \\mathrm{over}\\ \\Omega\\ \\ \\mathrm{with} \\ \\ f|_{\\partial \\Omega}=f^\\ast|_{\\partial\\Omega}\n$$\n以第一幅图和第二幅图为例，将图1中需要复制的区域设为$S$，定义$N_p$为$S$中的每一个像素$p$四个方向连接邻域，令$\u0026lt;p,q\u0026gt;$为满足$q\\in N_p$的像素对。边界$\\Omega$定义为$\\partial \\Omega ={p\\in S\\setminus \\Omega: N_p \\cap \\Omega \\neq \\emptyset }$，设$f_p$为$p$处的像素值$f$，目标即求解像素值集$f|_\\Omega ={f_p,p\\in \\Omega}$\n利用Poisson Image Editing算法的基本原理，上述问题转化为求解最优化问题：\n$$\n\\min\\limits_{f|_\\Omega}\\sum\\limits_{\u0026lt;p,q\u0026gt;\\cap \\Omega\\neq \\emptyset}(f_p-f_q-v_{pq})^2,\\mathrm{with}\\ f_p=f_p^*,\\forall\\ p\\in \\partial\\Omega\r$$\n化为求解线性方程组：\n$$\n\\forall\\ p\\in \\Omega,\\ |N_p|f_p-\\sum\\limits_{q\\in N_p\\cap \\Omega} f_q=\\sum\\limits_{q\\in N_p\\cap \\partial \\Omega}f_p^*+\\sum\\limits_{q\\in N_p}v_{pq}\n$$\n对于梯度场$\\boldsymbol{v}(\\boldsymbol{x})$的选择，文献[1]给出两种方法，一种是完全使用前景图像的内部梯度，即：\n$$\n\\forall\\ \u0026lt;p,q\u0026gt;,v_{pq}=g_p-g_q\n$$\n另一种是使用混合梯度：\n$$\n\\forall\\ \\boldsymbol{x}\\in \\Omega,\\ \\boldsymbol{v}(\\boldsymbol{x})=\\begin{cases}\n\\nabla f^*(\\boldsymbol{x})\u0026amp;\\mathrm{if}\\ |\\nabla f^*(\\boldsymbol{x})\u0026gt;|\\nabla g(\\boldsymbol{x})|,\\\\\\\\\n\\nabla g(\\boldsymbol{x})\u0026amp;\\mathrm{otherwise}\n\\end{cases} $$\n**扫描线算法**\n为实现多边形和自由绘制闭合图形区域的Poisson Image Editing算法，需通过扫描线算法获取多边形内部掩膜。这里从网上资料了解到一种有序边表法，其基本思想是定义边表ET和活动边表AET，ET记录当前扫描线与边的交点坐标、从当前扫描线到下一条扫描线间x的增量、该边所交的最高扫描线，AET记录只与当前扫描线相交的边的链表，通过迭代得到当前扫描线与待求多边形各边的交点，再利用奇偶检测法判断该点是否在多边形内部进行填充。\n3. 实验结果 3.1. 标准图像测试 原图像：\n新背景图像：\n   边界形式 图1选择区域 图2选择区域 结果图像     矩形边界      多边形边界      自由绘制边界       3.2. Poisson vs. Mix Poisson 背景图像：\n前景图像：\n混合结果：\n如图，左上为直接复制粘贴，保留前景全部颜色梯度信息；左下为普通Poisson编辑，保留前景全部梯度信息，前景像素颜色与背景作融合；右上为应用混合梯度的Poisson编辑，前景梯度部分保留，效果上比普通Poisson编辑更加“透明”，适合用在水印等场景。\n3.3. 其他应用 3.3.1. 遮盖不必要的信息（如去皱纹） 原图像：\n处理效果：\n3.3.2. 恐怖片特效 原图：\n掩盖镜子中人物：\n使用电影《修女》中的角色：\n处理效果：\n3.3.3. 生成表情包 原图：\n处理效果：\n参考文献 [1] Patrick Pérez, Michel Gangnet, Andrew Blake. Poisson image editing. Siggraph 2003.\n","description":"复现Siggraph2003论文《Poisson Image Editing》","id":17,"section":"posts","tags":["Digital Image Process"],"title":"Poisson Image Editing","uri":"https://chaphlagical.github.io/zh/posts/image_process/possion/"},{"content":"1. 算法原理 1.1. 基本原理  输入：$n$对控制点对$(\\pmb p_i,\\pmb q_i)$，$i=1,2,\\cdots,n$，其中$\\pmb p_i\\in\\mathbb R^2$为控制起始点，$\\pmb q_i\\in\\mathbb{R}^2$为控制目标点 目标：找到一个映射$f:\\mathbb R^2\\rightarrow \\mathbb{R}^2$，满足$f(\\pmb p_i)=\\pmb q_i$，$i=1,2,\\cdots,n$  1.2. Inverse distance-weighted interpolation methods(IDW)[1] IDW 算法基本原理是根据给定的控制点对和控制点对的位移矢量，计算控制点对周围像素的反距离加权权重影响，实现图像每一个像素点的位移。\n选择$n$对控制点对$(\\pmb p_i,\\pmb q_i)$，$i=1,2,\\cdots,n$，目标映射$f:\\mathbb R^2\\rightarrow \\mathbb{R}^2$可表示成\n以下形式：\n$$\nf(\\pmb p)=\\sum_{i=1}^n\\omega_i(\\pmb p)f_i(\\pmb p)\n$$\n其中，权重$\\omega_i(\\pmb p)$满足：\n$$\nw_i(\\pmb p)=\\frac{\\sigma_i(\\pmb p)}{\\sum_{j=1}^n\\sigma_j(\\pmb p)}\n$$\n$\\sigma_i(\\pmb p)$反映第$i$对控制点对像素$\\pmb p$得反距离加权权重影响程度，可以直接取：\n$$\n\\sigma_i(\\pmb p)=\\frac{1}{|\\pmb p-\\pmb p_i|^\\mu}\n$$\n其中$\\mu\u0026gt;1$，也可以取locally bounded weight：\n$$\n\\sigma_i(\\pmb p)=\\left[\\frac{R_i-d(\\pmb p,\\pmb p_i)}{R_id(\\pmb p,\\pmb p_i)}\\right]^\\mu\n$$\n$f_i$为线性函数，满足：\n$$\nf_i(\\pmb p)=\\pmb q_i+\\pmb T_i(\\pmb p-\\pmb p_i)\n$$\n其中$\\pmb T_i$为二阶矩阵：\n$$\n\\pmb T_i=\\begin{bmatrix}\nt_{11}^{(i)}\u0026amp;t_{12}^{(i)}\\\\\nt_{21}^{(i)}\u0026amp;t_{22}^{(i)}\n\\end{bmatrix}\n$$\n矩阵$\\pmb T$得确定，可以通过求解如下最优化问题：\n$$\n\\arg\\min_{\\pmb T_i} E(\\pmb T_i)=\\sum_{j=1,j\\neq i}^n\\sigma_i(\\pmb p_j)|\\pmb q_j-f_i(\\pmb p_j)|^2\n$$\n上式对$\\pmb T_i$求导，令方程为0得：\n$$\n\\pmb T_i\\sum_{j=1,j\\neq i}\\sigma_i(\\pmb p_j)\\pmb p\\pmb p^T=\\sum_{j=1,j\\neq i}\\sigma_i(\\pmb p_j)\\pmb q\\pmb p^T\n$$\n其中$\\pmb p=\\pmb p_j-\\pmb p_i$，$\\pmb q=\\pmb q_j-\\pmb q_i$\n又$\\sigma_i(\\pmb p_j)\\pmb p\\pmb p^T$非奇异，因此可以直接解出$\\pmb T_i$的值：\n$$\n\\pmb T_i=\\left(\\sum_{j=1,j\\neq i}\\sigma_i(\\pmb p_j)\\pmb q\\pmb p^T\\right)\\left(\\sum_{j=1,j\\neq i}\\sigma_i(\\pmb p_j)\\pmb p\\pmb p^T\\right)^{-1}\n$$\n求出$\\pmb T_i(i=1,\\cdots,n)$后，映射$f$也就相应确定\n1.3. Radial basis functions interpolation method(RBF)[2] 选择$n$对控制点对$(\\pmb p_i,\\pmb q_i)$，$i=1,2,\\cdots,n$，目标映射$f:\\mathbb R^2\\rightarrow \\mathbb{R}^2$可表示为以下形式：\n$$\nf(\\pmb p)=\\sum_{i=1}^n\\alpha_ig_i(|\\pmb p-\\pmb p_i|)+\\pmb{Ap}+\\pmb B\n$$\n其中，$g_i$为径向基函数，通常可以取Hardy multiquadrics：$g(t)=(t^2+c^2)^{\\pm \\frac{1}{2}}$或高斯函数$g_\\sigma(t)=e^{-t^2/\\sigma^2}$，\n为了计算方便，这里取Hardy multiquadrics：\n$$\n\\begin{aligned}\ng_i(d)\u0026amp;=(d+r_i)^{\\pm\\frac{1}{2}}\\\nr_i\u0026amp;=\\min_{j\\neq i}d(\\pmb p_i,\\pmb p_j)\n\\end{aligned}\n$$\n对于线性部分分量$\\pmb {Ap}+\\pmb B$，本例简单地取$\\pmb A=\\pmb I$和$\\pmb B=\\pmb 0$\n2. 实验结果 2.1. 标准图像测试 如下图所示，固定四角，蓝色为控制起始点，绿色为控制终止。\n2.2. IDW算法    $\\mu$取值 修复前 修复后     $\\mu=-1$     $\\mu=-2$      2.3. RBF算法    $\\mu$取值 修复前 修复后     $\\mu=-0.5$     $\\mu=0.5$      2.4. 相关应用 2.4.1. 柴犬表情包 原图像：\n开心：\nEmmm……：\n2.4.2. 藏狐的笑容 原图像：\n处理后：\n参考文献 [1] D. Ruprecht and H. Muller. Image warping with scattered data interpolation. IEEE Computer Graphics and Applications, 15(2):37–43, 1995. 10\n[2] N. Arad and D. Reisfeld. Image warping using few anchor points and radial functions. In Computer graphics forum, volume 14, pages 35–46. Wiley Online Library, 1995.\n","description":"基于IDW与RBF方法的图像扭曲算法实现","id":18,"section":"posts","tags":["Digital Image Process"],"title":"Image Warping","uri":"https://chaphlagical.github.io/zh/posts/image_process/image_warping/"},{"content":"1. 问题描述 给定一张原图像：\n和一张参考图像：\n我们希望通过设计一个颜色转换算法，使得源图像具有目标图像的颜色风格，如下图：\n2. 算法描述 衡量一幅图像的颜色分布最基础的统计特征就是均值和标准差，文献[1]中便通过这两个特征对图像进行简单的变换并取得不错的效果。\n首先，需要将图像的颜色空间从$RGB$空间变换到$l\\alpha\\beta$空间：\n  $RGB$空间$\\rightarrow$ $XYZ$空间\n$$\n\\begin{pmatrix}\nX\\\\Y\\\\Z\n\\end{pmatrix}=\n\\begin{pmatrix}\n0.5141\u0026amp;0.3239\u0026amp;0.1604\\\\\n0.2651\u0026amp;0.6702\u0026amp;0.0641\\\\\n0.0241\u0026amp;0.1228\u0026amp;0.8444\n\\end{pmatrix}\n\\begin{pmatrix}\nR\\\\G\\\\B\n\\end{pmatrix}\n$$\n  $XYZ$空间$\\rightarrow$ $LMS$空间\n$$\n\\begin{pmatrix}\nL\\\\M\\\\S\n\\end{pmatrix}=\n\\begin{pmatrix}\n0.3897\u0026amp;0.6890\u0026amp;-0.0787\\\\\n-0.2298\u0026amp;1.1834\u0026amp;0.0464\\\\\n0.0000\u0026amp;0.0000\u0026amp;1.0000\n\\end{pmatrix}\n\\begin{pmatrix}\nX\\\\Y\\\\Z\n\\end{pmatrix}\n$$\n  变换到对数空间\n$$\n\\begin{aligned}\n\\pmb L\u0026amp;=\\lg L\\\\\n\\pmb M\u0026amp;=\\lg M\\\\\n\\pmb S\u0026amp;=\\lg S\n\\end{aligned}\n$$\n  $\\pmb{LMS}$空间$\\rightarrow$ $l\\alpha\\beta$空间\n$$\n\\begin{pmatrix}\nl\\\\\\alpha\\\\\\beta\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\frac{1}{\\sqrt{3}}\u0026amp;0\u0026amp;0\\\\\n0\u0026amp;\\frac{1}{\\sqrt{6}}\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;\\frac{1}{\\sqrt{2}}\n\\end{pmatrix}\n\\begin{pmatrix}\n1\u0026amp;1\u0026amp;1\\\\\n1\u0026amp;1\u0026amp;-2\\\\\n1\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\pmb L\\\\\\pmb M\\\\\\pmb S\n\\end{pmatrix}\n$$\n  同理，将图像的颜色空间从 lαβ 空间变换到 RGB 空间只需将相应的变换矩阵依次求逆即可。\n设变换到$l\\alpha\\beta$颜色空间的源图像的均值和标准差分别为$\\mu_s$、$\\sigma_s$，目标图像的均值和标准差分别为$\\mu_t$、$\\sigma_t$，只需通过如下简单处理，即可将源图像的颜色分布变换到接近与目标图像\n$$\n\\begin{aligned}\nl'\u0026amp;=\\frac{\\sigma_t^l}{\\sigma_s^l}(l-\\mu^l_s)+\\mu^l_t\\\\\n\\alpha'\u0026amp;=\\frac{\\sigma_t^\\alpha}{\\sigma_s^\\alpha}(\\alpha-mu^\\alpha_s)+\\mu^\\alpha_t\\\\\n\\beta'\u0026amp;=\\frac{\\sigma_t^\\beta}{\\sigma_s^\\beta}(\\beta-\\mu^\\beta_s)+\\mu^\\beta_t\\\n\\end{aligned}\n$$\n并将图像$(l',\\alpha',\\beta')$变换回$RGB$空间即可得到处理后的结果。\n3. 实验结果    原图像 参考图像 结果图像                               参考文献 [1] E. Reinhard, M. Adhikhmin, B. Gooch, and P. Shirley. Color transfer between images. IEEE Computer graphics and applications, 21(5):34–41, 2001.10\n","description":"复现论文《Color Transfer between Images》","id":19,"section":"posts","tags":["Digital Image Process"],"title":"Color Transfer","uri":"https://chaphlagical.github.io/zh/posts/image_process/color_transfer/"},{"content":"1. 问题描述 给定一张原图像：\n我们希望通过设计一个灰度图着色算法，使得下述灰度目标图像能够利用彩色原图像的颜色信息进行合理的上色：\n以得到类似下图的效果：\n2. 算法描述 实验参考了论文[1]，并使用全局匹配的方法进行求解。我们在图像的$l\\alpha\\beta$颜色空间上进行求解，这是由于$l\\alpha\\beta$颜色空间的$l$即代表着亮度，通过查找灰度源图像上的像素与彩色目标图像的$l$分量最佳匹配像素，再将目标图像对应匹配像素的$\\alpha$和$\\beta$分量赋予源图像即可\n进行灰度图像上色。算法流程如下：\n  将源图像$img_{src}$变换到$l\\alpha\\beta$颜色空间得到$img_{src}^{(l\\alpha\\beta)}$，同时将源图像$img_{src}$转换为灰度图$img_{src}^{(grey)}$\n  利用如下均值标准差变换，将$img_{src}^{(l\\alpha\\beta)}$的$l$通道和$img_{src}^{(grey)}$映射到具有灰度目标图像$img_{tar}$的像素值分布，得到$luminance_{src}$和$luminance_{src}^{grey}$\n$$\n\\begin{aligned}\nl'\u0026amp;=\\frac{\\sigma_t^l}{\\sigma_s^l}(l-\\mu^l_s)+\\mu^l_t\\\\\n\\alpha'\u0026amp;=\\frac{\\sigma_t^\\alpha}{\\sigma_s^\\alpha}(\\alpha-\\mu^\\alpha_s)+\\mu^\\alpha_t\\\\\n\\beta'\u0026amp;=\\frac{\\sigma_t^\\beta}{\\sigma_s^\\beta}(\\beta-\\mu^\\beta_s)+\\mu^\\beta_t\\\\\n\\end{aligned}\n$$\n  近邻域标准差计算。利用一个$n\\times n$（本实验中取$n=5)$）滑动窗口遍历图像（类似于卷积操作，边界用0填充），对窗口内的所有像素值计算它们的标准差并赋值到一幅标准差图像上。对$luminance_{src}^{grey}$和$img_{tar}$进行该计算，得到$stddev_{src}^{grey}$和$stddev_{tar}$\n  最佳匹配查找。遍历$img_{tar}$，已知$img_{tar}$上的某一像素值$p_{tar}$和其标准差$stddev_{tar}$对应的值$\\sigma_{tar}$，在源图像上寻找最佳匹配的像素点，这里简单地采用加权的$\\mathcal{L}_2$范数平方去算：\n$$\n\\arg\\min_{x,y} \\Big(w_1\\ast |luminance_{src}(x,y)-p_{tar}|^2+w_2\\ast|stddev_{src}^{grey}(x,y)-\\sigma_{tar}|^2\\Big)\n$$\n其中$w_1$和$w_2$分别表示亮度值和标准差的对匹配结果的贡献，这里简单地取$w_1=w_2=0.5$\n  灰度图上色。将查找到的最佳匹配像素$(\\tilde x. \\tilde y)$在$img_{src}^{(l\\alpha\\beta)}$所在像素值的$\\alpha$和$\\beta$分量赋值给源图像作为其$\\alpha$和$\\beta$通道的值，而原来的灰度值则作为$l$分量继续使用，并将源图像重新变换回$RGB$颜色空间得到最终的结果\n  3. 实验结果    原图像 参考图像 结果图像                               参考文献 [1] Welsh, M. Ashikhmin, and K. Mueller. Transferring color to greyscale im-ages. In Proceedings of the 29th annual conference on Computer graphics and interactive techniques, pages 277–280, 2002.11\n","description":"复现Siggraph2002论文《Transferring Color To Greyscale Image》","id":20,"section":"posts","tags":["Digital Image Process"],"title":"Colorization","uri":"https://chaphlagical.github.io/zh/posts/image_process/colorization/"},{"content":"1. 概述 1.1. 计算机的发展简史 1.1.1. 计算机的诞生  布莱兹·帕斯卡(Blaise Pasca)：基于齿轮结构的机械加减法器 莱布尼茨(Gottfried Wilhelm Leibniz)：可进行乘法、除法和自乘运算的机械计算器 查尔斯·巴贝奇(Charles Babbage)：基于齿轮结构的差分机和分析机 阿兰·图灵(Alan Turing)：图灵机 莫克利(John Mauchly)、艾克特(Eckert)团队：ENIAC(电子数字积分器和计算器)  世界上第一台数字式电子计算机   冯诺依曼(Von Neumanm)：EDVAC(离散变量自动电子计算机)  确定计算机五个构成部分：运算器，控制器，存储器，输入设备，输出设备 三方面重大改进  二进制 存储程序 程序执行顺序可通过“条件转移”指令自动完成     莫里斯·威尔克斯(Maurice Wilkes)：EDSAC  第一台存储程序式电子计算机    1.1.2. 现代计算机发展历程  第一阶段： 电子管阶段 (1946至20世纪50年代中期)  计算机体积庞大，功耗大，可靠性低，售价昂贵 主要用在重要场合的科学计算和数据处理   第二阶段： 晶体管时代 (1955至20世纪六十年代中期)  内存采用磁芯，外存采用磁带或磁鼓，减小体积，降低功耗，提高可靠性，降低成本 运算速度提高，出现了高级程序设计语言(FORTRAN, Algol)，计算机开始进入工业过程控制领域   第三阶段： 集成电路时代 (1965至20世纪七十年代初期)  计算机体积进一步减小，可靠性进一步提高，成本进一步降低，速度大大提高(IBM 360系列计算机) 操作系统逐渐成熟，应用扩大   第四阶段： LSI \u0026amp; VLSI时 (1972~1990)  LSI和VLSI得到广泛使用，内存普遍采用半导体存储器，外存采用磁盘、磁带和光盘 体积进一步缩小，性能和可靠性进一步提高，成本进一步降低 应用日益广泛，PC机成为办公和娱乐设备   第五阶段： ULSI \u0026amp; GSI时代 (1991年至今)  流水线、超标量、多线程、多内核、多CPU和新型高速总线技术使得普通PC机的速度可达每秒数十亿次 更加注重多媒体信息和并行数据处理能力 单片机和嵌入式系统性能不断提高，应用领域不断扩大 现代计算机是云计算、大数据、物联网、移动互联网和人工智能等技术发展的最重要基础    1.1.3. 计算机的类型   微型计算机\n 台式计算机 个人工作站 笔记本电脑 平板电脑    服务器\n具有较强大计算能力，可通过网络为大量用户提供计算、信息处理和数据存储服务，用于大型企事业单位和政府机构的信息处理服务。可分为：\n 采用Unix操作系统的小型机（服务器）  具有高可靠性和高可用性，数据处理能力较强 多为基于RISC架构的国外品牌   采用Intel架构的x86服务器  支持Linux或者微软视窗操作系统 出色的性价比，国产化程度高      嵌入式计算机\n 集成到应用对象中的专用计算机，以自动监测与控制应用对象的物理过程 服务与特定目的，不属于通用计算机 典型应用：工业自动化、智能家居、通信设备、数码产品、交通工具、安防、军工等    超级计算机\n 提供最高的计算性能，最昂贵、物理上最大型的计算机 广泛用于复杂过程仿真等科学计算领域    1.2. 计算机系统的组成 计算机硬件： 构成计算机的物理部件\n计算机软件： 按特定顺序组织的指令和数据集合\n1.2.1. 计算机硬件 1.2.1.1. 存储器 主存储器\n 简称主存或内存，由半导体材料构成，每个单元存储1位二进制信息，单位为1个比特(bit) 8bit组成1个字节(Byte) 字节是存储器存储和读取数据的基本单位，每个字节都有唯一的物理地址(PA) 若干字节构成一个字，每个字所包含的位数称为计算机的字长 典型的字长有16位、32位和64位  辅助存储器\n 主存特点：读写速度相对较快，价格高、容量受限、掉电后RAM存储的信息消失 辅存特点：读写速度慢，价格低，容量大、具有非易失性，又称为外存 常见外存包括：  基于磁介质极化的磁盘和磁带 基于表面几何微观形状的光盘 (CD, DVD, BD) 基于半导体的闪存    1.2.1.2. 运算器  主要功能： 完成各种数据运算和处理 核心构成： 算术逻辑单元ALU和寄存器阵列 ALU：在控制信号的作用下完成任意的算术或逻辑运算 (加、减、乘、除、移位或比较大小等) 寄存器： 运算器内部的高速存储单元，访问速度最快  受芯片面积限制，寄存器的数量不会很多 运算器工作时，需要处理的数据（操作数）先被送到某个寄存器中暂存 运算过程中的临时数据或者处理后的结果也暂存在特定的寄存器中    1.2.1.3. 控制器  计算机的指挥控制中心 主要功能： 根据指令对计算机各部件进行操控，协调各部件有序工作 主要构成：  指令寄存器IR 指令译码器ID 操作控制器OC   VLSI出现后，运算器和控制器被集成到CPU中 CPU与主存是计算机的核心部分  1.2.1.4. 输入设备  主要功能：将信息进行编码后输入计算机 最常见输入设备： 键盘和鼠标 用于人机交互的输入设备：  触摸屏、操纵杆、轨迹球、麦克风、游戏机手柄……   其他输入设备  扫描仪、证件读卡器、摄像头等    1.2.1.5. 输入设备  主要功能： 向外界输出计算机处理后的结果 有些兼具输入和输出功能，如触摸屏和计算机通信设备，简称I/O设备，外存也可以看作是一种I/O设备 特点： 种类繁多、信息格式各异、速度快慢不一 慢速设备：打印机、绘图机、扬声器、…… 高速设备：外存、数据通信设备、超高清显示器、数字波形合成器、……  1.2.1.6. 适配器  主要功能： 在计算机与和外设之间进行桥接和匹配，解决种类繁多、速度快慢不一、信息编码格式各异的输入输出设备的互连问题  数据缓冲，解决速度不匹配问题 信息转换，解决编码格式不同的问题 电平转换，解决电平不一致问题 状态监测，收发双方的相互沟通 时序控制，协调外设和主机并行工作   适配器又称I/O接口 多个不同种类的外设，需要多个接口 常见的外设接口：并行接口、I^2^C接口、串行接口和USB接口  1.2.1.7. 总线  主要功能： 实现各部件之间的信息传输和交换 按用途分三类：  数据总线DB：双向 地址总线AB：单向 控制总线CB：有些单向有些双向    1.2.2. 计算机软件 1.2.2.1. 计算机软件分类 按特定顺序组织的计算机数据和指令的集合，可分为：\n系统软件\n 控制和管理计算机工作并且无需用户干预的各种程序集合。主要功能是调度、监控和维护计算机运行，管理各种部件，协调各种资源 系统软件的核心是操作系统，负责管理硬件与软件资源、控制I/O设备和网络、维护文件系统、提供用户接口UI  应用软件\n 利用计算机解决特定问题而编程开发的各种程序  中间件软件\n 处于计算机系统软件与用户应用软件之间，是分布式应用系统的基础软件 为上层应用软件提供开发、集成和运行环境，并实现应用软件之间的互操作 通过网络通信功能解决分布式环境下数据传输、数据访问、应用调度、系统构建、系统集成和流程管理等问题，是分布式环境下支撑应用开发、运行和集成的平台 核心思想：抽取分布式系统对于数据传输、信息系统构建与集成等问题的共性要求，封装共性问题的解决方法，对外提供简单统一的接口，从而减少系统开发难度，优化系统结构和提高系统的开发效率  1.2.2.2. 计算机软件的发展  第一代 1846~1953  机器语言 汇编语言   第二代 1954~1964  算法语言 Fortran LISP ALGOL BASIC   第三代 1965~1970  多用户多任务操作系统 数据库技术 软件工程   第四代 1971~1989  结构化程序设计思想 PASCAL C语言 多媒体技术   第五代 1990~至今  GUI和OA软件 面向对象技术 万维网 分布式架构 API 软件定义一切    1.3. 计算机中数的表示方法 1.3.1. 进位计数制 10进制\n 后缀为D 基数为10  $$\n456D=456=4\\times 10^2+5\\times10^1+6\\times 10^0\n$$\n二进制\n 后缀为B 基数为2  $$\n10110B=1\\times2^4+0\\times2^3+1\\times2^2+1\\times2^1+0\\times2^0 $$\n16进制 (两位16进制表示1字节)\n 后缀为H或h 基数为16 $0\\sim 15,\\ 0123456789ABCDEF$  $$\n32AEh=3\\times16^3+2\\times16^2+10\\times16^1+14\\times16^0\n$$\n位、字节、字和字长\n 位=比特，计算机存储数据的最小单位 字节Byte，用B表示，一个字节=8个二进制位 (1 Byte=8 bit)，字节是计算机存储和读取数据的基本单位 字：计算机进行数据处理时一次存取、加工和传送的数据长度，一个字=多个字节 n 位计算机的字长为n bit (位)  1.3.2. 有符号数的原码、反码和补码表示 原码\n  约定： 数值$x$的原码记为$_原$，若机器（处理器）字长为$n$位，那么数值$x$的原码定义为：\n$$\n_原=\n\\begin{align}\n\\begin{cases}\nx\u0026amp;0\\leq x\\leq 2^{n-1}-1\\\\\\\\\n2^{n-1}+|x|\u0026amp;-(2^{n-1}-1)\\leq x\\leq 0\n\\end{cases}\n\\end{align}\n$$\n  最高位为符号位：0为正数，1为负数，其余为绝对值\n  n bit原码可表示的数值范围是：$-(2^{n-1}-1)\\sim 2^{n-1}-1$\n  例：8位有符号二进制数：\n$$\n\\begin{align}\n0000\\ 0001\\to +1\\ \\ \u0026amp; \\ \\ 0111\\ 1111\\to +127\\\\\n1000\\ 0001\\to -1\\ \\ \u0026amp; \\ \\ 1111\\ 1111\\to -127\\\\\n0000\\ 0000\\to +0\\ \\ \u0026amp; \\ \\ 1000\\ 0000\\to -0\n\\end{align}\n$$\n  原码表示的0有正负之分，习惯上将0用+0表示\n  原码存在的问题：原码表示的有符号数在运算时会出现错误 (原因：在运算过程中，符号位也参与了运算)\n  反码\n  约定：数值$x$的反码记为$_反$，若机器（处理器）字长为$n$位，那么数值$x$的反码定义为：\n$$\n_反=\n\\begin{cases}\nx\u0026amp;0\\leq x\\leq 2^{n-1}-1\\\\\n(2^n-1)-|x|\u0026amp;-(2^{n-1}-1)\\leq x\\leq 0\n\\end{cases}\n$$\n  n bit反码可表示的数值范围为：$-(2^{n-1}-1)\\sim 2^{n-1}-1$\n  整数的反码与原码相同；负数的反码符号位为1，其余各位与原码相反\n  反码表示的0有正负之分，习惯上将0用+0表示\n  使用反码表示数据，在运算时符号位也参与运算，故计算机未采用反码\n  补码\n  约定：数值$x$的补码记为$_补$，若机器（处理器）字长为$n$位，那么数值$x$的补码定义如下：\n$$\n_补=\\begin{cases}x\u0026amp;0\\leq 2^{n-1}-1\\\\2^n-|x|\u0026amp;-2^{n-1}\\leq x\\leq 0 \\end{cases}\n$$\n  正数的补码与原码完全相同\n  负数的补码用模$2^n$的补数$2^n-|x|$的二进制编码表示\n 求一个负数的补码时，可先求出该负数的反码，然后加1即可 另一种方法，求负数绝对值的原码，然后从低位向高位扫描，将遇到的首个1以及之前的0保持不变，对之后的各位按位取反    补码运算\n  对于有符号数$p$和$q$有：\n$$\n\\begin{align}\n[p+q]_补\u0026amp;=[p]_补+[q]_补\\\\ [p-q]_补\u0026amp;=[p]_补-[q]_补=[p]_补+[-q]_补\n\\end{align}\n$$\n  采用补码运算的前提：结果不能发生溢出（结果超出了补码所能表示的范围）\n  结论：若记符号位向前进位为CP，次高位向前进位为CF，当且仅当$CP\\bigoplus CF=1$时，结果发生溢出\n  推论：\n 若参加运算的二进制数被看成无符号数，没有符号位，加减运算结果可能会有进位或借位，没有溢出问题 若参加运算的二进制数被看成有符号数，运算结果受到最大表示范围的限制，超出则出现溢出，结果错误 有符号数运算必须判断是否出现溢出，如果出现溢出只能重新设计算法      1.3.3. 定点数和浮点数   定点数：采用定点格式表示的数据，能够表示的数值范围较小，所需的硬件电路较简单\n 定点格式：小数点位置固定不变，无需再用符号表示 现代计算机中多采用定点纯整数，定点数称为整数    浮点数：采用浮点格式表示的数据，可以表示的数值范围很大，所需的硬件电路较复杂\n  浮点格式：有效数字和数值范围（比例因子）分别表示，小数点位置将随比例因子不同在一定范围内浮动\n  任意一个二进制数$N$也可以表示为：$N=M\\times 2^e$\n $M$—浮点数尾数，$e$—浮点数阶码    IEEE-754规定的浮点数格式\n    1.3.4. 其他信息编码 BCD编码\n  4位二进制表示1位十进制数，最常用的是8421 BCD码，简称BCD码\n  例如：10进制数135，其BCD码位0001 0011 0101\n  计算机以字节为基本存储单位，有两种BCD码表示方法\n 压缩BCD码：一个字节表示2位十进制数  例如：十进制数89D的压缩BCD码为：1000 1001B   非压缩BCD码：一个字节仅用来表示一位BCD码，其中低4位表示0~9，高4位为0  例如：十进制数89D的非压缩BCD码需要使用两个字节：0000 1000B和0000 1001B      存在的问题\n  每4位二进制数可以表示成16种状态，但是BCD码只使用其中的10个，二进制数状态空间利用率低\n  计算机对数据运算均按照二进制运算规则将带来问题\n  例如：7+5用非压缩BCD码计算\n$0000\\ 0111b+0000\\ 0101b=0000\\ 1100b(\\neq 12D=0001\\ 0010b)$\n  错误原因：使用二进制运算法则计算BCD码\n  解决方法：BCD码运算后必须对结果进行调整\n      ASCII码——美国信息交换标准代码\n ASCII等同于国际标准的7单位制IRA码  用于给西文字符编码，由7位二进制数组合而成，可以表示128种字符 在ASCII码中，按其作用可分为  34个控制字符 10个阿拉伯数字 52个英文大小写字母 32个专用符号      字符串表示方法\n  字符串：一串连续字符，在内存中占用连续多个字节，每个字节存放一个字符\n  字长为多字节的计算机，一个字可存放多个字符\n  不同类型的计算机，一个字有两种字符存放顺序\n 第一种：从高位字节向低位字节顺序存放 第二种：从低位字节向高位字节顺序存放    1.4. 嵌入式系统简介 1.4.1. 嵌入式系统的基本概念  Embedded System：嵌入式计算机系统的简称 IEEE定义：嵌入式系统是用于控制、监视或者辅助设备、机器和车间运行的装置 中国大陆定义：以应用为中心、以计算机技术为基础，软件硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统 三个特点：嵌入性、专用性和计算机系统 嵌入性的两层含义：  本系统是嵌入另一个目标大系统中，成为目标系统的一个组成部分，并为实现目标系统的功能提供特定服务 提供特定服务的软件代码也嵌入目标系统中    1.4.2. 嵌入式系统的硬件  主要包括：  嵌入式微处理器（核心）  有MPU，MCU，DSP和SOC之分   存储器（外存多采用半导体非易失存储器，如flash） 嵌入式外围设备 I/O接口    嵌入式微处理器 (EMPU)\n 原理和功能和通用微处理器相同 MPU没有存储器和外设接口 (MPU的特征)  使用MPU构建嵌入式系统需要外接存储器和I/O接口芯片 如果所有器件安装在一块主板上—单板机 单板机特点：  与传统工控机相比，集成度高、成本低、功耗小和可靠性高 板上芯片、总线、结构呈裸露状态，技术保密性差      嵌入式微控制器 (EMCU)\n 将计算机的主要部件，如ROM、RAM、总线控制逻辑和中断控制器，以及可能需要的定时/计数器，并/串接口、看门狗、ADC和DAC等集成在一块芯片上，构成一个功能相对完整的计算机系统，又称为单片机 特点：集成度高，产品开发周期短，成本低廉，功能丰富，功耗小和可靠性高  数字信号处理器 (DSP)\n 通过内部硬件电路和专门的DSP指令，快速实现各种高强度数字信号处理，广泛用于数字滤波、信号特征分析、电子对抗、音视频编/解码等领域 有非嵌入式和嵌入式、定点和浮点之分  非嵌入式：独立的芯片，需要与其他处理器通过总线互连，具有较高的处理能力 嵌入式：作为一个功能部件，被集成到MCP中 定点DSP的运算精度稍差，但是功耗小，成本低 浮点DSP的运算精度高，但是功耗大，成本高    片上系统 (SOC)\n 将一个复杂系统集成在一块硅片上 如果将设计后的系统下载到FPGA上，就形成了SOC的另一种形式SOPC 特点：应用系统集成度高，技术保密性强，功耗低，工作可靠  1.4.3. 嵌入式系统软件 分为嵌入式操作系统和嵌入式应用软件\n 嵌入式操作系统  实时性：在规定的时间内准确地完成应该执行地操作 可靠性：也称为可依赖性或者可信任性 可裁剪：可根据需求进行功能模块配置   应用软件  围绕特定应用需求开发，许多简单应用无需操作系统 复杂应用软件需要嵌入式操作系统支持 逻辑准确、时间确定、运行可靠、减少硬件资源开销    1.4.4. 嵌入式系统的发展概况  第一个嵌入式处理器：Intel 4004 嵌入式系统发展的四个阶段：  以MPU为核心的可编程控制器，无操作系统 以MCU为核心的嵌入式系统，出现了简单的操作系统 32位高性能MCU大量涌现，嵌入式操作系统开始成熟，内核精致，效率高，兼容性较好，可提供文件管理、多任务支持和网络接口等功能 与Internet深度融合，嵌入式系统是物联网的主要基础    1.4.5. 典型嵌入式处理器简介 ARM\n Advanced RISC Machines：全球最大的IP供应商 体系架构版本先后有ARMv1~v8，从v4开始成熟，从v8开始升级到64位，版本号与产品名称之间的关系较为复杂 早期产品：ARM7、ARM9和ARM11等系列 v7版本以后产品名称改用Cortex，有CortexA、M和R三大系列，分别适用不同的应用需求  A系列：Application，高性能处理器 M系列：MCU，针对价格和功耗敏感应用 R系列：RealTime，针对有实时性要求的应用    MIPS\n Microprocessor without Interlocked piped stages：第二大IP供应商 设计理念：强调软硬件协同提高性能，简化硬件设计 嵌入式处理器非常小巧  2. 计算机系统的基本结构与工作原理 2.1. 计算机系统的基本结构与组成 2.1.1. 计算机的层次模型 分层目的：分析计算机各个部件之间的逻辑关系\n层次模型发展历程：\n  最初阶段：只有两层\n 硬件层：逻辑电路 软件层：指令系统    第二阶段：微程序 vs RISC\n 微程序设计思想 → 三层模型  一条指令可以分解为多个微操作 微操作可以用微指令实现 多条微指令组成微程序实现指令功能 微程序存储在控制ROM中，执行时逐条读出完成微操作     微程序  微程序简化了控制器硬件，并可实现复杂指令 增加新指令，引入新的寻址方式，导致  芯片中的器件数量增加 芯片功耗不断增大 而计算机性能与电路规模不成比例     RISC  二八定律  80%的时间运行的是占总量不到20%的简单指令 80%的任务是由占总量不到20%的电路完成的   为提高性能，应该：  减少指令数量，一条复杂指令用多条简单指令替代 取消微程序，指令功能由硬件电路（硬核）实现        第三阶段：操作系统\n 早期计算机没有操作系统，必须“手工”对计算机进行管理，如任务调度、内存管理、I/O控制等 第一个真正的操作系统：1964年可运行在不同规格的IBM System/360系列大型机的OS/360 操作系统负责管理计算机硬件资源和用户作业，提供了人机交互界面、多条用户命令和多种子程序调用接口，极大简化了计算机操作、管理的复杂性    第四阶段：编程语言\n 使用各种语言编写的程序，必须经过相应的编译（或解释）程序进行处理后，计算机才能识别和执行    2.1.2. 基于冯诺依曼架构的模型机系统结构 结构特点：\n 以CPU为核心（现代计算机逐步转化为以存储器为核心） 单总线系统（类似于快慢车道不分的混合式交通） 指令和数据使用同一条总线（冯诺依曼架构的主要缺陷）  2.2. 模型机存储器子系统 2.2.1. 存储器的组织和地址  每个字节拥有一个独一无二的物理地址（PA），字节是计算机可访问的最小存储单元 字节寻址存储器：按照字节组织存储器，连续地址对应于连续的字节单元（存储器按照字节组织）  如果计算机的字长是8位，总线宽度也为8位，CPU访问存储器时，总线一次可以传送一个字节数据 字节单元地址有n, n+1, n+2, \u0026hellip; 若模型机字长为32位，一个字有4个字节，连续的字被分配到n, n+4, n+8, \u0026hellip;中    计算机的分体结构：\n问题描述：若总线宽度为16位、32位或64位，CPU访问存储器时，为一次能够传输一个完整的字（2/4/8字节），或根据需要一次传送这个字中的一部分字节，应如何组织存储器和连接存储器与总线？\n以32位模型机为例，总容量为2^32^的存储器分成4个存储体，每个存储体为2^30^，分别与32位数据总线按下图连接，每个存储体只需30条地址线，用字节选择信号进行选择\nIntel 8086系统存储器的分体结构\nIntel 8086数据总线位宽为16位，地址总线位宽为20位\n 总容量为1MB的存储系统分成2个512KB的存储体 高位和低位字节存储体分别连接DB的高8位和低8位 $\\overline{BHE}$和$A_0$为存储体选择信号 $\\overline{BHE}$有效（低电平）选中高字节存储体；$A_0=0$选择低字节存储体；都有效同时选中两个存储体  2.2.2. 字的对齐——对准存放  8位计算机没有对准存放问题 对准存放：  16位机的字起始地址应该是2的倍数，如0、2、4…… 32位机的字起始地址应该是4的倍数，如0、4、8…… 64位机的字起始地址应该是8的倍数，如0、8、16……   对准存放不是必须的，但如果采用对准存放，存取一个字只需要一次总线操作即可完成  2.2.3. 小端格式和大端格式   假设$W$由$B_3$，$B_2$，$B_1$和$B_0$组成，$B_3$是最高字节，$B_0$是最低字节，存储$W$需使用4个地址连续的内存单元\n  对于地址依次为$m$、$m+1$、$m+2$和$m+3$的连续4个存储单元，$m$单元地址最小，称为尾部；$m+3$单元地址最大，称为头部\n  $W$有两种存放格式：\n Intel x86采用小尾或小端格式 Motorola采用大尾或大端格式    如果采用对准存放，$m$是整个字的地址\n  现代许多CPU兼容大端格式和小端格式，如：ARM处理器默认小端格式，但可通过硬件引脚或者指令选择大端格式\n  2.2.4. 存储器操作 计算机运行时所需的指令和数据都存放在存储器中。一条指令在执行之前必须将这条指令完整地从存储器取出并传送到CPU中；指令执行时所需的操作数和操作结果有时也需要在CPU和存储器之间进行传送\n两个最基本操作：读出和写入\n读操作\n 作用：将一个指定内存单元的内容读出并传送到CPU中 特点：读操作之后存储单元的内容保持不变 过程：  读操作开始时，CPU通过地址总线AB向存储器发送指定存储单元的地址，并通过控制总线CB向存储器发出读命令 被选中的存储单元的内容则被读出并送上数据总线DB CPU在时序信号的控制下，采样DB上的数据并存入内部，完成一次读操作    写操作\n 作用：从CPU中向一个指定存储单元传送一条数据 特点：传送的数据将覆盖目的单元中原有的内容 过程：  写操作开始时，CPU通过地址总线向存储器发送目的存储单元的地址，通过数据总线传送所需写入的内容 通过控制总线向存储器发送写命令 数据总线上的数据被写入存储器指定单元，完成一次写操作    连续数据读写\n 只需在第一次读写时发送地址 对于地址连续的数据块，只需告知存储器本次传送是数据块传送、一次读写的字节数和地址修改的方向，存储器即可推断出下一次读写操作的地址，无需CPU再次重复发送  2.2.5. 存储器的分级 对存储器的要求：速度快、容量大、成本低\n分级存储体系结构\n 使用外存满足大容量、低成本和非易失的要求 使用DRAM型内存，兼顾容量、速度和成本 使用高速缓存，减少CPU访问内存的开销  高速缓存(Cache)：位于CPU与内存之间，SRAM型小容量快速存储器，用于存放CPU最近使用过或者可能要使用的指令和数据    2.3. 模型机CPU子系统 模型机CPU内部结构：\n2.3.1. 运算器 基本组成\n 算术逻辑单元 (ALU) 累加器 (ACC) 标志寄存器 (FR) 暂存寄存器  算术逻辑单元ALU：运算器的核心\n 作用：负责运算，也是数据传送的一条重要途径 组成：带有先行进位功能的全加器（简称加法器）、移位寄存器以及相应的控制逻辑 加法器是ALU最主要的部件，所有二进制算术运算都可通过加法和移位来实现  累加器ACC：特殊寄存器\n 提供需要送入ALU的操作数，存储ALU的计算结果 早期的CPU只有一个ACC，因ACC与ALU之间密不可分，常被划分到运算器中，不属于通用寄存器组 现代CPU中有很多通用寄存器都可以当作累加器来使用 ACC下方的累加锁存器：其作用是防止ALU的输出经ACC再反馈到ALU的输入端  暂存器\n 暂时存放需要送入ALU的操作数，但不存放计算结果 暂存器是透明的，程序员不可见  标志寄存器：也称为程序状态寄存器\n  标志寄存器的内容称为程序状态字PSW，PSW分为状态标志位（条件码标志位）和控制标志位\n  状态标志位：记录ALU运算后的状态或者特征\n  如：结果是否为零？是否为负数？是否有溢出？是否有进位？\n  后续指令可根据状态标志决定程序执行顺序\n  例如：\n  ARM处理器的程序状态寄存器（PSR）中有4个状态（条件码）\n  Intel 8086中还有辅助进位位A和奇偶校验位P（P现已不用）\n    后续指令可根据这些状态标志决定程序是顺序执行还是跳转执行\n    控制标志位：是对CPU的某些行为进行控制和管理\n Intel 8086的标志寄存器中有3个控制标志位  D(Direction)：串操作的地址改变方向 （D=1 → 地址减量） I(Interrupt)：是否允许外部中断（I=1 → 允许中断） T(Trap)：单步中断（T=1 → 单步中断）   Intel 8086提供了对D和I进行单独操作的指令，如  STI：将I置位为1，允许外部可屏蔽中断，亦称开中断 CLI：将I复位为0，禁止外部可屏蔽中断，亦称关中断   Intel 8086还提供了对状态标志位C的3条操作指令，操作内容分别是置位、复位和取反    2.3.2. 控制器 整个CPU的指挥控制中心\n功能和作用：\n根据指令中的操作码和时序信号，产生各种控制信号，对系统各个部件的工作过程进行控制，指挥和协调整个计算机有序地工作\n控制器主要构成：\n  指令寄存器IR (Instruction Register)\n  指令译码器ID (Instruction Decoder)\n  操作控制器OC (Operation Controller)\n  有观点认为包括程序计数器PC (Program Counter)\n（也有观点认为PC属于数据通道）\n  指令寄存器IR\n 临时存放从内存或者缓冲区中取出地下一条待执行指令，其输出作为指令译码器的输入  指令译码器ID\n 计算机能且只能执行“指令” 指令由操作码和地址码两部分构成  操作码表示要执行什么操作 地址码表明指令执行时操作对象（操作数）的存放地址   指令译码器只对操作码进行译码，分析和识别指令应该执行什么样的操作  操作控制器OC\n 根据指令译码器的译码结果，产生所需的各种控制信号并发送到相关部件，控制这些部件完成规定的操作 操作控制器内部包括时序脉冲发生器、控制信号发生器、启停电路和复位逻辑等  程序计数器PC\n 存放下一条待执行指令在内存中的地址 计算机开机时，指向引导程序的第一条指令 顺序执行时，每条指令执行后自动修改，PC=PC+n，n与指令字长以及PC的单位有关 遇到转移指令，转移目标地址→PC  控制器的工作过程：\n 根据程序计数器的内容获取下一条指令的存放地址 通过总线从存储器中取出这条指令并存放到指令寄存器中（取指） 指令寄存器的输出直接接到指令译码器的输入 指令操作码送入到指令译码器，由指令译码器对操作码进行分析和译码，识别出应执行什么样的操作 由操作控制器确定操作时序，产生所需的各种控制信号并发送到相关部件，控制这些部件完成指令规定的操作 地址生成部件根据指令特征将地址码转换成有效地址，送往地址缓冲器 对于转移指令，所生产的转移地址被转入程序计数器，实现程序的转移  微操作\n 每条指令的执行过程都可以分解为一系列的微操作 特点：可由简单电路实现；可被多个指令复用 举例：  假设指令“ADD R1，R2，R3”的功能为R2+R3→R1 这条指令的执行过程可以分解为以下几个微操作：  根据程序计数器的内容，从内存中读取一条指令到指令寄存器 指令译码器对指令进行译码 读取R2寄存器的数值，并发送到ALU中作为加法器的输入 读取R3寄存器的数值，也送到ALU作为加法器另外一个输入 加法器进行加法运算 将加法器运算结果写入R1 根据运算结果更新状态寄存器中的状态标志位 修改程序寄存器的内容，使其指向下一条指令      控制器的实现方式\n  微程序控制器\n 简介  指令执行过程看作多个微操作序贯执行完成的 对每个微操作进行编码，形成微操作码，微操作码可由简单电路产生微操作控制信号 执行顺序控制位：指示后续微操作的执行顺序 微操作码+执行顺序控制位=微指令 指令→一段由若干微指令编排而成微程序 所有指令对应的微程序都存放在控制存储器CM中逐条读出，其中微操作码经过译码产生微操作控制信号   结构  微地址：微指令在控制存储器CM中的存放地址 CLK：作用等于读信号     工作原理和过程  计算机指令分为操作码和操作数地址两部分 操作码由指令译码器译码，译码结果是该指令对应的微程序在CM中的首地址 该地址经微地址译码器译码后，从CM中读出第一条微指令，其中微操作码部分送往微操作码译码器进行译码，生成相应的控制信号以实现规定的微操作 执行顺序控制位送往微地址形成电路，生成下一条微指令的微地址 不断重复上述过程，直到这段微程序全部执行完毕      硬连线控制器\n  简介\n 也称为组合逻辑控制器，最早采用的控制器设计方法 把控制器看作专门产生固定时序的控制信号的逻辑电路，以使用元件少和速度快作为设计目标 因指令功能的多样性和差异性，导致所实现的控制器逻辑电路复杂、规模庞大，并且一旦形成就无法变更，除非重新设计和布线    设计步骤\n 输出：需要产生的微操作控制信号 输入：微操作信号类型、执行条件和时序 列出逻辑表达式，经过化简，设计相应的逻辑电路    一般结构\n  特点：速度快，电路复杂，不支持复杂指令，调试和改动困难，一度被微程序取代。近年因RISC的兴起和VLSI的进步，再度兴起\n    2.3.3. 寄存器阵列  也称为寄存器组、寄存器堆和寄存器文件 CPU内部若干高速存储单元，每个都有编号或名称，根据指令中的编号或者名称对其直接访问 CPU与寄存器之间的数据交换是通过内部总线直接进行的，所以CPU与寄存器之间的数据传送速度最快 受指令长度限制，寄存器数量有限，只能暂时存放CPU工作时所需的少量数据和地址 分为专用寄存器和通用寄存器两大类  专用寄存器作用固定，如PSR(FR)、IR和PC等 通用寄存器：为ALU运算提供一个存储区，早期数量较少且通用性差，现在数量增加，通用性增强    2.3.4. 地址与数据缓冲器 CPU内部总线与系统总线之间的接口，提供地址和数据传送缓冲，同时增加CPU的系统总线驱动能力\n2.3.5. 数据通道 计算机各部件按功能划分为两大阵营：控制单元CU和执行单元EU\nCU就是控制器，也是计算机中指令流的终点。控制器的组成包括指令寄存器、指令译码器和操作控制器。负责指令译码，生成相应的控制信号，控制执行单元完成指令规定的各种操作\nEU负责指令执行，如生成地址、读取和传送数据、计算和处理数据、存储结果、更新PSR和PC。执行单元包括运算器、寄存器组、内部总线以及系统总线接口\n在指令执行过程中，数据是在运算器、寄存器阵列和系统总线接口之间通过内部总线进行传送，所以这几个部件也被称为数据通道\n2.4. 模型机指令集和指令执行过程 2.4.1. 模型机指令集 指令\n根据计算机组成的层次结构，可以分为：微指令，机器指令和宏指令\n 微指令：微程序级的指令，属于硬件层面 宏指令：由若干条机器指令组成的软件指令，属于软件层面 机器指令：简称指令，介于位指令与宏指令之间，是CPU能识别和直接执行的一条二进制编码序列，包括操作码和操作数两部分  指令系统\n一台计算机中所有指令的集合称为这台计算机的指令系统\n 指令集架构ISA：狭义上的计算机体系结构  汇编指令\n  使用助记符（容易理解和记忆的字母）表示指令的操作码\n  使用标号和符号地址代替指令和操作数的地址\n  模型机部分常用汇编指令：\n  RISC指令风格：定长指令，Load/Store体系，三操作数\n  Rs-源操作数，Rd-目的操作数，Imm-立即数\n  Label-标号（用符号表示的指令地址）\n  定长指令\n 每条指令长度固定 特点（假设32位机，32位指令长度）  一次取指操作读取一个完整的指令 受指令位数限制，对立即数的大小或者类型有要求 同样原因，对内存寻址时，无法在指令中直接给出内存的单位地址 内存单元地址可用如下方法表示：  某个32位寄存器中的数值—寄存器间接寻址 某个32位寄存器内容+偏移量—基址加偏移量寻址 某两个寄存器之和—基址加索引寻址      2.4.2. 指令周期 计算机运行流程\n开始 → 取指 → 执行 → 取指 → 执行 → ……\n指令周期\n开始取指到完成指令操作的时间\n 因功能和操作内容不同，许多处理器指令周期也不同 有些采用流水线技术的RISC处理器，所有指令执行时间相同，被称为单周期处理器  CPU时间\n 又称总线周期、机器周期 一个CPU周期等于一次取指时间 一个指令周期分为若干个CPU周期  T周期\n 又称时钟周期 一个总线周期包括若干个T周期 T周期是处理器最基本的时间单位  2.4.3. 模型机指令执行流程 示例：利用模型机汇编指令编程实现如下操作：\n将数据000FF000h(0x000FF000)与内存中某个字数据相加，字数据的地址位于R3寄存器中，如果相加结果没有溢出，则将0x000FF000存入由R3+80h指定的内存单元，然后停机；如果溢出，直接停机\n模型机汇编语言源程序片段：\n模型机系统结构：\n用汇编语言编写的程序称为汇编语言源程序，简称汇编程序。将其转换成机器语言的过程称为汇编，能够实现汇编功能的软件称为汇编器或者汇编软件\n汇编后的机器指令顺序存放，若指令长度为4字节，后一条指令地址等于前一条地址加4（PC的单位为字节）\n模型机结构假设：\n 模型机是32位，数据总线32位，地址总线32位 RISC结构，定长指令设计，每条指令长度也是32位 待运行程序的首地址为0x2000 0000 第一条指令的机器码为“E3 A0 06 FF”  执行过程：\n 第一条：源操作数是立即数（取指时能从指令编码中立即得到的数），被装入R0寄存器后指令执行完毕  根据程序的名字，把0x20000000装入程序计数器PC 程序计数器PC内容0x20000000送至地址缓冲器/驱动器，地址总线的输出经地址译码器译码，寻址内存单元 操作控制器OC发读信号，将“E3 A0 06 FF”读出到数据总线 由于是取指操作，数据总线上的数据被装入指令寄存器IR 程序计数器PC值自动加4（假设PC内容的单元是字节），指向下一条指令的存放地址  流水线处理器取指后立刻更新，以便能够立即取下一条指令 另一种策略是临近指令执行结束时再更新，可根据执行结果确定该如何更新   指令译码器ID对操作码译码，操作控制器OC产生相应的控制信号 指令的地址码部分对应着汇编指令的操作数部分。本条指令中，源操作数为立即数#0x000FF000，目的操作数是R0寄存器 在操作控制器OC输出的控制信号作用下，立即数#0x000FF000经地址形成部件和地址驱动器送到地址总线，再经地址译码后寻址到源操作数存放的内存单元 操作控制器OC发出读信号，将源操作数读出到数据总线，然后加载到R0寄存器   第二条：Load操作，从内存取操作数到R1，操作数地址由R3提供  把第二条指令的地址0x20000004 装入程序计数器PC, 程序计数器的内容0x20000004 送到地址形成部件，地址形成部件产生的地址信号经地址缓冲器/驱动器和地址总线，被送到地址译码器进行译码，寻址指令存放的内存单元 操作控制器发读信号，将0x20000004 单元的内容“LDR R1, [R3]”读出，由于是取指操作，“LDR R1, [R3]”经过数据总线被存入到指令寄存器IR 如果程序计数器的单位是字节，则PC 自动加4，指向下一条指令的存放地址 指令译码器ID 对指令操作码进行译码，操作控制器OC 按照操作时序发出相应的控制信号 指令的地址码部分对应着汇编指令的操作数部分。本条指令中，存放源操作数的内存地址位于R3 寄存器中，目的操作数是R1 寄存器 在操作控制器输出的控制信号作用下，R3 寄存器的内容经地址形成部件和地址驱动器送到地址总线，再经地址译码后寻址到源操作数存放的内存单元 操作控制器发出读信号，将源操作数读出到数据总线，然后加载到R1寄存器。   第三条：ADD运算，R0与R1相加，结果存入R1寄存器，完成运算后更新到FR中相关状态位 第四条：条件转移，溢出则跳转执行标号为L2的指令，PC=PC+m（m是转移目的指令与转移指令之间的相对距离）；否则继续执行下一条指令 第五条：Store操作，源操作数是R0寄存器的内容，目的操作数的地址是R3寄存器的内容再加上偏移量80h 第六条：HTL停机，持续执行空操作  总结与讨论\n 指令执行时，指令操作码送到IR，经IR译码后OC产生操作控制信号，指令的地址码送到地址形成部件，生成地址信号  指令存储器 → 数据总线 → 指令寄存器 → 指令译码器/地址形成部件 指令译码器是指令操作码的终点 地址形成部件是指令地址码的终点   CPU中的所有数据都在数据通道中传送 指令执行过程属于多级串行作业，始终有一部分部件处于空闲状态，部件的利用率不高  取指 → 指令译码 → 取操作数 → 执行 → 存操作数   模型机属于冯诺依曼架构，串行工作方式的取指和存取操作数在时间上相互错开，不会出现冲突 如果改用流水线方式，前后指令的取指和存取操作数可能同时发生。冯诺依曼体系结构将造成总线竞争，故不太适合流水线模式  2.5. 计算机体系结构的改进 2.5.1. CISC和RISC CISC：指令数量多、功能丰富、可实现复杂操作\n  简介\n 采用微程序控制器，为了减少硬件实现难度，减少硬件规模 控制器结构简单、规整。增加新指令或者为已有指令添加新的功能较为容易 → 指令系统规模日渐庞大    CISC处理器指令的特点\n  指令长度不一\n 较长指令取指需要使用多个总线周期和多次总线操作 长短不一的指令给指令译码器设计带来挑战，增加了控制器的复杂性和电路规模，也不利于采用流水线和超标量等新技术 举例：  Intel 8086处理器的最短指令只有一个字节（如CLC），最长指令6字节。指令长度的变化范围为1~6字节 Motorola 68020处理器（32位）的指令长度从半个字到8个字，变化范围为2~32字节      非Load/Store体系\n算术和逻辑运算指令的操作数可以是存储数\n 例如：存储器数 + 寄存器数 → 存储器 CISC仅需要一条指令：ADD[addr], Ri RISC需要三条指令：LDR、ADD和STR，比CISC至少多出2次取值和译码操作    MOVE操作\n 格式为：Move destination，source的传送指令，可实现寄存器与存储器之间的数据传送 大多数CISC处理器规定，MOVE指令的源操作数和目的操作数最多只能有一个是存储单元 同一条总线上的两个存储单元，如果彼此之间需要传送数据，无论是RISC和CISC处理器，无论采用多条简单指令还是一条复杂指令，数据传送过程都分为两步  第一步，将源操作数从内存单元中读出到某个通用寄存器暂存 第二步，将暂存的内容写入目的存储单元      两操作数\n  在现代CISC处理器中，大多数算术和逻辑运算指令只有两个操作数，其格式一般为：\nOPR(操作码)\tDST(目的操作数),\tSRC(源操作数)\r\r  例如，加法指令：\nAdd B, A\r\r对应的操作是(B)+(A)→B。指令执行后，结果送到B原来的存储位置，替换原先的内容。意味着DST既是目的操作数，也是参与运算的两个源操作数中之一\r    指令功能强大，寻址方式多样，程序简洁\n CISC处理器的指令功能强大，可以实现复杂的操作，灵活多样的寻址方式有利于软件编程 与RISC处理器相比，完成同样任务CISC处理器所需的指令数量较少，软件显得较为简洁 指令数量少意味着所需的取指和译码操作次数也比较少，在不考虑其他技术因素（如流水线）的情况下，CISC处理器执行效率要高于RISC处理器      CISC处理器的性能问题\n 主要影响因素：微程序控制器的工作流程  完成一条指令需要从控制ROM中顺序读出多条微指令，需要多个在时间上序贯执行的微操作，这种在时间上串行作业模式将影响指令的执行速度   两种解决思路：  提高处理器的工作时钟频率，加快微操作的节奏，但是增加时钟频率受到半导体材料物理特性的限制，并且难以消除由此产生的功耗和发热问题 使用流水线和超标量等技术，让多条指令在时间上并行执行。但是由于CISC体系结构的特点，流水线和超标量的设计和实现遭遇很多困难      RISC\n 特点  摒弃微程序设计思想，采用硬连线方式实现控制器 为了减少硬件实现难度，采用精简指令集 减少处理器电路数，多余的芯片面积用于增加Cache容量以及寄存器数量，利用层次化的存储结构优化数据传送 指令简单、长度一致、执行时间相同等特点使其更加易于引入流水线技术和超标量等可大幅度提高处理器性能的并行处理技术 CISC处理器一条复杂指令就能实现的操作，RISC处理器需要使用多条简单指令才能完成 需要优秀的程序编译器，优化由数量较多的简单指令构成的程序代码   RISC指令特点  寻址方式简单，种类较少 指令集中的指令数量较少 Load/Store体系结构 每条指令长度一致，执行时间相同 面向寄存器的编程思想 算术和逻辑运算指令普遍支持三操作数 只能对寄存器操作数进行算术和逻辑运算 程序代码量较大，因为执行复杂操作需要使用较多的简单指令    CISC \u0026amp; RISC借鉴与融合\n 为了减少执行一项操作所需的指令数量，RISC处理器也增加了一些能够快速执行的非RISC指令 为降低硬连线控制器的设计难度，有些RISC处理器还是部分采用了微程序和微指令设计 Intel通过与RISC阵营的合作引入RISC技术，从P6开始，处理器中有一部分采用了RISC设计 Intel 64位IA-64架构处理器是在HP的帮助下完成的；Intel所提出的EPIC体系大部分是Alpha的遗产  2.5.1. 流水线技术 流水线原理\n  指令执行过程可分解为多个步骤，假设分解为：\n etch(取指) → Decode(译码) → Read(去操作数) → Execute(执行) → Writeback(回写)    每个步骤都有专用部件完成操作，各部件分工明确，各司其职，每个步骤按照顺序执行\n  模型机任何时候只能执行一条指令，前后指令呈多级串联作业模式，将会造成部件的“窝工”\n 取指时，译码、取操作数、执行和回写处于等待状态 执行时，取指、译码、执行和回写又处于等待状态    将功能部件按指令操作步骤顺序进行排列部署，前后部件之间增加缓冲寄存器，构成指令处理流水线\n  前后两个部件经过缓冲寄存器隔离后，可以相对独立地并行工作\n   部件之间地工作交接（数据传递）将通过缓存寄存器进行 这种缓存寄存器被称为流水线寄存器 多条指令可以在流水线上以时间重叠的方式序贯执行   从流水线时空图可看出，在10个流水线周期内  串行作业模式只能完成2条指令的执行 流水线方式至少可以完成5条指令的执行。多条指令以时间方式重叠方式执行使得IPC大大提高 由于增加了流水线寄存器，增加了流水线寄存器写入时间和额外的门电路时延。因此，单条指令在流水线上执行所花费的时间要比非流水线方式更长 流水线周期将受制于最慢的部件，将导致流水线的性能下降    流水线中技术存在的主要问题\n流水线高效运行的前提：保持畅通，不发生断流\n指令执行过程中可能发生的三种相关冲突：\n  资源相关，又称结构相关\n 多条指令在同一周期内争用同一个公用部件 例如：冯诺依曼结构计算机的Fetch、Load和Store操作都使用公用总线接口访问同一个存储器，前一条指令的数据存取操作可能会影响后续指令的取指操作 解决方法  后面一条指令等待一个节拍再启动。称为向流水线插入气泡或者插入阻塞，这将造成流水线性能下降 采用哈佛结构（程序指令和数据分开的结构）。解除存取操作数与取指之间的资源相关      数据相关\n  后一条指令执行需要使用前一条指令的结果。例如流水线上前后执行的两条运算逻辑令\n  SUB指令在第5个周期才将结果写回R1，但是AND指令在第4个周期就要读R1进行运算，而程序的本意是“写后读”（RAW）\n  RAW是一种最为常见的数据相关\n  流水线可能还存在“写后写”（WAW）和“读后写”（WAR）两类数据相关\n WAW：$I_{j+1}$试图在指令$I_j$写数据之前写数据，这样最终结果将由$I_j$决定，而程序本意是保留$I_{j+1}$的结果 WAR：$I_{j+1}$试图在指令$I_j$读数据之前写数据，此时指令$I_j$读到的是被$I_{j+1}$篡改后的结果 插入气泡可消除数据相关，但将造成流水线性能下降    解决方法\n 定向推送，前一条指令执行结果通过专用通道直接推送给下一条，减少一个流水线周期，可减少数据相关 优化编译器，对前后指令进行检查，调整执行顺序      控制相关\n  遇到转移指令时，后续已进入流水线的指令都应清空\n  以无条件转移（包括子程序调用）指令为例：\n 假设指令$I_j$是无条件转移指令，其执行步骤为：取指、译码、计算转移地址并更新程序计数器PC。在第4个周期读取转移目标指令$I_k$（转移目标指令：转移指令的目标指令，即下一条紧接着执行的命令）。在此之前流水线上的指令$I_{j+1}$和$I_{j+2}$应清除，造成流水线断流。产生两个流水线周期延迟被称为**转移代价**    减少转移代价的方法\n 对于无条件转移指令，增加电路，在译码阶段提前计算转移目标地址，在第3个周期读取转移目标指令$I_k$，将转移代价减少到一个流水线周期   依旧存在的问题：大多数条件转移指令是否转移取决于状态标志位，而标志位在ALU运算后才更新，转移代价较大。流水线级数却多，代价越大  转移预测技术        转移预测技术\n 转移延迟槽：转移指令$I_j$后面的一个时间片。无论是否转移，位于转移延迟槽的指令总是会被执行 动态转移预测：根据转移指令过去的行为进行预测  评估：用2bit（权值）对转移指令过去行为进行量化，‘11’总是转移，‘00’总是不转移 动态打分：每发生一次转移，权值+1，加到11b为止；每发生一次不转移，-1，减到00b为止 使用BTB（转移目标缓冲器），收集和存储了近期所有转移指令的有关信息，并按照查找表的形式进行组织，为动态转移预测提供信息 BTB不能太大，一般为1024个表项，其内容包括：  转移指令$I_j$的地址（查找表索引） $I_j$转移可能性的量化结果（2bit权值） 转移目标指令$I_k$的地址   每条指令在取指时，处理器根据其地址在BTB中进行快速搜索，若有记录则表明这是一条转移指令，并根据其“档案”进行相应处理，最后根据这条指令的实际行为修正BTB的记录内容        2.5.3. 超标量处理器和多发射技术  标量处理器：只能处理标量数据，一条指令一次只能处理一个数据，属于SSID 向量处理器（阵列处理器），一条指令完成一个向量计算，属于SIMD，用于科学计算和信号处理等领域 超标量处理器：拥有多条流水线，通过空间并行方式提高处理能力  将多条指令分发到多条流水线上，同时执行 分发前需配对检查，不同流水线上的指令不相干  若流水线2的指令要用到流水线1的结果，那便会产生窝工   可以使用不同类型的流水线，如整数和浮点数   多发射技术：多个指令分发单元  指令分发单元需要在一个流水线周期之内向多条流水线发射多条指令    2.5.4. 超线程处理器  进程：程序的动态执行过程  多任务系统中，CPU的运行时间被划分成多个时间片，CPU在不同的时间片轮流为每个任务进行服务 早期，进程被作为作业调度和资源管理的基本单位 进程运行时拥有所需的全部资源；任务切换时，操作系统回收资源并重新分配，无效开销太大   线程：能独立执行的代码最基本单元  每个进程拥有若干个线程 线程是作业调度和执行的基本单元，拥有少量的必备资源，与进程中的其他线程共享全部资源 线程调度时资源不可回收，无效开销小   单处理器同时只能执行一个线程，多线程只是利于操作系统的任务调度，减少无效开销，性能提高有限 超线程技术：为进一步减少处理器内部的硬件资源闲置，对流水线进行改造并添加少量部件，使处理器在同一时间可以执行两个线程  超线程只是有了两个逻辑上的线程处理单元，每个线程并不是独自拥有所需的全部资源 ALU、FPU、Cache和总线接口等仍是两个线程共享 超线程需要操作系统、应用软件以及主板BIOS的支持 性能提升：多任务时可提升30%，单任务时处理器性能不升反降    2.5.5. 多处理器计算机和多计算机系统 多处理器计算机\n 一个计算机有分布在不同的芯片上的多个处理器 多个处理器芯片通过共享内存或者共享总线进行数据交换，并行工作，属于一种紧耦合多处理器系统 多处理器计算机分为：  非对称多处理器计算机AMP  处理器有主从之分，不同的处理器承担不同的任务   全对称多处理器计算机SMP  现代服务器的主流架构。各处理器地位相同，对称工作；所有共享系统内存、I/O通道和外部设备      多计算机系统\n 每台计算机通过局域网以及私有网络彼此互连 每台计算机受各自独立的操作系统控制，有属于自己的存储系统和I/O设备，属于一种松耦合系统 可通过LAN或者SAN（存储域网）共享外部存储器，组成计算机集群 除提高了计算能力以外，也减少单点故障，具备高可用性，普遍应用于执行关键任务的信息系统中  分布式计算机系统\n 若干独立计算机或者集群通过网络互连而成 有一个全网统一的分布式操作系统，能够对用户所需的各种资源进行统一调度和管理，并且保证系统的一致性与透明性（不可见） 用户无需关心系统中的资源分布情况以及计算机差异 计算机之间没有主从之分，彼此既合作又自治，协同工作 分布式计算机系统是计算机应用领域发展的一个重要方向，也是云计算的主要基础  2.5.6. 多核处理器   可集成的电路数越来越多，可以把多个功能完整的CPU集成在一个芯片上——单芯片多内核处理器\n  每个计算内核普遍采用超标量和超级流水线技术，拥有所需的全部计算资源，可彼此独立地执行任务\n  多个内核通过片内总线或交叉开关矩阵互连，可看作一个片上多处理器机CMP系统，对外呈现为一个统一的处理器\n  分为同构多核和异构多核两种类型\n 同构  同构多核处理器的内核普遍采用通用处理器，每个处理器的结构相同，地位相同 同构多核的结构相对简单，硬件实现复杂度低   异构  通过配置具有不同功能和性能的内核以匹配实际应用需求 在提升芯片整体性能的同时，优化处理器结构，降低系统功耗 “让专业的人做专业的事”，避免“大马拉小车”和“小马拉大车” 范例：华为海思麒麟处理器      多核处理器性能与任务的并行性有关\n  安达尔定律：性能加速比\n$$\nS=\\frac{1}{1-a+\\frac{a}{n}}\n$$\n其中，$n$为节点数，$a$为可并行代码比例\n   若$a=0$，全是串行，$S=1$  若$a=1$，全是并行，$S=n$ 若$20%$代码为串行，$a=0.8$，即使$n\\rightarrow \\inf,S\\rightarrow 5$        应在核数、功耗、代价和实际效果间寻求平衡\n  2.6. Intel x86典型微处理器简介 2.6.1. Intel 8086处理器  全球第一款16位通用微处理器芯片 内部寄存器为16位，其中有4个可以分拆成8位使用 16位数据总线，20位地址总线 内存分段管理，段寄存器左移4位+偏移量=20位地址 I/O端口独立编址，端口总数为64K个 时钟频率仅有5MHz，最高不超过10MHz 分成指令执行单元EU和总线接口单元BIU两部分  2.6.2. Intel Pentium处理器  与以往的80x86系列微处理器兼容 32位地址总线，64位数据总线 采用CISC结果实现超标量结构，两条并行的5级整数指令流水线（U和V），一条8级浮点运算流水线 独立的指令Cache和数据Cache，数据和代码分离 汲取RISC的优点，简单指令改用硬连线控制器实现 基于BTB(转移目标地址缓冲器)的预测转移技术 191条指令，支持9种寻址方式 支持64位外部数据总线突发传输方式 支持SMM模式，增强的错误检测和报告功能  2.7. ARM嵌入式处理器简介 2.7.1. ARM体系结构、ARM处理器和ARM内核 ARM体系结构\n ARMv1~ARMv7属于32位架构，ARMv8属于64位架构 ARMv7子版本  ARMv7-A，对应的产品系列是ARM Cortex-A ARMv7-R，对应的产品系列是ARM Cortex-R ARMv7-M，对应的产品系列是ARM Cortex-M    ARM处理器和ARM内核\n 严格地说，ARM处理器是ARM公司设计的处理器  内部仅有的最基本的数据处理核心，习惯上称之为内核 基于同一体系结构版本，应用软件层面可相互兼容   芯片制造商获得授权后，根据实际需求和产品定位，在某款ARM设计的处理器基础上，再增加诸如实时时钟、ADC、DAC、存储器、协处理器、DSP，以及各种接口单元部件，形成多种各具特色的嵌入式处理器芯片，实际上应该属于SOC，但是往往也被称为ARM处理器（芯片）  2.7.2. ARM处理器的特点  ARM处理器成功三要素  代码密度高（代码占用内存少） 功耗低 性价比高   不同版本的ARM内核都具有如下RISC架构的共同特征：  每条指令长度固定 指令集中的指令数量较少 Load/Store体系结构 只能对寄存器操作数进行算术和逻辑运算 采用硬件布线逻辑，大部分指令在一个周期内完成执行   ARM内核吸取的CISC架构特点：  保留少数功能强大的复杂指令，如多寄存器传送指令 提供自增、自减指令和基于PC的相对寻址方式 用于转移指令和条件执行的条件码（N-负，Z-零，C-进位，V-溢出） 少数指令可以在多个周期内完成   其他特点  支持不同的指令集 指令的条件执行 移位操作的实现方式    2.7.3. 典型ARM内核的基本结构 ARM7TDMI——ARM7系列基本型产品\n  属于ARMv4T版本，产品后缀含义：\n T表示支持16位的Thumb指令（ARM指令集的子集） D表示支持片上Debug M表示内嵌硬件乘法器 I表示内嵌ICE逻辑    内部结构：\n  简介\n ARM7家族其他产品的基础，内核中的内核 包括一个32位ALU，一个32位桶形移位寄存器和一个32位x8位乘法器 共有37个程序可访问的32位物理寄存器，包括31个通用寄存器和6个状态寄存器  这些资源不是同时可见，在不同工作状态以及不同工作模式下只能看到其中一部分 在任何状态和模式下，最多只能看到其中的18个   “写”和“读”数据总线分开，片外只需配置单向总线驱动器，没有双向驱动器的方向转换时延    特点\n 有ARM和Thumb两种状态，可软件切换，分别支持全功能的32位ARM指令集和简洁的16位Thumb指令集 一条3级（取指、译码和执行）流水线，性能可达0.9MIPS/MHz；支持8bit、16bit和32bit数据操作 快速中断响应能力 写数据和读数据总线分开，片外无需双向驱动器 冯诺依曼结构，系统简洁，门电路数量较少 高性能、低成本，超低功耗，尤其适合对功耗有苛刻要求的场合，如依赖电池供电的各种手持式电子设备    ARM920T基本结构和特点\n  ARM9系列简介\n ARM9产品家族可分为ARM9和ARM9E两个系列  ARM9系列是基于ARMv4T版本的普通型产品，包括ARM9TDMI、ARM920T、ARM922T和ARM940T ARM9E系列则是基于ARMv5TE版本的增强型产品，具有DSP和Java扩展功能，包括ARM926EJ和ARM946E   ARM9系列与ARM7相比在体系结构上的改进  指令流水线升级为5级（取指、译码、执行、存储器访问和回写），每级电路更简单，执行速度更快 采用哈佛结构，减少发生资源冲突的概率 Thumb指令采用硬件译码，速度高于软件译码的ARM7      ARM9TDMI处理器简介\n ARM9TDMI是ARM9产品家族中的基本型产品 同系列的其他处理器都是以ARM9TDMI为核心，扩展和集成其他功能部件所构成：  指令Cache和数据Cache、AMBA总线接口、嵌入式跟踪宏单元ETM、MMU或者MPU等      ARM920T处理器简介\n 属于ARM9系列，以ARM9TDMI为核心，另外配置了  各16B的数据和指令cache 数据和指令MMU 写缓存（16字的数据，4个地址） CP15 外部协处理器接口 嵌入式跟踪宏单元ETM   支持VxWorks，WindowsCE和Linux等嵌入式OS 高性价比和低功耗，典型的目标SOC芯片 提供1.1MIPS/MHz的哈佛结构    ARM920T处理器结构\n 两类地址信号：物理地址PA和虚拟地址VA  Physical Address：每个存储单元所拥有的真实地址 Virtual Address：编程时所使用的地址，也称为逻辑地址 由MMU负责PA和VA的映射和转换   CP15：系统控制协处理器，用于管理和控制Cache、MMU、时钟类型和大小端设定等系统级操作 回写物理地址TAG：地址标记寄存器，存放Cache中需要回写（更新）数据字段在主存中的地址信息 数据总线上的写缓存：提高数据回写操作的速度 JTAG：符合JTAG规范的测试接口    2.8. 计算机性能评测 2.8.1. 定性描述指标 机器字长\n计算机中的字长不仅影响计算精度，也影响运算速度。64位计算机的性能显然高于32位\n存储容量\n在计算机存储系统中，高速缓存和内存（主存）容量和类型是评价计算机系统性能的两项重要指标\n一般来说，高速缓存和内存容量越大、存取速度越快，计算机的处理能力就越强\n总线带宽和数据吞吐速率\n一般来说，总线带宽取决于总线结构、位宽、主频等。数据吞吐速率还与存储器的存取速度、传送方式、数据的组织形式以及外设接口速度等因素有关\n能耗与环保\n关于CPU效能的指标主要有EPI，EPI指标越低，表明CPU的能源效率越高\n计算机的环保指标：耗电量、辐射、噪声、各种器件中有害物质的含量、各种废弃物的可处理性等\nRASIS特性\n Reliability，可靠性，MTTF与MBTF Availability，可用性，系统正常运行时间的百分比 Serviceability，可维护性 Integrity，集成性，all in one Security，安全性  2.8.2. 定量指标描述 定量描述指标：速度\n一般来说，一台计算机的主频高、CPU数量或者内核数量多、高速缓存和主存容量大、总线传输速率高，表明计算机运算速度也快\n早期指标：MIPS\n对于执行相同的任务，RISC计算机相比CISC计算机要花费更多的指令，MIPS对CISC和RISC不能客观评价\n现在指标：基准测试\n  Whetstone和Dhrystone\n 前者包括浮点数，后者只有整数，使用FORTRAN编写，代码量太小，与编译器有关    CoreMark\n 2009年由EEMBC提出，用C语言编写，包含嵌入式系统常见的4种计算（矩阵、查找和排序、状态机和CRC），已成为嵌入式内核标准评测的事实标准    SPEC测试，通用计算机使用最多的基准测试\n SPECjbb，用于评测JAVA应用服务器的性能 SPECint，用于评测整数计算及编译器优化能力 SPECfp，用于评测浮点数计算及编译器优化能力 SPEC CPU，用于评测单核或多核处理器在进行整数及浮点数计算时的性能，包括多个种类和多个测试项目    其他基准测试\n  TPC\n 大型信息系统核心主机选型的重要依据 主要针对计算机在数据库应用及事务处理方面的性能，常见的有  TPC-C，反映OLTP（联机事务处理）性能 TPC-H，反映OLAP（联机事务分析）性能      Linpack（线性系统软件包）\n一种高性能计算机系统浮点性能测试基准。通过在计算机（集群）系统中运行Linpack测试程序，可以得到能够反映高性能计算机浮点性能的测试结果Flops。在高性能计算领域，Linpack指标收到普遍重视\n  SAP基准测试\n SAP研发ERP在大型企业中得到广泛的应用，其测试结果对于ERP系统的硬件选型和配置具有一定指导意义      3. 存储器系统 3.1. 概述 3.1.1. 存储器的类型及特点 3.1.1.1. 半导体存储器 原理\n半导体存储器是一种以半导体电路作为存储媒体的存储器，内存储器就是由成为存储器芯片的半导体集成电路组成\n分类\n  按其功能分\n 随机存取存储器RAM 只读存储器ROM    按地位和作用分\n  按结构和工艺分\n TTL（Transistor-Transistor Logic） COMS（Complementary metal-oxide-semiconductor）    按存储信息的可保存性分\n 易失性存储器 非易失性存储器    按存储器在计算机中的功能分\n 高速缓冲存储器（Cache） 主存储器 辅助存储器（外存储器）    优点\n 体积小 存储速度快 存储密度高 与逻辑电路接口容易  缺点\n 和磁芯存储器不同，半导体存储器如RAM，属于易失性存储器，在电源中断时数据消失 可擦除、可编程ROM，编程次数有限  3.1.1.2. 磁介质存储器 原理\n利用磁性介质的磁极化来存储信息\n分类\n 早期主要用磁泡、磁鼓和磁芯作为存储器 现在主要采用磁表面存储器；磁盘（硬盘、软盘）和磁带  特点\n 早期为主存。现在为外设，需接口电路支持 非易失性存储器，容量大，存取速度越来越快，体积不断减小。主要的外设，应用广泛  磁芯存储器结构和工作方式\n磁芯在导线上流过一定电流情形下会被磁化或者改变磁化方向，实现通过实验和材料的工艺控制得到这个能够让磁芯磁化的电流最小阈值。根据磁化时电流的方向磁芯可产生两个相反方向的磁化，这就可作为0和1的状态来记录数据。每个磁芯都有XY互相垂直的两个方向的导线穿过，另外还有一条斜穿的读出线，这些线组成阵列，XY分别做两个不同方向的寻址\n磁盘结构和工作方式\n 磁盘，是在一片或多片金属、薄膜或玻璃上覆盖磁性材料，由磁头随机存取表面被磁化的不同信息 以硬磁盘为代表的存储器，由硬磁盘、磁头、磁盘旋转运动机构，以及控制器组成，驱动盘片高速运动，由磁头沿径向运动进行存取信息的读写 作为计算机的海量外存，主要存储文件、图像和视频等 硬磁盘存储器已经是微型计算机系统最主要的标准外设之一，经过不断地技术进步，其容量越来越大，存取速度越来越高，而体积却不断减小  磁带结构和工作方式\n 磁带是一种柔软地带状磁性记录介质，由带基和磁表面层两部分组成，带基多为薄膜聚酯材料，磁表面层所用材料多为$\\gamma-\\mathrm{Fe_2O_3}$和$\\mathrm{CrO_2}$等 由磁带传送机构、赐福控制电路、读写磁头、读写电路和有关逻辑控制电路等组成。驱动磁带相对磁头运动，用磁头进行电磁转换，在磁带上顺序地记录或读出数据 磁带控制器是中央处理器在磁带机上读写数据用的控制电路装置。存储数据地磁带可脱机保存和互换读出  3.1.1.3. 光存储器 原理\n光盘上刻有凹点和空白，光照射后辐射强度不同，接收电路再转化为0、1地数字信号\n分类\n 只读型光盘 可记录型光盘  光驱结构和工作方式\n 光驱组成：激光头组件（激光发射器、半分光棱镜、物镜、透镜以及光电二极管）、驱动机械部分、电路及电路板（电源电路、前置信号处理电路、聚焦/循迹/径向/主轴伺服电路、光电转换及控制电路、DSP数字信号处理电路等）、IDE解码器及输出接口、控制面板及外壳等 工作方式：驱动光盘高速旋转，激光二极管产生对应波长地激光光束，照射光盘表面，经由激光头组件中地光电二极管捕捉反射回来地信号从而识别实际地数据  特点\n 作为计算机外设：内置、外置。不同类型地光盘需要不用类型设备地支持 非易失性存储器，容量大，成本低，应用广泛  3.1.2. 微机系统的存储体系架构 微型计算机系统的存储体系架构是分层次的，离CPU越近的存储器，速度越快，每字节的成本越高，同时容量越小。按照与CPU由近到远的距离，有\ngraph LR\r寄存器 --\u0026gt; 高速缓存 --\u0026gt; 内存/主存 --\u0026gt; 本地磁盘 --\u0026gt; 网络存储\r按照访问速度快慢和容量，有\ngraph LR\rCPU内核 --\u0026gt; 寄存器堆 --\u0026gt; 高速缓存 --\u0026gt; 主存储器 --\u0026gt; 联机外存储器 --\u0026gt; 脱机外存储器\r简单的二级结构：内存+外存\n完整的四级结构：寄存器+Cache+主存+辅存（联机、脱机外存）\n  寄存器\n 组成  采用触发器，构成中央处理器CPU中地一部分   功能  暂存指令、数据和地址   特点  CPU处理的数据先提取到寄存器。有限存储容量，高速      高速缓冲存储器Cache\n  组成\n存在于CPU与内存之间，由静态存储芯片SRAM组成\n  功能\nCPU向内存读取数据时，首先查询Cache存储体缓存区是否有对应数据，如果有则直接读取，没有再从内存中读取\n  特点\n 成本高，容量比较小。但速度比内存高得多，近于CPU的速度 系统动态管理缓存中的数据，如果有数据访问频率降低到一定值，就从Cache存储体中移除，而将内存中访问更加频繁的数据替换进去      主存储器\n  组成\n 主存储器，简称内存，是计算机运行过程中的存储主力，主要由DRAM和ROM组成 在一些特殊类型或者小容量应用场合，如，在嵌入式系统中，也采用SRAM作为主存    功能\n程序的运行都是在内存中进行。存储指令（编译好的代码段），运行中的各个静态，动态，临时变量，外部文件的指针等等\n  特点\n成本较高，容量比较大，速度高，但比Cache低得多\n    辅存\n 联机外存储器  组成：主要为磁介质的机械硬盘、固态硬盘SSD 功能：存储需要永久存储的文件 特点：  磁介质机械硬盘空间大，价格便宜 固态硬盘在接口的规范和定义、功能及使用方法上与普通机械硬盘完全相同，在产品外形和尺寸上也完全一致     脱机外存储器  移动硬盘、光盘、U盘、Flash等便携式存储器，便于携带      3.1.3. 辅助存储器主要接口标准 常将联机、脱机存储器称为辅助存储器。辅助存储器接口，主要包括硬盘接口标准、Flash存储卡的接口标准等。通用的接口标准为不同类型辅助存储器产品提供接入的互换性，便于产品升级和维护\n微机常用存储接口：\ngraph LR\rIDE --\u0026gt; ATA\u0026amp;PARA --\u0026gt; SCSI --\u0026gt; SATA --\u0026gt; SAS\r嵌入式设备常用存储接口：\ngraph LR\rSD --\u0026gt; eMMC --\u0026gt; UFS\r IDE接口  IDE又称为ATA，用40/80针排线连接PC机和硬盘，16位双向总线并行传送，盘体与控制器集成一起以减少接口电缆长度，提高传输可靠性 后发展为Ultra DMA，最快的Ultra DMA133接口的时钟达到133MHz 由于采用并行接口传输数据，也称为PATA硬盘    SCSI接口  并行接口，用于计算机及其周边设备之间（硬盘、软驱、光驱、打印机、扫描仪等）系统级接口的独立处理器标准 配专门SCSI控制卡，最多连15个硬盘，也可驱动其他SCSI接口外设 优点：CPU占用率低，多任务并发操作效率高，转速高，传输速度快，更稳定，支持热插拔，连接设备多，连接距离长等 成本高，多用于中高端的服务器和工作站。主流的Ultra 320SCSI的速度为320MB/s    SATA接口  SATA使用了差动信号系统，能有效滤除噪声 4针串行点对点传输数据，一次传一位，但总线8位，每时钟周期能传送1字节，并用数据包传送，速率达150MB/s 接口结构简单，能减小功耗，支持热插拔，还能对传输指令进行检查，并自动纠错，传输可靠性高 SATA2和SATA3是最新硬盘接口，传输速度分别达到300MB/s和600MB/s   SAS接口  串行连接SCSI接口 新一代SCSI技术，它和SATA接口那样采用串行技术来获得更高的传输速度，并通过缩短连线来改善内部空间等 SAS的接口技术可以向下兼容SATA，而SATA系统不兼容SAS    SD接口  SD卡的数据传送和物理规范由MMC（Multi Media Card）发展而来，大小和MMC卡相似，长宽和MMC卡一样，比MMC卡厚0.7mm SD卡集成了闪存记忆卡控制器、MLC（Multilevel Cell）和NAND闪存，通过9针的接口界面与专门的驱动器相连接 SD卡系统是一个新的大容量存储系统，提供了一个便宜的、结实的卡片式的存储媒介 SD卡的低耗电和广供电电压，可以满足移动电话、电池应用。使用非常有效的数据压缩比如MPEG，SD卡可以提供足够的容量来存储多媒体数据 SD卡衍生类型Micro SD（T-Flash，简称TF）卡，具有更小的尺寸，在大部分场合替代了常规的SD卡，成为脱机外存储器的主流    eMMC接口  嵌入式存储器接口  嵌入式MMC，基于MMC协议的内嵌式存储器标准规格。主要针对使用成本较低的数据存储和传播媒体产品，手机或平板电脑等产品 eMMC=控制器+NAND Flash+MMC标准封装接口 eMMC封装为MCP芯片。为BGA封装 eMMC支持MMC、SPI模式   特点  接口速度高达每秒400MBytes 不需处理其它复杂的NAND Flash兼容性和管理问题，简化了存储器的设计 eMMC加快了新产品更新速度，减少研发成本，缩短新产品研发周期 eMMC为半双工方式。将有被全双工的UFS取代的趋势      UFS  UFS，即“通用闪存存储”，同样是一种内嵌式存储器的标准规格，由JEDEC（Joint Electron Device Engineering Council）发布。同样是整合有主控芯片的闪存，不过其使用的是PC平台上常见的SCSI结构模型并支持对应的SCSI指令集 UFS是UFSHCI标准JESD223的扩展 UFSHCI标准定义了UFS驱动程序和UFS主机控制器之间的接口。除寄存器接口外，它还定义了系统内存中的数据结构，用于交换数据，控制和状态信息 技术特点  串行传输，全双工，同一通道允许读写传输，读写能够同时进行，单通道带宽达1.5GB/s以上，传输效率有效提高 抗EMI和串扰 差分信号可以使用较低的电压，并且由于提高了抗噪声性能，获得更好的信噪比（SNR） 差分信号集成到UFS卡，降低接收器电路复杂性 CLK线上的电阻，通过阻尼减少信号失真和EMI 电源电容，去耦以及储能      3.2. 半导体存储芯片的基本结构和性能指标 电子计算机主板上主要采用半导体存储器，称为内存\n内存用来存放当前执行的数据和程序，有易失性和非易失性两种\nRAM：易失性存储器，仅用于暂时存放程序和数据，关闭电源或断电数据会丢失\nROM：非易失性存储器，用于存放程序或静态数据，即使断电，数据也不会丢失\n3.2.1. 随机存取存储器RAM 简介\n 特点：  在使用过程中即可利用程序随时写入信息，又可随时读出信息，分为双极型和MOS型两种。前者读写速度高，但功耗大，集成度低，故在微型机主存中几乎使用后者   分类：  静态RAM（SRAM）：其存储电路以双稳态触发器为基础，状态稳定，只要不掉电，信息不会丢失。  优点是不需刷新 缺点是集成度低。适用于不需要大存储容量的微型计算机（例如，单板机和单片机）中   动态RAM（DRAM）：其存储单元以电容为基础，电路简单，集成度高。但也存在问题，即电容中电荷由于漏电会逐渐丢失，因此DRAM需定时刷新电路。它适用于大存储容量的计算机    静态RAM（SRAM）\n  特点\n 用**双稳态触发器（SR锁存器）**存储信息 速度快（双极型\u0026lt;5ns，MOS型几十～几百ns ），不需刷新，外围电路比较简单，但集成度低（存储容量小，约1Mbit/片），功耗大 SRAM被广泛地用作高速缓冲存储器Cache 对容量为$M\\times N$的SRAM芯片，其地址线数=$\\lg2M$；数据线数=$N$。反之，若SRAM芯片的地址线数为$K$，则可以推断其单元数为$2^K$个。如，地址线分别为13、10根，则单元数为$2^{13}×8,2^{10}×4$    基本存储电路\n $V_1～V_4$管组成双稳态锁存器，用于记忆1位二值代码 $V_1$截止 → A为高电平 → $V_2$导通 → B为低电平 → $V_1$截止 → 状态“1” $V_1$导通 → A为低电平 → $V_2$截止通 → B为高电平 → $V_1$导通 → 状态“0” 控制管$V_5$、$V_6$ 实现状态控制    工作原理\n  保持状态\n  读出状态\n选择线通过译码控制为高电平\n  写入状态\n选择线通过译码控制为高电平\n    静态RAM芯片结构\n静态RAM芯片内部由多个基本存储电路单元组成，容量为单元数与数据线位数之乘积\n为了选中某一个单元，往往利用矩阵式排列的地址译码电路：行选择信号 + 列选择信号\n 例如，1K单元的内存需10根地址线，其中5根用于行译码，另5根用于列译码 译码后在芯片内部排列成32条行选择线和32条列选择线，这样可选中1024个单元中的任何一个，而每一个单元的基本存储电路的个数与数据线位数相同  常用的典型SRAM芯片有6116、6264、62256、628128等\n以6116芯片为例：\n 6116芯片的容量为$\\pmb {2K×8}$位 2048个存储单元需11根地址线  7根用于行地址译码输入，4根用于列译码地址输入 每条列线控制8位，形成了128×128个存储阵列，即16384个存储位   6116控制线有三条：片选CS#、输出允许OE#和写入允许(读写控制)WE# 工作过程：  读出  地址输入线$A_{10}～A_0$送来的地址信号经地址译码器送到行、列地址译码器 译码后选中一个存储单元（8个存储位） 由CS#、OE#、WE#构成读出逻辑(CS#=0，OE#=0，WE#=1） 打开右面的8个三态门，被选中单元的8位数据经I/O电路和三态门送到D~7~～D~0~输出   写入  地址输入线$A_{10}～A_0$送来的地址信号经地址译码器送到行、列地址译码器 译码后选中一个存储单元（8个存储位） 由CS#、OE#、WE#构成写入逻辑(CS#=0，OE#=1，WE#=0） 打开左边的三态门，从D~7~～D~0~端输入的数据经三态门和输入数据控制电路送到I/O电路，从而写到存储单元的8个存储位中   无读写操作  CS#=1，即片选处于无效状态，输入输出的三态门均为高阻状态，存储器芯片与系统总线断开        动态RAM（DRAM）\n  特点\n DRAM是靠MOS电路中栅极电容存储信息，电容上的电荷会逐渐泄漏 需要定时充电以维持存储内容不丢失（称为动态刷新），动态RAM需要设置刷新电路，相应外围电路就较为复杂。刷新定时间隔一般为几微秒～几毫秒 集成度高（存储容量大，可达1Gbit/片以上），功耗低，但速度慢，约为SRAM的一半，需要刷新 DRAM在微机中应用广泛，如微机中的内存条（主存）、显卡上的显示存储器几乎都是用DRAM制造的    存储原理\n 存储单元由1个MOS管和1个小电容构成  电容C充满电荷便保存了逻辑\u0026quot;1\u0026quot; 电容C无电荷为逻辑“0”   数据输入输出端连数据总线的某一位D~i~（位线） 低位地址（如A~0~~ A~7~）译码产生**行选信号X**，高位地址（如A~15~~A~8~）译码产生**列选信号Y**。X、Y都为**高电平**时该单元被选中 刷新操作：  电容C上保存的电荷会逐渐泄漏。故DRAM使用过程中需要及时向保存“1”的那些存储单元补充电荷，也就是对电容C进行预充电，这一过程称为DRAM的刷新 刷新逐行进行，当某一行选择信号X为“1”时，选中了该行，电容上信息送到刷新放大器上，刷新放大器又对这些电容立即进行重写。刷新时，列选择信号Y为“0”，因此电容上信息不会被送到数据总线上 温度升高会加快电容放电，因此两次刷新的间隔不能太短，规定为1~100ms。在70°C时的典型刷新间隔为2ms，绝大多数刷新电路按此标准设计   写操作时，X=1，Y=1，Q和T管均导通，要写入的值（0或1）从D~i~加到C上 读操作时，Q和T同样导通，存储在C上电荷通过Q、刷新放大器和T输出到D~i~    DRAM芯片举例\n 常见小容量DRAM芯片有：  64K×1位－4164/2164 256K×1位－41256 1M×l位－21010 256K×4位－21014 4M×1位－21040\u0026hellip; \u0026hellip;等   大容量DRAM芯片有：  16M×16位 64M×4位 32M×8位 256M×4位 512M×4位（DDR结构）\u0026hellip;等   DRAM芯片举例：Intel 2164A  单管存储电路设计，容量：64K×1位 数据线有二根：数据输入$\\mathrm{D_{IN}}$和输出$\\mathrm{D_{OUT}}$； 8根地址输入脚A7~A0，分时接收8位行、列地址； 行和列地址选通信号RAS#和CAS#输入端； 读写命令WE# , 0-写，1-读    以Intel 264A为例\n Intel 264A的地址线与寻址  容量为64K×1位，即片内有65536个存储单元，每个单元只有1位数据，用8片2164A才能构成64K字节的存储器。若想在2164A芯片内寻址64K个单元，则需要用16条地址线。但为减少地址线引脚数目，地址线又分为行地址线和列地址线，进行分时工作，这样DRAM对外部只需引出8条地址线 芯片内部有地址锁存器，利用多路开关，由行地址选通信号RAS，把先送来的8位地址送至行地址锁存器加以锁存。由随后出现的列地址选通信号CAS把后送来的8位地址送至列地址锁存器加以锁存   64K×1存储主体，设计成4个128×128矩阵 4个128路刷新放大器，接收由行地址选通的4×128个存储单元信息，经放大后再写回原存储单元进行刷新 16位地址分为行地址A~7~~ A~0~和列地址A~15~~A~8~，以**分时复用**方式，分两次送入芯片。**行地址在先，列地址随后**，各由一个8位地址锁存器保存 两次送来的8位地址信息的最高位（A~7~和A~15~），形成RA7和CA7去控制4选1的I/O门电路，从4个矩阵中选择1个进行读/写 行/列地址译码器对行/列地址的低7位进行译码，从某个128×128个单元中选择1个进行读/写 行地址到达，选通信号RAS#变低；列地址到达，选通信号CAS#变低。经行/列时钟缓冲器协调后，有序控制行/列地址的选通以及数据读/写或刷新 要写入的1位数据从$\\mathrm{D_{IN}}$脚输入，由数据输入缓冲器暂存；准备从$\\mathrm{D_{OUT}}$脚读出的1位数据，也先由输出缓冲器暂存 写允许WE#以及RAS#、CAS#信号, 通过写允许时钟缓冲器控制后, 决定打开哪个数据缓冲器    DRAM存储条\n  内存条\n PC配置的内存已高达16GB、32GB，服务器更高达256GB，要求更高的DRAM集成度 容量为1G位以及更高集成度的存储器芯片已大量使用。通常，把这些芯片放在内存条上形成更大存储容量，用户只需把内存条插到系统板上提供的存储条插座上即可使用。 内存条标准化，实现通用和互换，便于维护和升级    内存条的主要技术指标\n 容量：用户最关心的指标，每种内存条都有多种容量规格 时钟频率：内存芯片的基本工作频率，即表5.2中列出的时钟频率 数据速率：芯片上每根引脚可传输数据的速率 数据宽度：可同时传输数据的位数，现大多为64位 奇偶校验：在每1字节外增加了1位，用作出错检测 ECC功能：出错检查和修正功能 \u0026hellip;\u0026hellip;    存储条示例\n 图中是采用HYM59256A存储芯片，构成256K×9位存储容量的存储条 其中，2片256K×4位的存储芯片通过位扩展形成256K字节的存储单元，1片256K×1位的存储芯片作为奇偶校验 引脚  A8～A0为地址输入线。 DQ7～DQ0为双向数据线，PD为奇偶校验数据输入，PCAS#为奇偶校验的地址选通信号，PQ为奇偶校验数据输出。 WE#为读写控制信号，RAS#、CAS#为行、列地址选通信号。 V~DD~为电源（+5V），V~SS~为地线。 30个引脚定义是存储条的通用标准之一        3.2.2. 只读存储器ROM 只读存储器（ROM）掉电后信息不会丢失（非易失性或不会挥发性），弥补了RAM的不足，因此成为计算机中的一个重要部件\nROM包括掩模ROM、PROM、EPROM、EEPROM等多种类型\n掩模ROM和PROM已淘汰，广泛使用的是EEPROM 和Flash\n注意：\n ROM早已不是“只读”，仍称为ROM只是一种习惯 只读，是相对于CPU的读写控制电平及其控制逻辑而言 EEPROM、Flash都是可在线编程读写的，只不过需要专门的写、擦除电平和时序  掩膜ROM\n  Mask ROM（掩膜ROM）的存储数据由专门设计的掩模板决定，为固化数据，用户不能修改\n  ROM电路结构包括存储矩阵、地址译码器和输出缓冲器三个组成部分\n 存储矩阵由许多存储单元排列而成。存储单元可以用二极管构成，也可以用双极型三极管或MOS管构成。每个单元能存放一位二值代码（0或1）。每一个或一组存储单元有一个对应的地址代码 地址译码器的作用是将输入的地址代码译成相应的控制信号，利用这个控制信号从存储矩阵中将指定的单元选出，并把其中的数据送到输出缓冲器 输出缓冲器的作用有两个，一是能提高存储器的带负载能力，二是实现对输出状态的三态控制，以使与系统的总线连接与隔离    掩膜ROM芯片示例：\n  4位数据输出，4×4位的MOS管，单译码结构\n  地址线A~1~、A~0~，译码后可译出4种状态W~3~~ W~0~。输出4条选择线，分别选中4个单元，每个单元4位输出\n  存储矩阵由MOS门组成，当W~3~~ W~0~每根线上给出高电平信号时，都会在4根线d~3~~ d~0~上输出一个4位二值代码\n  将每个输出代码称为一个“字”，并将W3~ W0称为字线，将d3~d0称为位线(或数据线），而A1、A0称为地址线\n  输出端的缓冲器用来提高带负载能力，并将输出的高、低电平变换为标准的逻辑电平\n  通过给定EN#信号实现对输出的三态控制，将数据反相输出\n  若地址线A~1~A~0~=00，则选中0号单元，即字线0为高电平，若有MOS管与其相连(如位线d2和d0），其相应的MOS管导通，位线输出为0，而位线1和3没有MOS管与字线相连，则输出为1\n 行列交叉处有无MOS管分别表示了“0”和“1”    掩膜ROM存储矩阵的内容：\n   单元/位 d~3~ d~2~ d~1~ d~0~     0 1 0 1 0   1 0 1 0 0   2 1 0 1 1   3 0 0 0 1        可编程ROM（PROM）\n  简介\n 可编程ROM，即PROM是一种简单的可编程逻辑器件PLD PROM的总体结构与掩模ROM一样，同样由存储矩阵、地址译码器和输出电路组成 在出厂时已经在存储矩阵的所有交叉点上全部制作了存储元件，即相当于在所有存储单元中都存入了“1” 用户可以根据需要将其中的某些单元写入数据“0”（部分的PROM在出厂时数据全为“0”，则用户可以将其中的部分单元写入“1”），以实现对其“编程”的目的    PROM采用经典的“双极性熔丝结构”\n 由一只三极管和串在发射极的快速熔断丝组成 三极管be结相当于接在字线与位线之间的二极管，熔丝用很细的低熔点合金丝或多晶硅导线制成 如果改写某些单元，则可以给这些单元通以足够大电流，维持一定时间后，需存入0的那些存储单元上的熔丝烧断    编程过程\n 地址译码器选择要编程的地址，找出要写“0” 的单元地址 将V~CC~和选中的字线提高到编程所要求的高电平 在编程单元的位线上加入编程脉冲（幅度约20V，持续时间约十几微秒） 写入放大器A~W~的输出为低电平、低内阻状态，有较大的脉冲电流流过熔丝，将其熔断 正常工作时读出放大器AR输出的高电平不足以使D~Z~导通，A~W~不工作    EPROM\n  简介\n 可擦除可编程ROM  采用叠栅注入MOS管SIMOS (Stacked-gate Injection MOS)做存储单元   是一个N沟道增强型的MOS管，有两个重叠的栅极—控制栅G~c~和浮置栅G~f~  控制栅G~c~用于控制读出和写入 浮置栅G~f~用于长期保存注入电荷   初始状态  浮栅上未注入电荷以前，在控制栅上加入正常的髙电平能够使漏-源之间产生导电沟道，MOS管导通，存储信息“0”   重复擦写编程的EPROM  利用编程器写入后，信息可长久保持，因此可作为只读存储器 需要变更时，可利用擦除器将其擦除，各单元内容读出值为FFH 再根据需要利用EPROM编程器编程，因此这种芯片可反复使用      编程原理\n 漏-源间加较高电压（约+20~+25V），发生雪崩击穿 同时在控制栅上加以高压脉冲（幅度约+25V，宽度约50ms） 在栅极电场作用下，一些高能量电子穿越SiO~2~层到达浮置栅，被浮置栅俘获而形成注入电荷 浮置栅上注入了电荷的SIMOS管相当于写入了“1”，未注入电荷的相当于存入了“0”    擦除原理\n 存储器芯片开有玻璃窗口 用特定波长紫外线照射该窗口数分钟，所有存储单元浮栅上的电荷会形成光电流泄放掉，使浮栅恢复初态 擦净的芯片可重新编程 编程过程总是从头到尾，对1块芯片的全部单元进行重写，因此不能修改芯片中的部分内容（哪怕1个字节） 通过编程器写入新的数据后，需要将窗口用不透光胶带遮蔽，避免紫外线照射而使电荷泄放，以防数据丢失    EPROM芯片示例\n  EPROM芯片有多种型号，如2716(2K×8 位）、2732(4K×8 位）、2764(8K×8 位）、27128(16K×8 位）、27256(32K×8 位）等\n  典型EPROM芯片2764A\n 28脚DIP封装 13条地址线A~12~~A~0~ 8条数据线D~7~~D~0~ 2个电压输入端V~CC~和V~PP~ 片选端CE#(功能同CS#） 输出允许OE# 编程控制端PGM#    读方式（数据）\n V~CC~和V~PP~都接至+5 V，PGM#接至高电平 当从2764A的某个单元读数据时，先通过地址引脚接收来自CPU的地址信号，然后使控制信号和CE#、OE#都有效 经过一个时间间隔，指定单元的内容即可读到数据总线上    读方式（读Intel标识符）\n A~9~引脚接至11.5～12.5 V 分两次顺序读出两个字节，先让A~1~～A~8~全为低电平，而使A~0~从低变高 A~0~=0，读出制造商编码(陶瓷封装为89H，塑封为88H） A~0~=1，读出器件编码(2764A为08H，27C64为07H）    备用方式\n CE#为高电平，2764A就工作在备用方式，输出端为高阻状态 芯片功耗将下降，从电源所取电流由100 mA下降到40 mA    编程方式\n V~PP~接+12.5V，V~CC~接+5V 从数据线输入数据 CE#端保持低电平，OE#为高电平 每写一个地址单元，都必须在PGM#引脚端给一个低电平有效，宽度为45 ms的脉冲    编程禁止\n 在编程过程中，只要使该片CE#为高电平，编程立即禁止    编程校验方式\n 完成一个字节编程后，电源接法不变 PGM#为高电平，CE#、OE#均为低电平 则同一单元数据在数据线上输出，这样就可与输入数据相比较，校验编程结果是否正确    快速编程方式\n 传统编程按字节方式，宽度为45 ms的编程脉冲，速度慢。且容量越大，速度越慢 新的编程方法提高速度达6倍以上 思路：V~pp~上加编程电压，用1ms编程脉冲依次写完所有数据，再从头开始校验；若有错误，重写此单元    小结\n2764A的工作方式选择表\n   方式/引脚 CE# OE# PGM# A~9~ A~0~ V~CC~ V~pp~ 数据端功能     读 低 低 高 × × 5V V~CC~ 数据输出   输出禁止 低 高 高 × × 5V V~CC~ 高阻   备用 高 × × × × 5V V~CC~ 高阻   编程 低 高 低 × × V~CC~ 12.5V 数据输入   校验 低 低 高 × × V~CC~ 12.5V 数据输出   编程禁止 高 × × × × V~CC~ 12.5V 高阻   标识符 低 低 高 高 低 5V V~CC~ 制造商器件编码        EPROM存在的问题\n EPROM虽可多次重新编程使用，但是整个芯片只要写错一位，就必须从电路板上取下擦掉重写，擦除时间很长，因而使用不便 在实际应用中，往往只要改写几个字节的内容，因此多数情况下需要以字节为单位进行擦写    电可擦除可编程ROM（EEPROM，E^2^PROM）\n  基本特性\n 可以在电路板上直接编程写入（在系统编程） 允许以字节为单位擦除和重写，而EPROM需要将整个芯片所有的信息擦除后才能重写 使用单一的+5V电源，不需要专门的编程电源 在写入过程中自动进行擦写，一个字节的擦写时间远远小于EPROM所需的时间，约需10ms左右（但还是远远大于RAM） 无需专用电路，只要按一定的时序操作即可进行在线擦除和编程    工作原理\n 采用了一种称为浮栅隧道氧化层MOS管（Floating gate Tunnel Oxide，简称Flotox管）。Flotox管与SIMOS管相似，属于N沟道增强型的MOS管，有两个栅极—控制栅G~C~和浮置栅G~f~ 在E^2^PROM中，使浮动栅带上电荷与消去电荷的方法与EPROM不同 在E^2^PROM中，在浮动栅上方增加了一个控制栅，而浮动栅与漏极之间有一层极薄的氧化硅，称为隧道区（隧道二极管），在控制栅与源极之间的电压（实际是在电场）VG的作用下，电荷通过隧道流向浮空栅，实现写入 若VG的极性相反，则使电荷从浮动栅流向源极，即起擦除作用。编程与擦除所用的电流是极小的，可用普通的电源供给    结构示意\n为了提高擦、写的可靠性，并保护隧道区超薄氧化层，在E^2^PROM的存储单元中除Flotox管外还附加了一个选通管T~2~。右图中的T~1~为Flotox管（也称为存储管），T~2~为普通的N沟道增强型MOS管（也称为选通管）\n  工作过程\n 读出  字线加高电平使选通管T~2~导通 T~1~管浮置栅没充负电荷 → T~1~管导通 → 在位线上读出“0”（低电平） T~1~管浮置栅充有负电荷 → T~1~管截止 → 在位线上读出“1”（高电平）   写入  使写入为“0”的存储单元的T~1~管浮置栅放电 控制栅G~C~为0电平 同时在字线和位线上加**+20V左右、宽度约10ms的脉冲电压** 浮置栅存储电荷通过隧道区放电，使T~1~管开启电压降为0V左右，成为低开启电压管   擦除  控制栅、字线施加+20V左右、宽度约10ms脉冲电压，漏区接0电平 浮置栅存储的负电荷，使Flotox管的开启电压提高到+7V以上 读出时控制栅上电压只有+3V，故T~1~管不导通。一个字节擦除后，所有的存储单元均为1状态      典型芯片\n E^2^PROM的主要产品有：  早期的高压编程芯片，如：2816、2817\u0026hellip; 低压编程芯片，如：2816A、2817A、2864A\u0026hellip; “大容量”28010(1M位，128KB)、28040(4M位)等   主要技术指标  读取时间120~250ns 字节擦写时间10ms左右 写入时间与字节擦写时间相当，约10ms左右    举例：2816芯片\n  基本特点\n 2 K×8 位的E^2^PROM 24脚DIP封装 2816为双向数据线，以适应读写工作模式 2816的读取时间为250ns，可满足多数微处理器对读取速度的要求 最突出的特点是可以字节为单位进行擦除和重写 擦或写用CE#和OE#信号加以控制，一个字节的擦写时间为10ms 2816可整片进行擦除，整片擦除时间也是10ms 无论字节擦除还是整片擦除均在机内进行    工作方式选择表\n   方式/引脚 CE# OE# V~PP~/V 数据端功能     读 低 低 +4V~+6V 输出   备用 高 × +4V~+6V 高阻   字节擦除 低 高 +21V 输入为高电平   字节写 低 高 +21V 输入   片擦除 高 +9~+15V +21V 输入为高电平   擦写禁止 低 × +21V 高阻      2816读方式\n 允许CPU读取2816的数据 发出地址信号以及相关的控制信号 CE#、OE#信号有效 延时读取，有效数据出现在总线上    2816写方式\n 以字节为单位的擦除和写入是同一种操作，即均为写 字节擦除与写入  CE#为低电平 OE#为高电平 数据线为字节数据 V~PP~端输入编程脉冲，宽度最小为9ms，最大为70ms，电压为+21V 字节擦除是固定写“1”，数据输入是TTL高电平      2816片擦写方式\n 两种擦除方式：片擦除、字节擦除 CE#为高电平 OE#引脚电压达+9～+15V V~PP~接+21V编程脉冲 数据输入引脚置为TTL高电平 约经10ms，整片内容全部被擦除，即2KB的内容全为FFH    2816备用方式\n 进入备用状态，输出呈高阻态 CE#端加TTL高电平 OE#控制无效 备用状态下，其功耗可降到55％      快闪存储器Flash\n  简介\n 快闪存储器，常称为闪存，也称快擦写存储器，简称Flash Memory 闪存是一个笼统的称呼，准确地是指具有快速擦写和非易失等特性的存储器件 与普通存储芯片不同，闪存内部通常还带有多个寄存器和内部控制逻辑，可以编程选择闪存的工作方式和操作内容 由于闪存的存储密度（容量）大、非易失、存取速度快等特点，成为各个主要半导体厂商争先恐后的研发重点，新技术、新材料和新产品不断涌现 除了半导体以外，采用新型材料作为存储介质的全新一代闪存也在不断涌现、发展和完善之中    工作原理\n 目前常见的半导体闪存工作原理类似于E^2^PROM，采用MOS工艺  浮空栅保存有电荷 → 源、漏极之间形成导电沟道 → 稳定状态 → 保存信息“0” 浮空栅没有电荷 → 源、漏极之间无法形成导电沟道 → 稳定状态 → 保存信息“1”      Flash与E^2^PROM的区别\n  Flash没有选通管T，因此集成度高，容量大，但稳定性和擦写次数都不如E^2^PROM\n  E^2^PROM可按位擦除，Flash只能按块（或按页或行）擦除\n    Flash的缺陷：由于闪存写入时有“突破氧化膜”这一剧烈动作，不仅限制了写入速度，而且随着反复的写入，氧化膜出现老化。NOR和NAND闪存可擦写次数分别限制在10万次和100万次左右\n    工作方式\n 读出：源极V~SS~接地，字线为5V逻辑高电平 写入：利用雪崩注入法。源极V~SS~接地；漏极接6V；控制栅12V脉冲，宽10s 擦除：利用隧道效应。控制栅接地；源极接+12V脉冲，宽为100ms。用于片内所有叠栅管的源极都连在一起，所以一个脉冲就可以擦除全部单元    分类\n 基于MOS工艺的闪存从结构上就有：AND、NOR、NAND、DiNOR等类型，其中NAND和NOR是目前的主流类型 快闪存储器Flash分为NAND flash和NOR flash二种 NAND flash的擦和写均是基于隧道效应，电流穿过浮置栅极与硅基层之间的绝缘层，对浮置栅极进行充电（写数据）或放电（擦除数据） NOR flash擦除数据是基于隧道效应（电流从浮置栅极到硅基层），但在写入数据时则是采用热电子注入方式（电流从浮置栅极到源极）    NOR型闪存\n N是NOT，含义是浮置栅中有电荷时，读出‘0’，无电荷时读出‘1’，是一种‘非’的逻辑；OR的含义是同一个位线下的各个基本存储单元是并联的，是一种‘或’的逻辑 NOR型闪存读写和存储格式与内存相近，其基本存储单元是bit，有独立的地址线和数据线，可按位随机读取 NOR型闪存的特点之一是芯片内执行，应用程序可以像访问内存一样使用闪存 NOR型闪存读操作的传输效率很高，在1～4MB的小容量时具有很高的成本效益。适合存储程序及相关数据 闪存的写入操作只能在空（存储“0”）或已擦除的单元内进行。虽然可以按位读取，但其擦除只能按“块”进行，所以写入和擦除速度较慢，影响了它的性能。NOR型闪存另一个的缺点是容量小，成本较高 允许单字节编程但不能单字节擦除 手机中存放电话簿、短信和通话记录的是NOR型闪存    NAND型闪存\n N是NOT，含义是浮置栅中有电荷时，读出‘0’，无电荷时读出‘1’，是一种‘非’的逻辑；OR的含义是同一个位线下的各个基本存储单元是并联的，是一种‘或’的逻辑 NAND型闪存的优点是存储密度和存储容量大 NAND型闪存也需要先擦除再写入，擦除和写入是以块或者页为单位进行的，一个块包含了若干页，每一页的有效容量是512字节的倍数  有效容量指数据存储可用容量，此外还有m×16字节的空闲字节，用(n×512+m×16)Byte表示。2GB以下多是每页(512+16)字节，32页组成一个块（16KB）；2Gb以上页容量扩大到（2048+64）字节，64页组成一个块（128KB）。空闲字节可用于ECC和磨损均衡      3.2.3. 存储芯片的性能指标 存储容量\n在一个存储器中容纳的存储单元总数通常称为该存储器的存储容量\n存储容量可以用位数、字数或字节数来表示\n以位数表示的存储器芯片容量计算：存储器芯片容量＝单元数×数据线位数\n 例如，设地址线位数为n，数据线位数为m，则：  编址单元总数为：2^n^ 存储器芯片容量为：2^n^×m    存储器芯片是以存储1位二进制数（bit）为最小单位\n存放一个机器字的存储单元，通常称为字存储单元，相应的单元地址叫字地址。而存放一个字节的单元，称为字节存储单元，相应的地址称为字节地址\n如果计算机中可编址的最小单位是字存储单元，则该计算机称为按字编址的计算机。如果计算机中可编址的最小单位是字节，则该计算机称为按字节编址的计算机\n一个机器字可以包含数个字节，所以一个存储单元也可以包含数个能够单独编址的字节地址\n虽然微型计算机的字长已经达到16位、32位，甚至64位，但其内存仍以一个字节为一个单元\n计算机存储单位换算表：\n   中文单位 中文简称 英文单位 英文简称 进率（Byte=1）     位 比特 bit b 0.125   字节 字节 Byte B 1   开字节 开 KiloByte KB 2^10^   兆字节 兆 MegaByte MB 2^20^   吉字节 吉 GigaByte GB 2^30^   太字节 太 TeraByte TB 2^40^   拍字节 拍 PetaByte PB 2^50^   艾字节 艾 ExaByte EB 2^60^   泽字节 泽 ZettaByte ZB 2^70^   尧字节 尧 YottaByte YB 2^80^   布字节 布 BronteByte BB 2^90^    存取时间和存取周期\n  存取时间（访问时间）T~a~\n 存取时间称存储器访问时间，是指从启动一次存储器操作到完成该操作所经历的时间。如，从一次读操作命令发出到该操作完成，将数据读入数据缓冲寄存器为止所经历的时间 超高速存储器的存取时间小于20ns、中速100～200ns之间、低速300ns以上    影响T~a~的因素\n 不同存储器芯片，存取速度不同 只读存储器还是随机存储器 芯片的位容量，表示存储功能的指标 功耗，CMOS器件功耗低，速度慢 HMOS存储器件在速度、功耗和容量方面进行了折中 价格，存储器的价格，包括附加电路的价格    存取周期T~M~\n 存取周期是指连续启动两次独立的存储器操作（如连续两次读操作）所需间隔的最小时间。通常，存取周期略大于存取时间    其他指标\n 数据传送速率（频宽）B~M~  数据传送速率，指单位时间内能够传送的信息量 若系统的总线宽度为W，则B~M~=W/T~M~（b/s） 例如，若W=32位，T~M~=100ns，则  B~M~=32位/(100×10^-9^s)=320M位/s=40MB/s 若T~M~=40ns，则B~M~=100MB/s     体积与功耗  便携式微机，其便携性能和续航时间尤为重要，因而对体积、功耗非常敏感   可靠性  采用平均故障间隔时间MTBF衡量，即两次故障之间的平均时间间隔 MTBF=1/λ λ为故障率，表示单位时间内故障次数    3.3. 内存条性能的改进 内存条的特点：\n 扩展性：早期，计算机将内存芯片直接固化在线路板上。由于无法拆卸更换，要进行内存的扩展非常麻烦。这对于计算机的发展造成了阻碍。随着软件规模的扩大，以及新的硬件平台对扩展性提出了更高的要求，迫切需要提高运行速度和扩大内存容量 互换性：不同的系统采用同样的内存，降低系统成本 灵活性：针对不同的系统规模，要求内存以更加灵活的方式配置 可维护性：通过标准化，使得内存通用，提高维护效率，降低维护成本  3.3.1. 内存条的组成 graph LR\r内存条 --\u0026gt; 内存颗粒\r内存条 --\u0026gt; PCB电路板\r内存条 --\u0026gt; SPD芯片\r内存条 --\u0026gt; 引脚/俗称金手指\r内存条 --\u0026gt; 阻容元件\r内存颗粒\n  内存芯片称为内存颗粒\n  芯片封装：TSOP(Thin Small Outline Package）和BGA(Ball-Gird-Array）\n  TSOP：引脚由四周引出\n  BGA：引脚由芯片中心方向引出\n  有效缩短信号的传导距离，使信号衰减减少，更加快速有效的散热\n  在相同容量下，体积只有TSOP封装的三分之一\n      根据内存条容量，集成数量不等的内存颗粒\n  SPD芯片\n SPD（Serial Presence Detect）是一片E2PROM，记录内存条出厂时预先存入的速度、工作频率、容量、工作电压、行/列地址带宽、传输延迟、SPD版本等基本参数 开机时BIOS自动读取SPD记录信息，对主存进行设置，使内存运行在规定的工作频率，工作在最佳状态  PCB电路板\n 内存条的PCB采用4层或6层电路板  紧凑，减小电路板体积 分层屏蔽电路，减少电磁辐射，电源和地用单独的层有利于信号完整性    引脚/金手指\n 金手指就是内存条电路板上的引脚，用于与计算机总线连接，也是内存条在主板上进行固定的装置，并连接总线上的有关信号线 按照引脚布局，常用的内存条有：SIMM（single in-line memory module）、DIMM（Dual In-line Memory Module）、SODIMM（Small Outline Dual In-line Memory Module）等  排阻和电容\n 用于提高信号完整性，如防止信号反弹、滤除高频干扰等  3.3.2. 内存条的演变 graph LR\rSIMM --\u0026gt; FPM_DRAM\u0026amp;EDO_DRAM --\u0026gt; SDR_SDRAM --\u0026gt; RDRAM --\u0026gt; DDR_SDRAM五代\r  SIMM\n 最初的内存是直接以DIP封装芯片的形式安装在主板的DRAM插座上 最早的30脚SIPP（Single In-line Pin Package）接口，针脚的定义与30脚SIMM一样。SIPP很快就被SIMM取代，两侧金手指传输相同的信号 早期的内存频率与CPU外频不同步，采用异步DRAM。可细分为FPM DRAM（Fast Page Mode DRAM）、EDO DRAM（Extended Data Out DRAM），常见接口为30脚SIMM与72脚SIMM，工作电压都是5V 第一代SIMM内存为30个引脚，单根内存数据总线为8位，用在16位数据总线处理器上需要两根，用在32位数据总线处理器上则需要四根 随后出现了72脚SIMM内存，单根内存位宽增加到32位，一根就可以满足32位数据总线处理器，拥有64位数据总线的奔腾处理器则需要两根    FPM DRAM \u0026amp; EDO DRAM\n 传统DRAM的访问，需要经过“发送行址—发送列址—读写数据”3个阶段，一次访问时间是每个阶段所需时间之和 FPM（Fast Page Mode，快速页面模式）对地址连续（列址相同）的多个单元进行读写访问。除访问第一个数据之外，后续访问只需要经历“发送行地址—读写数据”2个阶段，从而缩短了访问时间 EDO（Extended Data Out，扩展数据输出）是对传统DRAM存取技术的改进。它取消了主板与内存两个存储周期之间的时间间隔，每隔2个时钟脉冲周期传输一次数据，大大地缩短了存取时间。在输入下一个行地址时，仍然允许数据输出进行，扩展了数据输出的时间，“EDO”因此得名    SDR SDRAM (Single Data Rate SDRAM)\n SDRAM（Synchronous DRAM，同步动态随机存取内存） 传统DRAM采用“异步”的方式进行存取，存储器的吞吐速率受限从而导致系统性能难以提高 SDRAM采用同步方式进行存取。送往SDRAM的地址、数据和控制信号都在一个时钟信号的上升沿被采样和锁存，SDRAM输出的数据也在另一个时钟上升沿锁存到芯片内部的输出寄存器 SDRAM收到地址和控制信号之后，在内部进行操作。在此期间，处理器和总线主控器可以处理其它任务（例如，启动其它存储体的读操作），无需做无谓等待，从而提高了系统性能 输入地址、控制信号到数据输出所需的时钟个数可以通过对芯片内“方式寄存器”的编程来确定 SDRAM芯片支持“突发总线模式（Burst）”进行读写操作。当对一组相邻的存储单元进行访问时，第一个地址给出后，后续地址自动生成，无需再发，可以进行连续读写，大大提高了速度  SDRAM增加了时钟信号和内存命令的概念。内存命令的类型取决于时钟上升沿上的CE#、RAS#、CAS# 和WE#信号状态 SDRAM工作电压为3.5V，采用168线带两个缺口的DIMM插槽。早期时钟频率为66M，后来多为133M，可进行64位的读写。产品规格用时钟频率表示，如pc100或pc133表示其时钟频率为100M或133M SDRAM的存在时间相当长，Intel奔腾2、奔腾3与奔腾4，以及Slot 1、Socket 370与Socket 478的赛扬处理器，AMD的K6与K7处理器都可使用SDRAM内存条      RDRAM (Rambus DRAM)\n Intel与Rambus合作并推出了Rambus DRAM内存条以代替SDR SDRAM，简称为RDRAM 与SDRAM不同，采用了新的高速简单内存架构，减少数据复杂性，提高整个系统性能  RDRAM内部引入了RISC，依靠高时钟频率来简化每个时钟周期的数据量   RDRAM采用RIMM（Rambus In-line Memory Module）插槽，184脚，总线位宽16位，插两条组建双通道时就是32位，工作电压2.5V，频率有600、700、800、1066MHz等  RIMM与DIMM的外型尺寸差不多，金手指同样也是双面的   RDRAM内存条通常都是用在Socket 423的奔腾4平台上，搭配Intel 850芯片组使用。由于RDRAM的制造成本高，使得RDRAM的价格居高不下。同时由于奔腾4平台的成本相对较高，最终导致RDRAM被DDR SDRAM替代    DDR SDRAM (Double Data Rate SDRAM)\n DDR（Double Data Rate）SDRAM（双倍速率同步内存），原来的SDRAM被称为SDR SDRAM SDR仅在时钟脉冲的上沿进行一次写或读操作，DDR内部有两个乒乓交替工作的存储体，还有2bit的预取缓冲，可在时钟上沿和下沿都进行一次对等的写或读操作，至少在理论上DDR的数据传输能力比同频率的SDR提高了一倍 DDR内存条的工作电压是2.5V，共有184线，金手指只有一个“缺口”  DDR工作频率有100/133/166/200/266MHz等。所谓双倍速率就是传输速率是工作频率的两倍，因此型号上所标识的是工作频率×2，即标称为DDR200、266、333、400和533，容量128/256/512MB等，主要用于P4级别的64位PC机 DDR内存条最初只有单通道，后来出现了支持双通芯片组，让内存的带宽直接翻倍，两根DDR-400内存条组成双通道，可以满足FBS800MHz的奔腾4处理器  能用DDR内存条的CPU很多，除Intel与AMD外，还有NVIDIA、VIA、ALI、ATI等厂家        DDR2 SDRAM\n DDR2内存采用了4bit预读取（类似于快餐店里的备餐）技术，数据通过四条线路串行传输到I/O缓存区，使工作频率为100MHz的内存可实现400MHz的数据传输频率，因此称为DDR2-400，其带宽为（100MHz×4）×（64b/8b）=3200MB/s=3.2GB/s 数据预取以及多路串行传送，实际数据传送速率相同时的功耗更低；或同样的功耗下拥有更快的传送速率  DDR2有240个金手指，DDR是184个，两者的防呆缺口位置不同 DDR2采用CAS、OCD、ODT等技术提高信号完整性 DDR2的标准电压下降至1.8V，相较上代产品更为节能 DDR2的频率从400MHz到1200MHz，主流的是DDR2-800 容量从256MB至最大4GB，4GB的DDR2内存条应用很少 DDR2在2004年6月与Intel的915/925主板同步推出，伴随了大半个LGA 775时代      DDR3 SDRAM\n  在DDR2基础进一步改进为8位预取，如100MHz的DDR3-800，带宽可达到: （100MHz×8）×（64b/8b）＝6.4GB/s\n  预存比特数 vs 数据传送速率\n 提高预存比特数需要将I/O控制器的频率再次翻倍，并且增加数据线数量，在I/O芯片频率已经很高时，技术难度和成本都会大幅增加    其他特性\n DDR3的工作电压1.5V，240线，容量512MB和1/2/4/8GB，单条16GB的DDR3内存比较少。 DDR3还采用CWD、Reset、ZQ、STR、RASR等新技术，让内存在休眠时也能够随着温度变化去控制对内存颗粒的充电频率，以确保系统数据的完整性。 DDR3内存条随着Intel在2007年发布3系列芯片组一同到来。 支持DDR3内存的平台有Intel后期的LGA 775主板P35、P45、x38、x48等，LGA 1366平台，LGA 115x系列全都支持。还有LGA 2011的x79，AMD方面AM3、AM3＋、FM1、FM2、FM3接口的产品均支持DDR3      DDR4 SDRAM\n DDR4是目前的主流，相比DDR2和DDR3有以下几项关键技术  Bank Group架构。使用2个或4个可选择的采用8n预取的Bank Group分组，每个Bank Group可以独立读写数据，如果是2个独立的Bank Group，相当于将内存预取值提高到了16n，如果是4个独立的Bank Group，则等效的预取值提高到了32n。 点到点传输。每个通道只连接一根内存条，消除了共享传输带来的性能瓶颈。 3D堆叠。在散热允许情况下，采用3D堆叠封装技术，使得单根内存条的容量从目前8GB提高到64GB。 其他技术变化  DDR4功耗明显降低，电压达到1.2V，传输速度从2133 MT/s起，最高可达4266 MT/s DDR4增加了DBI（Data Bus Inversion，数据总线反转）、CRC（Cyclic Redundancy Check，循环冗余校验）、CA parity等功能，增强了信号的完整性、改善数据传输及储存的可靠性        DDR5 SDRAM\n 主导内存标准制定的JEDEC（Joint Electron Device Engineering Council）规范组织，虽然之前宣布2018年正式发布DDR5标准，但实际上并没有，最终规范要到2020年才能完成。 DDR5主要特性是芯片容量，而不仅仅是更高的性能和更低的功耗。  内存带宽在DDR4基础上翻倍，从8位翻倍到16位。 频率最低4800MHz，最高6400MHz。 电压则从1.2V降至1.1V，功耗减少30%。 每个模块使用两个独立的32/40位通道，支持ECC（Error Correcting Code）。   此外，DDR5将具有改进的命令总线效率，更好的刷新方案以及增加的存储体，以获得额外的性能，提高总线效率    小结：\n 传统DRAM访问，“发送行址—发送列址—读写数据”3个阶段 FPM DRAM：访问地址连续的多个单元，不发送列址 EDO DRAM：在输入下一个行地址时，仍然允许数据输出进行 SDR SDRAM：采用同步方式，支持Burst模式 Rambus DRAM：简单内存架构，减少复杂性，提时钟频率 DDR SDRAM：在时钟上沿和下沿都进行一次写或读操作 DDR2 SDRAM：4bits预读取 DDR3 SDRAM：8bits预读取 DDR4 SDRAM：Bank Group架构、点到点传输、3D堆叠 DDR5 SDRAM：预期2020年才能完成规范  3.4. 存储系统的层次架构 3.4.1. 存储系统的分层管理  完整的四级结构  寄存器+Cache+主存+辅存（联机、脱机外存）   存储系统的基本特点  存储系统是指计算机中由存放程序和数据的各种存储设备、控制部件及管理信息调度的设备（硬件）和算法（软件）所组成的系统 存储系统的性能在计算机中具有非常重要的地位，存储管理与组织的好坏影响到整机效率。主要因为冯·诺伊曼体系结构是建筑在“存储程序”概念基础上，访存操作约占中央处理器70%左右的时间   存在的问题  存储器的存取速度在不断提高，但相比较而言，主存增速与CPU增速不同步。 指令执行期间多次访问存储器。频繁的存储器访问，导致占用大量的CPU运行时间。 主存储器（内存）存放当前正在执行的应用程序及数据，但难以同时满足存取速度快、存储容量大和成本低的要求。 在早期计算机系统中，程序员会直接对主存储器的物理地址进行操作，这种编程方式的缺陷是，当程序出现寻址错误时，可能会导致整个系统崩溃，一个进程出现寻址错误时也可能会导致另一个进程崩溃   虚拟存储器的意义  特点  允许用户程序使用比实际主存空间大得多的空间来访问主存 每次访存都要进行虚实地址转换   提供三个重要能力  将主存看成是一个存储在磁盘上的地址空间高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，高效使用主存 为每个进程提供一致的地址空间，从而简化存储器管理 保护每个进程的地址空间不被其他进程破坏   解决三个根本需求：  确保可以运行存储空间需求比实际主存储容量大的应用程序 确保可执行程序被装载后占用的内存空间是连续的 确保同时加载多个程序的时候不会造成内存地址冲突      3.4.2. 虚拟存储器与地址映射 虚拟存储器简介\n  虚拟存储器思想的诞生\n 问题：应用程序太大以至于内存容纳不下该程序 简单解决方法：程序分割覆盖块片段，程序员需要对代码进行分割 更好的解决方法：虚拟存储器    虚拟存储器的基本思路\n 程序，数据，堆栈的总的大小可以超过物理存储器的大小，操作系统把当前使用的部分保留在内存，而把其他未被使用的部分保存在磁盘上 例如一个16MB的程序和一个内存只有4MB的机器，操作系统通过选择，可以决定各个时刻将哪4MB的内容保留在内存中，并在需要时在内存和磁盘间交换程序片段，这样就可以把这个16M的程序运行在一个只具有4M内存机器上了。而这个16M的程序在运行前不必由程序员进行分割      Cache与虚拟内存的异同\n 相同点：  两者都有利于提高存储系统的性能。 均基于程序局部性原理。一个程序运行时，只会用到程序和数据的一小部分，仅把这部分放到比较快速的存储器（内存）中，其他大部分放在速度低、价格低、容量大的存储器中   不同点  在虚拟存储器中未命中的性能损失要远大于Cache系统中未命中的损失。因为主存和Cache的速度相差5~10倍，而外存和主存的速度相差上千倍 Cache主要解决主存与CPU的速度差异问题，而虚存主要解决内存容量问题 CPU与Cache和主存之间均有直接访问通路，Cache不命中时可直接访问主存。而虚存所依赖的辅存与CPU之间不存在直接的数据通路，当主存不命中时只能通过调页解决，CPU最终还是要访问主存 Cache的管理完全由硬件完成，对系统程序员和应用程序员均透明。而虚存管理由软件（操作系统）和硬件共同完成，虚存对实现存储管理的程序员是不透明的（段式和段页式管理对应用程序员”半透明“）      虚拟地址与物理地址\n  概念\n 任何计算机上都存在一个程序能够产生的地址集合，称之为地址范围。这个范围的大小由CPU的位数决定，例如一个32位的CPU，它的地址范围是0~0xFFFFFFFF (4G)。我们把这个地址范围称为虚拟地址空间，该空间中的某一个地址我们称之为虚拟地址 与虚拟地址空间和虚拟地址相对应的则是物理地址空间和物理地址，例如，对于一台内存为256MB的32bit x86计算机而言，它的虚拟地址空间范围是0~0xFFFFFFFF(4GB)，而物理地址空间范围是0x000000000~0x0FFFFFFF（256MB） 在没有使用虚拟存储器的机器上，虚拟地址被直接送到内存地址总线上，使具有相同地址的物理存储器被读写    虚拟地址与物理地址之间需要映射\n 在使用了虚拟存储器的情况下，虚拟地址不是被直接送到内存地址总线上，而是送到内存管理单元MMU。MMU由一个或一组芯片组成，其功能是把虚拟地址映射为物理地址 MMU是一种负责处理CPU内存访问请求的计算机硬件。它的功能包括虚拟地址到物理地址的转换、内存保护、CPU高速缓存控制等    虚拟存储器地址映射方式\n 虚拟存储器利用大容量的外存来扩充内存，产生一个比实际内存空间大得多的、逻辑的虚拟内存空间，简称虚存  例如，Windows操作系统下，虚拟内存在硬盘上就是为一个很大的隐藏文件文件，文件名是PageFile.Sys。虚拟内存有时候也被称为是“页面文件”就是从这个文件的文件名中来的   一般情况下，程序代码是保存在虚存。但是当代码需要运行的时候就必须将其装入内存，要将虚存地址以一定的规则转换成物理地址 虚存的地址变换，分三种：段式，页式，段页式      段式虚拟存储器\n  简介\n 段式存储管理是一种把主存按段分配的存储管理方式，主存与辅存间信息传送单位是不定长的段  段：按照程序的自然分界划分的长度可以动态改变的区域。通常可把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段      地址变换\n 多用户虚地址是由用户号U，段号S，和段内偏移地址D组成 虚地址和物理地址之间通过段表（存放于主存储器）来映射，CPU中会有一个段表基址寄存器，段表记录段号、段长、起始地址，从基址寄存器能够直接读出段表的起始地址。 通过用户号U查找到对应的基址寄存器，基址寄存器的起始地址加上虚地址的段号，就能找到段表地址A~s~ 如果所访问的段在内存中，则从段表中给出的起始地址，加上虚地址的偏移量，则得到物理地址（主存实地址）    段式存储管理的优点\n 段的分界与程序的自然分界相对应，使得段易于编译、管理、修改和保护，也便于多道程序共享    段式存储管理的缺点\n 容易在段间留下许多空余的存储空间碎片 段式存储管理还存在交换性能较低的问题。因为辅存的访问速度比主存慢得多，而每一次交换，都需要把一大段连续的内存数据写到硬盘上，导致了当内存交换一个较大的段时，会让机器显得卡顿    页式虚拟存储器\n  简介\n  页式存储管理是一种把主存按页分配的存储管理方式，主存与辅存间信息传送单位是定长的页\n    地址映射\n 将一个进程的地址空间划分成若干个大小相等的区域（页） 对应地主存空间划分成与页同样大小的若干个物理块 在为进程分配主存时，将进程中若干个页分别装入多个不相邻的块中  graph LR\r划分地址空间 --\u0026gt; 分配主存\r划分主存空间 --\u0026gt; 分配主存\r\r  地址转换\n 用户虚地址，由用户号U，虚页号P，和页内偏移地址D组成 页表用来记录页号和主存页号 CPU中的基址寄存器存放页表的基地址。和段表一样，用户号U会通过基址寄存器找到页表起始地址，起始地址与虚页号相加，再与偏移地址拼接就得到物理实地址 由于页的大小一样，故它在虚地址中某一页的偏移量和主存中某一页的偏移量相同    特点\n 对比段式虚拟存储，管理的粒度更细，所以造成内存页碎片浪费也会小很多 但页不是程序独立模块对应的逻辑实体，处理、保护和共享都不如段方便 页要比段小得多，如Linux操作系统采用页式存储管理，页的默认设置为4KB，所以页在进行交换时，相比段交换卡顿有所缓解 加载程序的时候，无需一次性把程序加载到内存，而是在程序运行中需要用到的对应虚拟内存页里面的指令和数据时，再加载到内存中，由操作系统完成 当CPU要读取特定的页，但却发现页的内容没有加载时，就会触发一个来自CPU的缺页错误（Page Fault）。操作系统会捕获这个错误，然后找到对应的页并加载到内存中。通过这种方式，使得可以运行那些远大于实际物理内存的程序，但相对的执行效率也会有所下降    段页式虚拟存储器\n  简介\n 段页式虚拟存储器，先将用户程序按程序的逻辑关系分为若干个段，并为每一个段赋予一个段名，再将每一个段划分成若干页，以页为单位离散分配 段页式虚拟存储器充分利用段式和页式两种虚拟存储器在管理主存和辅存空间的优点，提高了主存利用率    地址转换\n 虚地址，由用户号U，段号S，虚页号P，页内偏移D组成 段表，记录页表长度和页表地址 页表用来记录页号和主存页号 先通过U在段表基址寄存器中找到段表基地址，然后和段号S相加，得到页表起始地址和页表长度，通过页表找到主存实页号再与偏移量拼接，得到物理地址 如果要访问的地址不在内存中，就会需要调入一页或一段到主存中    3.5. 高速缓冲存储器Cache 3.5.1. 高速缓冲存储器Cache的原理 Cache的意义\n 在CPU的所有操作中，存储器的存取访问是最频繁的操作 CPU的运行速度比大容量DRAM存储器的存取速度高得多 存储器的访问速度低是制约计算机系统性能的关键因素  CPU与DRAM的发展现状\nCPU和主存储器的速度总是有差距，CPU的发展一直是提高速度为核心目标；主存的发展则一直以提高容量为核心目标\n程序访问的局部性原理\n  程序在一定时间段内通常只访问较小的地址空间\n  两种局部性：时间局部性和空间局部性\n 时间局部性：最近访问的信息很可能再次被访问 空间局部性：最近访问信息的邻近信息可能被访问    在主存与CPU之间设置Cache\n  思想：根据程序访问的时空局部性，把经常访问的代码和数据保存到高速缓冲存储器（Cache)中，把不常访问的代码和数据保存到大容量的相对低速DRAM中，尽量减少CPU访问DRAM的概率，在保证系统性能的前提下，降低存储器系统的实现代价\n  实现：Cache设置在CPU与主存储器之间，通常采用存取速度快并且无需刷新的SRAM来实现\n 根据时间局部性：将最近被访问的信息项装入到Cache中 根据空间局部性：将最近被访问的信息项的邻近信息也装入到Cache中    在主存和CPU之间设置了Cache之后，如果当前正在执行的程序和数据存放在Cache中，则当程序运行时不必再从主存储器读取指令和数据，而只需访问Cache即可\n  使用场合：CPU与主存之间、显示系统、硬盘和光驱，以及网络通讯中\n  Cache的基本运行原理\n  当CPU访问主存时，给出的地址同时送往Cache。首先检查Cache，如果要访问的数据已经在Cache中，则CPU就能很快完成访问，这种情况称为Cache“命中”（Cache hit）\n$$\n命中率=\\frac{命中次数}{访问次数（即总线周期数）}\\times 100 %\n$$\n  否则，CPU就必须从主存中提取数据，称为Cache“未命中”（Cache miss）\n  如果组织的好，那么程序所用的大部分的数据都可在Cache中找到。Cache的“命中率”（hit rate）和Cache的容量大小、控制算法和组织方式等有关，当然还和所运行的程序有关\n  Cache的“命中率”通常应在90%以上。某些组织较好的Cache系统，命中率可达95%（例如早期IBM 360可达99%）\n  Cache的组织方式\n Cache的基本单元称为行或区块，其中包括：  数据字段：保存从主存单元复制过来的数据，单位是（区）块。每个区块的大小为4~128字节，典型的Cache line通常的大小为32或64字节 标志字段：保存数据字段在主存中的地址信息，又称为地址标记寄存器，记为Tag 有效位字段：标识区块和Tag是否有效   在Cache系统中，主存是以区块为单位映象到Cache中。以CPU读取一个字节的数据为例，如果所需字节不在Cache中，在CPU从内存中读取数据的同时，Cache控制器将把该字节所在的整个区块从主存复制到Cache  Cache的管理\n 主存和Cache都会采用**分Cache Line（也称字块）**的方式进行管理，Cache中保存的就是对应的主存字块的一个副本。每一个Cache字块都会有一个标记位，用于表示当前字块里存放的是哪一个内存字块的副本。通过这个标记位，CPU就可以判断出希望访问的内存字块是否已经存在于Cache中 当Cache已经用满，但主存还需将新的字块调入Cache时，就会执行一次Cache字块的替换。这种替换应遵守一定的规则，最好使得被替换的字块是下一个时间段内估计最少使用的。这种规则称为替换策略或替换算法，由替换部件实现 当程序对Cache字块执行写入时，如何保证Cache字块和内存字块的一致性。通常的有两种写入方式：一个是先写Cache字块，待Cache字块被替换出去时再一次性写入内存字块；再一个是在写Cache字块的同时也写入内存字块  Cache管理的基本问题\n Cache中存放近期需要重复运行的指令数据，形成主存储器内容的副本。CPU首先从副本中读取数据，只有Cache中没有所需的数据时或Cache中已满时，才直接访问内存。从而提高CPU对存储器的访问速度。 Cache和主存储器一起构成一级存储器。高速缓冲存储器和主存储器之间信息的调度和传送由硬件自动进行。 高速缓冲存储器Cache，需要解决两个问题：一是主存地址与缓存地址的映像及转换；二是按一定原则对Cache的内容进行替换。  依靠专门的硬件实现，Cache对CPU和程序员而言是透明的    3.5.2. 高速缓冲存储器Cache的基本结构 计算机的Cache系统基本组成\n Cache模块（SRAM） 主存（DRAM） Cache控制器  Cache的基本结构\n  Cache由Cache Tag、Tag存储体和Cache控制器三部分组成\n  Cache Tag主要用来记录Cache存储体中数据的位置，判断Cache内数据是否命中\n  Cache存储体主要用来存储片外数据，方便处理器直接调用\n  Cache控制器由主存地址寄存器、Cache地址寄存器，主存-Cache地址变换部件及替换控制部件等四部件组成。Cache控制器控制整个Cache的具体工作，决定了Cache的工作效率\n 主存地址寄存器，存放主存的页号、块号、字号或者块内偏移地址等信息，具体包括哪些信息决定于所采用的地址映射方式 Cache地址寄存器，存放所要映射的Cache的页号、块号、字号或者块内偏移地址等信息，具体包括哪些信息决定于所采用的地址映射方式 地址变换部件，建立目录表以实现主存地址到缓存地址的转换 替换控制部件，在缓存已满时按一定策略进行数据块替换，并修改地址变换部件  注意：地址寄存器中存放的信息不是直接地址，要得到地址信息必须通过地址变换部件按地址映射方式进行变换\n    Cache控制器的控制行为\n Cache控制器控制主存和Cache间的数据传输  CPU发出数据读（写）请求后，Cache控制器先将这个请求转向Cache存储器 若数据在Cache中，就对Cache进行读（写）操作，称为一次命中 若不在Cache中，CPU就对主存操作，称为一次脱靶，这时CPU必须在其总线周期中插入等待周期T~w~   Cache控制的特点  Cache对于CPU和用户程序都是透明的，即CPU和程序不知道它的存在 主存-Cache地址变换部件，以判断CPU要寻访的数据是否在Cache中 主要包含一个相联存储器，能在Cache控制器管理下，按照一定的地址映射关系，动态地在其中构建起一个表格，将Cache中的一个存储块与主存中的若干个存储块对应起来    影响命中率的因素\n影响命中率的因素：Cache容量、存储单元组数目和组大小、地址映射方案、联想比较策略、数据替换算法、写操作处理方法、程序本身特性等\n命中率的计算：\n$$\nh=N_c/(N_c+N_m)\n$$\n 式中，$N_c$和$N_m$是对Cache和主存的存取次数，只有$N_c$足够大，才有$h\\rightarrow 1$ $(1-h)$为丢失率（Miss Rate），访问信息不在Cache中的比率 没有命中的数据，CPU只好从内存获取，并把该数据所在的数据块调入Cache，使以后对整块数据的读写都从Cache中进行，不必再调用内存  3.5.3. 地址映射与转换  地址映射（或称映像）：主存单元的数据在被复制到Cache中的同时，该主存单元的地址，在经过某种函数关系处理后也被写进Tag，这一过程被称为Cache的地址映像 地址变换：CPU读写数据时，把访问主存地址变换为访问Cache的地址，这一过程被叫做Cache的地址变换。再根据地址变换结果对Cache进行检查 按照主存和Cache之间的映像关系，Cache的组织方式分为以下几种：  全相联映像（Fully associative mapping ）：完全随意的对应。 直接映像（Direct mapping）；一对多的硬性对应。 多路组相联映像（Multi-way set associative mapping）:多对多有限随意对应    全相联映射\n  简介\n Cache与主存都分成块(Cacheline)，每块由多个字节组成，大小相等。在一个时间段内，Cache的某块中放着主存某块的全部信息，即Cache的某一块是主存某块的副本(或叫映像) 主存中任意一个块都可以映射到Cache中任意一个块。设Cache共有$2^C$块，主存共有$2^M$块，当主存的某一块j需调进Cache中时，它可以存入Cache的块0、块1、\u0026hellip;、块i、\u0026hellip;或块$2^C-1$的任意一块上    地址变换\n 主存地址到Cache地址的转换是通过查找块表完成 CPU的访主存地址：M为主存的块号，W为块内的字号 CPU访Cache的地址：C为Cache的块号，W为块内的字号 当一个主存块调入Cache中时，会在一个存储主存块号M~j~和Cache块号C~i~映射关系的块表中进行登记。 CPU访问内存时：  根据主存地址中的主存块号M~j~在块表中查找Cache块号C~i~ 若找到，则本次访Cache命中，于是将对应的Cache块号C~i~取出 并与块内字号W一起形成一个访Cache的地址 最后根据该地址完成对Cache单元的访问      特点\n 大多数程序运行时需要访问位于主存不同位置的数据，在全相联映像方式中，主存中的区块可以映像到Cache的任意位置，因此Cache的利用率高 在这种方式中，Cache中区块的位置与在内存的位置没有任何关系。每个区块在主存中的地址需要在Tag中保存。CPU访问主存时，Cache控制器对访问主存的地址与Tag中的地址逐一进行比较，匹配成功才算命中 为保证比较的时效性，若Cache中共有N个区块，则需要有N个比较电路同时并行比较。若主存有2^m^个区块，则有m位区块地址，Tag较长，不仅造成Cache的实际利用率较低，并且比较电路的实现代价太高 优点：Cache存储空间利用率高，不易产生冲突，命中率比较高 缺点：比较和替换策略都需要硬件实现，电路复杂，只适用于小容量Cache。访问相关存储器时，每次都要与全部内容比较，速度低，成本高。因而应用少    直接相联映射\n  简介\n 直接相联映射(Direct-Mapped)方式是将主存空间按照Cache的大小划分为若干页，也称为区，页内分块。主存储器中一块只能映射到Cache的一个特定的块中  主存的某块j只能映射到满足如下特定关系的Cache块i中：$i＝j\\mod2^C$ 例如，主存的第0、2^C^、2^C＋1^、\u0026hellip;块只能映射到Cache的第0块，主存的第1、2^C^+1、2^C＋1^+1、\u0026hellip;块只能映射到Cache的第1块，\u0026hellip;\u0026hellip;，主存的第2^C^-1、2^C＋1^-1、\u0026hellip;2^M^-1块只能映射到Cache的第2^C^-1块      地址变换\n CPU的访主存地址为如下形式：T为标志号，C为Cache的块号，W为块内的字号。在这里，原主存的块号M实际上被分成了两个字段：T和C，其中C用于指出主存的块可以映射的Cache的块（即对2^C^求余后的余数部分），而对于余数相同的不同的主存块来讲，整除2^C^后的商（即T）部分则不相同。在直接相联映射方式下，标志号T是随Cache的每个块一起存储的 CPU送来一个访存地址时  根据该主存地址的C字段找到Cache的相应块 然后将该块标志字段中存放的标志与主存地址的T标志进行比较 若相符，说明主存的块目前已调入该Cache块中，则命中 根据主存地址的W字段合成Cache地址 访问该Cache块的相应单元。若不相符，未命中，使用主存地址直接访主存      特点：\n 直接映象是一种最简单的地址映像方式，其思想是：按照Cache的大小，将主存也分为同样尺寸的若干“页”。主存中位于不同页但是偏移量相同的数据在调往Cache时，只能存放在Cache中具有同样偏移量的位置，Tag只需记录区块在主存的页号 当程序访问不同页但具有相同偏移量的数据时，将不可避免地产生冲突。此时，即使Cache中有其它空闲块，也因为固定的地址映像关系而无法应用 优点：地址映射方式简单，数据访问时，只需检查页号是否相等即可，因而可以得到比较快的访问速度，硬件设备简单 缺点：替换操作频繁。主存每个块在Cache中只有一个对应位置，若另一个块也要调入该位置，将会发生冲突，即使Cache的其它块位置空闲，也不能接受它，导致命中率低    组相联映射\n  简介\n Cache划分成大小相等的组，将总块数为2^C^的Cache分成2^u​^组，每组2^v^块。主存容量是Cache容量的整数倍，将总块数为2^M^​的主存划分为2^s^页，每页2^u^块，即主存每页的大小与Cache的组数相等 主存的块与Cache的组之间采用直接相联映射，而与组内的各块则采用全相联映射。也就是说，主存的某块只能映射到Cache的特定组中的任意一块。主存的某块j与Cache的组k之间满足关系：$k＝j \\mod 2^u$    地址变换\n 主存划分为2^s^页，每页2^u^块，Cache分成2^u^组，每组包含2^v^块  s为主存的页号，u为页内的块号，w是块内地址 u为Cache的组号，v为组内的块号，w是块内地址   Cache的块号C＝u+v，而主存的块号M＝s+u 主存块被调入Cache时，同时将其地址的前s位写入块表的s字段 CPU访问存储器时  根据主存地址中的u字段，找到块表对应的组 然后将该组的所有项的前s位，与主存的s字段比较 若相符，则表明主存块在Cache中，则将该项的v字段取出 再取出主存地址w字段 u+v+w形成Cache地址      特点\n 又称为成组相联映像方式，是以上两种方式的一种折衷方案。主存和Cache之间，既不是硬性的多对一对应，也不是完全的随意对应，而是采用了一种有限度的随意对应 该方案将Cache进行分组（路），例如分成2组或4组。每组采用直接映像方式，以减少比较电路的成本；组与组之间为全相连映像方式，以避免区块位置的冲突。用多组Cache并行提供高速缓存功能 CPU访问内存时，Cache控制器经过两次比较，判断是否命中。这种方式集中了以上两种方式的优点，因此得到了广泛应用 优点：块冲突概率比较低，块利用率大幅度提高，块失效率明显降低 缺点：实现难度和造价要比直接映射方式高    3.5.4. Cache更新与替换策略 读取结构\n 贯穿读出（Look Through）  该方式将Cache隔在CPU与主存之间 CPU对主存的所有数据请求都首先送到Cache，由Cache在其中查找 如果命中，则切断CPU对主存的请求，并将数据送出 不命中，则将数据请求传给主存 优点：降低了CPU对主存的请求次数 缺点：延迟了CPU对主存的访问时间   旁路读出（Look Aside）  CPU同时向Cache和主存发出数据请求 由于Cache速度更快，如果命中，则Cache在将数据回送给CPU的同时，还来得及中断CPU对主存的请求 不命中，则Cache不做任何动作，由CPU直接访问主存 优点：没有时间延迟 缺点：每次CPU都存在主存访问，从而占用一部分总线时间    写入更新策略\n当CPU对Cache数据做了修改之后，应修改主存相应位置内容\n 写通方式（Write Through）  从CPU发出的写信号送到Cache的同时，也写入主存，保证主存的数据能同步更新 优点：操作简单，较好地保持了Cache与主存内容的一致性，可靠性高 缺点：由于主存的慢速，降低了写速度并占用了总线时间，没有发挥Cache高速访问优势   写回方式（Write Back）  更新数据只写到Cache，而主存中的数据不变 在Cache中设置“修改标志位”，Cache中有被修改的数据时，该标志位置“1” 每次Cache有数据更新时，判断该标志位。只有该标志位为1，即Cache中的数据被再次更改而需要换出时，才将原更新的数据写入主存相应的单元中，然后再接受再次更新的数据 优点：克服了写通方式写速度低的问题，有利于提高CPU执行效率 缺点：有Cache与主存数据不一致的隐患，控制也较复杂    替换策略\nCache一个块对应主存多个块，块大小相同。主存数据块装入Cache时，如果相应位置被其他块占用，则必须替换掉旧块，以新块填充\n  随机（Random）替换策略\n 随机确定需要替换的Cache块，不管Cache块过去、现在及将来的使用情况，而随机地选择某块进行替换 优点：方法最简单，易硬件实现，速度快 缺点：被换出的数据可能马上就需要再次使用，增加了映射装入次数，降低命中率和效率    最不经常使用（Least Frequently Used，LFU）替换策略\n 将一段时间内被访问次数最少的块替换出去 每块设置一计数器，从0开始计数，每访问一次，被访块的计数器就增1 需要替换时，将计数值最小的块换出，同时将所有块的计数器清零 优点：方法较简单，较易硬件实现 缺点：统计的是各块两次替换间的访问次数，不能严格反映近期被访问情况。新调入的块很容易被替换出去    先进先出（FIFO）替换策略\n 根据进入Cache的先后次序来替换，先调入的Cache块被首先替换掉 优点：不需要随时记录各个块的使用情况，容易实现，且系统开销小 缺点：一些需要经常使用的程序块可能会被调入的新块替换掉    近期最少使用（Least Recently Used，LRU）替换策略\n 将CPU近期最少使用的块作为被替换的块 需要随时记录Cache中各块的使用情况，以便确定哪个块是近期最少使用的块 为每个块设置一个“未访问次数计数器” 每次Cache命中时，命中块的计数器清0，其它各块的计数器加1 每当有新块调入时，将计数值最大的块替换出去 优点：确保新加入的块保留，还可把频繁调用后不再需要的数据淘汰掉，提高Cache利用率和命中率。硬件实现并不困难    3.5.5. 影响Cache性能的因素 Cache脱靶的原因\n  分块太小\n程序开始执行时，主存块逐步复制进Cache，因此容易脱靶，需经过一段时间后Cache才装满。首次执行产生脱靶的次数，与分块大小有关，块越大，不命中次数就越小\n  容量太小\n不能将所需指令和数据都调入Cache，因此频繁的替换，导致CPU访问慢速主存次数增多\n  替换进Cache的主存块过大或过多\n 替换进Cache的主存块数目太多，会把下次要访问的指令或数据替换出去 数据块太大，替换所传数据量越大 Cache所含块数减少，少数块刚装入就被覆盖掉    提高Cache性能的方法\n  增大Cache容量来降低不命中率\nCache太小致命中率太低，过大改善不明显。一般选Cache与内存容量比4：1000，命中率90％以上。每块取4～8字节（或字）较好\n  通过结构设计减少不命中次数\n指令、数据分开存储，存取比例不一样，可将两类Cache分开，并采用二级、三级Cache结构\n  通过预取技术提高命中率\n预测将要访问的指令和数据，提前将下条要执行指令取入Cache，提高CPU取指令的速度\n  3.6. 存储器系统设计 3.6.1. 主存储器系统设计技术   CPU总线的负载能力\nCPU通过总线直接驱动负载的能力有限，应根据需要连接的存储器芯片参数，考虑在总线上增加缓冲器或驱动器，增大CPU的负载能力\n  CPU时序与存储器存取速度间的配合\nCPU要对存储器频繁读/写，选芯片时要考虑其存取速度能否与CPU读/写时序匹配\n  存储器的地址分配和片选\n需要为存储器分配地址范围。由于每块芯片存储容量有限，一个存储器系统可能是由多块芯片组成，要重点考虑容量的扩充方案和片选信号的形成\n  控制信号的连接\nCPU提供的存储器控制信号，如CS#、OE#、WE#等，应与存储器的相关引脚正确连接，才能实现读/写等控制功能\n  3.6.2. 存储器系统扩展方式 位扩展\n在存储器芯片字数不变的前提下，进行数据的位数扩展\n举例：1M×1位的芯片扩展为1M×8位的RAM并与CPU总线连接\n 每个芯片数据线分别连接数据总线D~7~~D~0~的不同位，以形成8位数据 各芯片的地址线A~19~~A~0~与CPU地址总线对应地址线并联 读写控制线R/W#与CPU读写控制线分别并联连接，CPU的片选控制线CS#与各芯片的CS#并联  字扩展\n在存储器芯片的位数满足的前提下，进行字数扩展\n举例：存储器芯片为256K×8位，采用4片进行字扩展为1M×8位的RAM，并与CPU总线连接\n 每个芯片的各位数据线分别与数据总线D~7~~D~0~位并联 各芯片低位地址线A~17~~A~0~与CPU地址总线对应地址线并联 高位地址线A~19~、A~18~通过2线-4线译码器分别产生不同的译码输出信号控制每个存储器芯片的片选端CS# 各芯片的读写控制线R/W#与CPU读写控制线分别并联连接  复合扩展\n在位长和字数均不足时，采用复合扩展方式\n举例：如将256K×1位的芯片扩展为1M×8位的存储器系统\n 先进行位扩展，用8片256K×1位芯片进行位扩展，构成256K×8位的存储器 再将位扩展后的存储器作为整体进行字扩展，用4个256K×8位的存储器，从而构成1M×8位的存储器系统  3.6.3. 嵌入式存储器系统设计 存储结构特点：\n嵌入式微处理器内置小容量NOR Flash内存和小容量的SRAM\n嵌入式系统的存储器扩展\n 通过不同的总线接口，连接大容量的NAND Flash、DRAM、SD、eMMC、TF等存储器 嵌入式微处理器内置的存储器容量有限，在内置存储器存储容量不足时，可外部扩展SRAM或者DRAM  NOR Flash内存的存储器扩展设计\nHY29LV160 NOR Flash芯片\n 地址线20根，共1M=220个存储单元 每个存储单元16位 容量2MB=16Mbits 地址线A[19:0] →ARM A[20:1] 数据线DQ[15:0] 控制线OE#、WE#、CE# BYTE# = 1表示工作在字模式 RY/BY#指示编程或擦除的状态  ARM微处理器对NOR Flash的访问不需要其他任何软件的设置，系统在上电复位后，从NOR Flash的0X0地址开始执行第1条指令，即开始执行NOR Flash存储器的启动代码\nNAND Flash内存的存储器接口设计\nNAND Flash与嵌入式微处理器的连接，通过NAND Flash控制器实现\n ARM微处理器集成的NAND Flash控制器的内部结构方框图，如图1所示 NAND Flash K9F2808U0A与ARM嵌入式微处理器的接口电路，如图2所示  NAND Flash 是以存储外设方式存在，故ARM微处理器对NAND Flash的访问，是通过NAND Flash控制器接口进行\nSDRAM的存储器扩展设计\nSDRAM作为同步动态存储器，是利用同一个时钟信号同步控制DRAM的地址、数据和控制信号。从而保持SDRAM的时钟频率与系统前端时钟频率，保证CPU对存储器的访问速度与处理速度一致\n嵌入式系统采用SDRAM或者SRAM作为系统的主存储器器，用于保存程序运行过程中的实时数据或者存储从外存装入的程序或数据\n在SDRAM与ARM微处理器进行电路连接时，要根据实际，对扩展主存容量、芯片粒数、单元数、芯片位宽与Bank之间的关系进行配置\nARM微处理器SDRAM控制器Bank地址配置：\nHY57V561620T SDRAM的引脚定义：\nARM微处理器与HY57V561620T SDRAM的连接示意图：\nHY57V561620T的存储器组织为4M×16位×4Banks，从而构成32MB的总存储容量\n4. 总线和接口 计算机不同部件间，如从硬盘到处理器、从CPU到内存，从内存到显卡，都需要进行数据传输。总线提供了一种经济的思路：把不同计算机部件均接到一个公共的通道上\n4.1. 总线技术 4.1.1. 总线技术概述 4.1.1.1. 总线的概念   总线的作用\n总线：计算机系统内部或者计算机系统之间传输信息的公共信道。总线是由一些电导体的互连组成，其具体形式可以是印刷线路、各种连接器、多路电缆等\n 系统早期的互联方式——分散连接  内部连线十分复杂，布线困难，扩展性差 效率高   现代的系统互连方式——总线连接  优点：简洁、协调、扩展性好 缺点：有共享竞争问题      接口的作用\n 计算机数据处理过程中存在大量数据交换  CPU和计算机其他部件/外设之间 计算机不同部件/外设间：内存到显卡、网卡到内存\u0026hellip;   外部设备种类繁多、差异大  信号形式：数字/模拟、电压/电流\u0026hellip; 速度：摄像头30帧/s、键盘2-6次/s、打印机1-30页/s\u0026hellip;   需要中间环节来协调  中间环节就是输入/输出（Input/Output，I/O）接口 接口电路起转换、缓冲速度匹配作用      总线与接口的区别与联系\n 电路单元之间的硬件电路  接口包括了电路单元之间的硬件电路 总线不仅包括分时共享传输线路和相关电路，也包括传输和管理信息的规则（即协议）（硬件+协议） 挂接在总线上的电路单元一定需要相应的接口电路。   点到点连接和多点互联  两个电路单元连接需要接口电路，未必需要总线协议。 多个电路单元互联，每个电路单元不仅要有接口电路，还需要按照总线协议来规范。   有时候并不做严格区分  广义的接口还包括了接口电路相应的驱动程序      总线的意义\n考虑一个具有$N$个电路模块的计算机系统，若模块间两两采用直接连接的方式，则实现所有模块互联共需要$N×(N-1)/2$组连接线\n  总线的基本特性\n 总线的两个基本特性：共享、分时 共享：当多个部件连接在同一组总线上，各部件之间相互交换的信息都可以通过这组总线传送 分时：是指任意时刻只能有一个设备向总线发送信息，但是允许多个部件同时从总线接受相同信息（广播）  分时是制约系统性能的瓶颈      总线的主要性能指标\n  总线频率\n 每秒能够发起数据传输的最大次数（Transfer/s，T/s），也称总线传输速率，常用单位MHz 许多总线每个时钟周期能发起一次传送，总线频率就等于总线时钟频率 总线频率越高，传输速度越快 如ISA/EISA的总线频率为8MHz，PCI有33.3MHz和66.6MHz两种总线频率    总线宽度\n 总线可同时传输的数据位数，也称总线位宽。例如，8位总线、16位总线、32位总线等 总线越宽，相同时间内能传输更多的数据    总线带宽\n  又称总线最大数据传输速率，单位MB/s。影响带宽的因素有总线宽度、总线频率等，并行总线的带宽为：\n带宽（MB/s）=总线宽度/8×总线频率\n  例：求33.3MHz@32位总线的带宽\n总线带宽=32b/8×33.3 MHz =133.2MB/s\n    并行总线一次能传输多位数据，但信号间存在干扰，频率越高，位宽越大，干扰越严重，带宽难于提高\n  串行总线可通过较高的总线频率获得较大的总线带宽。此外，为弥补一次只能传送一位数据的不足，串行总线常用多条管线传输，其带宽为：\n带宽=总线频率×管线数\n    同步方式\n 同步总线：主、从模块之间严格按照确定的时钟进行数据传输，传送速率较高，但是对模块的速度有要求 异步总线：主、从模块之间通过应答握手确保可靠传送，适应性广，灵活性高，但会减小总线带宽    总线复用\n在一条线路上，不同的时刻传送不同的内容，例如某一时刻传输地址，另一时刻传输数据或命令信号，以减少总线的信号线数量，并提高信号线的利用率\n  信号线数\n数据、地址、控制和电源总线数的总和。信号线数量与总线的性能不成正比\n  总线控制方式\n包括并发工作、自动配置、仲裁方式、逻辑方式、计数方式等\n  寻址能力\n指地址总线的位数及所能直接寻址的存储器空间大小\n  总线的定时协议\n为使源与目的同步，需要有信息传送的时间协议。分为同步总线定时、异步总线定时、半同步总线定时\n  负载能力\n指总线上最多能连接的器件数，一般指总线上的扩展槽的个数\n    总线特性\n 为了保证总线与部件之间机械上的可靠连接，必须规定其机械特性 为了保证电气上正确连接，必须规定其电气特性 为了正确传输信息，必须规定其功能特性和规程特性    4.1.1.2. 总线的分类 按物理接口分类：电缆式、主板式、背板式\n按总线信号传输类型分类：数据总线、地址总线、控制总线、电源总线\n按控制特性分类：同步总线、异步总线、半同步总线\n按通信方式分类：串行总线和并行总线\n按总线位置分类\n 片内总线（In Chip Bus），位于芯片（CPU或其他的处理器）的内部，连接CPU内部的各个部件 芯间总线（Chip Bus），也称为芯片总线（Component-Level Bus）或者局部总线（Local Bus），连接CPU和外围芯片 内总线（Internal Bus），又称为板级总线（Board-Level Bus）或系统总线（System Bus），用于系统内部各高速模块之间的互连。例如ISA、EISA、PCI等 外总线（External Bus），又称I/O总线或通信总线（Communication Bus），用于计算机之间，或者计算机与外设之间的互连。例如SCSI、USB等  片上总线的由来：片上系统SoC的发展，采用片上总线来描述芯片内部使用的总线（实际涵盖传统内总线及外总线的定义）\n总线的层次结构：\n 计算机内部同时存在多条总线，通常采用多级分层结构  外总线的分层结构：\n 由于外设种类繁多，速率不一，通用计算机外部总线也采用层次化的结构  总线按功能分类\n  地址总线AB：专门用来传送地址\n 一般为单向传送总线，信号通常从CPU发出，送往总线上所连接的各个模块 也可用于I/O的寻址 地址总线宽度决定了系统最大存储器空间寻址范围。如：20位宽度的地址总线可寻址空间为2^20^=1M，可寻址1M个存储单元。若数据总线为8位宽，则可寻址1MB；若数据总线为16位宽，则可寻址2MB    数据总线DB：用于传送数据信息\n  双向三态\ngraph LR\rCPU --\u0026gt; 存储器或I/O接口等部件\r存储器或I/O接口等部件 --\u0026gt; CPU\r\r  数据总线的位数（宽度）通常与微处理的字长相一致\n  带宽(B/s)=总线宽度/8X总线频率\n    控制总线CB：用于传输完成各项操作所需要的控制信号\n 一般来说，总线信号线中，除电源线、地线、数据线和地址线外的所有信号线都归纳为控制总线    按数据传输方式分类\n  串行传输：串行总线\n 串行总线只用一根信号线（如果传输的是差分信号则是两根信号线）来传输数据 需传输的比特串一个接一个地在一条信道上传输    并行传输：并行总线\n 比特以成组的方式在两条或更多的并列信道上进行传输 一般为一字节或多字节，其位数为该总线的宽度    过去，内总线一般为并行总线，系统外总线多采用串行总线\n按时序控制方式分类\n  异步总线\n 传输的双方有各自独立的定时时钟 通过主从双方的“握手”应答机制进行数据传输 传输可靠性高 但是握手应答导致速度较慢，例如Motorola公司的VME总线    同步总线\n 所有挂接在总线上的设备，按照统一的时钟，在规定时间完成规定的工作 需要独立的信号线来传输时钟 没有握手应答过程，速度快 所有部件的速度应该相对一致 可靠性不如异步总线 为了照顾少数低速设备，采用“就绪-等待”机制——半同步总线    按时分复用方式分类\n  非复用\n 每条信号线的功能恒定 缺点：总线上信号线数量较多    复用\n  某些信号线在不同时段传输不同的数据，目的为了减少信号线的数量\n  区分服用信号的方法：\n  约定。例如PCI总线上的AD[31:0]是32根地址和数据复用的信号线，按照数据传送的规律，首先传送地址，然后再传送数据\n  增加专用信号线加以标识，如下图所示：\n      4.1.1.3. 总线的结构 单总线\n 将CPU、主存、I/O接口等都挂到一组总线上，CPU与内存以及与I/O之间访问都通过同一条总线 优点：结构简单 缺点：影响了CPU与存储器之间的数据存取速度  双总线：面向CPU的双总线结构\n 思想：设置一条与主存总线独立的I/O总线，专门连接速度低的I/O接口 优点：在CPU与主存储器之间、CPU与I/O设备之间分别设置了总线，提高了微机系统信息传送的速率和效率 缺点：外部设备与主存储器之间没有直接的通路，它们之间的信息交换必须通过CPU才能进行中转，会降低了CPU的工作效率  双总线：面向存储器的双总线结构\n 思想：在CPU与存储器之间，专门设置了一条高速存储总线，使CPU可以通过它直接与存储器交换信息 优点：面向存储器的双总线结构信息传送效率较高 缺点：I/O接口与存储器交换信息时，速度依然较慢  典型的三总线结构\n 主存总线：连接CPU与主存 I/O总线：I/O总线只有在CPU执行I/O指令时才能用到 DMA总线：为高速I/O设备建立了一个到达主存的高速通道，称为DMA（Direct Memory Access，直接存储访问）总线  注意：任意时刻只有一套总线能够使用，主线总线与DMA总线不能同时访问主存\n四总线结构\n 局部总线、系统总线、高速总线、扩展总线 增加了一条与系统相连的高速总线，连接高速的I/O设备，它们通过高速总线桥或者高速缓冲器与系统总线和局部总线连接 较低速的设备放在扩展总线上 优点：对于高速设备而言，比扩展总线上的设备更接近CPU，有利于提升高性能设备与CPU的效率，且高速总线和扩展总线的速度以及各自的信号线定义可以不同，有利于扩展不同类型的外设  4.1.2. 总线仲裁 总线上的设备\n总线上的设备一般分为总线主设备（主控模块）和总线从设备（从属模块）。常把总线主设备称作总线主机，把总线从设备称作总线从机\n总线主设备是指具有控制总线能力的模块，在获得总线控制权之后能启动数据的传输\n从设备能够对总线上的数据请求做出响应，但本身不具备总线控制能力\n总线仲裁（bus arbitration）是在多总线主设备的环境中提出来的\n总线仲裁\n总线的使用权分配即总线判优控制，也称为总线使用权仲裁。当有多个主设备同时申请总线时，按一定的优先等级顺序，判定哪个主设备能优先使用总线\n两种仲裁方式：\n 集中式：将控制逻辑（即总线仲裁器）集中在一处，分为串行仲裁、并行仲裁、循环优先权以及串并行混合等方式 分布式：将控制逻辑分散在（与总线连接的）各个部件或设备上，由各个节点按照事先约定的协议，竞争使用权  4.1.2.1. 集中式仲裁 串行仲裁\n串行仲裁是最为常见的链式仲裁（“菊花链仲裁”）\n 信号线包括：总线请求BR（Bus Request）信号、总线允许BG（Bus Grant）信号和总线忙BB（Bus Busy）信号  仲裁过程：\n BB无效（即总线空闲）时，主设备才能提出总线请求 各主设备的BR信号用“线与”方式接到仲裁器的请求输入端 仲裁器在接到BR信号后输出BG信号，BG信号通过主设备链向后逐个传递，直到提出总线请求的那个设备为止 请求总线的主设备收到BG号后，获得总线的控制权，将BB信号置为有效，以通知其他设备总线已被占用，同时使总线仲裁器撤销BG信号 主设备的总线操作结束后，撤销BB信号，从而允许其他设备重新申请总线  特点：\n 使用总线的优先权由它到总线仲裁器的距离决定，最近的优先级最高，最远的优先级最低 链形优先级存在传播延迟，这种延迟与模块数量成正比，仲裁较慢。由于总线申请和使用权分配必须在一个时钟周期内完成，受总线周期的限制，一般只能接少量的（几个）模块 优点：信号线数与设备数目无关，电路实现简单，造价低 缺点：速度慢，连接方式确定后优先级即固定，不易更改，可靠性低，一个模块故障将造成整条链失效  举例：\n Intel MultiBus Motorola VME总线  并行仲裁\n并行仲裁又称为“独立请求式仲裁”\n 每个主设备都有独立的总线请求BR和总线允许BG信号线，并分别接到仲裁器上  仲裁过程：\n 任一主设备使用总线都要通过BR信号向仲裁器发出请求，仲裁器按规定的优先级算法选中一个主设备，并把BG信号送给该设备 被选中的设备撤销BR信号，并输出有效的BB信号，通知其他设备“总线已经被占用” 主设备总线操作结束后，撤销BB信号，根据各请求输入的情况重新分配总线控制权  独立请求方式的工作原理：\n 每个模块有一条总线请求（BR）、一条总线允许（BG）和一条所有模块共用的总线忙（BUSY）信号 控制器内置一个优先级编码器和优先级译码器，用以选择优先级最高的请求，并产生出相应的“总线允许”信号 当BUSY信号有效时，表示有模块正使用总线，因此请求使用总线的模块必须等待，直至BUSY信号变为无效。所有需要使用总线的模块都可发“总线请求”信号，总线仲裁器仅向优先级最高的模块发出“总线允许”信号  特点：\n  判优速度快，且与模块数无关\n  所需的“请求线”和“允许线”较多，N个模块需要2N条\n  优点：仲裁速度快，优先级设置灵活\n  缺点：连接到总线上的设备数量受到限制\n  混合仲裁\n混合仲裁又叫多级仲裁\n两级混合仲裁的结构：\n 总线判决器按照并行方式连接BR1和BR2 所有主设备的总线请求BR要么连接在BR1，要么连接在BR2上 BG1按照串行方式连接一部分主设备，BG2按照串行方式连接另一部分主设备  仲裁过程：\n 先并行，所有主设备的总线请求首先经过总线判决器（BR1或BR2），总线判决器决定是BR1所连主设备还是BR2所连主设备获得总线控制权 按串行方式来决定BR1上的设备是主设备2还是主设备4、BR2上的设备是主设备1还是主设备3应该获得总线控制权 并行请求线BR1和BR2的优先级由总线判决器内部逻辑确定，同一链路上各设备的优先级则由该设备与总线判决器的远近程度确定  特点：兼具有串行仲裁和并行仲裁的优点，既有较好的灵活性、可扩充性，又可容纳较多的设备而结构也不会过于复杂，且具有较快的响应速度\n4.1.2.2. 分布式仲裁 分布式仲裁方式中，每个设备模块都包含总线访问的控制逻辑，这些设备模块共同作用，分享总线\n以自举分布式的总线仲裁为例：\n假定模块1～4通过BR~1～4~进行自举分布式仲裁。其中BR~1~为总线忙信号，正在使用总线的模块应将BR~1~置为有效；BR~i~为模块i的总线请求信号线，只有在BR~1~无效时才能发总线请求。下图中设备1的优先级最低，设备4的优先级最高（主设备4输出，主设备1只能取回）\n特点：使用多个请求线，不需要中心裁决器，每个设备独立地决定自己是否是最高优先级请求者\n原理：分为申请期和裁决期\n 在申请期，需要请求总线控制权的设备在各自对应的总线请求线上发送出请求信号 在裁决期，每个设备将有关请求线上的合成信号取回分析，已确定自己能否拥有总线控制权 每个设备通过取回的合成信息能够检测出其它设备是否发出了总线请求 若检测到其他优先级更高的设备也请求使用总线，则本设备暂时不能使用总线；否则，本设备可立即使用总线  举例：NuBus（Macintoshi II中的底板式总线）和SCSI总线\n4.1.3. 总线操作与时序 计算机系统中，通过总线进行信息交换的过程称为总线操作\n 包括：读/写存储器周期、读/写I/O端口周期、DMA周期、中断周期等  总线设备完成一次完整信息交换的时间称为总线周期（或总线传输周期）\n在含多个主控制器的总线系统中，一个总线操作周期一般分为如下四个阶段：\n 请求及仲裁阶段：主模块请求，仲裁机构决定把下一个总线传输周期分给哪一个请求源 寻址阶段：取得总线使用权的主模块通过总线发出本次要访问的从模块（存储器或I/O端口）地址及有关命令，通知参与传输的从模块开始启动 数据传输阶段：主模块和从模块进行数据传输，数据由源模块发出，经数据总线到达目的模块 结束阶段：主模块、从模块的有关信息均从总线上撤销，让出总线，以便下一个总线传输周期其他模块能够使用总线  总线时序是指总线操作过程中总线上各信号在时间顺序上的配合关系，即主从设备如何在时间上协调和配合，以实现可靠的寻址和数据传送\n总线时序的分类：同步总线时序、半同步总线时序、异步总线时序、周期分裂式总线时序\n4.1.3.1. 同步总线时序 总线上的数据传输由统一时标控制\n时标通常由CPU的总线控制部件发出，送到总线上的所有部件；也可以由每个部件各自的时序发生器发出，但是必须由总线控制部件发出的时钟信号对它们进行同步\n优点：模块间的配合简单一致\n缺点：主从模块之间的时间配合属强制性同步，必须按速度最慢的部件来设计公共时钟\n例1：写命令\n传输周期为：\n T~1~：主模块发地址 T~1.5~：主模块提供数据 T~2~ ：主模块发写命令，从模块必须在规定时间内将数据写入地址总线所指明的单元中 T~4~：主模块撤销写命令和数据等信号  例2：读命令\n传输周期为：\n T~1~：主模块发地址 T~2~：主模块发读命令 T~3~：从模块提供数据 T~4~：主模块撤销读命令  STD总线的读存储器时序\n4.1.3.2. 异步总线时序 异步总线允许各模块速度的不一致性，提高了模块的适应性\n异步总线中系统没有公用的时钟，主从模块之间通信时，采用应答方式进行联络和协调工作\n根据问答信号之间的关系，异步总线时序可分成不互锁方式、半互锁方式和全互锁方式（又称握手方式）\n主设备在发数据的同时发选通信号STB，从设备收到数据后应答ACK；主从模块之间增加两条握手应答线\n不互锁方式\n 主设备发STB，高速从设备当前数据有效，间隔固定时间后，认为从设备已收到，撤销STB 从设备收到数据后发ACK应答，间隔固定时间后，撤销ACK  半互锁方式\n 主设备发STB后，等待从设备的ACK应答，只有收到ACK应答后才撤销STB 从设备发ACK后，不等待主设备的应答，在间隔固定时间后，撤销ACK  全互锁方式（四边沿协议）\n 主设备发STB后，等待从设备的ACK应答，只有收到ACK后才撤销STB 从设备发ACK后，等待主设备的应答（撤销STB），然后才撤销ACK  主从设备相互等待，传输可靠性最高\n关于同步和异步通信方式的讨论\n 传输速度  同步：如果从设备太慢，就无法满足时序要求 异步：应答过程的交互次数越多，速度越慢   可靠性  最可靠的方式：异步全互锁，每步操作“环环相扣”   兼顾传输速度和通信的可靠性  互锁方式应配合使用等待超时处理机制    4.1.3.3. 半同步总线时序 半同步总线是对同步总线的一种优化，对于大多数速度较快的传送对象，均按照同步方式定时\n 例如：主存储器的速度太慢，可插入一个时钟周期的办法让CPU等待存储器准备数据  对于系统所连接的少数速度较慢的设备，增加一条Ready/wait状态信号线，当慢速设备被访问时，可以利用这条信号线请求主模块延长传送周期\n 例如：8086/8088 采用的就是半同步总线。当检测到READY信号线被拉低，则在T~3~/T~4~之间插入T~w~  半同步总线提高了系统的适应性，但是速度依然偏慢\n示例\n WAIT#信号表示需要进行等待，低电平有效，WAIT#信号持续一个时钟周期，则CPU读数据的时间滞后一个时间周期 插入等待时钟周期的数目可以根据存储器访问速度来确定，如果存储器访问速度低于两个时钟周期，那么就需要插入两个等待时钟周期（WAIT#信号持续两个时钟周期）  4.1.3.4. 周期分裂式时序 在上述各种传输过程中，占用总线使用权的主设备以及被其选中的从设备，无论是否进行数据传输，始终占据着总线资源\n若对读命令过程的进一步分析：在读命令传输周期中，除了申请总线这一阶段外，其余时间主要被用于如下三个方面的开销：\n 主模块通过总线向从模块发送地址和命令 从模块按照命令进行读数据的必要准备 从模块经总线向主模块提供数据  周期分裂总线的思想：将一个传输周期（或总线周期）分解成两个子周期（或称子阶段）\n 在第一个子周期（寻址子周期，或称为地址阶段）中，主模块A获得总线使用权后，将命令、地址、A模块编号等信息发到系统总线上，由相关的从模块B接收下来。然后A模块放弃总线，供其他模块使用 在第二个子周期（数据传输子周期，或称为数据阶段）中，B模块根据所收到的命令，经过一系列的内部操作，将A模块所需的数据准备好，然后由B模块申请总线使用权，一旦获准，B模块将A模块的编号和所需数据，B模块的地址等信息送到总线上，供A模块接收  分裂式操作的技巧是总线设计中一种重要的思路：\n 将一个耗时长的操作分成几个耗时短的操作也是流水线设计的基本思想 周期分裂式操作又称“分离式操作”、“流水线分离”等  4.2. 片内总线AMBA 4.2.1. AMBA总线概述 简介\nAMBA（Advanced Microcontroller Bus Architecture）总线是ARM公司研发的一种片上总线（on-chip bus）标准\nAMBA设计独立于处理器和芯片制造工艺\n 与工艺无关的片上协议，不提供任何与电气特征有关的信息，电气特性取决于设计时选择的生产工艺  AMBA拥有众多第三方支持\n AMBA2已具备相对完整的功能 AMBA3侧重引入高性能的功能支持 AMBA4/AMBA5针对多CPU核环境做相应的优化  AMBA定义了三种不同的总线：\n 高级性能总线AHB（Advanced High-performance Bus） 高级系统总线ASB（Advanced System Bus） 高级外设总线APB（Advanced Peripheral Bus）     AMBA AHB AMBA ASB AMBA APB     高性能\n流水线（pipelined）操作多总线主机（multiplebusmasters）突发传输（bursttransfers）分裂式操作（splittransactions） 高性能\n流水线操作\n多总线主机 低功耗地址锁存和控制接口简单适合大多数外设    基于AMBA总线的系统：\n 以AHB或ASB作为高性能系统中枢总线，支持CPU、片上存储器、外部存储器和DMA设备间的数据传输 用桥接器以连接低带宽的APB，外设挂接在APB上  一个基于AMBA2总线的微控制器系统如下：\n4.2.2. AHB总线 4.2.2.1. AHB系统的构成 在AMBA2中，AHB担当高性能系统的中枢总线。AHB支持处理器、片上存储器、片外存储器，以及低功耗外设单元之间的有效链接\nAHB总线是支持多主机的总线，能支持高带宽、高时钟频率的数据传输操作\nAHB系统要素\n  AHB主机（Master）\n即总线的主控模块。总线主机能够通过提供地址和控制信息发起读写操作。任何时候只允许一个总线主机处于有效状态并能使用总线\n  AHB从机（Slave）\n即总线的从属模块。从机在给定的地址空间范围内响应主机发起的读写操作。从机将成功、失败或等待的信号返回给有效的主机\n  AHB仲裁器（Arbiter）\n确保每次只有一个总线主机被允许发起数据传输。AHB要求即便在单总线主机系统中也要实现仲裁器，且所有系统中只有一个仲裁器\n  AHB译码器（Decoder）\nAHB译码器用来对每次传输进行地址译码，从而为从机提供选择信号。AHB要求实现集中式的译码器\n  基于多路选择器的AHB总线互联\n 地址和控制选择器负责将主机发出的地址和控制信号连接至从机 数据选择器负责主机和从机之间的数据信号连接 仲裁器在不同的总线主机之间进行总线使用权仲裁，并决定当前得到授权的主机能将它的地址和控制信号连通到哪个从机 译码器控制读数据选择器，读数据选择器负责将从机信号连接到对应的主机上  AHB特点概述\n  支持突发传输（burst transfer）\n启动一次AHB传输可以连续传输一个数据块\n  支持分裂式操作（split transaction）\n寻址和数据传输子周期分离\n  单周期总线主机移交（single cycle bus master handover）\n主机在时钟上升沿发出总线使用请求，仲裁器在时钟下降沿采样获得该请求，随即在下一个时钟上升沿更新总线允许信号。即：仲裁器在每个时钟周期都更新总线允许信号\n  单一时钟沿操作（single clock edge operation）\n所有信号变化均发生在时钟上升沿，这利于芯片内集成更多的电路单元\n  非三态实现（non-tristate implementation）\n  可扩展至更宽的数据总线架构（64位或128位）\n  4.2.2.2. AHB信号定义  AMBA中信号名称的前缀规则：     前缀 含义及示例     T 测试信号（与总线类型无关）   H AHB信号，如HREADY是表示AHB的数据传输完毕的信号，高电平有效   A ASB信号，主机与仲裁器之间的单向信号   B ASB信号，如BRESn为ASB复位信号，低电平有效   D ASB信号，单向的ASB译码信号   P APB信号，如PCLK表示APB使用的主时钟    ​\t所有的信号名均为大写字母，信号若为低电平有效，则信号名称的最后加小写字母n\nAMBA中AHB的信号     信号名称 信号来源 用途说明     HCLK\n总线时钟 时钟源 为所有总线传输提供时基，所有信号时序都与HCLK的上升沿相关   HRESTn复位 复位控制器 总线复位信号，用于复位系统和总线，低电平有效   HADDR[31:0]地址总线 主机 32位系统地址总线   HTRANS[1:0]传输类型 主机 主机表示当前传输的类型，可以是不连续、连续、空闲和忙（NONSEQUENTIAL,SEQUENTIAL,IDLE,BUSY）   HWRITE传输方向 主机 高电平时表示一个写传输，低电平时表示读传输   HSIZE[2:0]传输大小 主机 表示传输的大小，可以是字节(8位)、半字(16位)或字(32位)等，协议允许的最大传输大小是1024位   HBURST[2:0]突发类型 主机 表示传输是否组成了突发的一部分。支持4个、8个或16个节拍的突发传输，突发传输可以是增量或回环的   HPROT[3:0]保护控制 主机 提供总线访问的附加信息，指示当前传输的安全保护级别   HWDATA[31:0]写数据总线 主机 用来在写操作期间，从主机到从机传输数据。建议最小数据宽度为32位，在高带宽运行时可扩展   HSELx从机选择 译码器 每个AHB从机都有自己独立的从机选择信号，并且用该信号来表示当前传输是否打算送给选中的从机。该信号是地址总线的组合译码   HRDATA[31:0]读数据总线 从机 用来在读操作期间，由从机向主机传输数据。协议允许的数据宽度为：8、16、32、64、128、256、512、1024位   HREADY传输完成 从机 当该信号为高电平时，表示总线上的传输已经完成。在扩展传输时该信号可能会被拉低   HRESP[1:0]传输响应 从机 给传输状态提供了附加信息，提供四种不同的响应：OKAY、ERROR、RETRY和SPLIT    AMBA中AHB的仲裁信号     信号名称 信号来源 用途说明     HBUSREQx总线请求 主机 从总线主机x传向总线仲裁器，用来表示该主机请求(控制)总线的信号。系统中每个总线主机都有一个HBUSREQx信号，最多16个总线主机   HLOCKx锁定的传输 主机 当该信号为高时，表示主机请求锁定对总线的访问，并且在该信号为低之前，其他主机不应该被允许授予总线   HGRANTx总线授予 仲裁器 该信号用来表示总线主机x目前是优先级最高的主机。当HREADY为高电平时，传输结束，地址控制信号的所有权发生改变。所以主机应在HREADY和HGRANTx都为高电平时，获得对总线的访问   HMASTER[3:0]主机号 仲裁器 表示哪个总线主机正在执行传输，被支持突发传输的从机用来确定哪个主机正在尝试一次访问   HMASTLOCK锁定顺序 仲裁器 表示当前主机正在执行一个锁定序列（sequence）的传输。该信号与HMASTER信号有相同时序   HSPLITx[15:0]分离式传输请求 从机（支持分裂式操作） 指示仲裁器，总线主机被允许重试一个分裂式操作。每位对应一个总线主机    信号后缀x表示模块x。如，HBUSREQx可能分别表示HBUSREQarm或HBUSREQdma\n4.2.2.3. AHB的数据传输过程及“流水线” 在一次AHB传输开始之前，总线主机必须先获得总线访问的授权\n该授权过程由总线主机向仲裁器发出一个请求信号而发起，随后仲裁器指示主机何时被授权\n获得授权的主机通过提供关于地址信号、传输方向、传输宽度和传输类型等控制信号发起一次AHB传输\n  单个数据简单传输\n两个阶段：地址阶段和数据阶段\n  地址阶段仅持续一个时钟周期，用来传输地址和控制信息\n  数据阶段可持续一个或多个时钟周期，用来传输有效数据\n  主机写传输应关注HADDR[31:0]和HWDATA[31:0]；\n主机读传输应关注HADDR[31:0]和HRDATA[31:0]\n  传输过程：\n 第一个时钟周期的上升沿：主机把地址、控制等信息驱动到总线上（HADDR[31:0]及其他控制信号线） 第二个时钟周期的上升沿：从机采样获得这些地址和控制信息，并据此把相应的数据驱动到数据总线HRDATA[31:0]上 第三个时钟周期的上升沿：主机在HRDATA[31:0]上采样即可获得从机响应的数据      AHB的流水线机制\n地址信息和数据信息交叠的操作方式，被称为流水线机制\n流水线分离：\n 2级流水线  第n次传输的地址在第n-1次传输时被驱动到了地址总线上。“驱动地址”和“驱动数据”两个操作构成2级流水线操作 从机因某种原因不能及时响应时，这个流水线就会被打断   周期分裂式时序  地址阶段和数据阶段可以被分离 从机不能及时响应时，发送控制信号HSPLITx通知仲裁器 仲裁器检测到HSPLITx后，知道从机当前不进行传输，则可以把总线的使用权出让给其他主机 当从机做好接收数据准备后，通过控制信号HSPLITx发出重新启动传输的信号，仲裁器根据挂起操作主机的优先级决定何时再次分配总线使用权 当主机获得总线使用权后，重新发送地址、控制等信息，继续刚才挂起的传输操作      单个数据简单传输中插入等待状态\n如果数据阶段持续一个时钟周期不足以完成数据的传输，从机可以通过HREADY信号（拉为低电平）扩展数据周期（即插入等待周期）\n传输过程：\n 主机在HCLK上升沿之后将地址和控制信号驱动到总线上 在时钟的下一个上升沿，从机采样地址和控制信号 进入数据阶段，从机开始驱动适当的响应 若从机在数据阶段第一个时钟周期没能准备好，则需要把HREADY拉为低电平，插入等待周期 从机准备好后，拉高HREADY电平 总线主机在随后的下一个时钟（第五个时钟）上升沿采样HRDATA[31:0]获得从机响应的数据  说明：\n 对写操作而言，总线主机必须保持数据在整个扩展期中稳定 在读传输中，从机没必要提供有效数据直至传输结束，只需要在相应周期提供数据即可    多个数据的传输\n三次AHB传输分别需要传输的是地址A、地址B和地址C对应的数据\n 传输地址A和地址C数据都没有插入等待周期，但是传输地址B数据的时候插入了一个等待周期 地址B对应数据在总线上停留的时间被扩展为2个周期 对应地，地址总线上地址C也被扩展了    4.2.2.4. AHB的突发传输 突发传输\n突发传输就是一次传输过程传输一个数据块而不是单个数据。既然是传输一个数据块，就涉及到数据块的长度，数据块的地址递增方式等\n用突发传输类型信号HBURST[2:0]标识：\n   HBURST[2:0] 类型 类型的描述     000 SINGLE 单次传输   001 INCR 未标识长度的地址递增式传输   010 WRAP4 突发长度为4的地址循环增式传输   011 INCR4 突发长度为4的地址顺序增式传输   100 WRAP8 突发长度为8的地址循环增式传输   101 INCR8 突发长度为8的地址顺序增式传输   110 WRAP16 突发长度为16的地址循环增式传输   111 INCR16 突发长度为16的地址顺序增式传输    突发传输的状态\nHTRANS[1:0]用来向从机指示突发传输过程中的不同状态，因而从机可知自身下一步的操作提示\n   HTRANS 状态 状态含义描述     00 IDLE 指示当前周期没有数据需要传输，当主机被授权使用总线，但是不需要传输时使用该状态   01 BUSY 指示主机正在进行突发传输，但是下一次数据传输不会马上发生。地址和控制信号线上的信号对应下一次即将发生的传输   10 NONSEQ NONSEQUENTIAL，指示当前传输是一次突发传输过程或单次传输的第一次传输。地址和控制信号线上的信号与前一次传输无关   11 SEQ SEQUENTIAL，一次突发传输过程中非第一次的传输。地址和信号线上的信号对应上一个刚完成的传输    WRAP4突发传输时序\nWRAP4，拟传输数据的地址在16字节的边界处发生回转，0x38、0x3C → 0x30、0x34\n整个传输过程共进行4次数据传输，插入1个等待周期T2\n T1周期：第一个拟传输数据对应的地址为0x38，在T1周期被推送到地址总线HADDR[31:0]上，T1周期传输状态指示信号HTRANS[1:0]为NONSEQ，指示拟传输的数据是突发传输中的第1次 T2周期：第2个拟传输数据的地址0x3C被推送到地址总线上，同时传输状态指示为SEQ T3周期：第1个拟传输数据被推送到数据总线HWDATA[31:0]上 T4周期：第3个拟传输数据的地址0x30被推送到地址总线上，同时第2个拟传输数据被推送到数据总线上 T5周期：第4个拟传输数据的地址0x34被推送到地址总线上，同时，第3个拟传输数据被推送到数据总线上 T6周期：第4个拟传输数据被推送到数据总线上  INCR4突发传输时序\nINCR4，4个传输数据的地址变化是递增的（0x38，0x3C，0x40，0x44），没有在16字节边界处发生回转\nAMBA规范中定义：突发传输过程中拟传输的数据块不能跨越1kB的边界\n4.2.2.5. AHB的译码   地址译码和从机选择信号\nAHB总线通过一组多路选择器实现主从设备的互连\n从机选择信号HSELx：AHB总线上的所有从机使用一个中央地址译码器提供从机选择信号HSELx。选择信号是高位地址信号的组合译码结果。从机x在HSELx和HREADY有效的情况下，对地址和控制信号进行采样，从而获得地址和相关的控制信息\n能够分配给单个从机的最小地址空间是1KB。所有总线主机不允许执行超过1KB的地址边界的增量传输，因此确保了一个突发传输不会超过地址译码的边界\n  总线允许信号与主机号的生成\n主线允许信号HGRANTx：由于采用了一个集中式的译码器，每个主机可以在需要的时候随即驱动自身的地址信号，而无须等待总线允许信号HGRANTx\n对于主机而言，HGRANTx信号是自身获得总线控制权的指示，同时，通过HGRANTx可知自己所驱动的地址是否已经被从机采样\n集中式的译码器根据各个主机的总线使用请求产生总线允许信号HGRANTx，并在仲裁器的控制下生成主机号HMASTER[3:0]，HMASTER[3:0]指示地址和控制多路选择器把主机的地址总线与对应从机的地址总线连接\n  4.2.2.6. AHB的仲裁 AMBA2中AHB的仲裁器接口信号\n信号后缀x表示模块x，每个总线主机都有一个HBUSREQx信号，最多支持16个总线主机\n仲裁机制是为了保证在同一时刻，只有一个主机能够控制总线。仲裁器通过检测请求的优先级等信息确定哪个主机能够获取总线控制权。同时，仲裁器也响应从机分离式传输的请求\n无等待状态的仲裁授予\n基本步骤：\n 主机通过HBUSREQx信号请求对总线的使用需求，如果主机x希望使用总线的时候能够锁定总线资源，则同时需要发出HLOCKx信号 仲裁器通过HGRANTx信号指示主机x获得了总线使用权 如果当前HREADY有效，则不需要等待，仲裁器通过HMASTER[3:0]以指示当前获得总线使用权的主机号  HREADY有效的前提下的仲裁授予过程：\n 在T3周期的时钟上升沿。HGRANTx有效 在T4周期的时钟上升沿，仲裁器开始驱动HMASTER[3:0]指示了当前获得总线使用权的主机号，同时获取了总线控制权的主机将地址A驱动到地址总线HADDR[31:0] 在T5周期的时钟上升沿，地址A对应的数据被驱动到数据总线HWDATA[31:0]  有等待状态的仲裁授予\n如果HGRANTx有效，HREADY为无效状态（低电平），则需要插入等待周期\n有等待状态的仲裁授予过程：\n T4周期时钟上升沿由于HREADY无效，插入了一个等待周期 T5周期时钟上升沿时候，可检测到HREADY有效，仲裁器开始驱动HMASTER[3:0]指示了当前获得总线使用权的主机号，同时，获取了总线控制权的主机将地址A驱动到地址总线HADDR[31:0]上 T6周期时钟上升沿时候，HREADY无效，故获得总线使用权的主机又等待了一个周期 T7周期时钟上升沿的时候，才驱动数据到HWDATA[31:0]上  总线控制权在两个主机之间移交\n总线的控制权包括地址总线控制权和数据总线控制权，数据总线控制权滞后于地址总线\n当一次传输完成后（通过HREADY信号高电平予以指示），随后拥有地址总线控制权的主机接管数据总线\n主机2控制地址总线的时候，主机1仍在控制数据总线\n突发传输后的总线移交\n总线控制权移交发生在一次突发传输的末尾\n仲裁器在倒数第二个地址被采样后改变总线允许信号HGRANTx\n新得总线允许信号HGRANTx将与最后一个地址在相同时刻被采样\n4.2.2.7. AHB主机接口及时序参数 复位信号HRESETn：\n 复位信号HRESETn是AHB中定义的唯一一个低电平有效的信号，该信号将引起所有总线上电路单元进行复位操作 复位信号HRESETn的产生可以与时钟信号HCLK异步，但是复位信号的撤除是与HCLK同步的，需要与HCLK上升沿对齐 复位过程中，总线上所有的主机要确保地址总线和控制总线处于有效的状态且HTRANS[1:0]指示处于IDLE状态  主机接口：\n 主机在HREADY和HGRANTx都为高电平时，获得对总线的访问 主机x通过HBUSREQx向总线仲裁器请求使用总线，通过HLOCKx告知其他主机不应该被允许授予总线  4.2.2.8. AHB从机接口及流水线分离 HMASTER[3:0]、HMASTLOCK和HSPLIT[15:0]用于支持“SPLIT”传输模式\nSPILT传输\n AHB传输的两个阶段（地址阶段和数据阶段）可以被分离 流水线机制：第n次AHB传输的地址在第n-1次传输时就已经被驱动到地址总线上；两级操作：驱动地址+驱动数据 从机因某种原因不能及时响应时，流水线就会被打断，从而影响到总体性能。SPLIT方式的数据传输就是为了应对这种情形 从机在不能及时准备好数据时，HSPLITx[15:0]发出启动SPLIT传输的信号。仲裁器检测到HSPLITx后，知道从机当前不进行传输，则可以把总线的使用权出让给其他主机 当从机做好接收数据准备后，通过HSPLITx[15:0]发出重新启动传输的信号，仲裁器根据挂起操作主机的优先级决定何时再次分配总线使用权。当主机获得总线使用权后，重新发送地址、控制等信息，继续刚才挂起的传输操作 在传输的地址阶段，仲裁器产生一个标识号（主机号）HMASTER[3:0]，用来指示哪个主机正在使用总线。任何一个从机如果要发出SPLIT信号，需要根据HMASTER[3:0]信号决定HSPLITx[15:0]中哪个位要置1.HSPLITx有16耕信号线，意味着最多支持16个不同主机来源的传输采用SPLIT分离机制 注意：AHB中仅允许一个主机存在一个SPLIT传输，即SPLIT传输不可嵌套  4.2.3. AXI总线 从设计思想上看，ASB、APB可视为AHB功能的一个子集；AXI可视为AHB的升级版本；AXI之后的其他版本针对高性能、智能手机等不同场景改进设计\nAHB总线分离了一个总线周期的地址阶段和数据阶段，更便于实现在现代总线中常用的Pipelining和Split技术\nAXI总线则进一步分离了总线的通道，将AHB的单通道分解为5个独立的通道：读地址通道（Read Address）、读数据通道（Read Data）、写地址（Write Address）通道、写数据（Write Data）通道、写响应（Write Response）通道，进一步加速了对存储器的读写访问\nAXI、AHB和APB的对比：\n   总线 AXI AHB APB     总线宽度 8，16，\u0026hellip;，1024 32，64，128，256 8，16，32   地址宽度 32 32 32   通道特性 读写地址通道 读写通道均独立 读写地址通道共用 读写数据通道独立 读写地址通道共用 读写数据通道独立 不支持读写并行操作   体系结构 多主/从设备 仲裁机制 多主/从设备 仲裁机制 单主设备（桥）/多从设备 无仲裁   数据协议 支持流水线 支持分裂式操作 支持突发传输 支持乱序访问 字节/半字/字 大小端对齐 非对齐操作 支持流水线 支持分裂式操作 支持突发传输 支持乱序访问 字节/半字/字 大小端对齐 不支持非对齐操作 一次读/写传输占两个时钟周期 不支持突发传输   传输方式 支持读写并行操作 支持读写并行操作 不支持读写并行操作   时序 同步 同步 同步   互联 多路 多路 无定义    4.3. 系统总线/外部总线 4.3.1. PCI PCI总线\nPCI（Peripheral Component Interconnect）外部设备互连总线，是一种高性能的局部总线\nPCI最早由Intel的IAL实验室提出，在IBM兼容PC上得到应用，后得到Compaq、HP和DEC等公司的响应，成立PCI-SIG\nPC领域：逐渐被PCI Express总线替代；工业控制计算机领域：Compact PCI仍在广泛使用\nPCI → PCI-X\n最初的PCI标准中总线时钟（总线频率）为33MHz，数据线宽度为32位，可扩充到64位，数据传输速率可达132MB/s~264MB/s。后期的PCI版本64位并行数据传送，总线时钟支持33/66MHz，能够达到最高528MB/s的数据传输速率\n在PCI的基础上，进一步提出PCI-X规范。PCI-X 553峰值速率是4.2GB/s\nPCI总线结构\nPCI总线的三类设备：PCI主设备、PCI从设备和桥设备\nPCI总线在高速处理器与其他低速设备之间架起了一座“桥梁”。使计算机结构成为基于PCI总线的三级总线结构\nPCI总线是一种树型结构，PCI总线上可以挂接PCI设备和PCI桥片，PCI总线上只允许有一个PCI主设备，其他的均为PCI从设备，而且读写操作只能在主从设备之间进行，从设备之间的数据交换需要通过主设备中转\nPCI系统框图\n#0总线挂接了主存储器、辅助存储器、多媒体设备等不同外设\n#1总线通过PCI-to-PCI桥设备挂接到#0总线\n4.3.2. PCI Express PCI Express（简称PCI-E或PCIe）\nIntel公司提出用新一代的技术取代PCI总线和多种芯片的内部连接，称之为第三代I/O总线\n包括Intel、AMD、DELL、IBM在内的20多家业界主导公司开始起草新技术的规范，并在2002年完成，对其正式命名为PCI Express\n标准由PCI特别兴趣工作组（PCI Special Interest Group，PCI-SIG）维护和升级\n相比于PCI，PCI-E最大的改变是由并行改为串行，使用差分信号传输\nPCI-E的通道\n 两个设备间的一条PCI-E链路（link）可包含1至32个通道（lane）。习惯上用X1、X4、X8、X16、X32等方式表示链路所包含的通道数目，也称为PCI-E的“宽度”或“位宽” 单个通道（lane）包含两对差分传输信号线，一对用于接收数据，另一对用于发送数据。故每个通道共4根信号线（wire） 逻辑上看，每个通道就是一条双向的比特流传输通路  目前高速接口均为串行标准\n ATA(IDE) → SATA (Serial ATA) SCSI → SAS (Serial Attached SCSI) ISA → PCI → PCI-Express  并行数据线多，CLK不能高\nPCI-E点对点串行连接拓扑结构\n PCI Express总线是一种点对点串行连接的设备连接方式，各个设备之间并发的数据传输互不影响。PCIe系统包括Root complex、Switch、PCIebrige、Endpoint四大类设备  Rootcomplex（根复合体）是处理器与PCIe总线的接口，通常由CPU集成 Switch（交换器），允许多个设备连接到一个PCIe端口，用于扩展PCIe总线，具有路由功能 PCIe桥，负责PCIe和其他总线转换连接，如连接PCI、PCI-X甚至是另外一条PCIe总线 Endpoint（端点设备），即PCIe接口的各种设备，分为标准PCIe端点和传统端点（LegacyEndpoint）    PCI-E不同版本的传输速率\n 表中“8b/10b编码”意为将8比特编码为10比特 表中“GT/s”表示“giga transfers per second”，2.5 GT/s对应每秒钟每通道传输2500M比特，若采用8b/10b编码，实际每秒钟每通道能传输的业务比特是2500M*8/10=2000M (bits)=250M (Bytes)  4.3.3. USB USB\nUSB(universal serial bus)，通用串行总线，是一种外部总线标准。用于规范电脑与外部设备的连接和通讯，是应用在PC领域的接口技术\nUSB接口支持设备的即插即用和热插拔功能\nUSB是在1994年底由由Compaq、Digital、BM、Intel，Microsoft、NEC和NothernTelecom7家公司联合提出的\n在USB1.0/USB2.0中，“D+”和“D-”组成一对差分信号线用于数据传输，VBUS和GND对应5V电源和地\nUSB3.0后，又增加了两对差分信号线以提供更高速的数据传输\nUSB的机械接口\nUSB不同版本\n4.3.4. 典型的计算机总线系统 以8051为核心的嵌入式控制器的总线\n8051是一种八位单芯片微控制器，属于MCS-51单芯片的一种，由Intel于1981年设计\n以Cortex-M3为核心的嵌入式控制器的总线\n Cortex-M3内核通过DCode总线访问数据存储器SRAM，通过ICode总线访问代码存储器Flash，同时挂接到系统总线上 两个DMA控制器通过DMA总线连接系统总线 外设模块则APB总线挂接，AHB到APB的桥连接所有的APB设备 所有的总线通过一个多级的AHB总线架构相互连接  基于8086的初期PC系统总线\n 全球第一款16位通用微处理器芯片，诞生于1978年 Intel在二十世纪70年代设计了8086微处理器，是x86架构处理器的鼻祖。8086有16根数据线和20根地址线（其中16根是与数据线复用的） 8086系统为简单的单总线结构  x86架构PC早期基于前端总线的多总线结构\nCPU通过前端总线FSB（F ro n tSideBus）与存储器和外设进行数据交互，计算机主板上的北桥（Northbridge）芯片负责联系内存、显卡等数据吞吐量最大的部件，并和南桥芯片（S o u t hbridge）连接。CPU就是通过前端总线FSB连接到北桥芯片，进而通过北桥芯片和内存、显卡交换数据\n如今x86架构PC的PCH控制总线结构\n2009年，Intel推出的单芯片设计的南北桥芯片整合方案。这颗主控芯片既不叫北桥，也不叫南桥，而是称作“Platform Controller Hub”芯片。PCH主要负责PCI-E和I/O设备的管理，它实际上仅提供南桥的功能（此时处理器已经整合北桥功能）\n第十代智能英特尔® 酷睿™\n 2019年Intel发布的第十代智能英特尔® 酷睿™ 移动式处理器，添加了一些新的接口标准，如雷电接口、USB3.1、SATA3.0。 PCH已经不再是一颗单独封装的芯片，而是和CPU一起被封装在一起  4.4. 输入/输出接口 CPU与存储器交换信息——数据格式和存取速度基本匹配\nCPU与外设交换信息——由于外设的多样性\n 速度有较大差异 信号电平不一致 数据格式不同 时序不匹配  因此CPU必须经过中间电路再与外设相连，这部分电路被称为I/O接口电路\n完整的I/O接口不仅包括外部设备与CPU或计算机之间的硬件电路，也包括相应的驱动程序\nPC机系统板的可编程接口芯片、I/O总线槽的电路板、适配器/连接器都是接口电路\n4.4.1. 输入/输出接口概述 4.4.1.1. I/O接口的功能  设置数据缓冲解决速度不匹配问题  事先把要传送的数据准备好，在需要的时刻完成传送。经常使用锁存器和缓冲器，并配以适当的联络信号来实现这种功能   设置电平转换电路解决电平不一致问题  如计算机和外设之间串行通信时，必须采用（线路）驱动器进行电平转换   设置信息转换逻辑满足各自格式要求  将外设传送的模拟量，经A/D转换成数字量，送到计算机去处理。计算机送出的数字信号经D/A转换成模拟信号，驱动某些外设工作   设置时序控制电路同步CPU和外设的工作  接口电路接收CPU送来的命令或控制信号、定时信号，实施对外设的控制与管理，外设的工作状态和应答信号也通过接口及时返回CPU，以握手联络(handshaking)信号来保证主机和外部I/O操作实现同步   提供地址译码电路  计算机中存在多个外设，每个外设需要与CPU交换几种信息，因此接口电路中常含若干端口，其I/O地址由接口电路中的地址译码电路提供   提供I/O控制、读/写控制及中断控制等逻辑  4.4.1.2. I/O接口的分类 按数据传输方式\n 可分为串行接口和并行接口  并行接口：指微处理器与I/O接口之间、I/O接口与外部设备之间均以多个比特位的并行方式送数据 串行接口：接口与外设之间采用单个比特位串行方式传送数据   串行接口 vs 并行接口  并行接口适用于传输距离较近、传输速度较高的场合，接口电路相对简单 串行接口适用于传输距离较远、传输速度相对较低的场合，传输线路成本较低，接口电路相对并行接口更复杂    按时序控制方式分类\n  同步接口\n 同步接口是指数据传输由统一的时钟信号同步控制，这个时钟信号为发送方和接收方共有    异步接口\n 异步接口上的数据传送则采用异步应答的方式进行，不依赖于统一的时钟    按主机访问I/O设备的控制方式分类\n 程序查询接口  指CPU通过程序来查询I/O设备的状态（状态信息通常保存在状态寄存器中），并执行相应接口的数据访问操作   中断接口  指I/O设备与CPU之间采用中断方式进行联络，即I/O设备向CPU提出中断请求，CPU响应中断请求后运行中断服务程序与I/O设备进行信息交换   DMA接口  指I/O设备与主存间采用直接内存访问的方式传递数据，这种交换方式一旦建立后，，不需要CPU参与即可实现存储器与I/O设备之间的数据传送    其他分类\n如按数据流方向可分为单工、半双工、全双工\n4.4.1.3. I/O接口规范的常规内容 接口设计的目的是为了协调上述微处理器与外设之间的不一致，用来实现速率匹配、缓冲、数据格式的转换和电平的转换等功能\n依据不同外设的特点，形成了很多典型的接口设计，这些全球通用的接口设计方案往往以工业界公认的规范（Specification）形式出现\n 存储接口SATA(Serial Advanced Technology Attachment) 通用数据接口USB (Universal Serial Bus) 视频接口DVI (Digital Video Interface) 视频接口HDMI(High Definition Multimedia Interface)  输入/输出接口电路\n输入/输出接口电路的功能隶属于通常意义的物理层功能。规定了为传输数据所需要的物理链路创建、维持、拆除，而提供具有机械的、电子的、功能的和规范的特性\n 机械特性，指明通信实体间硬件连接接口的机械特点。如接口所用接线器的形状和尺寸、引线数目和排列、固定装置等。 电气特性，规定了在物理连接上，导线的电气连接及有关电路的特性。一般包括接口电缆的各条信号线上出现的电压的范围、信号的识别、最大传输速率的说明、发送器的输出阻抗、接收器的输入阻抗等电气参数。 功能特性，指明物理接口各条信号线的用途，如某条信号线上出现的高低电压表示什么含义。如接口信号线分为数据线、控制线、地址线、时钟线和接地线等。 规程特性，规定接口传输比特流的全过程，及不同传输事件发生的先后顺序，规定了物理连接建立、维持和交换信息时，收发双方在各自电路上的动作序列  I/O接口标准的链路层功能\n在一些输入/输出接口的标准定义中，除了物理层功能，也纳入了数据块格式、数据块检验方式等链路层功能（OSI模型的第二层）\n4.4.1.4. I/O接口的结构 I/O端口\nI/O端口指I/O接口电路中的各类寄存器\nCPU与外设通信时，主要传送数据信息、状态信息和控制信息\n在接口电路中，这些信息分别进入不同寄存器，CPU也是通过地址对这些寄存器进行寻址。为了与内存单元及CPU内部寄存器相区别，通常将这些寄存器和它们的控制逻辑统称为I/O端口\n在一般接口电路中都要设置以下几种端口：数据端口、状态端口、命令/控制端口。此外还有中断控制逻辑，负责中断请求信号的建立与撤销\n端口寄存器\n读信号用以指示数据从I/O传输到CPU\n写信号用以指示数据从CPU传输到I/O接口\n高位地址生成片选信号，选择当前接口\n低位地址连接外设片内地址线，选择内部端口\n 数据端口  用来存放CPU与外设需要交换的数据，长度一般为1~2字节。数据口主要起数据缓冲作用   状态端口  指示外设的当前状态。状态口通常具有以下几个常见的状态位，以反映外设的工作状态 准备就绪位（Ready）  对于输入输出端口，该位为1表明端口的数据寄存器已准备好数据，等待CPU来读取；当数据被取走后，该位清0 对于输出端口，该位为1表明端口中的输出数据寄存器已空，可以接收下个数据；当新数据到达后，该位清0   忙碌位（Busy）  表明输出设备是否能接受数据 若该位为1，表示外设正在进行I/O传送操作，暂时不允许CPU送新的数据过来 本次数据传送完毕，该位清0，表示外设已处于空闲状态，又允许CPU将下一个数据送到输出口   错误位（Error）  如果在数据传送过程中产生了某种错误，可将错误状态位置1，以便CPU进行相应的处理 系统中可以设置若干错误状态位，表明不同性质的错误，如奇偶校验错、溢出错等     命令端口  也称为控制端口(Control Port)，用来存放CPU向接口发出的各种命令和控制字，控制接口或设备的动作 常见的命令信息有启动、停止、允许中断等    4.4.1.5. I/O端口编址 I/O端口的编址方法\n为了让CPU能够访问这些I/O端口，每个I/O端口都需要有自己的端口地址（或端口号）\n处理器通过端口地址可对各个端口寻址访问\nI/O端口有两种编址方式：独立编址和统一编址\n  I/O端口统一编址\nI/O端口统一编址也称为内存映像编址（memory mapped I/O addressing）方式\n将外设接口中的I/O寄存器（即I/O端口）视为主存的存储单元，每个端口占用一个存储单元的地址，把主存地址的一部分划出来用作I/O地址空间\n所有访存指令均可用来访问I/O端口，不用设置专门的I/O指令\n  I/O端口独立编址\nI/O端口独立编址又称分离编址（Isolated I/O Addressing）\n存储器和I/O端口分开编址，即存储器和I/O端口的地址空间相互独立，I/O端口编址不占用存储空间，使用专门的IN/OUT指令来访问I/O端口\n  统一编址 vs 独立编址\n  独立编址：\n优点：\n I/O端口地址不占用存储器地址空间 I/O端口地址译码较简单，寻址速度较快 使用专用I/O指令和存储器访问指令有明显区别，可使程序可读性较好  缺点：\n 专用I/O指令类型少，功能简单，远不如存储器访问指令丰富 CPU提供存储器读/写，I/O端口读/写两组控制信号    统一编址：\n优点：\n 对I/O口的操作与对存储器的操作完全相同，无需专用的I/O指令 外设数目或I/O寄存器数目几乎不受指令限制 CPU读/写控制逻辑较简单  缺点：\n 占用了存储器的一部分地址空间 增加了地址译码电路的复杂性      4.4.2. 输入/输出接口的数据传送方式 外设的多样性使外设极其接口电路的差异极大，故而需要多种CPU与外设接口交换信息的方式。常用的数据传送方式包括：\n 程序控制方式（软件），数据传送在程序控制下完成  无条件传送：外设永远处于“准备好”的状态 条件传送（查询传送）：只有外设状态许可才可访问   中断方式（软件）  中断发中断请求，CPU响应后完成数据传送   DMA方式（硬件）  DMA控制器临时接管CPU地址、数据和控制总线，在存储器和I/O接口之间实现直接数据传送   通道处理机方式（I/O Processor），专用I/O处理器，如Intel 8089  4.4.2.1. 无条件传送方式 也称为同步传送方式，主要用于对简单外设进行操作，所需的硬件和软件都较少\n特点\n 需要输入时，总是认为输入设备处于准备好状态 需要输出时，总是认为输出设备处于准备好状态，无需对外设进行查询 需要输入或输出操作时，直接执行I/O输入输出指令，立即进行数据传送操作 此类接口在实现时，数据输入需要使用缓冲器，数据输出需要使用锁存器  I/O接口电路\n 三态缓冲器：  三态输出受使能输出端的控制，当使能输出有效时，器件实现正常逻辑状态输出；当使能输入无效时，输出处于高阻状态，相当于与所连电路断开 作用：  外设数据保持时间相对于CPU的处理时间要长的多 输入数据不能影响系统总线的正常使用     输出使用一个锁存器  CPU速度很快，而物理外设的速度比较慢，需要电路输出端保持数据    4.4.2.2. 查询传送方式 也称为异步查询传送方式\n有一些外设，处理器访问时需要关心外设的状态，只有状态许可方可访问外设：\n 如，对A/D转换器的访问，只有模/数转换结束后，CPU才能读取转换的结果。又如，在使用串口外设进行数据通信时，只有串口发送缓冲区有空位置了，CPU才可以写入数据；同理，CPU接收数据的时候，也需要在接收缓冲区不空（有接收数据）时进行读取 CPU对此类外设进行输入或输出操作时需要考虑外设的状态，故此类外设的访问方式也称为条件传送方式 大多数外设都是条件访问方式  特点：\n 输出：CPU对外设查询“BUSY？”，不忙才输出，否则继续查询 输入：CPU对外设查询“READY？”，准备好才读入，否则继续查询 接口特点：  优点：避免了对端口的“盲读”、“盲写”，数据传送的可靠性高，并且硬件接口相对简单 缺点：CPU工作效率低，I/O响应速度慢   对外设的要求：提供状态口和数据口 在有多个外设的系统中，CPU的查询顺序由外设的优先级确定  查询流程\nI/O接口电路\n为了实现状态的查询，接口电路中既要有数据端口，又要有状态端口\n4.4.2.3. 中断传送方式 特点\n 优点：  提高了CPU的工作效率 外围设备具有申请服务的主动权 CPU可以和外设并行工作 可适应实时系统对I/O处理的要求   采用中断方式后，仅在需要进行I/O传送时外设才向CPU发中断请求 CPU在中断服务程序中完成CPU和外设之间的数据交换  I/O接口电路\n 外部设备需要传输数据时，外设触发中断控制器的中断请求信号并由中断控制器把该信号送给CPU，CPU收到中断请求信号后，暂停当前程序的运行，而转去执行读/写接口数据的中断服务程序，实现CPU与外设的数据传输 在程序查询方式中，由于CPU对外部设备会执行大量状态查询的指令，CPU的利用率不高。如果CPU采取不断查询的方法，则长期处于“等待”状态，不能进行别的处理，也不能对其他事件做出响应。在程序中断传输方式下，I/O端口状态查询工作交给中断控制器去完成。由中断控制器接收申请，并负责优先级排队、嵌套（抢占）管理和中断屏蔽设置等事务  中断的概念\n  定义\n 中断：由于某些事件计算机中止当前程序的运行，转去执行中断服务程序，中断服务程序完毕后，又返回继续运行正常程序 中断源：引起中断的原因    中断源\n 为了区分源自CPU的内、外的中断源，早期的资料中习惯上把来自CPU外部的外中断称作中断（Interrupt），而把来自CPU内部的内中断称作陷阱（Trap） 如今的微处理器芯片则习惯用异常处理（Exception Handling）机制来描述过去CPU设计中的中断技术  ARM的Cortex-m3/m4的嵌套中断控制器（NVIC，Nested Vectored Interrupt Controller）处理芯片内所有的异常（Exception） Cortex-m3/m4定义的异常包括不可屏蔽中断（NMI）、硬件错误（HardFault）内存管理错误（MemMange Fault）、总线错误（Bus Fault）、使用错误（Usage Fault）、系统定时器（SysTick）等，另外还有多达240个外部中断 Intel 8259A是著名的可编程中断控制器，一片可以管理的外部中断数为8个      典型计算机系统中的中断源\n通常计算机系统的中断处理模块可以管理多个中断源并处理多种不同类型的中断。为了能够识别不同的中断源，会对中断源进行命名或编号，这个编号被称为中断类型码或中断类型号\n  中断向量\n 中断向量即中断服务子程序的入口地址（或首地址）。即中断服务子程序的第一条指令在存储器中的存放地址。一般来说，每个中断源都有自身的中断名或中断向量，有自身对应的中断服务子程序 通常的处理器设计中，所有的中断服务子程序入口地址会集中存放在存储器的特定区域（如8086系统中是内存的最低1KB），特定的中断类型码对应这个区域中特定位置的中断矢量。这个特定的区域称为中断向量表（IVT，Interrupt Vector Table），通过中断向量表将中断类型码和中断向量关联起来 当中断发生的时候，系统根据中断类型码到中断向量表中获得中断向量的过程也被称做中断索引    断点和现场\n 断点：指被中断的主程序下一条待执行指令在存储器中的地址，也就是中断返回时的程序地址  为保证在终端服务子程序执行完之后能正确返回到原来的程序，中断系统必须能在中断发生时自动保存断点，并在中断返回时自动恢复断点   现场：指中断发生时原主程序的运行状态，一般指系统标志（状态）寄存器和其他相关寄存器中的内容  为了保证在中断返回后能继续正确地执行原来的程序，中断系统必须在中断发生时对现场进行保护，并在中断返回时恢复现场      中断处理过程\n 计算机系统中，中断的整个过程分为：中断响应、中断处理和中断返回等三个阶段 上图位8086 CPU的中断处理过程  TF（Trap Flag），陷阱标志位 IF（Interrupt Flag），允许标志位 CPU内部标志寄存器中的两个控制标志位 TF=1，表示单步中断（陷阱） IF=1，表示允许外部中断   注意：  保护断点是由CPU自动完成 保护现场是由中断服务程序完成，但是现代CPU也能自动保护部分寄存器      优先级、嵌套\n 中断优先级  中断请求有优先顺序之分。若同时出现多个中断请求，CPU按照事先规定的策略，响应优先级最高的中断请求 对外设优先级的判断一般可以采用软件查询、硬件排序或采用专用芯片管理等方法来实现   中断嵌套  CPU正在执行中断服务程序时又有优先级更高的中断请求到达时，如果此时CPU允许中断，则CPU暂停当前中断服务程序，进入更高级的中断服务程序   中断屏蔽  CPU通过硬件电路和软件设置，对中断源产生的中断请求能否到达CPU的硬件引脚进行控制  系统设置+优先级 可屏蔽中断INTR(Non Maskable Interrupt)和不可屏蔽中断NMI（Interrupt Require） 不可屏蔽中断源一旦提出请求，CPU必须无条件响应，而对可屏蔽中断源的请求，CPU可以响应，也可不响应        中断优先级管理\n  软件管理（软件查询）\n 软件管理也需要使用少量硬件电路，当系统中有多种外部设备，将这些设备的中断请求信号相“或”，从而产生一个总的中断请求信号INTR发给CPU CPU读取中断请求寄存器后可获知有哪些中断，之后程序员所选择的处理顺序就体现了优先权    中断优先权编码电路（硬件排序）\n任一外设对应的中断请求位和中断允许位同时为“1”时，即可产生中断请求信号\n在两种情况下该中断请求信号能传送至INTR引脚：\n 比较器输出为“1”时，中断请求信号可通过与门1送出 “优先权失效”信号为“1”时，中断请求信号可通过与门2送出  编码器每位输入线的有效电平都对应一个编码，在多位输入线有效时编码器只输出优先权最高的编码\n优先权寄存器中记录的是CPU当前正在处理的中断的编码\n若A\u0026gt;B，比较器输出“1”，可以产生中断嵌套\n“优先权失效”信号用于一种名为特殊屏蔽中断方式，该方式所有中断源没有优先级之分\n  菊花链式优先权排队电路（硬件排序）\n每个中断源接口电路中设置一个逻辑电路，组成一个daisy chain，菊花链\nCPU送出中断响应信号后，若设备1无中断请求，则与门A1关门，A2开门，中断响应信号继续向下一级传送\n若设备2有中断请求，则与门B1开门，中断响应信号送至设备2，同时B2关门，中断响应信号不再向下传送\n设备接入菊花链的顺序就确定了设备的中断优先级别\n对链的长度有限制\n  中断控制方式的接口电路（以输入为例）\n当外设准备好输入数据后发出选通信号，数据进入锁存器中，并同时将中断请求触发器置“1”。如果中断屏蔽触发器允许中断（Q1输出为“1”），与门被打开，因而可以产生中断请求信号INT\nINTA#为中断响应信号，INTA#到达后将撤销INT请求\n4.4.2.4. 直接存储器访问（DMA）方式 问题的提出\n 采用程序控制方式进行数据传送时，都是靠CPU执行指令实现数据的输入/输出。CPU先从“源”将数据读入到内部寄存器，再将内部寄存器的数据写到“目的”，因此存储器与I/O接口之间进行数据传送至少需要两个完整的总线周期 中断方式虽能较好地利用CPU资源，但是每次进入中断和退出中断的现场保护与恢复需较多的时间开销 对于高速外设（如磁盘或高速数据采集系统等），程序控制方式传送无法满足数据传输率的要求  基本思路\n DMA方式也要利用系统总线，平时总线由CPU管理，当外设需用DMA方式传送数据时，可请求CPU让出总线控制权，用专用硬件接口电路临时接管总线，在I/O接口与存储器之间直接进行数据传送 该电路在一个总线周期内能够同时发出内存单元和I/O端口的选择信号以及“源”的读信号和“目的”的写信号，直接将“源”输出的数据写到“目的”中 以上方式称为直接存储器存取（Direct Memory Access），简称DMA方式。完成这一任务的硬件控制电路称为DMA控制器，简称DMAC  DMA传送形式\nDMA又分为DMA写（I/O接口 → 内存）和DMA读（内存 → I/O接口）。下图是几种DMA传送形式的示意：\n基本步骤\n 需要DMA传送的外设发DMA请求DREQ（DMA Request）到DMAC 若运行，DMAC向CPU或总线仲裁机构发出总线请求HRQ（Hold Request） CPU或总线仲裁器若同意总线使用权转移，发总线响应信号HLDA（Hold Acknowledge），并完成总线切换 DMAC接管总线，发DACK通知（也是选定）外设，即将DMA传送的外设 DMAC发内存单元地址信号，若是DMA写，再发I/O读和存储器写信号；若是DMA读，发存储器读信号和I/O写信号 DMA结束后，DMAC撤消HRQ，CPU或者总线仲裁器撤消HLDA，CPU重新接管总线  基本工作方式\n  单次传输方式\n  假设从Memory → 外设\n  DMA控制器每次请求总线只传送一次数据，每次传送的数据大小取决于总线宽度\n  传送完后即释放总线控制权，如果还有数据需要传送，继续申请\n    块传输方式\n DMAC获得总线使用权之后，“一口气”把整个数据块全部传送完成后再释放总线控制权 特点：获得总线使用权后，DMAC控制总线连续传送，直到传送任务全部完成 如果在传送期间遇到了外部输入的EOP（End of Process）信号，传送任务将被强行终止    请求传输\n  此方式与块传输方式基本类似，不同的是每传输一次，DMA控制器都要检测DREQ信号是否仍然有效，如果该信号仍有效，则继续进行DMA传输；否则，就暂停传输，交还总线控制权给CPU，直至DMA请求信号再次变为有效，数据块传输则从刚才暂停的那一点继续（称为“断点续传”）\n  随机请求：\n  与成组传送区别：在传送期间，若DMA请求信号无效，DMAC暂停传送并放弃总线。当DMA请求信号重新有效，DMAC再次申请总线使用权，获准之后从断点处续传\n  在询问方式中，DMA请求信号的作用类似于“PAUSE”\n    DMA传送方式的特点\n 依靠硬件实现数据传送  不运行程序，不能处理较复杂的事件。故DMA方式并不能完全取代中断方式，当某事件处理不只是单纯的数据传送时，还是需要采用中断方式。事实上，在以DMA方式传送完一批数据后，常利用中断通知通知CPU结束处理   DMAC本身也是接口芯片  在使用之前需要进行初始化配置 DMAC有个缺陷，无法对接口进行寻址，当多个外设需要采用DMA传送方式时，DMAC一般会设置多个通道，为多个外设提供DMA传送服务。每个通道都有自己的一套寄存器和DMA请求响应信号线。多个通道还需要通过优先级电路加以排队，决定先响应哪个通道的DMA请求    4.4.3. 并行接口 串行与并行\n  串行传输\n 将需传输的比特串排成一行，一个接一个地在一条信道上传输 串行总线只用一根信号线（如果传输的是差分信号则是两根信号线）来传输数据 只需要少数几条线就可以在系统间交换信息，特别适用于计算机与计算机、计算机与外设之间的远距离通信    并行传输\n 将数据以成组的方式在两条或更多的并列信道上进行传输 一组数据的各数据位在多条线上同时传输 并行通信时数据的各个比特位同时传送，可以字或字节为单位并行进行。并行通信速度快，但用到的信号线多、成本高，故不宜进行远距离通信    4.4.3.1. 无握手信号的并行接口 无握手信号的并行接口典型电路\n采用无握手信号接口连接的外设一般是功能简单的电路模块，如按键，数码显示管等。CPU与这些无握手信号的外设接口传输数据时，总是假定外设总是处于准备好的状态\n输入接口示例：线性键盘\n  键盘分类：按压式、常开式、开关阵列\n  按压式开关存在的问题：抖动、串键（2个或2个以上的键被同时按下，又称重键）\n  依据按键状态获取方式的不同，可以将键盘分为线性键盘和矩阵键盘，矩阵键盘又可分为非编码键盘和编码键盘\n 线性键盘：每一个案件需要占用I/O端口的一根口线 矩阵键盘：可分为非编码键盘和编码键盘  编码键盘——能够自动提供被按下键的编码信息，同时产生选通脉冲，具有抖动处理和重键保护功能，但是键数较少 非编码键盘——由一组开关组成，通常按照行列排列所以又称为矩阵键盘。需要通过接口电路和软件实现键码识别（确定被按下键的行列位置），并解决防抖和串键的问题      输入接口示例：矩阵键盘\n 思路：首先输出0x00，读入如果为0xFF则无按键按下；再逐列检查是否有键按下，发现某列有键按下后再确定行  输出接口示例：LED显示\n 码显示管是一种半导体发光器件，简称数码管，分为点阵式和段式。常见的段式有7段或8段（多一个小数点） 按照连接方式分为共阳极和共阴极两种结构 按照显示特性又分为静态显示和动态显示  静态显示方式  每个数码管相应的段（发光二极管）恒定地导通或截止，直到下一次更换信息 若需要显示N个数字，那么数码管个数为N时，需要的接口口线数目为8×N   动态显示方式  各个数码管轮流显示，每位数码管的点亮时间约1～2ms，由于人的视觉暂留现象及发光二极管的余辉效应，尽管各个数码管并非同时点亮，但给人的印象是所有数码管同时显示 在动态显示方式下，各个数码管的对应段输入控制端并连在一起，因此无论数码管的个数是多少，需要的口线数目都只需要8条，该端口称为段选口。各个数码管的公共端分别连接一根口线，该口线称为位选口。当数码管的个数为N时，则需要的位选口口线数目为N，因此动态显示方式总共需要的口线数为8＋N      输出接口示例：数码管的显示接口电路\n 图为显示5位十进制数的共阴极LED数码管接口电路。8位段选码由一个I/O端口控制，在每次输出段码之后，5个数码管同时获得了该段码值。要在每个数码管显示不同的字符，就必须采用扫描方法，轮流点亮各个LED数码管 扫描即控制位选码 显示第一个十进制数字时，段选控制端口输出相应字符的显示码；位选码中对应第一个数码管的位为“0”（低电平，因数码管为共阴极结构），而其他位为“1”（高电平） 显示第二个数字时，第二个数码管的位选码为“0”，其他位都为“1”  4.4.3.2. 带握手信号的并行接口 带握手信号的输入接口电路\n 输入设备发出选通信号，将准备好的数据送到接口电路的数据锁存器中，同时使D触发器置“1”并将该信号送到状态缓存寄存器中待CPU查询 CPU读取接口中的状态寄存器，检查状态信息。READY为“1”，说明数据已到数据缓冲寄存器 CPU读数据端口，同时数据端口的读信号将D触发器清零，令READY为“0”，完成本次传送  带握手信号的输出接口电路\n CPU读状态口，若BUSY为“0”，说明数据缓存器空，外设可以接收数据 CPU向数据端口写入需发送的数据，同时将接口中的D触发器置“1”，该信号作为状态信号BUSY，一方面通知输出设备：“输出缓冲器满”，外设可以取数据；另外一方面作为状态信号，让CPU了解数据输出的动态 输出设备发响应信号ACK，一方面从接口的数据锁存器中读出数据；另外一方面将接口中的D触发器清零，再次使BUSY=“0”，完成本次数据传送  4.4.3.3. 可编程并行接口（GPIO） GPIO模块电路\n可编程通用并行接口是计算机及其他数字电路系统中最常使用的一种简单外部设备接口电路。其结构简单、应用途广泛，且可以通过编程控制字来实现控制，故得名“通用可编程I/O接口”，即GPIO（General-Purpose IO ports）\n可编程并行接口芯片：Intel 8255A\n早期的计算机使用单独的可编程芯片来控制I/O，如英特尔的8255芯片有3个8位并行I/O口，具有3个通道、3种工作方式：\n 工作方式0：基本输入/输出方式 工作方式1：选通输入/输出方式 工作方式2：带选通的双向传送方式  典型嵌入式控制器的I/O端口位接口\n微控制器芯片（单片机）往往会集成GPIO接口。一般来说，GPIO接口至少有两个寄存器，即“通用I/O控制寄存器”与“通用I/O数据寄存器”\n4.4.4. 串行接口 4.4.4.1. 串行接口概述 概述\n串行通信——数据在单条一位宽的传输信道上按时间先后一位一位地进行传送。与并行通信相比，串行通信具有以下特点：\n 优点：  不仅传输距离远，而且串行数据传送速率比并行数据传送速率更快，因为串行通信的通信时钟频率比并行通信更容易提高 抗干扰能力强，通信费用低 传输线既传数据，又传联络信息   缺点：需要串/并转换，对数据格式有要求  通过Modem实现远程数据通信\n串行通信常用于需要远距离传输的情形，然而受限于传输线的特性，数字信号无法在传输线上直接进行远距离传输。一般发送方需要使用调制器（Modulator），把要传送的数字信号调制为适合在线路上传输的信号；接收方则使用解调器（Demodulator），将从线路上接收到的调制信号进行解调，还原成数字信号。调制器和解调器两者通常集成在一起作为一个设备，称为调制解调器（Modem）\n调制解调器被称为DCE（Data Communication Equipment，数据通信设备）数据终端被称为DTE（Data Terminal Equipment，数据终端设备）\n串行通信的性能参数\n 衡量数据传输速率有两个单位：  比特率：单位时间内传送的二进制码元的个数，单位是bps ( bit per second )。由于1个二进制码元代表了1 bit的信息，因此比特率也称为传信率 波特率：单位时间内传输的符号个数，单位是波特(Baud或Bd)   计算机普遍采用二进制，一个“符号”仅有高、低两种电平，分别代表逻辑值“1”和“0”，所以每个符号的信息量为1比特，此时波特率等于比特率。但在其它一些应用场合，一个“符号”的信息含量可能超过一个比特，此时波特率小于比特率  串行通信的同步方式\n同步技术——能够检测和识别所传送的数据单元（位、字符或字节、帧、数据块等）的起止的技术\n根据同步方式，串行通信又分为：\n  同步通信方式\n 收发双方在时钟同步的基础上，通过位同步以及帧同步等措施，保证可正确接收和识别所传送的数据 同步串行接口传输信息时，发送方和接收方电路在同一个时钟下工作，所传输信息的字节与字节之间、位与位之间均与时钟有严格的时间关系 图中包含了八个数据位。很多同步协议首先发送MSB（Most Significant Bit），而很多异步协议首先发送LSB（Least Significant Bit）    异步通信方式\n 收发双方通过信号波形编码表示所传输数据单元的起止。收发双方的时钟相位互不相关，甚至允许频率存在误差 收发双方使用异步串行接口传输数据时，只使用数据线，而不像同步串行接口那样还需要时钟信号。异步串行接口常用于计算机系统之间的远程数据传输，可以实现远程通信 图示为异步传输协议下发送串行数据的示意，中包含了七个数据位、一个起始位和一个停止位    4.4.4.2. 异步串行接口 概述\n 如果采用相同的接口时钟频率，串行数据传输的速度要比并行传输慢得多，但对于覆盖面极其广阔的公用电话系统来说具有更大的现实意义 另外，并行接口时钟频率提升会遇到瓶颈，近年来出现了很多高速的串行接口标准 “异步串行接口”包括了两方面的内容：  串行通信双方进行数据传输时的接口电路 收发双方约定的通信协议    异步串行数据帧格式\n拟传输的数据以字符（一个字符通常含五至八位）为单位进行传送。考虑到传送发生的相对时间是随机的，为了确保整个通信过程的正确性，需要找一种合适的方法，使发送方和接收方在所传送的字符与字符间实现同步。常用的方法：在字符数据格式中设置起始位和停止位\n如图。每个字符传输包括：一个起始位（低电平，逻辑“0”）、五至八位有效数据位、一位奇偶校验位、一位（或1.5位，或2位）停止位，停止位（高电平）之后是不定长度的空闲位（高电平）\n异步传输信号波形的检测\n问题：难以保证收发双方时钟的频率完全相等、相位严格对齐 → 检测困难\n解决办法：设约定的波特率为$N$，接收方用频率为$M$的时钟对接收信号进行检测，$M＝K×N$，$K$称为波特率因子，$K≥1$。有些芯片$K$可编程设置，有些固定，如$K=16$\n设$K=16$，接收端检测到一个低电平时，须证实是否的确是起始位。不同的芯片可能采用不同的方法，如：隔八个再检测一次，若仍为低电平则确认是起始位。或连续检测八个，若有五次以上是低电平则确认是起始位而不是干扰\n确认了起始位后，从第九个检测脉冲（起始位中间位置）开始，接收端每隔16个脉冲采样一次输入信号，顺序接收各个数据位\n异步串行接口电路\n异步串行接口电路需要完成的基本功能包括：\n 数据的串/并、并/串转换 串行数据的格式化（如自动加入起始位、校验位或同步字符等） 校验码的生成 现接口间控制信号的解析 调制与解调  发送过程：从数据总线上接收来自CPU的并行数据 → 基于移位寄存器进行并/串转换 → 入起始位、停止位等 → 按特定波特率由TXD发送\n接收过程：RXD输入的数据 → 在本地时钟和波特率发生器的控制下，经同步控制器送给移位寄存器 → 串/并转换后进入接收缓存器 → 同时进行错误检测、帧解析并把相关信息写入状态寄存器 → 通过中断告知CPU接收完毕\n异步串行接口信号定义\n异步串行接口协议\n 接口协议（标准）是通信的收发双方共同遵循的传输数据帧结构、传输速率、检错与纠错、数据控制信息类型等相关约定 在任何一个串行通信协议中，都会对接口物理层的机械特性、电气特性、规程特性和功能特性进行规范 本节讨论常见的异步串行通信协议，如RS-232、RS-422、RS423和RS-485  最常见的串行通信标准：RS-232C接口\n S-232是由EIA（Electronic Industry Association，美国电子工业协会）1970年制定的串行二进制数据交换接口技术标准。先后出现了多个版本，其中应用最广的是修订版C，即RS-232C RS-232C标准最初是为远程通信连接数据终端设备（DTE）与数据通信设备（DCE）而制定的。虽然该标准并未考虑计算机系统的要求，但后来它被广泛应用于计算机系统 RS-232C定义了DTE与DCE之间的物理接口标准。数据通信设备可以是传真机、电话机、智能终端等  物理层中的连接指的是DTE和DCE之间的连接（又称接口） 物理层的功能是在两个网络设备之间提供透明的比特流传输    信号线定义——机械特性、功能特性\n标准串口的设置——规程特性\n 波特率 数据位 奇偶校验位 停止位 流控制  电气特性——负载电容与传输距离\n RS-232C传输电缆的长度与负载的电容值有关 标准规定被驱动电路（终端）的电容，包括电缆的等效电容必须小于2500pF 对于多芯电缆，每英尺（0.305米）电容为40~50pF，所以满足电容特性要求的电缆长度最长为50英尺（约15米）  电气特性——PC与一般单片机的串口逻辑电平\n 电脑上的RS-232接口采用的是负逻辑电平  -15V~ -3V表示逻辑1 +15V~ +3V表示逻辑0 电压值通常在7V左右   单片机的串口输出电路采用的逻辑电平是TTL电平。这种电平信号由TTL器件产生的，一般的芯片，如运放，数字器件等\u0026hellip; TTL：三极管结构  VCC：5V VOH\u0026gt;=2.4V；VOL\u0026lt;=0.5V VIH\u0026gt;=2V；VIL\u0026lt;=0.8V    RS-422/432标准\n RS-232接口是一种基于单端非对称电路的接口，即一条信号线与一条地线，这种结构容易受到干扰，传输距离受限。为此，EIA又制定了RS-422和RS-423等标准 RS-422标准采用了平衡差分传输技术，即每路信号都使用一对以地为参考的正负信号线。这种平衡差分结构的抗噪声能力较强，传输速率与距离都明显提高。最高传输速率为10Mbps，最远传输距离为4000英尺（1218米） RS422标准有点对点全双工与广播两种通信方式。广播方式下只允许一个发送驱动器工作，而接收器可以多达十个。RS-423则是RS-232与RS422之间的一个过渡标准，因而兼有两者的特点  RS-485标准\n S-485是RS-422标准的改进增强版本，该标准兼容了RS-422，提供了多点通信能力，很好地支持了联网功能，在仪器仪表和工业控制等领域得到了广泛的应用 多点通信能力的支持，把RS-232定义的异步串行接口改造为了一种总线。多个主机系统可以同时挂接到线缆上，RS-485实际上提供了“总线仲裁”的能力 在RS-485的多点通信系统中，接收器节点数可达32个，后期推出的版本则多达64/128/256个节点 RS-485标准器件的数据传输速率有32Mbps、20Mhps、12Mbps、10Mbps、2.5Mbps及数百kbps等各种规格  RS232/RS485/RS422对比\n4.4.4.3. I^2^C接口及总线 NXP(Philips) Inter-Integrated Circuit (I^2^C)\n PHILIPS公司开发的两线式串行总线（一条串行数据线SDA，一条串行时钟线SCL），用于连接微控制器及其外围设备  Synchronous / Master-Slave Protocol / Half Duplex   标准模式下：100Kbps；快速模式下：400Kbps；高速模式下：3.4Mbps  示例：2块芯片通过I^2^C连接\n驱动SDA和SCL线的器件的输出级必须漏极开路（OD门），以实现总线的“线与”功能。使用外部上拉电阻（接电源），以确保当没有器件将线拉低时能保持高电平\nI^2^C接口典型电路\nI^2^C的接口电路一般包括数据寄存器、控制寄存器、状态寄存器、地址寄存器，有些还包括和时钟有关的分频寄存器等\n主从式通信方式\n 为便于描述，I2C定义了“主器件”和“从器件”的概念。主器件（主机，或称为主设备）用于启动总线传送数据，并产生时钟，此时任何被寻址的器件均被认为是从器件（从机，或称为从设备） 从如果主器件要发送数据给从器件，则主器件首先寻址从器件，然后主动发送数据至从器件，最后由主器件终止数据传送 反之，如果主器件要接收从器件的数据，首先由主器件寻址从器件。然后主器件接收从器件发送的数据，最后由主器件终止接收过程  多主机总线\n I^2^C总线是一个多主机总线，在两根信号线上可同时挂接多个器件（存储器、键盘、LED、ADC等）。任何器件既可以作为主机也可以作为从机，但同一时刻只允许有一个主机 多主机总线，需要通过仲裁机制予以协调 I^2^C总线对发生在SDA信号线上的总线竞争进行仲裁。原理为：在检测到总线空闲（SCL和SDA均为高电平）后，拟使用总线的主机向SDA信号线发送数据（高电平或低电平），每一位数据发送后随即检测SDA信号线电平是否与自身发送电平一致，若电平不符则竞争失败，自动关闭其输出  I^2^C的地址\nI^2^C总线采用两线制总线，不具备微机系统所具有的由多位地址线所组成的并行地址总线，通过串行发送地址实现\n总线上每一个器件的地址必须是唯一的\nI^2^C标准中有7位地址和10位地址两种\nI^2^C总线协议状态\n 启动数据传输（S）；停止数据传输（P） 重新启动（Sr）：重新启动可以让主器件在不失去总线控制的情况下改变总线方向 数据有效（D）应答（A）或不应答（N） 等待/ 数据无效（Q）总线空闲（I）  I^2^C数据传输过程\n  主设备向从设备发送信息\n 主设备发送开始信号(S)，对应图中(S)状态 主设备发送7比特的从设备地址，对应图中发送地址阶段 主设备发送写命令(低电平，W#)，对应图中R/W# 接着从设备应答(A)，ACK为应答成功(A)，表示有这个设备 主设备发送8位字节数据 接着从设备应答，ACK为应答成功(A)，或，NACK为不成功为(N) 如果从设备应答成功(A)继续主设备发送数据；若应答不成功(N)则主设备发送停止信号(P)，对应图中(P)状态    主设备读取从设备信息\n 主设备发送开始信号(S)，对应图中(S)状态 主设备发送7比特的从设备地址，对应图中发送地址阶段 主设备发送读命令(高电平，R)，对应图中R/W# 接着从设备应答(A)，ACK为应答成功(A)，表示有这个设备 从设备发送8位字节数据，主设备从SDA上读取数据 接着主设备应答，ACK为应答成功(A)，或，NACK为不成功为(N) 如果主设备应答成功(A)则从设备继续往SDA上送数据；若应答不成功(N)则主设备在发送NACK后发送停止信号(P)，对应图中(P)状态    I^2^C电气特性\n I^2^C允许不同制造工艺生产的器件、使用不同电源电压的器件进行通信。具有固定输入电平的I^2^C总线器件，可以分别单独连接适合自己的电源电压，但是SDA和SCL必须通过上拉电阻（图中RP）连接到5V的公共电源上。 单个IO引脚的负载电容不能超过10pF，所有IO引脚的总负载电容不能超过400pF。拓展传输距离和可挂接器件数目，可将I^2^C总线分段。分段时可以使用缓存（buffers）、多路复用器（multiplexers）、交换开关（switches）等不同的芯片隔离不同的段，每段总的负载电容不能超过400pF  I^2^C支持的节点数\n 决定因素1：I^2^C从设备的地址位数。I^2^C标准中有7位地址和10位地址两种。如果是7位地址，允许挂接的I^2^C器件数量为：2^7^＝128，如果是10位地址，允许挂接的I^2^C器件数量为：2^10^＝1024，一般I^2^C总线上挂接的I2C器件不会太多，所以现在几乎所有的I^2^C器件都使用7位地址 决定因素2：挂在I^2^C总线上所有I^2^C器件的管脚寄生电容之和。I^2^C总线规范要求，I^2^C总线容性负载最大不能超过400pF  I^2^C操作示例：读取串行EEPROM\n 所有报文都以“启动”条件开始并以“停止”条件终止 第一个字节是器件地址字节 R/W = 0，表示主器件将充当发送器，从器件则将是接收器 接收到每个字节后，接收器件必须产生应答信号“ACK” \u0026hellip;\u0026hellip; 要让从器件向主器件发送数据，总线必须转为另一个方向。要实现此功能且不终止报文传送，主器件可发送一个“重新启动”信号。“重新启动”后接一个器件地址字节，该字节包含和前面相同的器件地址，但R/W = 1，以表明从器件发送，主器件接收 现在从器件发送驱动SDA 线的数据字节，主器件继续产生时钟信号  4.4.4.4. SPI接口及总线 SPI是一种高速、全双工、同步的通信总线，通信过程使用四根信号线\nSPI概述\n 同步串行外设接口，它可以使MCU与各种外围设备以串行方式进行通信以交换信息。是Motorola首先在其MC68HCXX系列处理器上定义的。SPI接口主要应用在EEPROM，FLASH，实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间 需要至少4根线，事实上3根也可以（单向传输时）  MISO (Master Input Slave Output)，主设备数据输入，从设备数据输出 MOSI(Master Output Slave Input)，主设备数据输出，从设备数据输入 SCLK(Serial Clock)，时钟信号，由主设备产生 CS (Chip Select)，从设备使能信号，由主设备控制    SPI中主设备与从设备的连接\n SPI上可以挂载一个主设备和多个从设备。任何时刻，一个主设备只与一个从设备进行通信，通信的从设备CS为低电平（有效） 在不使用CS信号时，SPI上只能有一个主设备与一个从设备 SPI的缺点是没有应答机制，传输过程全都由主设备进行控制，数据传输成功与否没法直接验证  SPI典型接口电路\n 发送缓冲区、移位寄存器、接收缓冲区的设计在一般串行通信接口电路中大体一致 状态寄存器SPI_SR、控制寄存器SPI_CR1、SPI_CR2、波特率控制寄存器BR虽然在不同厂家的SPI接口电路中也都有，但是寄存器比特定义往往略有差异  SPI数据传输过程\n通信过程由主设备发起，从设备参与\n当一个主设备需要向从设备发送数据，或者希望读取从设备数据的时候，主设备通过拉低对应从设备的CS#来告知从设备\n对于主设备来说，发送数据就是把比特逐个放到MOSI信号线上，而读取数据就是在MISO信号线上进行采样\nSPI的四种工作模式\nSPI工作状态简单，只有工作和空闲两个状态\n根据空闲状态对应时钟的高电平还是低电平，以及时钟上升沿和下降沿的动作，可以形成不同四种工作方式\n5. ARM处理器体系结构和编程模型 5.1. ARM体系结构与ARM处理器概述 5.1.1. 指令集体系结构与微架构 CA（Computer Architecture）：计算机体系结构\nCA是堆计算机系统的设计思想、逻辑特征、原理特征、结构特征和功能特征的一种抽象\n广义CA=指令集系统结构ISA+微架构μarch+硬件实现\n狭义CA=指令集系统结构ISA\n指令集体系结构ISA\n描述软件如何使用硬件的一种规范和约定，是程序员眼中的概念结构和功能特征，具体地就是程序员编程时能看到或者能用到的资源以及使用方式，包括：\n 可执行指令集合，包括指令格式、操作种类以及每种操作所对应的操作数规范 指令可接受的操作数类型 寄存器组结构，包括名称、编号、长度和用途 存储空间的大小和编址方式 操作数寻址方式及操作数存放格式 指令执行控制方式，包括程序计数器、条件码定义等  微架构μarch\nISA的硬件实现方式。亦即以何种方式来实现处理器的各种功能，包括运算器、控制器、流水线、超标量和存储系统结构等，属于计算机的组织和实现技术\n相同ISA的处理器可以有不同的微架构，如：\n ARM9T和ARM7Y  5级流水线哈佛结构vs.3级流水线冯诺依曼结构   AMD和Intel  都支持x86 ISA，但微架构不同    只要ISA相同，则软件兼容\n处理器体系结构的分类\nISA偏于处理器的软件层面，微架构偏于处理器的硬件层面\n基于ISA分类：CISC、RISC\n基于微架构分类：冯诺依曼结构、哈佛结构\n哈佛结构：\n 一种并行体系结构 程序和数据存储在不同的存储空间中，每个存储器独立编址，使用两套总线单独访问 可提高数据吞吐率，消除流水线上取指和取操作操作的资源相关，处理器性能高于冯·诺依曼结构 哈佛结构较为复杂，实现难度较大，早期较少采用  简化哈佛结构：\n Intel MCS-51单片机，指令和数据分别存储两个独立的存储模块，但仍共用一条公共总线，仍须分时访问 有些内部使用两条独立总线分别访问指令和数据（如Cortex-M系列处理器），有些内部分别配置指令和数据Cache或者TCM。但对外只有一条总线，外部指令和数据仍然存储在一个存储器中，旨在减少硬件复杂性  TCM（Tightly Coupled Memory，紧耦合内存），通过专用总线与CPU相连的高速存储器，性能与Cache相当，常与处理器集成在一起，早先也有片外的。与Cache的主要区别：具有物理地址、需占用内存空间、无Cache的不可预测性 用途：存放必须快速执行的中断服务程序和实时任务处理程序，以及不适合存放在Cache中的重要数据，如中断向量表和堆栈    5.1.2. ARM处理器体系结构简介 ARM体系结构版本特性简介\n v1版  与ARM1原型机同时诞生，仅用于ARM1原型机 32位处理器，地址总线只有26条，内存寻址空间64MB，只提供了一些基本指令，如：  基本数据处理指令，没有乘法运算指令 数据存取指令，可以对字节、半字和字数据进行存取 控制转移指令，包括子程序调用及链接指令  链接指令：一种转移指令，转移时将转移指令的下一条指令存入R14寄存器。需要返回时，使用MOV指令将R14寄存器的内容写入PC，就可实现程序的返回   供操作系统使用的软件中断SWI指令     v2版  ARM 2的内存寻址空间仍然只有64MB，为了提高数据处理能力，v2版增加了：  乘法运算和乘加运算指令 若干协处理器操作指令 快速中断模式FIQ（优先级高于普通IRQ） 存储器与寄存器之间进行数据交换的SWP（swap）指令，包括字交换指令SWP和字节交换指令SWPB   基于ARMv2版架构的处理器有ARM2、ARM2aS和ARM39   v3架构  有较大改进和完善，32位地址，内存寻址空间扩展到4GB，增加了Cache、新的寄存器和新的指令：  增加了CPSR，不再使用R15寄存器保存程序执行状态 增加了SPSR，用于异常处理时保存CPSR，以便恢复 增加了访问CPSR等特殊寄存器的MRS和MSR指令 增加了从异常处理返回指令的功能 新定义了abort和Undefined两种异常及相应的工作模式 将乘法和乘加运算指令扩展为32位  长乘法运算：32位×32位＝64位 长乘加运算：32位×32位+32位＝64位       v4架构  基于ARMv4的处理器主要是ARM8和Strong ARM ARMv4T版本——ARM体系架构的一个里程碑  引入16位Thumb指令集：ARM指令集中常用指令经重新编码压缩后的子集 执行时被实时且透明地解压，仍然是32位指令 具有ARM指令集的大部分功能但不如ARM指令集全面，实现某些复杂操作可能需要使用较多的Thumb指令 可提高代码密度，减少存储开销；在数据总线位宽为16位或8位的SOC系统中，可获得更优的性能 新增Thumb状态，与ARM状态可通过指令随意切换   v4T版在v3版的基础上所做的完善和扩展：  微架构开始采用流水线方式 增加了系统（System）模式，在该模式下可以使用用户模式寄存器运行具有特权级的系统管理任务 对软件中断指令SWI的功能做了完善 增加了无符号字节以及半字数据的加载/存储指令，如LDRB/STRB（字节）、LDRH/STRH（半字） 增加了有符号字节及半字的加载指令LDRSB/LDRSH 把没有使用的指令空间都作为“未定义指令”，并在UND异常中对其进行处理   ARM7T和ARM9T产品系列都基于v4T版   v5架构  微架构方面  增加了DSP，MCU和DSP可以合二为一 可选配矢量浮点处理器（Vector Float Processor，VFP） 增加JazelleDBX (Direct Bytecode eXecution) 的Java硬件加速器（ARMv5TEJ），可直接运行Java虚拟机字节码程序 带有AHB或者AHB Lite总线接口 引入（包括指令和数据）TCM或者TCM接口 v5版名称后缀中的字母T、E和J分别表示支持Thumb指令、增强的DSP指令和Java硬件加速技术   ISA方面的改进和完善  增加了DSP指令，为协处理器提供了更多可选择的指令 更加严格定义了乘法指令对条件标志位的影响 增加了支持有符号数的加减饱和运算指令（饱和运算是指出现溢出时，结果等于最大或者最小可表示范围） BLX指令，将可返回的转移指令与状态切换合二为一 CLZ指令，计算寄存器操作数最高位0（前导0）的个数，可提高归一化运算、浮点运算以及整数除法运算的性能，也使中断优先级排队操作更为有效 BRK指令，软件断点指令   基于ARMv5版架构的ARM处理器包含ARM7EJ、ARM9E和ARM10E三个系列产品   v6版  发布于2001年，ARM体系结构又一个重要里程碑 支持ARMv5TEJ所有指令，在多媒体处理、存储器管理、多处理器支持和异常响应等方面引入许多新技术 微架构实现：流水线级数增至8或9级（v6T2），采用动态和静态组合的转移预测方式，准确率可达85% 内核与Cache以及与协处理器之间的数据通路为64位，每个流水线周期可读入2条指令或存放2个连续字数据 增加了增强型的数字信号处理器以及用于功耗管理的IEM（Intelligent Energy Management）部件，在性能和功耗两个方面又有新的突破 在ISA方面，ARMv6版架构增加了以下功能和指令：  Thumb-2指令集（v6T2增强版），可以混合执行AMR指令和Thumb指令，兼具两者的优点，可认为是v6版大的进步 新增SIMD指令，使多媒体信号（如左右声道、三基色像素）的处理能力提高了2~4倍 支持混合大小端（Mixed-endian）和非对准（Unaligned）存储访问 采用了名为Trust Zone安全解决方案，在硬件层面划分可信区域和不可信区域，分别运行经认证的代码和未经认证的代码，不同代码具有不同的访问权限     v7版  发布于2004年，ARM体系结构的分水岭  全面支持Thumb-2技术。Thumb-2指令集包括了16位和32位指令，较先前的ARM指令集减少了31％的内存使用量，较原有的Thumb指令集提升了38％性能，并且无需在ARM指令集和Thumb指令集之间来回切换 引入名为NEON的多媒体处理引擎，支持128 位SIMD扩展，性能提升了4倍，以迎合3D图形与手游应用 在处理器的工作状态与操作模式、寄存器组织、异常和中断管理、对操作系统的支持等方面有许多变化，与以往版本有较大的区别，同时也兼顾了与经典ARM处理器软件保存较好的兼容     v8版  首款支持64位指令集的处理器架构  新增加64位指令集，称作A64，并继续支持原有的ARM指令集和Thumb-2指令集，但是改称为A32和T32指令集 新定义AArch64和AArch32两种运行状态，分别执行64位和32位指令集 在ARMv7安全扩展的基础上，新增加了安全模式，支持与安全相关的应用需求 在ARMv7虚拟化扩展的基础上，提供完整的虚拟化框架，在硬件层面上提供对虚拟化的支持 AArch64对异常等级赋予新的内涵，并重新解释处理器运行模式和特权等级概念   继续分为ARMv8-A、ARMv8-R和ARMv8-M三种类型  v8-A：支持AArch64和AArch32两种运行状态，两种运行状态之间进行切换。除了智能手机和平板电脑传统应用领域之外，开始向通用计算应用领域拓展 v8-R：具有快速中断响应能力和确定的中断响应时延，采用容错设计和MPU，支持A32和T32指令集，应用领域均为对实时性和可靠性有着极高的要求的场合 v8-M：使用与其他类型不同的异常处理模型，并且只支持T32指令集。主要面向低成本、小体积、低功耗、低中断延迟以及高性能的嵌入式应用 基于上述三种体系结构类型的处理器产品，仍然分为Cortex-A、Cortex-R和Cortex-M三个系列      ARM体系结构的增强型版本\n每个基础版还有增强版，支持的指令有区别。在v7版之前，增强版用版本号的字母后缀表示，如：\n T增强版：表示该版本支持Thumb指令集 E增强版：支持增强的DSP算法 J增强版：支持Java加速 S增强版：提供用于多媒体信号处理的SIMD指令 F增强版：支持矢量浮点处理单元 V6版还有：  T2增强版：支持Thumb-2指令集 Z增强版：支持TrustZone安全增强 K增强版：支持多核 M增强版：超低功耗，用于Cortex-M0/M0+/M1   v7版本之后，不再使用  小结\n ARM指令集：32位 Thumb指令集：16位，可提高代码密度，减少存储开销，是ARM指令集中常用指令经重新编码压缩后的子集，执行时被实时且透明地解压，仍然是32位指令 Thumb-2指令集：混合执行AMR指令和Thumb指令，兼具两者的优点，无需在ARM指令集和Thumb指令集之间来回切换  5.1.3. ARM处理器主要产品系列简介 5.1.3.1. ARM处理器的特点  固定长度操作码，简化了指令译码，便于流水线设计 具有多个通用寄存器，指令不局限在某个特定的寄存器上执行，可以实现寄存器组的均匀访问 操作数地址由寄存器内容或者指令码的位域指定，具有地址自动增减寻址模式，寻址方式灵活，可以优化程序循环结构，程序执行效率高 每条数据处理指令都可对算术逻辑单元和移位器进行控制，实现ALU和移位器的最大利用 具有多寄存器加载和存储指令，可实现大数据吞吐量 所有指令都可以条件执行，以提高代码执行速度 支持精巧的Thumb指令集（包括Thumb和Thumb-2），提高代码密度，减少所需的系统存储容量  5.1.3.2. ARM处理器相关产品的层次关系 从内到外分为：ARM内核、ARM处理器、MCU或者SOC、以及嵌入式系统四个层级\n  ARM内核\n 必备部件  CPU，v4T之后均采用流水线技术+转移预测 总线互连矩阵，提供多种数据的并行传送能力 中断管理部件，提供周期确定的低时延中断响应 系统定时器，多任务操作系统必不可少的部件   可选部件  指令和数据Cache或TCM MMU或者MPU 数据/指令跟踪单元 浮点单元、Java硬件加速器、多媒体处理部件      ARM处理器\n ARM内核的基础上，通过系统总线连接了：  指令存储器，一般是flash 数据存储器，一般是SRAM 协处理器或者协处理器接口部件 扩展RAM控制器，扩展存储器不能与系统总线直接相连，必须通过存储器扩展接口 外设总线桥接器 部分调试跟踪组件   通过外设总线连接  调试访问接口 内核私有外设      MCU和SoC\n 以ARM处理器为核心，增加了  扩展存储器 DMAC ADC、DAC 脉宽调制PWM 实时时钟RTC 电源监测BOD 串行接口UART ……      5.1.3.3. ARM处理器产品命名规则 体系结构版本与处理器采用两种标识方式，对应关系开始变得较为复杂\n常见以及仍在使用的产品与ISA的对应关系：\nv7版之前的产品命名规则\n 处理器名称后缀中的英文字母含义  T、E、J、S、F、T2、Z和K等字母表示所基于体系结构增强版本 基于v4T的产品（如ARM7TDMI ）中还出现过D、M和I，分别表示带有Debug调试接口、硬件乘法器和嵌入式ICE，后来成为标准配置，不再另外表示   第一个数字的舍义  表示产品系列，如ARM7TDMI和ARM920T分别对应ARM7系列和ARM9系列  ARM10和ARM11产品系列中，10和11各占两位数字     第二个数字的含义  2：表示带有MMU，如ARM720T和ARM920T 3：改良型MMU 4：表示带有MPU，如ARM946ES 6：无MMU和MPU，如ARM966E-S和ARM968EJ-S  ARM1156T2(F)-S中的“5”表示可选指令和数据MPU ARM1176JZ(F)-S中的“7”表示增加了IEM能源管理组件     第三个数字的含义  0：表示标准容量Cache 2：表示减小容量的Cache 6：表示带有紧耦合内存TCM5）   名称最后的“-S”表示软核（HDL描述的产品）  5.1.3.4. ARM7系列 分为ARM7（基于v3）和ARM7T（基于v4）两个子系列，获得广泛应用的是ARM7T\n ARM7T系列基本型产品是ARM7TDMI（-S），同系列其他产品都是在其基础上增加了Cache、MMU或者MPU、以及ASB总线接口 MMU和MPU都是用于内存管理，两者的功能和主要区别如下：  MMU：内存分页管理+虚拟地址VA到物理地址PA的转换+分区域访问权限管理，适用于多用户系统 MPU：内存分区域访问权限管理，适用于要求对处理时间有明确要求的实时系统    5.1.3.5. ARM9系列 分为ARM9T和ARM9E两个子系列\n ARM9T基于v4T版本架构（与ARM7T相同），但是微架构有不一样，采用的是哈佛结构，流水线为5级 ARM9E采用的也是哈佛结构，分为v5TE和v5TEJ两个子版本，从版本号后缀可以看出：  T：支持Thumb指令 E：支持增强的DSP指令 J：支持Java硬件加速   从ARM9E开始增加TCM，性能与Cache相当，可以对TCM进行寻址访问  5.1.3.6. ARM11系列   ISA大版本都是v6，有四款处理器产品（全是软核），每款处理器的ISA小版本各不相同\n ARM1136J(F)-S，基于ARMv6版本，主要特性：  SIMD、Thumb、Jazelle、MMU以及可选配的VFP   ARM1156T2(F)-S，基于ARMv6T2版本，主要特性：  Thumb-2指令集、SIMD、可选配MPU以及VFP，主要应用在高可靠性和实时嵌入式应用领域   ARM1176JZ(F)-S，基于ARMv6Z版本，主要特性：  在ARM1136J(F) -S基础上增加了TrustZone和IEM部件   ARM11MPCore，主要特性：  可配置1~4颗ARM1136J(F)-S的SMP处理器，后期的升级产品为基于ARMv7A系列的Cortex-A5处理器      ARM 11流水线仍属于单发射标量流水线，但是：\n 流水线的后几级，算逻单元ALU、乘积累加单元MAC和数据加载/存储单元LSU采用并行部署，属于一种分叉或者分支结构的流水线 当指令完成译码和取操作数之后，不同类型的任务被分发到不同的流水线分支上执行，每一级操作更加简单，执行速度更快，可以减少流水线周期，从而可提高流水线时钟频率 ARM11的工作时钟频率在500MHZ以上，最高可达到1GHz，取决于不同的工艺制程，尺寸越小速度越快    设计理念：在性能、功耗、芯片面积和成本之间进行均衡，支持休眠模式、待机模式和关机模式\n  ARM11流水线结构：\n  5.1.3.7. Cortex-A   Cortex-A系列处理器应用场景：\n 移动计算、智能手机、平板电脑、数字电视、企业网络、通用计算和服务器    主要特性：\n 支持可伸缩的异构或者同构多核的高性能处理器，内置VFP和NEON（DSP+SIMD），支持浮点运算和SIMD多媒体数据处理，时钟频率超过1 GHz，支持Linux、安卓和微软视窗操作系统    产品：从A5~A77共计20款，其中A5~A17为基于v7-A版本的32位处理器；A32虽然基于v8-A，但只有AArch32运行状态；A34以后产品基于64位v8-A版本结构，同时支持AArch32和AArch64两种运行模式\n  big.LITTLE(bL) 技术\n 允许拥有两种不同类型的内核，相同类型的内核组成一个簇（cluster），轻负载时运行低功耗内核，高负载时运行高性能内核，在性能和节能之间寻求平衡 采用bL结构的SOC芯片案例：  华为海思麒麟950：4A72+4A53+GPU+ISP+Modem+DSP 华为海思麒麟960：4A73+4A53+GPU+ISP+Modem+DSP      DynamIQ大小核技术\n bL技术升级版，允许最多8个内核构成一个簇，单个处理器最多可实现32个簇和256个内核 Cortex-A55（2017年），第一款采用DynamIQ技术的小核，基于ARMv8.2架构，“具有深远影响的产品”  利用神经网络算法提高转移预测准确性 对NEON、VFP和缓存结构做了改进，低功耗设计   可作为高性能低功耗的64位处理器单独使用，应用于数字电视、VR和AR 但A55的设计目标是作为DynamIQ结构中的小核，目前许多高端手机处理器中，有些虽然采用了自研的大核，但小核几乎都毫无例外地选用了A55    A76（2018年）和A77（2019年），基于DynamIQ技术的“大核”，设计目标是利用DynamIQ技术与更多的同构或者异构内核集成，提供更强大的计算能力和实现更高效的能源利用效率\n A76：使用了可以乱序执行的超标量结构，拥有4个解码发射单元和8条并行流水线，流水线级数为13级。采用7nm制程工艺时，峰值时钟频率可达3GHz A77：基本配置与A76基本相同。但在微体系结构做了许多改进，例如采用更大带宽的前端（取指+译码+转移预测+发射）、新的指令缓存技术、新的整数ALU单元和改进的加载/存储队列，在相同制程工艺和时钟频率条件下，A77的IPC比A76提高了20%，可以看作是A76的改良版    A76应用举例：华为海思麒麟980/990手机处理器\n A76+A55，基于DynamIQ技术的异构多核架构 CPU：两种内核，三种频率，兼顾性能与续航时间    5.1.3.8. Cortex-R  聚焦于高性能实时应用，设计目标包括：高性能、低延时、高可靠、可信赖、安全性和容错性，以确保嵌入式系统的时间确定性和行为确定性  时间确定性：有硬性的处理截止时间（Deadline）要求，必须在规定的时间内完成规定的操作 行为确定性：绝不允许出现因处理器或数据错误而导致的误操作。为此，软硬件必须具备一定的容错能力   Cortex-R应用领域：  手机基带调制解调器、硬盘驱动器、企业级网络设备、汽车电子、医疗设备和工业控制装置等，而后面几种应用对安全稳健（Safety-Critical）有极高要求   目前Cortex-R系列处理器共有5款：  基于v7-R版本架构的R4、R5、R7和R8 基于v8-R版本架构的R52，但只能运行AArch32状态 都支持A32和T32指令集，可以实现二进制代码兼容   容错设计：多处理器锁步（lock-step）技术  双处理器锁步：主处理器和监控处理器在时间上严格同步地执行相同的指令。主处理器承担系统处理任务并负责驱动输出，监控处理器连续监控主处理器总线上的数据、地址和状态等信息  如果发现两个处理器不一致，则说明某个处理器出现了差错，本次计算结果不输出，实现故障静默 但是，双处理器锁步无法实现故障恢复   多处理器锁步：单颗处理器出现故障时，可通过硬件表决方式判断出现故障的处理器并将其屏蔽，由其他处理器负责任务执行，可实现故障的实时恢复 所有Cortex-R处理器都支持锁步技术  R4是单内核处理器，锁步配置需要使用两颗独立的R4 R5升级为一主一备的异构双核，单处理器就可实现能够独立运行的锁步双核 R7在异构双核中增加了QoS（服务质量保证），另外增加一对同构双核，以提高处理器的性能 R8和R52中可锁步配置的内核数增至3颗或者4颗，可实现故障恢复，同时也增加了同构内核的数量     数据纠错/检错：ECC和奇偶校验  奇偶校验：每个数据（字节或半字或字）后面增加一位，使“1”或“0”的总数为奇数或偶数。若错码位数为奇数则可被发现，但是只能检错，无法纠错 ECC：存储数据时，利用编码算法在每个数据后面增加若干冗余位，读出时对其进行检查，不仅可以检错还可以纠错，纠错/检错能力与冗余位长度有关   R系列处理器的Cache或TCM都支持ECC和或奇偶校验，可实现2bit的检错和1bit的纠错 除R4外，R5~R52还支持对总线接口的ECC纠错和检错，R52增加了对互连交叉总线的错误防护功能 为满足实时性要求，Cortex-R处理器都采用指令和数据分离的哈佛结构，都带有指令和数据Cache、TCM存储器、硬件除法器、双精度FPU、MPU、内存和中断控制器，此外：  R4~R8处理器配置了SIMD单元和DSP R52处理器增加了NEON引擎 R5~R52配置了低时延外设接口（Low Latency Peripheral Port ，LLPP），可实现快速外设读取和写入   面向实时应用的处理器一般不采用虚拟地址，R系列处理器都没有配置MMU，但是都带有MPU ISR一般都存在私有TCM中，以减少中断响应延迟  5.1.3.9. Cortex-M   面向低成本、低功耗和高性能应用领域，虽然在性能、可靠性和实时性方面不如Cortex-A和Cortex-R系列，但目前是ARM公司销售量最大的产品\n  2019年第4季度ARM处理器的总出货量为64亿片，其中有42亿片属于Cortex-M系列，占比达66%\n  Cortex-M系列第一款产品是基于v7-M版本架构的Cortex-M3（2005年）。为减小功耗，流水线只有三级（取指、译码、执行），但带有NVIC、硬件除法器、支持Thumb-2指令集、丰富的调试和跟踪功能\n  2010年发布的Cortex-M4与Cortex-M3基本相似，但增加了DSP，并且可选配FPU\n  v7-M出现3年后，ARM继续推出v6-M架构，相关产品有Cortex-M1（面向FPGA设计）、M0和M0+，目标市场是低功耗、小体积和高性价比应用，例如：\n M0/M0+采用冯.诺依曼结构，3级流水线，带有NVIC、硬件乘法器、能源管理部件和AHB Lite总线接口，可选配WIC，功耗仅为5.3 μW(M0)和3.8μW(M0+)/MHz @1.1v/25°C，属于极低功耗处理器    Cortex-M7（2014年9月），基于v7-M，6级流水线，带有双精度浮点单元、可选Cache或者TCM，以迎合高端微控制器和密集型数据处理的需求\n  基于v8-M的M系列处理器：M23、M33和M35P，支持新的增强指令集，增加了Trust Zone安全扩展\n M23具有与M0类似的低成本和小体积特点 M33与M3和M4类似，但系统设计更灵活，能效比更高 M35P产品型号中的“P”表示具有物理（Physical）防篡改（tamper-resistant）功能，包含了多项防范物理攻击的安全特性    面向未来的物联网中的高端应用，2020年2月10日，ARM公司正式发布了基于ARMv8.1-M版本架构的Cortex-M55处理器（预计2021年才有产品问世），可看作Cortex-M33的下一代产品\n  M55首次使用了基于MVE（M-Profile Vector Extension，矢量扩展）技术的Helium引擎，将执行SIMD指令和DSP处理能力提升了5倍，机器学习能力提升了15倍\n  同时，ARM还发布了一款与Cortex-M55配套使用的嵌入式NPU，Ethos-U55（此前已有Ethos-N37、N57和N77），Ethos-U55是专为下一代Cortex-M处理器定制的，具有低功耗和低成本的特性\n  M55+U55，未来物联网应用领域的利器\n  5.2. Cortex-M3/M4处理器结构 5.2.1. Cortex-M3/M4处理器概述及指令集架构 5.2.1.1. Cortex-M3/M4主要特性 基于v7M版本架构，三级流水线（取指、译码和执行），哈佛结构。主要特性如下：\n 32位处理器，可以处理8位、16位和32位数据； 本身不包含存储器，但提供了连接不同存储器的总线接口； 多种总线接口，可分别连接存储器、外设以及调试接口； 紧耦合的NVIC，能以确定的周期快速响应中断； 丰富的调试和跟踪组件以及外部调试接口； 可选配MPU，实现内存的分区保护； 低功耗，低成本，具有丰富的开发调试工具； 但是，作为低成本低功耗处理器，没有Cache或TCM，没有协处理器以及接口，也不支持虚拟地址（没有MMU）  带有系统节拍定时器Systick，可为操作系统所需的定时提供周期性的定时中断\n双堆栈指针，操作系统和应用任务使用不同的堆栈\n 主栈指针MSP，供操作系统和中断处理使用 进程栈指针PSP，用户程序使用 对于不使用操作系统的简单应用，可以只使用MSP  特权和非特权访问等级\n 限制非特权等级访问某些寄存器，提高系统安全性 与MPU配合，限制非特权访问某些内存区域，防止破坏操作系统或者其他任务数据；即使用户程序出现问题，不会对其他任务带来影响，提高系统的健壮性  Cortex-M4可以选配单精度FPU，其功能主要包括：\n 提供多条浮点运算指令，以及多条浮点数据转换指令 支持融合MAC运算，以提高MAC结果的精度 若不需要浮点单元，可以将其关闭从而降低功耗  Cortex-M4指令集增加了DSP扩展，例如：\n 8位和16位SIMD指令，允许对多个数据同时进行并行操作，包括寄存器的高低16位多种组合乘法 支持多个饱和运算指令，包括SIMD运算，避免在出现上溢出和下溢出时计算结果产生大的畸变 单周期16位、双16位以及32位的乘累加（MAC）运算  Cortex-M3也有几条MAC指令，但不是单周期的\n5.2.1.2. Cortex-M3/M4所支持的指令集 Cortex-M4可看作Cortex-M3的增强版，两者都支持Thumb-2技术，但所支持的指令集有差异\n5.2.2. Cortex-M3/M4处理器结构 按各部件作用以及与总线系统的连接关系，整个处理器系统可以分为内核、处理器和系统三个层级\n5.2.2.1. 内核 包括CPU、NVIC、Systick以及可选的指令跟踪接口\nCortex-M4内核可选配FPU\n  CPU\n 32位微处理器，取指、译码、执行三级流水线 哈佛结构，指令和数据两条总线 三个关键部件：ALU、控制单元CU和寄存器阵列    NVIC和Systick\n 经典ARM处理器只有9中异常类型和6级优先级   若IRQ不止1个，经典ARM处理器需要另配VIC Cortex-M系列处理器的异常/中断处理较经典ARM处理器有很大改进，内核集成了一个与CPU紧耦合的NVIC，可对大多数系统异常、所有外部中断（最多240个）以及一个NMI进行全面管理 此外，内核还集成了一个简单的倒计时计数器Systick，负责产生类型号为15的系统定时异常（中断）    FPU\n Cortex-M4可选配FPU，支持符合IEEE 754-2008标准的单精度浮点运算，该浮点单元主要特性包括：  由32个32位寄存器组成的浮点寄存器组，可以单独用作32个寄存器，也可以被成对用作16个双字寄存器 支持的转换指令包括“整数↔单精度浮点”、“定点↔单精度浮点”、“半精度↔单精度浮点” 浮点寄存器组和存储器之间的单精度和双字数据的传输 浮点寄存器组和整数寄存器组之间的单精度数据的传输   Cortex-M4的FPU不支持双精度浮点运算、浮点余数以及二进制与十进制之间的转换，如若需要只能另外编写程序实现 Cortex-M4的浮点运算指令的助记符都是以v开头 FPU一般位于处理器内核与协处理器之间，带有状态控制寄存器，用以标明FPU当前运行状态，并可通过编程对其进行控制 为了与其他协处理器的管控方式一致，FPU被看作协处理器，并通过协处理器访问控制寄存器CPACR（Co-processor Access Control Register）对其进行管理和控制 CPACR寄存器中CP10和CP11两位负责对FPU进行管理，所以有时也将FPU看作协处理器CP10和CP11 通过对CPACR寄存器中CP10和CP11两位的置位或者复位操作，可以使能或禁用FPU 经典ARM处理器有单独的特殊寄存器访问指令MCR和MRC，实现对协处理器的操作控制和数据交换 与经典ARM处理器不同，Cortex-M4拥有专门的浮点运算和数据传送指令，实现浮点的读取、运算和写回 在Cortex-M4的三级流水线中，FPU和CPU共用取指阶段，在译码和执行阶段则二者并行执行    5.2.2.2. 处理器  总线交换矩阵  基于AHB总线协议的交换网络 通过总线矩阵，Cortex-M3/M4面向各种存储器、片上和片外不同类型的设备、以及调试组件提供了多条总线，可以让数据和指令在不同的总线上并行传送（只要不是访问同一个器件） Cortex-M3/M4的总线矩阵还包含一个写缓冲区，可以加快存储器写操作的速度 Cortex-M3/M4处理器的系统总线基于AHB-Lite总线协议，总线上只有一个主设备，无需使用总线仲裁   MPU  Cortex-M3/M4都可以选配 通过MPU可以把存储空间划分为最多8个Regina（区域），但是区域之间可以重叠 各个区域的存储特性和访问权限可以通过编程定义 如果使用了嵌入式操作系统，MPU由操作系统管理，给每个任务分配不同的存储区域以及访问权限，防止某个应用任务对操作系统或者其他任务的数据造成破坏 在没有操作系统的简单应用中，也可以通过MPU设定需要保护的存储区域和访问权限。例如，把某些存储空间设置为只读属性或只有特权用户才能访问，以提高系统的安全性和可靠性    5.2.2.3. 处理器系统 在处理器基础上，再选配唤醒中断控制器WIC以及若干调试组件之后，就构成Cortex-M3/M4处理器系统\n  WIC\n  为了减少功耗，Cortex-M处理器引入“睡眠”和“深度睡眠”两种模式\n 处于睡眠模式时，关闭大部分模块/部件的时钟 在深度睡眠模式时，系统时钟和Systick也被关闭 有些产品还采用了SRPG（State Retention Power Gating）电路。深度睡眠模式时包括内核和NVIC在内大部分电路都处于掉电状态，以进一步减少功率消耗    不同工作状态下的电流消耗\n  WIC的电路非常小巧，通过专有接口与NVIC以及电源管理单元PMU（Power Management Unit）相连\n  只有在处理器处于深度睡眠模式时，WIC才会使能，此时，如果出现NMI或者未被屏蔽的IRQ时，WIC触发PMU单元，将整个系统唤醒\n    调试组件\n  经典ARM处理器也有多种调试组件，大都带有JTAG接口，并通过JTAG接口实现对寄存器和存储器的访问\n  从v7开始，ARM处理器采用了一种命名为Core Sight全新的调试架构。Core Sight调试架构涵盖了调试接口协议、调试总线协议、调试部件控制、安全特性以及跟踪接口等\n  在Cortex-M3/M4处理器中，调试过程是由NVIC和若干调试组件协作完成的。NVIC中有一些用于调试的寄存器，通过这些寄存器对处理器的调试动作进行控制，如停机（halting）和单步执行（stepping）等\n  Cortex-M3/M4可以选配多种调试组件，这些调试组件提供了指令断点、数据观察点、寄存器和存储器访问、性能分析（profiling）以及各种跟踪机制，如：\n ETM：嵌入式跟踪宏单元 Embedded Trace Macro-cell ITM：指令跟踪宏单元 Instrumentation Trace Macro-cell DWT：数据观察点和跟踪单元 Data Watchpoint and Trace FPB：Flash地址重载和断点单元 Flash Patch and Breakpoint Unit TPIU：跟踪端口接口单元 Trace Port Interface Unit ROM表：类似于调试组件的“注册表”    Cortex-M3/M4处理器中的调试组件\n  调试（Debug）：是指通过调试接口读取或修改处理器内部的寄存器或存储器的内容，或者发布一些调试命令，让处理器执行某些调试动作，如暂停、单步执行或者断点执行等\n  跟踪（Trace）：是指在程序运行期间，无需停止处理器正常的指令执行流程，由相关的跟踪组件实时收集处理器在指令执行过程中产生的各种运行信息，并通过跟踪接口实时输出到外部调试主机中，再由调试分析软件（如Keil）对这些信息进行分析\n  在Core Sight的调试架构中，ETM、DWT和ITM等调试组件都属于跟踪数据源（Trace Source），负责收集处理器运行过程中产生的各种调试信息\n  TPIU属于调试信号汇集点部件，负责将汇集的调试信息进行格式转换和打包之后，再通过跟踪端口输出到外部的调试主机（PC机）\n  Cortex-M3/M4处理器中的调试信息流向图：\n  DAP（Debug Access Port）\n 在CoreSight调试架构中，定义了处理器内部的调试访问接口AP与外部调试端口DP。AP接收来自DP的调试命令，并将这些命令转换成对处理器内部各寄存器和存储单元的访问。DP和AP合称为调试访问端口    SWJ-DP和SW-DP\n SWJ-DP（Serial Wire JTAG DP）：基于JTAG协议的串行调试接口，有4条线 SW-DP（Serial Wire DP）：CoreSight调试架构新增加的串行接口，只有2条线 Cortex-M3/M4支持以上两种调试接口，芯片制造商可以根据需要选择其中的一种或者两种      5.2.3. 存储器管理 Cortex-M3/M4没有Cache或者TCM，而是通过多条总线连接片上各种不同类型和容量的存储器件\n如果需要进一步扩展存储容量，还可以通过存储器接口控制器，连接片外大容量存储器\n5.2.3.1. 存储器管理特性   4GB线性地址空间，可通过存储器接口控制器连接32位、16位和8位的存储器件\n  定义了明确的存储器映射关系，4GB存储空间被划分为多个区域，分别用于不同的存储器和外设\n  支持小端和大端，但芯片制造商只能选择一种类型\n  可选位带（Bit-Band Operations）操作，也称为位段或者位域操作\n 传统处理器中，如需修改某个存储单元或寄存器的一个bit位，而不影响其他位，需要读出、修改和写入三个步骤 位带操作：在某个区域内，每个bit位可以使用地址直接对其进行操作。但是具体MCU或者SOC芯片是否带有位带操作特性由芯片制造商决定    内置写缓冲，可以提高程序的执行速度\n  可选MPU，支持8个可编程区域，可提高系统健壮性\n  所有基于ARNv7M的Cortex-M系列处理器都支持非对准传送，但是非对准传送将增加总线传送次数\n  5.2.3.2. 存储器映射 所有基于ARMv7M的Cortex-M系列处理器，都采用相同的存储器映射关系方式（存储区域划分）\n  CODE区\n 只能被I-Code和D-Code总线访问，为使两条总线能够同时访问，CODE区可使用两个独立的存储器 最低端部分使用flash器件，用于存储程序代码 另外一部分使用SRAM，存储重要数据I-Code和D-Code对CODE区的所有空间都能访问 只要不是同时访问同一个存储器，两条总线上可以同时传输数据 但是，为了降低成本，许多SOC芯片并没有在CODE区部署SRAM    SRAM区\n 片上主存储区，存放数据 由AHB-Lite系统总线管理 许多芯片制造商只使用SRAM区存放数据    外设区\n 片上外设连接到系统总线上 片外设备与APB总线相连，APB与AHB之间有一个总线桥    外部RAM区\n 通过RAM控制器连接片外扩展RAM，可使用的RAM类型取决于RAM控制器    内核私有区域\n 内部私有外设，包括调试组件ITM、DWT和FPB，以及系统控制区SCS  系统控制空间SCS  位于内核私有区域，0xE000 E000~0xE000 EFFF，64KB 该区域集中了NVIC、Systick、FPU和MPU等在内的各种系统部件的寄存器组，只有特权访问等级才能访问     外部私有外设，包括调试组件ETM、TPIU和ROM表，以及外部PPB总线 芯片厂商定义的存储区  Cortex M系列处理器采用这种统一的地址映射方案，有助于提高设备之间的软件可移植性和代码可重用性\n虽然有明确的存储区域划分，但仍具灵活性，例如：\n 程序代码既可以存放CODE区域，也可以存放在AHB总线所连接的SRAM中，但影响指令执行性能 芯片制造商也可以在CODE区域使用SRAM存储器    5.2.4. 总线系统 Cortex-M3/M4总线结构\n5.2.4.1. 总线系统结构   核心：基于AHB总线协议的内部总线互连矩阵。其所连接的各类总线的作用以及主要特性简介如下\n I-Code总线，基于AHB-Lite总线协议的32位总线，负责在0x0000 0000~0x1FFF FFFF之间的取指操作。取指是以字为单位，对于16位的Thumb指令，一次取指操作可以取出两条指令 D-Code总线，与I-Code基本相同，但只负责数据读写 I-Code总线与D-Code在物理上彼此独立，但两者之间有一个仲裁器，当I-Code和D-Code同时访问同一区域时，D-CODE优先    System，基于AHB-Lite规范的32位系统总线\n 访问区域  0x2000 0000~0xDFFF FFFF 0xE010 0000~0xFFFF FFFF   包括：  SRAM区 片上外设 外部RAM 片外设备 芯片厂商定义的区域      APB/PPB总线，32位APB总线\n 访问区域  外部私有外设子区域：0xE004 0000~0xE00F FFFF 在外部私有外设子区域中，有一部分空间已被ETM、TPIU和ROM表等调试组件所占用，只有0xE004 2000 ~0xE00F EFFF之间可用于连接外部私有设备 由于内核私有区域需要特权访问权限，该总线一般是专门用于连接调试组件，不用于普通的外设，否则将会出现因特权管理导致的各种错误      四条总线各自管理的区域\nCPU通过内部总线互连矩阵直接访问内核私有外设，不经过四条总线\n  调试访问端口DAP\n 基于“增强型APB”总线规范的32位总线 主要用于连接处理器内部的调试访问接口AP与外部调试端口DP，如SWJ-DP和SW-DP    5.2.4.2. 各类总线的连接对象 AHB总线互联矩阵属于处理器内核设备\nCODE区的总线矩阵或者总线复用器是ARM公司提供的两种不同的选件，其作用是让I-Code和D-Code都能够访问CODE区的flash和SRAM\n 如果选用总线矩阵，I-Code对flash的取指操作与D-Code对SRAM的数据存取操作可以同时进行 如果选用总线复用器，I-Code和D-Code对CODE区的访问只能分时进行，数据传送不再有具有并行性 有些芯片CODE区没有配置SRAM，利用SRAM区存储数据，通过系统总线与I-Code总线的并行性传送数据，虽然浪费了一点存储空间，但可以降低成本  片上SRAM也称为主SRAM，应该连接到系统总线上，使其位于SRAM区，以便可以使用位带操作\n5.2.5. 异常与中断处理 5.2.5.1. 嵌套向量中断控制器NVIC Cortex-M3/M4处理器集成了一个与CPU紧耦合的嵌套中断控制器NVIC总共可以管理：\n 240个外部中断，从IRQ#0 到IRQ#239 1个不可屏蔽中断NMI 多个系统异常 NVIC是内核不可分割的一部分，可对240个外部中断以及大部分系统异常进行优先级设定、中断屏蔽、嵌套（抢占）管理、中断挂起（Pending）和解挂等事务进行全面并且细腻的集约化管理  支持的异常与中断处理种类\n异常与中断处理\n注意：CMSIS的中断编号0对应的是IRQ#0，中断编号239对应的是IRQ#239；而编号为负数的**-15到-1依次对应的是复位到SYSTICK等系统异常**\n CMSIS，（Cortex Microcontroller Software Interface Standard，微控制器软件接口标准），由ARM公司联合多家芯片和软件供应商合作定义，包含多个组件。其中，内核和设备访问库函数CMSIS-core提供了多种函数，可对CPU内部各种寄存器以及内核设备进行访问  配置了NVIC之后，Cortex-M3/M4具有以下异常处理特性：\n 除了复位和NMI之外，所有异常都可以被屏蔽 除了复位、NMI和硬件错误之外，所有异常都可单独使能或禁止 除复位、NMI和硬件错误具有固定的（高）优先级之外，所有异常/中断都具有多达256级可编程优先级，以及最多128个可抢占（嵌套）优先级 支持优先级的动态修改（Cortex-M0/M0+无此特性） 向量中断方式，中断响应时自动从中断向量表中获取中断处理程序（ISR）入口地址 向量表可以重定位在存储器中的其他区域 低中断处理延迟，对于零等待的存储器系统，中断处理延迟仅为12个时钟周期 中断和多个异常可由软件触发 可以按照优先级对中断进行屏蔽 进入中断/异常服务程序时，自动保存包括PSR在内的多个寄存器；异常返回时自动恢复，无需另外编程 可选配唤醒中断控制器WIC，支持睡眠以及深度睡眠模式 硬件自动抢占管理  当前正在处理的异常/中断优先级被存储专用寄存器中，如果允许抢占（嵌套），自动对新出现的异常与正在处理的异常进行比较，判断是否可以抢占    Cortex-M3/M4 和NVIC使用了多个可编程寄存器\n 可通过地址（大都在SCS区）和汇编指令对其进行访问 利用CMSIS-Core提供的调用函数（API）  关于中断嵌套\n 在经典ARM处理器中，所有IRQ同属一个优先级，彼此之间的中断嵌套只能通过软件编程实现 Cortex-M3/M4最多可以设置128个可抢占（嵌套）优先级，可通过NVIC对所有的外部中断和大多数系统异常实现硬件嵌套管理，无需另外编程控制 当前正在处理的异常/中断优先级被存储在程序状态寄存器的专用字段中，如果允许抢占（嵌套），当出现新的异常/中断时，硬件电路自动将其可抢占优先级与当前正在处理的异常/中断进行比较，如果新异常/中断的抢占优先级更高，就会中断当前正在执行的中断服务程序，转而处理新的异常/中断，从而实现中断嵌套  5.2.5.2. 中断向量表  经典ARM处理器的中断向量表中还包含了跳转到中断服务程序入口的转移指令，而Cortex-M3/M4处理器的中断向量表只有异常/中断服务程序的入口地址 Cortex-M3/M4处理器的每个异常服务程序的入口地址为32位，占用4个字节 Cortex-M3/M4处理器总共有256个异常/中断异常类型，所以中断向量表的容量为4x256=1024个字节（1 KB） 中断向量表作为一类系统表，起始地址默认位于存储器空间最开始位置（地址0x0） Cortex-M3/M4支持中断向量表  重定位中断向量表重定位：IVT的存放位置可以改变（relocate）   在中断响应时，若中断类型号为n，只需计算n×4（左移两位），立刻得到对应的中断向量在中断向量表中存放地址，可以快速获取中断服务程序的入口地址 中断响应时，读取中断向量以及ISR的取指操作可以与寄存器压栈操作同时进行；前者由I-Code完成，后者交由D-Code或者系统总线实现，以充分发挥哈佛结构的优势 由于中断向量表位于存储空间最开始的位置，而这片区域属于CODE区，由I-Code总线负责管理 理论上中断响应时的压栈操作可由D-Code或者系统总线完成，但是有些芯片制造商为了减少一片CODE区的SRAM，把数据都存放在由系统总线负责管理的SRAM区，这种情况下压栈操作只能由系统总线完成  5.2.5.3. 系统节拍定时器SysTick  在多任务系统中，CPU在不同的时间片为不同的任务进行进行服务，因此需要一个定时器来产生周期性的定时信号，“提醒”操作系统对任务进行切换 计算机中还有其他系统事务也需要定时信号，例如DRAM的定时刷新操作 为了支持多任务操作系统，Cortex-M系列处理器集成了一个系统节拍定时器SysTick，其作用是产生周期性的SYSTICK中断（异常号#15） 如果没有使用操作系统，SysTick定时器可以作为普通定时器使用，用于产生定时信号和进行时间测量 SysTick定时器是和NVIC捆绑在一起的，可认为是NVIC的一部分，都属于内核设备，非特权用户程序不能访问 内部有一个24位递减计数器和4个寄存器：  状态控制寄存器STCSR（Control and Status Reg.） 加载值寄存器STRVR（Reload Value Reg.） 当前计数值寄存器STCVR（Current Value Reg.） 校准值寄存器STCR（Calibration Value Reg.） 定时过程：SysTick被使能后，便从STRVR中的初值开始，按照时钟周期就那些递减计数，减至0后产生一个异常，在下个时钟周期又从STRVR中重新加载初值，重复递减计数过程，从而产生周期性的定时中断 改变STRVR的加载初值，即可改变定时周期 除了汇编指令外，CMSIS-Core也提供了对SysTick配置和管理的函数    5.3. Cortex-M3/M4的编程模型 所谓处理器的编程模型（Programmer’s model），就是程序员所看到的处理器的工作状态、操作模式以及以寄存器为主的各种资源\nCortex-M3/M4处理器的编程模型与经典ARM处理器有较大差别，例如：\n 以ARM7T系列为代表经典ARM处理器，具有ARM和Thumb两种工作状态，在不同的状态下有各自不同的指令系统。两种状态可以切换，但是状态切换会有一定的时间开销 而Cortex-M3/M4支持16位和32位指令并存的Thumb-2技术，不再有ARM和Thumb两种工作状态之分，也不再有状态切换导致的时间开销  经典ARM处理器支持以下7种运行模式：\nCortex-M3/M4对这些模式进行了化简与合并\n5.3.1. 操作状态与操作模式 5.3.1.1. 操作状态 Cortex-M3/M4有两种操作状态，分别是：\n Thumb状态，执行Thumb指令的状态。由于Cortex-M系列处理器不支持ARM指令集，所以没有ARM状态 调试状态，当处理器被暂停后（例如通过调试器或触发断点后）就会进入调试状态，并停止指令执行  调试状态仅用于调试操作，可以通过两种方式进入调试状态：\n 调试器发起暂停请求 处理器中的调试部件产生的调试事件  在调试状态下，调试器可以访问或修改处理器中寄存器的数值\n无论在Thumb状态还是调试状态下，调试器都可以访问系统存储器，包括位于处理器片内和片外的各种外设\n5.3.1.2. 操作模式和特权等级 操作模式也称为处理器工作模式或者运行模式，Cortex-M3/M4把经典处理器的7种运行模式归并为两种：\n 处理模式，类似于经典处理器中的异常模式，执行的是中断服务程序（ISR），此时处理器具有特权访问等级 线程模式，除处理模式以外的所有模式，又分为特权线程模式（类似于经典处理器sys模式）和非特权线程模式（类似于经典处理器usr模式）  关于特权访问等级和非特权访问等级\n 一种最基本的安全模型，对关键区域提供必要的保护 例如：为了防止不可靠的应用任务破坏操作系统内核以及其他任务使用的存储器和外设，可以通过特权等级划分限制应用程序可访问的区域；即使是某个应用程序出现了崩溃，也不至于影响到操作系统内核和其他应用任务的继续运行 非特权与特权访问等级在编程模型方面的差异：  有几条指令不能使用，否则引起用法错误异常 不能访问内核私有区域以及由MPU设定的保护区域 不能访问某些特殊寄存器，如NVIC内部的各种寄存器    系统启动后处于特权线程模式，在此模式下，可以对特殊寄存器CONTRL的写操作，将处理器从特权线程模式切换到非特权线程模式\n但是非特权线程模式不能访问CONTRL寄存器，因此不能采用类似方式回到特权线程模式\n处理模式和线程模式的编程模型也很类似，不过线程模式可以切换使用独立的进程栈指针PSP，使应用任务的栈空间和操作系统的主栈空间相互独立，可提高系统的健壮性和可靠性\nCortex-M系列处理器启动后默认处于特权线程模式以及Thumb状态\n对于简单应用，一般都使用特权线程模式和主栈指针\n基于ARMv6-M版本架构的Cortex-M0处理器不支持非特权线程模式，Cortex-M0+处理器只是将其作为一个可选项\n5.3.2. 常规寄存器 Cortex-M3/M4处理器种常规寄存器共有16个，其中13个为32位通用寄存器，其他3个为堆栈指针、链接寄存器和程序计数器\n经典ARM处理器的寄存器：\nCortex-M3/M4处理器中常规寄存器的分组\n5.3.2.1. 通用寄存器：R0~R12 分为2组：\n R0~R7，8个低位寄存器，因受指令编码空间限制，许多16位Thumb指令只能访问低位寄存器 R8~R12，5个高位寄存器，可用于32位指令和少数几个16位指令（如MOV指令）  系统复位后，R0~R12的初始值均未定义\n为实现汇编程序与C语言程序的相互调用，AAPCS（ARM Architecture Procedure Call Standard）规定：\n R0~R3用于子程序之间的参数传递 R4~R11用于保存子程序的局部变量 R12作为子程序调用中间寄存器  5.3.2.2. 栈指针：R13 Cortex-M3/M4处理器采用双堆栈设计，有两个物理上的栈指针，也就是有两个R13寄存器，一个是主栈指针MSP，另一个是进程栈指针PSP，对于一般程序而言，两个栈指针只有一个可见\nMSP为默认栈指针，在系统复位后或处理器处于处理模式时，处理器使用MSP；PSP只能用于线程模式，栈指针的选择是通过特殊寄存器CONTROL设定的\n在大多情况下，对于不使用操作系统的许多简单而言，没有必要使用PSP，只需使用MSP即可\n系统复位之后，PSP的初值未定义，而MSP的初值存放在整个存储空间最开始（中断向量表）处第一个字中，在系统初始化时，需要将其取出并对MSP进行赋值\n尽管v8版架构之前的ARM处理器都是32位的，PUSH和POP操作也是以字为单位进行的，堆栈采用字（4字节）对齐方式即可\n考虑到64位双精度浮点数的压栈问题，AAPCS规范要求堆栈应该采用双字（8字节）对齐方式\n在Cortex-M3/M4处理器中，通过对系统控制块SCB（System Control Block）中的配置控制寄存器CCR（Configuration Control Register）进行操作，可以使能或禁止双字栈对齐特性\n无论是采用字对齐还是双字对齐，MSP和PSP的最低两位总是为00，对这两位的写操作不起作用\n5.3.2.3. 链接寄存器：R14 用于保存函数或子程序调用时的返回地址，在函数或子程序结束时，LR中的数值用于调用返回\n在异常处理时，LR中将自动保存返回地址**EXC_ RETURN**，异常处理结束用于异常/中断返回\n如果是嵌套调用，调用时需将LR中的数值压栈保存\n由于Cortex-M3/M4中有16位指令，指令有时会对齐到半字地址，即便如此，返回地址总是偶数，LR的最低位默认为是0\n 但LR第0位可读可写，有些转移/调用操作将LR的第0位置1以表示Thumb状态。但是作为返回地址，无论最低位是0还是1，总是认为最低位是0  5.3.2.4. 程序计数器：R15 在基于x86处理器的PC机中，不允许对代码段寄存器CS以及指令指针IP进行写操作，CS和IP不能作为数据传送和数据处理指令的目的操作数，程序转移或者过程调用只能通过专门的指令来实现\n但是在ARM处理器中，PC不仅可读而且可写\n 读PC时返回的是当前指令地址加4，这是因为流水线的特性以及与ARM7T系列处理器兼容的需要 对PC的写操作可以使用MOVE指令以及数据处理指令来实现，以实现程序的跳转 在大多数情况下，跳转和调用操作都通过专用指令实现，利用数据传输和数据处理指令更新PC的情况较为少见 在访问位于程序存储器中的字符数据时，经常将PC作为基地址寄存器，而偏移地址由指令中的立即数给出  在Cortex-M3/M4中，由于指令必须对齐半字或字，作为代码地址，PC的最低位总是认为是“0”\n需要注意的是，无论使用跳转指令还是直接写PC寄存器，写入值必须是奇数，确保其最低位是“1”，以表示其处于Thumb状态，否则将被认为试图转入ARM模式，从而导致出现错误异常\n当使用高级编程语言（包括C和C++）时，编译器会自动将跳转目标的最低位置“1”，无需担心出错\n再次强调：PC最低位为“1”，只是表示处于Thumb状态，作为指令地址，PC最低位始终被认为是“0”\n关于寄存器的名称\n使用ARM汇编指令编程时，在汇编代码中出现的上述寄存器可以使用不同的名称，如大写、小写或者大小写混用，常用的汇编工具（如Keil MDK-ARM和ARM ADS）都能对其进行识别\n5.3.3. 特殊寄存器 除了常规寄存器，Cortex-M3/M4处理器中，还有多个特殊寄存器，分别是：\n xPSR：程序状态寄存器，包括：  APSR：应用程序状态寄存器 EPSR：执行程序状态寄存器 IPSR：中断程序状态寄存器   PRIMASK FAULTMASK BASEPRI（以上三个均为中断屏蔽设置寄存器） CONTROL 控制寄存器，定义处理器的操作状态  特殊寄存器没有映射到内存空间，只能利用MSR/MRS指令通过名字对其进行访问，例如：\nMRS \u0026lt;reg\u0026gt;, \u0026lt;special_reg\u0026gt;\t;读special_reg到通用寄存器reg\rMSR \u0026lt;special_reg\u0026gt;, \u0026lt;reg\u0026gt;\t;将reg内容写入special_reg\r注意特殊寄存器与“特殊功能寄存器（SFR）”的区别，后者一般用于I/O控制的寄存器\nCMSIS-core也提供了用于访问特殊寄存器的函数。在使用C或C++等高级开发简单应用时，可能不太需要这些特殊寄存器；如果开发需要在嵌入式操作系统环境下运行的应用程序，并且需要高级中断屏蔽特性时，就需要访问这些特殊寄存器\n5.3.3.1. 程序状态寄存器 在ARM7TDMI为代表的经典ARM处理器中，采用了CPSR和SPSR两个程序状态控制器。CPSR保存当前程序状态，SPSR用于在异常/中断处理时保存CPSR的状态，以便异常返回后能够恢复处理器的工作状态\n从ARMv7版架构开始，ARM采用了新的程序状态寄存器PSR，读取PSR的结果实际包含了APSR、EPSR和IPSR三个状态寄存器内容，因此，有时也将PSR称为xPSR（表中GE[3:0]只有Cortex-M4中有）\nPSR中各个标志位的含义如下：\nCortex-M3/M4的PSR与经典ARM处理器的CPSR有较大差异，下图给出几种ARM处理器PSR的对比：\n与ARM7TDMI的CPSR相比：\n 取消了反映工作模式的M[4:0]位 T标志位的位置发生变化 中断标志I和F被新的PRIMASK所取代  5.3.3.2. 三个中断屏蔽寄存器 PRIMASK、FAULTMASK和BASEPRI三个寄存器的用途是为了实现基于优先权等级的异常/中断屏蔽\n关于Cortex-M3/M4处理器的异常优先级：\n 复位、NMI和Hard Fault硬件错误三个系统异常具有固定的优先权等级 复位优先权等级为-3，数字最小，具有最高优先权 NMI优先权等级为-2，优先权等级仅次于复位 硬件错误优先权等级为-1，优先权等级排行第三 除了上述三个系统异常之外，其它所有异常和中断的优先级均可编程设置，优先权等级数值范围从0~255，数值越小，优先级越高；反之优先权越低  下图为三个中断屏蔽寄存器的编程模型，可以看出PRIMASK和FAULTMASK都只有一位\nPRIMASK\n 当最低位被置位（写入1）后，将屏蔽除复位、NMI和硬件错误以外所有的（优先级数值大于0的）系统异常和外部中断，类似于x86系统中的关中断（IF=0），以便处理紧急事务 当紧急事务处理完毕，要及时将PRIMASK的最低位进行复位，类似于x86系统的“开中断”  FAULTMASK\n 当最低位被置位后，硬件错误异常也被屏蔽，相当于把异常/中断的优先级门槛提高到“-1” 常用于执行负责错误处理的中断服务程序。因为既然出现了错误并且正在处理，就无需理会此刻出现的包括硬件错误在内的其他异常（只有几种），以便错误处理程序能够“专心致志”地进行错误修复 与PRIMASK不同的是，FAULTMASK无需主动清理，当错误处理程序运行结束返回时，会自动复位FAULTMASK FAULTMASK是ARMv7-M版架构引入的，Cortex-M0系列处理器没有FAULTMASK寄存器  BASEPRI\n  也是ARMv7-M版架构新增的，可以按照具体优先数值对中断屏蔽进行管理\n  BASEPRI寄存器的最低8位采用了“可伸缩”设计，具体宽度取决于芯片制造商实际设计的中断优先级数量\n  一般而言，芯片制造商设计的中断优先级不少于8级，此时BASEPRI中7:5这3位用于设置中断屏蔽\n  如果设计了32级中断，BASEPRI的宽度为7:3共5位，假如7:3这5位的数值是0b1 0000，将屏蔽优先级数值大于等于0b1 0000的所有中断\n  如果7:3这5位的数值是0 0000，其含义则是对所有中断都不屏蔽\n  中断屏蔽寄存器属于特殊寄存器，只有特权访问等级才可以进行读写访问。非特权状态下的写操作会被忽略，而读操作返回数值为0\n  使用汇编指令访问三个中断屏蔽寄存器示例：\nMRS r0, BASEPRI; 将BASEPRI寄存器读入R0\rMRS r0, PRIMASK; 将PRIMASK寄存器读入R0\rMRS r0, FAULTMASK; 将FAULTMASK寄存器读入R0\rMSR BASEPRI, r0; 将R0写入BASEPRI寄存器\rMSR PRIMASK, r0; 将R0写入PRIMASK寄存器\rMSR FAULTMASK, r0; 将RO写人FAULTMASK寄存器\r\r  中断设置示例：\n;关中断命令\rMOV R0, #1\rMSR PRIMASK, R0\r;开中断命令\rMOV R0, #0\rMSR PRIMASK, R0\r;假设系统中共有16级中断，BASEPRI寄存器的宽度\r;为7:4共4位，现在需要屏蔽优先级大于等于4的所有中断\rMOV R0, #0b100\rMSR BASEPRI, R0\r;取消BASEPRI寄存器的中断屏蔽设置\rMOV R0, #0\rMSR BASEPRI, R0\r\r  CMSIS-Core提供的访问函数：\nx = _get_BASEPRI()；\t//读BASEPRI寄存器\rx =_get_PRIMARK();\t//读PRIMASK寄存器\rx =_get_FAULTMASK();\t//读EAULTMASK寄存器\r_set_BASEPRI(x);\t//设置BASEPRI的新数值\r_set_PRIMASK(x);\t//置位PRIMASK\r_set_FAULTMASK(x);\t//置位FAULTMASK\r_disable_irq();\t//置位PRIMASK，禁止异常，\r//相当于_set_PRIMASK(1)\r_enable_irq();\t//清除PRIMASK，使能异常，\r//相当于_set_PRIMASK(0)\r\r  利用修改处理器状态CPS指令，也可以方便地设置或清除PRIMASK和FAULTMASK的数值，例如：\nCPSIE I; 使能异常（清除PRIMASK位）\rCPSID I; 禁止异常（置位PRIMASK位）\rPSIE f; 使能异常（清除FAULTMASK位）\rCPSID f; 禁止异常（置位FAULTMASK位)\r\r  对比上述指令，可以看出来\n PRIMASK类似于经典ARM处理器CPSR中的“I”标志位，置位后禁止IRQ中断 FAULTMASK类似于经典ARM处理器CPSR中的“F”标志位，置位后禁止FIQ中断    5.3.3.3. CONTROL寄存器 用于选择线程模式的特权访问等级以及栈指针\nCortex-M3/M4和Cortex-M0/M0+的CONTROL寄存器的编程模型如下图所示\n Cortex-M3/M4都只有SPSEL和nPRIV两位，配置了FPU的Cortex-M3/M4增加了一位FPCA Cortex-M0没有nPRIV ，Cortex-M0 M0+只是选项  CONTROL寄存器各位的含义：\n nPRIV：设置线程模式的特权访问等级，该位为0/1，处理器进入特权线程模式/非特权线程模式 SPSEL：选择线程模式中的堆栈指针  当该位为0时，线程模式使用主栈指针MSP 当该位为1时，线程模式使用进程栈指针PSP 在处理模式下，该位始终为0，并且忽略对其的写操作   FPCA：配置FPU的Cortex-M4才有此位。当发生异常时，若该位为1，浮点单元中的寄存器内容被压栈保存。执行浮点指令时FPCA位自动置位，在异常处理程序入口处该位被硬件自动清除  复位后，CONTROL寄存器被恢复成默认值0\n 这意味着复位之后，处理器处于线程模式、具有特权访问等级、并且使用主栈指针 在特权线程模式下，可以通过写CONTROL寄存器进入非特权线程模式 不过，当CONTROL寄存器的最低位nPRIV位被置位后，非特权线程模式下不能继续访问CONTROL寄存器了，也无法再切换回特权线程模式了 如果需要将非特权线程模式切换回特权线程模式，只能借助于异常处理。处理模式具有特权访问等级，可以清除nPRIV位，再在从异常返回线程模式后，处理器就进入特权线程模式  特权线程模式与非特权线程模式的切换过程：\n对于简单应用，可以一直运行在特权线程模式下，无须修改CONTROL寄存器的数值，并且只使用MSP\n5.3.3.4. 系统控制块SCB 系统控制块SCB是由多个寄存器组成的一个数据结构，属于Cortex-M3/M4内核的一部分并被综合到NVIC中\nSCB中各类寄存器的作用包括：\n 对处理器进行配置。如之前所述的双字栈对齐使能控制，以及低功耗模式设置等 提供错误状态信息。SCB中包含多个反映不同类型错误的状态寄存器 异常和中断管理。例如异常的挂起与解挂控制、优先级设置和优先级分组以及中断向量表的重定位 有多个反映处理器特性、指令集特性、存储模块特性以及调试特性的只读寄存器 对于配置了FPU的Cortex-M4处理器，还有一个协处理器访问控制寄存器  SCB的各类寄存器被映射到SCS中，地址范围：0xE000 ED00 ~ 0xE000 ED88\n 如果使用汇编语言，只能通过地址访问这些寄存器 但是CMSIS-Core为每个寄存器分配了一个符号，类似给这些寄存器赋予一个名称，例如：  中断控制和状态寄存器：SCB-\u0026gt;ICSR 系统控制寄存器：SCB-\u0026gt;SCR   使用C语言并利用CMSIS-Core定义的这些符号，可以更方便地对SCB中的各个寄存器进行访问  5.3.4. 堆栈结构 5.3.4.1. 堆栈的作用和堆栈类型 堆栈简介\n 堆栈是一种特殊的数据结构，是一种只能在一端进行插入和删除操作的线型表 堆栈的数据存取操作按照“后进先出（LIFO）”的原则，并通过堆栈指针指示当前的操作位置 压栈指令PUSH向堆栈中增加数据，出栈指令POP指令从堆栈中提取数据 每次PUSH和POP操作后，当前使用的堆栈指针都会自动进行调整 在32位系统中，堆栈操作至少是以字为单位，所以堆栈至少应该做到“字对齐”（在Cortex-M系列处理器中，为了遵守AAPCS的规范，堆栈需要采用双字对齐）  堆栈的作用\n 在异常/中断响应时，保存被中断程序的下一条指令的地址，以及处理器状态寄存器的内容（保护断点），以便在异常/中断返回后，处理器能够从断点处继续运行 异常/中断服务程序，或者正在执行的函数或者子程序如果需要使用某些寄存器，可以使用堆栈保存这些原来的内容（保存现场），以便异常返回或者函数或子程序处理结束时可以恢复现场 实现主程序与函数或者子程序之间的参数传递  函数或者过程调用有多种参数传递方式，堆栈传递是一种最安全的方式，并且对参数数量几乎没有限制   用于存储局部变量  堆栈的类型\n 按照堆栈区在存储器中的地址增长方向，可分为：  递增栈（Ascending Stack）：向堆栈写入数据时，堆栈区由低地址向高地址生长 递减栈（Descending Stack）：向堆栈写入数据时，堆栈区是由高地址向低地址生长   按照堆栈指针SP所指示的位置，又分为：  满堆栈（Full Stack）：堆栈指针SP始终指向栈顶元素，也就是指向堆栈最后一个已使用的地址 空堆栈（Empty Stack）：SP始终指向下一个将要放入元素的位置，也就是指向堆栈的第一个没有使用的地址或者空位置   组合上述两种地址增长方向和两种堆栈指针指示位置，可以得到4种基本堆栈类型：  满递增（FA）：SP指向最后压入的数据，且由低地址向高地址生长 满递减（FD）：SP指向最后压入的数据，且由高地址向低地址生长 空递增（EA）：SP指向下一个可用空位置，且由低地址向高地址生长 空递减（ED）：SP指向下一个可用空位置，且由高地址向低地址生长    5.3.4.2. Cortex-M处理器的堆栈模型 许多经典ARM处理器及ARM T32指令集可支持四种堆栈类型，但是，Cortex-M系列处理器只能使用满递减（FD）类型\n处理器在启动或者复位后，系统初始化程序从位于内存最开始处的flash中，取出地址为0x0000 0000的第一个字，作为主栈指针MSP的初始值\n每次PUSH操作时，处理器将SP的值减去4，然后将需要压栈保存的数据存储在SP指向的位置\n每次POP操作，SP所指向的存储器数据被读出，然后SP的数值自动加4，指向POP之后新的栈顶位置\n 出栈后，原来存放在堆栈中的数据依然存在，但无需理会，因为随后可能出现的PUSH操作将会将其覆盖  PUSH和POP操作应“匹配”，防止“张冠李戴”导致系统混乱甚至崩溃\n如果Cortex-M3/M4处理器使能了双字栈对齐模式，当出现异常时，假如压栈操作之后堆栈指针没有对齐到双字边界，将如何处理？\n 处理器会自动**插入一个“空”**字，强制堆栈对齐在双字边界上。同时，已经入栈保存的xPSR寄存器的第9位（未使用）被置为1，表示堆栈指针发生过调整 出栈时硬件电路对xPSR第9位进行检查，若为1则说明最后入栈的字是为了双字对齐插入的，应将其丢弃 虽然双字对齐可能会造成堆栈空间的一点点浪费，但是为了提高软件的标准化程度以及便于程序之间的相互调用，建议使用双字对齐模式  5.3.4.3. Cortex-M3/M4处理器中的双堆栈 Cortex-M3/M4的双堆栈设计有MSP和PSP两个堆栈指针，分别服务于不同的操作模式和特权访问等级\nCONTROL寄存器中nPRIV和SPSEL的不同组合，两个堆栈共有4种场景，其中前三种比较常见\n如果使用双堆栈，应通过MPU在SRAM中建两个区域\n 一个定义为特权级，其中一部分用作主栈存储区 另一个定义为非特权级，其中一部分用于进程栈  Cortex-M3/M4的堆栈是满递减类型，因此两个栈指针的初始值应该是两个区域的最大地址\n如果采用双字对齐，栈顶应位于双字边界上，MSP和PSP最低3位为000\nCortex-M系列处理器的堆栈空间一般位于系统主存储器SRAM区（也可以放置在CODE区中通过D-Code总线的连接的SRAM中）\n用于堆栈的存储区需要事先做好规划，预留足够的空间，以防出现堆栈溢出\nMSP的初始值事先存放在0x0000 0000处，该位置通常位于I-Code总线所连接的flash中，系统上电或者复位之后，系统初始化程序完成MSP的初始化\nPSP的初始化需要另外编程实现，PSP的初始化宜使用汇编指令代码，简单高效而且不易出错\n示例：\nBL Mpusetup\t;调用MPU设置子程序，建立region，并使\r;能存储器保护\rLDR r0, =PSP_TOP\t;读取进程栈栈顶\rMSR PSP, r0\t;初始化进程栈指针\rMOV r0，#0x3\t;准备置位CONTROL寄存器的SPSEL和\r;nPRIV\rMSR CONTROL, r0\t;完成CONTROL寄存器的更改，切换到\r;非特权线程模式\rB UserAppStart\t;已进入非特权线程模式，跳转到用户\r;程序入口\r5.4. Cortex-M处理器存储系统 5.4.1. 存储器映射 所有基于ARMv7M的Cortex-M系列处理器，都采用相同的存储器映射关系方式（存储区域划分）\n位段区\nCortex-M3/M4在SRAM区和片上外设区，各有一个位段区和位段别名区\n系统控制区SCS\n4KB，早期归属于NVIC，所以也称为NVIC区\n除NVIC以外，SCS还映射了SysTick、MPU、SCB和FPU等部件的寄存器\n不同存储器区域的用途\n5.4.2. 连接存储器和外设 为提高性能，CODE区使用专门的I-Code和D-Code总线，I-Code、D-Code和系统总线可以并行执行\n该结构也会加快中断响应速度，中断响应时，读取中断向量、取指和压栈操作可以同时执行\n此外，一些芯片制造商也会在MCU中增加自行设计的Flash访问加速器\n示例：Flash访问加速器\n意法半导体（ST Microelectronics）的STM32F2（基于Cortex-M3的微控制器）和STM32F4（基于Cortex-M4的微控制器），在I-Code和D-Code总线接口处实现了Flash访问加速器\n总线矩阵示例：NXP公司LPC1700\nAHB Lite协议仅适用于单主控设备的情形，有些产品用“总线矩阵”或“多层AHB”等术语来描述芯片内部支持多主控设备总线系统。对多主控设备的支持未在AHB Lite协议中定义\n5.4.3. 存储器的端模式 网路传输、文件存储均有大端小端问题\n在C语言下如果使用指针也需要注意大小端的问题\nCortex-M3/M4支持两种端模式\n大端：字节不变大端和字不变大端\n区别：数据传输时字节通道不同。字节通道指高低字节与总线上高低位数据线的映射关系，字节通道与存储系统设计相关\nCortex-M缺省支持小端模式\n小端模式下，Cortex-M3/M4和经典ARM处理器的字节通道都是相同的\nCortex-M处理器中：\n 取指令总是采用小端模式 访问包括系统控制区SCS、调试部件和私有外设总线（PPB）在内的0xE000 0000 ~ 0xE00F FFFF区域，总是小端模式 采用小端格式的MCU，若需要处理大端数据，可使用REV、REVSH和REV16等指令将数据做大端和小端转换  5.4.4. 非对齐数据的访问 Cortex-M的存储器系统是32位的，但处理器访问或处理的数据大小可能是32位（字）、16位（半字）或者8位（字节）的\n大部分经典ARM处理器只允许对齐传输\nCortex-M3和Cortex-M4处理器中，大部分存储器访问指令还支持非对其数据传输\n非对齐的注意事项：\n 非对齐的问题：非对齐传输会被拆分为两个对齐传输，导致数据访问花费更多的时间，降低了存储器的访问效率。在高性能应用中，确保数据的对齐存放是必要的 并非所有Cortex-M3和Cortex-M4的存储器访问指令都支持非对齐的数据传输。例如，多加载/存储指令、栈操作指令、排他访问指令必须是对齐的；位段操作也不支持非对齐传输 可设置Cortex-M3或Cortex-M4处理器在非对齐传输出现时触发异常  需要在配置控制寄存器CCR中置位UNALIGN_TRP（非对齐陷阱）位 软件开发过程中，程序员如果需要测试程序是否会产生非对齐传输，也可设置CCR的UNALIGN_TRP位    5.4.5. 位段操作 5.4.5.1. 位段与位段别名 位段（也称作位带）操作：一次存储器操作只访问一个位\nCortex-M3/M4处理器中，有两个位段区域：\n SRAM区域的最低1MB（0x2000 0000 ~ 0x200F FFFF) 外设区域的最低1MB（0x4000 0000 ~ 0x400F FFFF） 位段特性在Cortex-M3和Cortex-M4上是可选的  位段别名\u0026amp; 位段别名区域\n 位段区域中特定存储单元的某一位，映射为一个位段的别名地址（一个字） 一个字的32个比特被映射到32个位段别名地址（32个字）  位段别名地址数据的LSB$\\Leftrightarrow$位段区存储单元的某一个位\n位段区域的存储单元可以像普通存储器一样访问，还可以通过名为位段别名的一块独立的存储器区域进行位段访问\n使用位段别名地址访问存储器时，所得到字数据的最低位LSB即对应位段区域中某个特定的位\n1 MB位段区映射为32 MB位段别名区域。如0x2000 0000地址的字节数据的8个比特被映射到0x2200 0000 ~ 0x2200 001C处的别名区域\n外设区域的位段别名地址如图所示，若读取别名地址0x4200002C，则返回结果可能是0x00000000或0x0000 0001，分别代表0x4000 0000位置字数据的第11位取值为“0”和“1”\n修改某一位\n没有位段特性时，只能”读 → 改 → 写“\n位段操作可以帮助用户完成“读$\\rightarrow$改$\\rightarrow$写”\n示例：将地址为0x2000 0000的字数据的第2位置1\n读取特定位\n没有位段特性时，只能先读取字节/半字/字数据，再使用其他指令提取某一位，至少需要两次操作\n位段操作可以简化程序\n例：读取地址为0x2000 0000字数据的第2位\n5.4.5.2. 位段操作的优点 操作的原子性：操作过程不会被其它事务打断\n 原子性是位段操作的一个重要优点 无位段特性时，“读$\\rightarrow$改$\\rightarrow $写”流程可能会被其它行为打断（例如异常/中断处理、多任务切换），从而会有潜在的数据冲突风险 位段操作可以避免这种竞态现象，这是因为位段操作所完成的“读$\\rightarrow$改$\\rightarrow $写”是由硬件保障的，具有原子性  简化转移决断过程\n 假如程序是否转移执行是依据I/O端口某个状态寄存器中的某一位，位段操作可以直接读取该位数值，迅速完成判断  5.4.5.3. C程序实现位段操作   C编译器本身不支持位段操作，其原因是：\n 不知道可以用两个不同的地址来寻址同一个存储器位置 也不了解对位段别名的访问只操作存储器数值的LSB    但是可以编程实现位段操作\n 例：写地址为0x40000000的某端口寄存器的bit[1]    可以在C程序中声明存储器位置的地址和位段别名\n1 2 3 4 5 6 7  #define DEVICE_REG0\t*(( volatile unsigned long*) (0x40000000)) #define DEVICE_REG0_BIT0\t*(( volatile unsigned long*) (0x42000000)) #define DEVICE_REG0_BIT1\t*(( volatile unsigned long*) (0x42000004)) ... DEVICE_REG0 = DEVICE_REG0 | 0x2;//未使用位段特性设置bit[1] ... DEVICE_REG0_BIT1 = 0x1;//利用位段特性通过位段别名地址设置bit[1]   5.4.6. 存储器访问权限  Cortex-M3/M4的处理器映射具有默认的存储器访问权限配置，除了个别寄存器以及芯片厂商定义区之外，不允许非特权用户程序访问包括SCS（NVIC）在内的内核私有区域，否则将引起总线错误异常 如果系统配置了MPU并且使能，MPU设置所定义的其他访问权限也会决定是否允许用户访问其他的存储器区域 在没有MPU时，或者有MPU但未使能时，将使用默认的存储器访问权限设置  Cortex-M3/M4默认的存储器访问权限\n5.4.7. 存储器访问属性 Cortex-M3/M4处理器的存储器访问属性：\n 可缓冲（Bufferable）：存储器写操作可能无法在一个流水线周期内完成，如果配置了写缓存，但剩下的工作交由写缓冲执行，处理器继续执行下一条指令 可缓存（Cacheable）：读存储器所得到的数据可被复制到缓存，下次再访问时可以从缓存中取出这个数值从而加快程序执行 可执行（Executable）：处理器可以从本存储器区域取出并执行程序代码 可共享（Sharable）：存储器区域的数据可被多个总线主设备共用。但是，存储器系统需要在不同总线主设备之间，确保可共享存储器区域数据的一致性  可缓冲\nCortex-M3/M4支持总线接口的写缓冲\n 即使总线接口上的实际传输需要多个时钟周期才能完成，对可缓冲存储器区域的写操作可在单个时钟周期内执行，处理器可继续执行后续指令 代价：  虽然存储器系统不会改变指令执行顺序，但是，并不能确保多条顺序执行指令中的存储器访问完成顺序与指令顺序一致 存储器屏障指令，保证指令执行顺序与存储器访问结束顺序一致    可缓存与可共享\n 可缓存属性需要硬件支持，Cortex-M3/M4处理器本身没有缓存存储器或缓存控制器，但芯片制造商可在MCU增加缓存单元，支持可缓存属性 若系统中存在多个处理器，并且缓存控制器具有缓存一致性管理功能，就需要用到可共享属性 缓存控制器用来确保共享数据在各个缓存单元是一致的，从而保证共享内存中的数据一致性  存储器按访问属性分类\n按照可缓冲和可缓存属性，存储器分为以下三类：\n 其中后两种都属于普通型，算作一类  现有多数基于Cortex-M3/M4的微控制器，只有可执行和可缓冲属性会影响到应用程序的执行\n代码顺序$\\neq$存储器操作完成顺序\nA1和A2是两条前后相连的存储器访问指令，A1指令在前，A2指令在后，当A1、A2指令所访问的存储器类型不同时，这两条指令实际存储器访问的先后顺序如表所示\n存储器系统会确保”强序“类型存储器和”器件“类型存储器的访问顺序\n各存储器区域的默认访问属性\n5.4.8. 排他访问 在多用户操作系统中，当多个用户共享某个特定资源时，常利用信号量（semaphore）进行协调。若某共享资源只能满足一个用户使用时，被称为互斥体（Mutex）\n 若某资源已被用户占用，就会被锁定至该用户，在锁定解除前无法用于其他用户。每个用户在使用资源前，需要先检查资源是否已被锁定，若未被使用，则设置为锁定状态，再开始使用资源 在传统ARM处理器中，锁定状态访问由SWP指令执行，以确保读写锁定状态的原子性，避免资源被两个用户同时锁定，但SWP指令只适用于读写位于同一总线的场景 在Cortex-M3/M4，读/写访问可由独立的总线执行，此时使用SWP指令就无法保证存储器访问的原子性，所以采用了新的排他访问指令（Cortex-M3/M4 取消了SWP指令）  排他写过程\n排他访问需要软硬件配合才能完成，一次排他写过程需要先用排他读指令获取拟访问地址是否被锁定的信息；未被锁定时才可进行排他写并设置锁定状态\n5.4.9. 存储器屏障 利用存储器屏障指令，程序员可以控制不同指令存储器访问的先后顺序\nCortex-M处理器不会调整程序中指令执行的顺序（在超标量处理或支持乱序执行的高性能处理器中可能会出现调整），同时，AHB Lite和APB协议较为简单，不允许在前面的传输还未完成时就开始新的传输\n 通常情况下，存储器操作的先后顺序也是和指令的先后顺序一致的  但是，为提高处理器性能，Cortex-M3/M4增加了写缓冲，写操作可能会和下一条指令的操作同步执行\n 如果程序员需要保证下一条指令的操作不会在当前指令写存储器操作完成前执行，需要使用存储器屏障指令  存储器屏障指令可以用于：\n 确保存储器访问顺序 确保存储器访问和另外一个处理器操作之间的顺序 确保系统配置发生在后序操作之前  Cortex-M3/M4支持三种存储器屏障指令：\n DBM：数据存储器屏障。确保执行新的存储器操作之前所有的存储器操作都已经完成 DSB：数据同步屏障。确保下一条指令执行前所有的存储器访问都已经完成 ISB：指令屏障。清空流水线，确保在执行新的指令前，之前所有的指令都已经完成  5.4.10. MCU中的存储器系统 在许多MCU中，芯片制造商还集成了其他一些存储器特性，以提高存储器映射的灵活性，例如：\n Bootloader（上电复位后的第一段代码） 存储器重映射 存储器别名  很多情况下，MCU中除了CODE区的Flash之外，还有一个单独的ROM（也可能是Flash），其中包含了Bootloader，其功能包括：\n Flash编程功能，可以通过UART对Flash进行编程 通信协议栈，便于开发者通过API调用 通过芯片内部的自检功能  对于具有Bootloader ROM的芯片，系统上电时执行的是Bootloader ROM中的引导程序，因此Bootloader ROM应该位于地址0x0\n但是，系统再次启动时，可能不再运行Bootloader ROM中的程序，而是运行Flash中的程序。因此，可以使用下图所示电路修改存储器的映射关系\n以上切换操作称为存储器重映射（Memory Remap），由Bootloader实现。但是，在重映射切换的同时无法跳到Bootloader新地址。因此，可采用一种名为“存储器别名”的方法，从两个不同的位置访问Bootloader\n有多种存储器配置方法，下图只是其中的一种\n5.5. Cortex-M处理器的异常处理 5.5.1. Cortex-M异常管理模型 5.5.1.1. 异常类型 5.5.1.2. 异常状态 5.5.1.3. 异常处理程序 5.5.1.4. 异常向量表 当Cortex-M处理器接受了某异常请求后，处理器需要确定该异常对应的异常处理程序的起始地址。该信息位于存储器内的异常向量表中，向量表默认从地址0x0000 0000开始，按照异常类型号依次存放各个异常的入口地址\n Thumb-2指令有16位和32位两种长度，指令代码至少对齐在半字边界，程序入口地址的LSB应是“0” 但是异常向量的LSB必须是“1”，表示异常处理程序处于Thumb状态，否则将引起总线错误  5.5.1.5. 异常的优先级 Cortex-M3/M4中，每一个中断都有一个8位的中断优先级（配置）寄存器（0xE000E400~ 0xE000E4EF，位于NVIC中），实际使用位数3~8位，取决于MCU设计的中断数量\n优先级的减少通过去除优先级配置寄存器的最低位（LSB）实现，有两种不同的移除方法：\n每一个中断的优先级由各自的中断优先级寄存器定义，中断优先级寄存器可以按照字节/半字/字进行访问\n 若MCU设计了3位优先级，则有8个可编程优先级 若设计了4位优先级，会得到16个可编程优先级 ARMv7-M架构，宽度最少为3位  若设计中实现了4位优先级，优先级配置寄存器如下，会得到16个可编程优先级\n实际使用的位数越多，可用的优先级越多\n若出现优先级相同的异常同时发生，处理器将优先处理异常类型号低的，称之为”自然顺序优先级“\n 例如，假设IRQ#0和IRQ#1的优先级被设为相同数值，当IRQ#0和IRQ#1同时出现或均处于挂起状态时，处理器会先处理IRQ#0的ISR  复位后的初识状态：\n 所有可配置中断处于禁止状态，默认优先级为0 固定不变：复位为-3、NMI为-2、硬件错误为-1  5.5.1.6. 中断优先级分组 优先级寄存器3~8位又分为两部分（以8位为例）\n 分组优先级（group priority），过去称为抢占优先级（preempt priority）  后来的中断能否产生嵌套，由该中断的分组优先级决定   子优先级（subpriority）  两个具有相同分组优先级的异常同时出现时，首先处理子优先级（数值更小）高的异常    AIRCR（0xE000 ED0C）的PRIGROUP位域（AIRCR[10:8]），使用3位定义优先级分组的8种配置方案\n若优先级配置寄存器的宽度不同，设置优先级分组的方法：\n  优先级配置寄存器的宽度为8，优先级分组为配置0\n  优先级配置寄存器的宽度为3，优先级分组为配置1\n  优先级配置寄存器的宽度为3，优先级分组为配置5\n  5.5.1.7. 异常流程 异常处理的过程包括：中断响应、中断处理和中断返回\n 中断响应：CPU确定响应某中断后，根据中断类型码查找中断向量表中对应的表项，获得中断服务子程序入口地址；接下来保护断点（将标志寄存器和断点地址等信息压入堆栈）；随后（粗糙描述）中断向量被装入PC寄存器，下一个指令周期即进入中断服务子程序 中断处理：就是执行中断服务子程序的过程，处理之前需要保护现场（保护现场的执行主体是ISR） 中断返回：包括从堆栈中恢复现场和恢复断点，恢复现场需要编程实现，而恢复断点由硬件电路自动完成    异常请求的接受\n处理器接受请求的条件：\n 处理器处于运行状态 异常处于使能状态 异常的优先级高于当前等级 异常没有被屏蔽（如没有设置PRIMASK）  注意：若异常处理程序中出现了SVC指令，而该异常的优先级不低于SVC的优先级，就会发出硬件错误，从而进入硬件错误的处理程序\n  异常进入流程\n异常进入流程包括如下操作：\n 多个寄存器的值和返回地址被压入当前使用的栈  在不保护浮点运算寄存器组情形下，被压入堆栈的寄存器包括PSR、PC、LR、R0~R3、R12，共8个字 如果需要保护浮点运算单元状态，则有26字的状态会被压栈 若处理器处于线程模式且正在使用进程栈指针（PSP），则PSP指向的堆栈区域就会用于该压栈过程，否则就会使用主栈指针（MSP）指向的堆栈区域   从向量表中取出异常向量 取出异常处理程序中的指令 更新多个NVIC寄存器（后续介绍）和内核寄存器（PSR、LR、PC及SP）  根据压栈时实际使用的栈，MSP或PSP的数值会在异常处理开始前自动调整。PC也会被更新为异常处理的起始地址，而LR则会被更新为名为EXC_RETURN的特殊值\nEXC_RETURN服务于异常返回，其数值为32位，高28位为1，低4位用于指示进入异常是保存的状态信息（即指示使用的是MSP还是PSP，哪些寄存器被压入栈），其可能的数值如下所示\n在异常进入过程中，硬件自动完成的处理有：\n 根据压栈时实际使用的栈，MSP或PSP的数值会在异常处理开始前自动调整 PC被更新为异常处理的起始地址 LR被更新为EXC_RETURN R0~R3、R12，LR、PC（返回地址）和PSR共8个寄存器被压栈（注意：压栈顺序和栈帧结构不同） 如果需要压栈保存FPU状态，则共有26字 如果使能双字栈对齐，可能还会修改已入栈的PSR[9]  为加快中断执行速度，需要调整压栈顺序：\n  压栈时为了尽快更新PC，首先压栈的是PC（返回地址）和PSR，出栈时为了尽快恢复处理器状态和返回主程序，出栈时也应先出栈PSR和PC，这时需要根据压栈时实际使用的栈，MSP或PSP的数值会在异常处理开始前自动调整\n  此外，如果中断向量位于CODE区，压栈的同时可以使用I-Code总线取中断向量，以充分利用哈佛结构的优点；如果中断向量位于SRAM区或者RAM区，压栈和取向量只能都是用系统总线，会略微增加中断响应延迟\n    执行异常处理程序\n 进入异常处理程序内部后，处理器进入处理模式，并运行于特权访问等级，栈操作使用MSP 此过程中如果有更高优先级的异常产生，处理器会接受新的中断，当前正在执行的处理被更高优先级的处理抢占而进入挂起状态，此即异常嵌套 若执行过程中产生的其他异常具有相同或更低的优先级，新产生的异常就会进入挂起状态，待当前异常处理完成后才可能被处理  在异常处理的结尾，程序代码执行的返回会引起EXC_RETURN数值被加载到程序计数器PC中，并触发异常返回机制\n  异常返回\nCortex-M处理器的异常返回机制由EXC_RETURN触发，该数值在异常入口处产生且被存储在LR中\nEXC_RETURN写入PC时，就会触发异常返回流程\n异常返回可由表中所示的指令产生。异常返回机制被触发后，进入异常期间被压入栈中的寄存器数值会被恢复到寄存器组中，因而多个NVIC寄存器和处理器内核中的寄存器（如PSR、SP和CONTROL）都会被更新\n  加速中断处理速度——咬尾中断\n情形描述：\n 中断#1正在服务，又出现中断#2，因优先级问题，中断#2被挂起 当中断#1结束后，一般的流程是：中断#1返回（一系列的出栈操作，恢复现场和恢复断点），紧接着响应中断#2，又有一系列的入栈操作（保护断点和保存现场）  咬尾中断：\n 流程优化思想：中断#1结束后，读取中断#2的中断向量，立即为中断#2服务，减少中断#2的时延  加速中断处理速度——晚到中断\n情形描述：\n 当优先级较低的中断#n刚刚被响应，正在进行压栈，但是尚未取中断向量和进入ISR，此时又有优先级更高的中断#m到达 一般流程：响应中断#n时关中断，进入ISR后开中断，再响应优先级更高的中断#m，中断#m的服务可能被延误  晚到中断：\n 仍然压栈保护断点，但是取ISR#m的中断向量，提前为中断#m服务  5.5.2. 向量表重定位机制 向量表重定位简介\n 向量表默认位置位于CODE区最开始处，MCU制造商在此区域一般配置的是存放启动代码的Flash或者是ROM型存储器，这些器件运行时无法修改，而有些应用需要修改或者增加中断向量。一种解决方案是将向量表“迁移”到CODE区或者SRAM区其他可以修改的SRAM或者RAM型器件中 在有些MCU中，包含Bootloader的ROM就位于CODE区的最开始位置，而且没有使用存储器重定位特性或者存储器别名，这样就挤占了中断向量表原来应该的存放位置，中断向量表只能“背井离乡”，重新择址“安家” 上述中断向量表的迁移称为“向量表的重定位”  向量表重定位的实现\n在Cortex-M3/M4 处理器所集成的NVIC中，有一个名为VTOR（Vector Table Offset Register，地址为0x0E000 ED08）的寄存器，修改VTOR的值就能实现中断向量表的重定位\n对中断向量起始地址的要求：\n 起始地址必须能够被大于等于（中断向量数×4）的最小2的整数次幂整除 例如：CM3/M4最少中断数是8个，再加16个系统异常，8+16=24，24×4=96，大于96的最小2的整数次幂是128（=27），所以向量表的起始地址应该是0x80的整数倍，换言之，向量表起始地址低7位为000 0000  VTOR的格式\nr2p0版本之前的Cortex-M3，向量表只能“迁移”CODE区或者SRAM区；而新版Cortex-M3和所有Cortex-M4取消了上述限制\n 如前所述，VTOR的最低7位[6:0]为000 0000 r2p0版本之前的Cortex-M3最高两位没有意义，**位[29]**为0或1表明中断向量表位于CODE区还是SRAM区 在Cortex-M4和新版本的Cortex-M3中，最后7位没有变化，但是其他位是向量表起始地址的高25位  应用示例：\n  具有Bootloader的设备\n MCU启动时，首先执行ROM中的Boot loader代码 在跳转到Flash中的用户程序前，设置VTOR指向用户Flash存储器的开始处（此处放置重定位后的向量表） 向量表切换为用户Flash中的向量表    应用程序是从外部加载到RAM中执行\n 存储在片上存储器的启动程序初始化相关硬件，把外部设备（如SD卡或U盘）中的应用程序复制到RAM（包括SRAM）中 更新VTOR，指向位于RAM中新的向量表 最后执行已加载到RAM的程序    5.5.3. 中断请求和挂起 在传统ARM处理器中，若设备产生了中断请求，在得到处理前需要一直保持中断请求信号。在NVIC中设计了用于保存中断请求的挂起请求寄存器，即使请求中断的源设备取消了请求信号，已产生的中断仍会被处理\n如果处理器空闲，处于挂起状态的中断请求会马上得到处理，此时，中断的挂起状态被自动清除。但如果处理器正在处理另外一个更高优先级或同等优先级的中断，或者产生请求的中断源被屏蔽了（通过设置中断屏蔽寄存器），那么在其他中断处理结束前或中断屏蔽被清除前，该中断会一直保持在挂起状态\n某个中断被处理时就会进入激活状态。在NVIC中，中断激活状态寄存器保存每个中断的激活状态，只有在中断服务完成，处理器执行了异常返回后，中断激活状态寄存器中对应已完成服务中断的位才会被清除（自动完成）\n  中断的状态：请求$\\rightarrow$挂起$\\rightarrow$激活\n  挂起状态、挂起状态清楚、进入激活状态、清除激活状态\n  线程模式$\\rightarrow$处理模式$\\rightarrow$线程模式\n 从线程模式切换到处理模式时，多个寄存器会被自动压栈，并从向量表取出ISR的起始地址 从处理模式回到线程模式时，之前自动压栈的寄存器会被恢复，继续此前被打断的程序    在Cortex-M3/M4中，出现中断请求之后，如果没有得到服务，就一直被挂起。即使中断源因某种原因撤销了请求，仍然会被处理——在编写ISR时，应先读取中断源相关状态，若的确需要服务，继续执行ISR；否则退出\n一般而言，需要中断服务的外设，应该设置专门的“中断请求触发器”，在得到服务前，一直维持请求信号有效，在中断响应之后再撤销\n5.5.4. NVIC寄存器 NVIC中的寄存器组只能管理类型16~255的外部中断，管理NMI和Systick等系统异常需要SCB中的寄存器\n5.5.4.1. 中断的使能和禁止  中断使能和禁止是通过对2个寄存器（中断设置使能寄存器Interrupt Set-enable Registers和中断清除使能寄存器Interrupt Clear-enable Registers）进行写操作，实际是对一个物理寄存器进行配置  设置中断势能需要写入NVIC_ISERn寄存器的相应位    ​\t注意：中断使能和禁止使用两个地址，操作的是同一个物理寄存器\n  清除使能（禁止中断）需要写入NVIC_ICERn寄存器的相应位\n 每个ISER/ICER寄存器都是32位，每位对应一个中断输入，若外部中断源超过32个，ISER和ICER寄存器不止一个 ISER/ICER分开设置，操作的是同一个寄存器，某位置1无需担心其他位被置零；没有“读-改-写”过程，操作具有原子性    5.5.4.2. 中断挂起和中断清除 若中断请求产生但没有立即执行，就会进入挂起状态\n设置中断挂起状态或者读取中断挂起状态，可以通过访问中断设置挂起寄存器（Interrupt Set-pending Registers，NVIC_ISPRn）实现\n通过写ISPR将某个中断设置为挂起状态，该中断就进入了等待中断服务的队伍中\n清除中断挂起状态可以通过中断清除挂起（Interrupt Clear-pending Registers，NVIC_ICPRn）寄存器实现\n每个ISPR/ICPR寄存器也是32位，每位对应一个中断输入，若外部中断源超过32个，ISPR和ICPR寄存器也不止一个\n中断的激活状态\n 只要进入中断服务子程序，中断激活状态寄存器（Interrupt Active Bit Registers，NVIC_IABR）中的对应位就置1 如果发生中断嵌套，会出现多个中断处于激活状态（尽管处理器在执行优先级高的中断处理，之前执行的较低优先级的中断仍处于激活状态） NVIC_IABR为只读类型  中断优先级配置寄存器\n 每个中断都有各自的优先级寄存器（Interrupt Priority Registers），每个优先级寄存器位宽为8位（实际位宽为3~8位），一个32位的NVIC_IPRn管理4个中断 每个优先级寄存器又分成分组优先级和子优先级两部分 优先级寄存器的数量取决于芯片实际的外部中断数  软件触发中断寄存器\n除了写ISPR以外，还可以向软件触发中断寄存器（Software Trigger Interrupt Register，STIR）写类型号来触发相应中断（写ISPR是置位对应位）\n 可以通过设置CCR，允许非特权程序访问STIR 但是只有特权访问等级才可以访问ISPR  5.5.5. SCB寄存器 中断控制和状态寄存器\nICSR: Interrupt Control and State Register\n用于设置和清除系统异常的挂起状态，包括NMI、SysTick和PendSV\n通过ICSR可以获知当前正在处理的异常的类型号、当前挂起异常中优先级最高者的类型号、是否发生了抢占信号等信息\n应用中断和复位控制寄存器\nAIRCR: Application Interrupt and Reset Control Register\n用于控制异常/中断优先级管理中的优先级分组，指示系统的端配置信息，提供自复位特性\nVECTRESET和VECTCLRACTIVE位域是为调试器设计的。软件可利用VECTRESET触发处理器复位，但它不会复位外设，若需要产生系统复位，应该使用SYSRESETEREQ\n系统处理优先级寄存器\nSHPR： System Handler Priority Register\n共3个，SHPR1到SHPR3，SHPR的位域定义与中断优先级寄存器定义相同，差别在于SHPR用于（除了复位、NMI和硬件错误以外的）系统异常\n系统处理控制和状态寄存器\nSHCSR: System Handler Control and State Register\n可以使能的异常包括：使用错误、存储器管理错误和总线错误异常\n上述异常和多数系统异常的激活状态也可从SHCSR获得\n6. ARM指令系统 6.1. ARM处理器指令集概述 指令集体系架构：描述处理器指令及其功能、组织方式和规范\n指令系统：计算机系统中所有机器指令的集合\n机器指令：\n 表示一条指令的二进制代码（即比特串，或称位串）称为指令字，简称指令 指令字可以是固定长度的，也可以是可变长度的 指令字需要包含操作码、操作数（可能有多个）和操作数地址等字段 所有指令字的相关信息在指令集中予以规定  6.1.1. ARM的不同指令集 ARM处理器的指令集\n ARM Instruction Set Architecture 不同时期的ARM处理器指令集存在较大差异  ARM公司在多个体系结构版本的基础上，还定义了若干增强型版本，配合相应的硬件部件以支持协处理器、DSP、VFP、Java和SIMD多媒体信号处理等功能   目前，ARM公司将其不同系列处理器所支持的指令集架构ISA统一为三个  A64：与现有A32指令集相似，仍然是32位宽，具有相似的语法，支持64位处理器 A32：即原来的ARM指令集，指令长度固定为32比特 T32：即原来的Thumb-2指令集，16位和32位指令共存    各个版本架构所支持的指令集\n\u0026lt;image-20200430143407031.png\u0026quot; alt=\u0026ldquo;image-20200430143407031\u0026rdquo; style=\u0026ldquo;zoom:67%;\u0026rdquo; /\u0026gt;\n说明：\n 自ARMv6-M之后，所有版本都支持T32指令集 不同处理器设计（配置的功能部件不同），增加了不同的指令集扩展（也称扩展指令）  6.1.2. ARM指令集扩展 指令集扩展\n 除基本指令集以外，为满足具体应用需求，ARM处理器可选配一些功能部件，并增加与之“配套”的指令，构成扩展指令集（Arm Architecture Extensions） 例如：  DSP extensions $\\rightarrow$ 数字信号处理 Floating-point Extension $\\rightarrow$ 浮点数运算（如Cortex-M4） Neon: 单指令多数据（SIMD） Helium: Armv8.1-M引入的M-Profile Vector Extension，矢量处理，用于Cortex-M系列 \u0026hellip;\u0026hellip;    ARM指令集的扩展过程\nARMv8-A的的指令集扩展过程：先后增加了Jazelle、VFP、TrustZone、SIMD 、NEON以及可选密码扩展\nARM的指令集扩展\n DSP 扩展  单周期16×16 和32×16 MAC 实现 零开销饱和运算扩展支持 用于加载和存储寄存器对的新指令，包含增强的寻址模式 CLZ 指令，改善归一化以及除法运算性能   浮点数运算扩展  半精度、单精度和双精度浮点运算支持 运算指令：Add、Sub、Mult、Neg-Mult、Negate、Abs Value、Compare、Div、Square Root FMAC：Multiply-Add、Multiply-Subtract、Neg-Multiply-Add、Neg-Multiply-Subtract、类型转换、加载/存储标量和矢量，64 位/周期   多媒体SIMD 扩展  小数运算 用户可定义的饱和模式（任意字宽） 同时计算2×16位或4×8位操作数 双16×16 乘加/减和32×32 小数MAC   NEON 是SIMD的128 位升级版，具有32个64 位宽（也可以看作16个128位宽）寄存器  寄存器被视为同一数据类型的元素的矢量 数据类型：8 位、16 位、32 位、64 位单精度浮点 指令在所有通道中执行同一操作   JAVA加速  ARM Jazelle 包括在任何现有JVM 和Java 平台中支持Jazelle 硬件的技术   安全计算的指令扩展  ARM TrustZone 技术是系统级的安全方法，针对高性能计算平台上的大量应用，包括安全支付、数字版权管理(DRM) 和基于Web 的服务   虚拟机有关的指令扩展  ARM架构的虚拟化扩展（Virtualization Extensions ）提供了在ARM处理器基础上建立虚拟机（virtual machines ）的基本支持    Cortex-M支持的指令集\n部分Cortex-M系列处理器所支持的指令集以及扩展指令功能如下：\n\u0026lt;image-20200519090656588.png\u0026quot; alt=\u0026ldquo;image-20200519090656588\u0026rdquo; style=\u0026ldquo;zoom: 50%;\u0026rdquo; /\u0026gt;\nCortex-M处理器的兼容性\n 由上图可见，在Cortex-M0/M0+/M1上编译过的代码可在Cortex-M3/M4上直接运行 Cortex-M3/M4不支持ARM指令，不能向后兼容传统ARM处理器（如ARM7TDMI），亦即Cortex-M处理器不能直接运行ARM7TDMI的二进制代码 但是，Cortex-M3/M4的Thumb-2指令是Thumb指令的超集，大部分ARM7TDMI的指令可以移植为等价的32位Thumb-2指令，因此传统ARM处理器上的应用软件可以重新编译后再移植到Cortex-M3/M4上 虽然指令有16位和32位之分，对于同一个操作，不同长度的指令执行时间相同  Cortex-M处理器的适用场景\n 对于一般的数据处理和I/O控制，Cortex-M0/M0+完全可以胜任（性能达2.15 Core Mark/MHz） 如果需要进行复杂的数据处理和快速乘加运算，就应该升级到Cortex-M3/M4处理器 如果需要DSP功能，则应该选择Cortex-M4 如果还需要计算浮点数，Cortex-M4还应该选配FPU 需要特别指出的是：  虽然Cortex-M3/M4支持的指令较多，但是C编译器也能生成高质量的代码，CMSIS-DSP库提供了较丰富的应用函数，现代大多数嵌入式软件都使用C或C++语言开发，因此无需过于关注汇编指令的细节    6.2. T32指令格式 6.2.1. 16比特指令二进制格式 T32的指令由半字对齐的序列构成\n 若为16比特Thumb指令，则指令中含有一个半字 若为32比特Thumb指令，则指令中含有两个半字  通过半字的最高5个比特来区分是16比特指令还是32比特指令。若一个半字的最高五个比特（bits[15:11]）为如下三种情况则该半字为一个32位比特指令的第一个半字：\n 0b11101 0b11110 0b11111  其他情况的半字均为16比特指令\n16比特指令的二进制位串编码格式如下：\n\u0026lt;image-20200519093222202.png\u0026quot; alt=\u0026ldquo;image-20200519093222202\u0026rdquo; style=\u0026ldquo;zoom: 50%;\u0026rdquo; /\u0026gt;\n高六比特为操作码，操作码定义了不同的指令类别：\n\u0026lt;image-20200519093242993.png\u0026quot; alt=\u0026ldquo;image-20200519093242993\u0026rdquo; style=\u0026ldquo;zoom: 50%;\u0026rdquo; /\u0026gt;\n6.2.2. 32比特指令二进制格式 T32指令集中32比特指令的二进制编码格式如下：\n\u0026lt;image-20200519093310847.png\u0026quot; alt=\u0026ldquo;image-20200519093310847\u0026rdquo; style=\u0026ldquo;zoom:67%;\u0026rdquo; /\u0026gt;\n操作码被分成三段：”op1“、”op2“、”op“\n当”op1==0b00“时，表示是该指令T32指令集中的16比特指令\n当”op1!=0b00“时，根据”op1“、”op2“、”op“可对32比特指令进行分类\n\u0026lt;image-20200519093331069.png\u0026quot; alt=\u0026ldquo;image-20200519093331069\u0026rdquo; style=\u0026ldquo;zoom: 50%;\u0026rdquo; /\u0026gt;\n6.2.3. T32指令的汇编语法 在定义一条机器指令的时候，需要将指令的功能、源操作数、目标操作数、操作数地址等信息予以明确。ARM处理器中汇编指令的通用格式构成要素如下：\n\u0026lt;opcode\u0026gt; [cond] [q] [S] _\u0026lt;Rd\u0026gt;, _\u0026lt;Rn\u0026gt; [,_Oprand2]\r其中，\u0026lt;\u0026gt;内的参数是必选参数，而[]内参数是可选参数\n opcode，操作码，也称为助记符。说明指令需要执行的操作类型 cond，条件码（可选后缀），描述指令的执行条件 q，可选后缀，指令宽度选择，“N”表示指令为16比特，“W”表示指令为32比特 S，可选后缀，加上“S”，在指令执行完毕后自动更新APSR中的标志位的值  早期产品，几乎所有数据操作指令都会更新APSR^5^中的标志位    Rd，ARM指令中的目标操作数，总是一个寄存器 Rn，存放第一个源操作数寄存器，该操作数必须是寄存器 Oprand2，第二源操作数，不仅可以是寄存器，还能是立即数，且能用经过偏移量计算的寄存器和立即数  6.2.4. T32的条件执行指令 T32中多数Thumb指令可以根据应用程序状态寄存器APSR中的标志位决定当前指令是否被执行\n这种在特定条件满足时才执行的指令被称为条件执行指令\nAPSR寄存器的标志位定义为：\n\u0026lt;image-20200519094147590.png\u0026quot; alt=\u0026ldquo;image-20200519094147590\u0026rdquo; style=\u0026ldquo;zoom:67%;\u0026rdquo; /\u0026gt;\n处理器执行指令的时候，其运算过程可能会改变APSR中的标志位\nAPSR寄存器的各标志位定义为：\n N bit[31] 负数标志位。N==1 表示上一次运算结果为负数，否则为正数或零 Z bit[30] 零标志位。Z==1 表示上一次运算结果为零 C bit[29] 进位标志位。C==1 表示上一次运算结果产生了进位 V bit[28] 溢出标志位。V==1 表示上一次运算结果产生了溢出 Q bit[27] 饱和标志位。Q==1 表示上一次运算结果产生了饱和操作 GE[3:0] bits[19:16]，DSP扩展指令中SIMD类指令指示上一次运算结果信息  在Thumb指令中，只要条件码不为“1110”，均为条件执行指令：\n\u0026lt;image-20200519094411309.png\u0026quot; alt=\u0026ldquo;image-20200519094411309\u0026rdquo; style=\u0026ldquo;zoom: 50%;\u0026rdquo; /\u0026gt;\n6.2.5. T32指令格式示例 指令一般由操作码字段和操作数字段两部分组成\n操作码字段 操作数字段 ... 操作数字段\r 操作码字段：指示计算机要执行是什么操作 操作数字段：指令执行操作过程中所需要的操作数，该字段可以是：  操作数本身 操作数地址或是地址的一部分 指向操作数地址的指针 或其他有关操作数的信息（如寄存器名称）    ARM处理器绝大多数算逻运算指令支持3操作数，也有1～2个操作数，少数隐含多个操作数（如LDM指令），还有若干指令无操作数\n6.3. T32指令集寻址方式 寻址：根据指令内容确定操作数地址的过程\n 确定当前指令中的操作数地址，称为数据寻址 确定下一条待执行指令的地址，称为指令寻址  寻址方式：如何寻找操作数的方法。不同的寻址方式实质上是构成操作数地址的方法不同\n\u0026lt;image-20200519184955267.png\u0026quot; alt=\u0026ldquo;image-20200519184955267\u0026rdquo; style=\u0026ldquo;zoom:50%;\u0026rdquo; /\u0026gt;\n6.3.1. 立即数寻址 立即数寻址也叫立即寻址，是一种特殊的寻址方式\n操作数本身包含在指令中，只要取出指令也就取到了操作数\n这个操作数叫做立即数，对应的寻址方式叫做立即寻址，如\nMOV R0, #66 ;将立即数66传送到寄存器R0\rADD R0, R0, #66\t;R0+66→R0\rSUB R0, R0, #0x33\t;R0-0x33→R0\r在立即数寻址中，要求立即数以“#”为前缀，对于以十六进制表示的立即数，要求在“#”后加上“0X”或“\u0026amp;”或“0x”\nCortex-M3/M4支持的T32指令集中，指令长度要么是16比特，要么是32比特，指令长度有限 → 立即数取值只能在一定范围内\n对立即数的限制\n 在传统ARM处理器所使用的32位ARM指令中，要求32位立即数必须是一个“位图”数据  位图数据：一个任意的8位立即数经过偶数次循环左移得到的数据   在16位Thumb指令集中，可以将任意8位立即数通过左移得到一个32位立即数 满足格式“0x00XY00XY”或“0xXY00XY00”或“0xXYXYXYXY”的数是合法的立即数，其中X和Y为16进制数  6.3.2. 寄存器寻址 寄存器寻址（或称为寄存器直接寻址）就是利用寄存器中的数值作为操作数\n在各类微处理器经常被采用，执行效率高\nADD R0,R1,R2\t;将R1和R2相加结果送入R0\r寄存器仅限于通用寄存器，不可以是PC\n6.3.3. 寄存器间接寻址 寄存器间接寻址就是把寄存器中存放的数值作为操作数，通过这个地址去取得操作数，操作数本身存放在存储器中\nLDR R0, [R1]\r;以寄存器R1的值作为操作数地址，取得操作数后加载到R0\r;常常记为[R1]→R0\rADD R0, R1, [R2]\r;基于寄存器R2间接寻址取得操作数后与R1相加，结果存入R0\r;常常记为R1+[R2]→R0\r6.3.4. 寄存器移位寻址 寄存器移位寻址是ARM指令集特有的寻址方式\n寻址方式为：先由寄存器寻址得到操作数，对该操作数再进行移位操作后得到最终的操作数\nMOV R0, R2, LSL #3\t;R2\u0026lt;\u0026lt;3, → R0\rMOV R0, R2, LSL R1\t;R2\u0026lt;\u0026lt;R1,→ R0\r支持的移位方式：\n LSL：逻辑左移，寄存器中字的低端空出的位补零 LSR：逻辑右移，寄存器中字的高端空出的位补零 ASR：算术右移，移位过程中符号位不变，即如果源操作数是正数，则字的高端空出的位补零，否则补“1” ROR：循环右移，由字的低端移出的位填入字的高端空出的位 RRX：带扩展的循环右移，操作数右移一位，高端空出的位用进位标志C的值来填充，低端移出的位填入进位标志位  6.3.5. 寄存器偏移寻址 寄存器偏移寻址：操作数地址由一个寄存器中存放的数值与指令中给出的地址偏移量相加得到\n寻址过程：将寄存器（基址寄存器）中的基址与指令中给出的地址偏移量相加，得到一个新的地址，通过这个地址取得操作数\n汇编语法：\nopcode Rd [\u0026lt;Rn\u0026gt;,\u0026lt;offset\u0026gt;]\r指令中给出的地址偏移量有三种形式：\n 立即数，偏移量是一个立即数，该数值与基址寄存器相加或相减得到操作数地址 寄存器，偏移量是另外一个寄存器的数值，该数值与基址寄存器中数值相加或相减得到操作数地址 寄存器移位，偏移量是另外一个寄存器中数值经过移位运算得到的数值，并与基址寄存器中数值相加或相减得到操作数地址  LDR：从存储器特定位置读取32比特数值后存入指定的寄存器\nSTR：把指定寄存器的数值保存到存储器的特定位置\n举例：\nLDR R0, [R1, #4]\t;将R1中的值加4形成操作数的地址，取得的操作数送入R0,R1值不变\rLDR R0, [R1, R2]\t;R1中的值加上R2中的值形成操作数地址，取得的操作数送入R0，R1和R2值不变\rSTR R0, [R1, -R2, LSL #4]\t;R1中的数值减去R2中的值x16，形成操作数地址，取得的操作数送入R0，执行后R1和R2的值不变\r采用寄存器偏移寻址的LDR指令的典型汇编语法可存在如下三种形式：\n LDR \u0026lt;Rt\u0026gt;, [\u0026lt;Rn\u0026gt; {,#\u0026lt;imm\u0026gt;}] LDR \u0026lt;Rt\u0026gt;, [\u0026lt;Rn\u0026gt;, \u0026lt;Rm\u0026gt;] LDR \u0026lt;Rt\u0026gt;, [\u0026lt;Rn\u0026gt;, \u0026lt;Rm\u0026gt; {,LSL #\u0026lt;shift\u0026gt;}]  其中，\u0026lt;Rn\u0026gt;表示基址寄存器，而\u0026lt;offset\u0026gt;表示偏移量，偏移量可以是：\n 5位立即数\u0026lt;imm5\u0026gt;或8位立即数\u0026lt;imm8\u0026gt;或12位立即数\u0026lt;imm12\u0026gt; 寄存器值\u0026lt;Rm\u0026gt; 寄存器值移位#\u0026lt;shift\u0026gt;  6.3.6. 前变址寻址 前变址寻址方式：在执行指令的时候自动把基址与偏移加和形成的操作数地址写回到基址寄存器\n前变址：基址寄存器中的数值和立即数偏移量的加和计算发生在寻址前\n汇编语法：\nopcode Rd[\u0026lt;Rn\u0026gt;, \u0026lt;offset\u0026gt;]!\r\u0026ldquo;!\u0026ldquo;后缀表示指令完成时更新存放基地址的基址寄存器（写回）\n举例：\nLDR R0,[R1,#4]\t;将R1中的值加4形成操作数的地址，取得的操作数送入R0，R1不变\rLDR R0,[R1,#4]!\t;与上一条指令的区别：执行后R1=R1+4\rLDR R0,[R1,R2]\t;R1中的值加上R2中的值形成操作数地址，取得的操作数送入R0\rLDR R0,[R1,R2]!\t;与上一条指令的区别：执行后R1=R1+R2\r6.3.7. 后变址寻址 后变址寻址：在执行指令的时候，操作数地址从基址寄存器获取，指令执行后再将操作数地址加上偏移量生成一个新的地址，并将该新地址写入基址寄存器\n后变址：指令中的偏移量在存储器访问期间不会用到，而是在数据传输后更新基址寄存器\n汇编语法：\nopcode Rd [\u0026lt;Rn\u0026gt;],\u0026lt;offset\u0026gt;\r示例：\nLDR R0,[R1,#4]\t;将R1中的值加4形成操作数的地址，取得的操作数送入R0\rLDR R0,[R1,#4]!\t;与上一条指令的区别：“!”表示指令执行后操作数地址存入R1\rLDR R0,[R1],#4\t;R1中的值做操作数地址，取得操作数送入R0，R1=R1+4\r6.3.8. 多寄存器寻址 从一块连续的存储器区域装载多个数据到多个寄存器中\n汇编语法：\nLDM/STM{addr_mode} \u0026lt;Rn\u0026gt;{!},\u0026lt;registers\u0026gt;\r其中，\u0026lt;Rn\u0026gt;为基址寄存器，\u0026lt;registers\u0026gt;为需要载入数据的寄存器集合，可选项{!}表示需要将修改后的地址写入基址寄存器\u0026lt;Rn\u0026gt;。可选后缀{addr_mode}可选择如下四种方式（Cortex-M3/M4只支持IA和DB方式）\n IA（Increment address After each access），每取一个操作数后基址寄存器递增 IB（Increment address Before each access），每取一个操作数前基址寄存器递增 DB（Decrement address Before each access），每取一个操作数前基址寄存器递减 DB（Decrement address After each access），每取一个操作数后基址寄存器递减  LDM：可以从连续的存储区域转载多个数据\nSTM：将一组寄存器中的数值保存到连续的存储器区域\n举例：\nLDMIA R0!,{R1,R2,R3,R4}\t;将连续存储单元的32比特数值传送到R1~R4\rLDMIA R0!,{R1-R4}\t;与上一条指令功能完全相同\rSTMIA R0!,{R1-R7}\t;R1~R7的数保存到R0指向的地址，每取一个数后R0递增4\rSTMIB R0!,{R1-R7}\t;R1~R7的数保存到R0指向的地址，每取一个数前R0递增4\rSTMDA R0!,{R1-R7}\t;R1~R7的数保存到R0指向的地址，每取一个数后R0递减4\rSTMDB R0!,{R1-R7}\t;R1~R7的数保存到R0指向的地址，每取一个数前R0递减4\r6.3.9. 堆栈寻址 如果把前述多寄存器寻址方式中LDM和STM指令中的基址寄存器更换为堆栈指针寄存器SP，并添加{!}（意为每次存/取操作数就更新一下SP），则寻址操作数为堆栈中存放的数值，寻址方式变成堆栈寻址\nLDM：每次取操作数自动POP堆栈中的数据到指定寄存器\nSTM：每次将寄存器中的数自动PUSH到堆栈中\nCortex-M系列处理器支持满递减类型的堆栈，可以使用LDMFD指令从堆栈装载数据，使用STMFD指令保存数据到堆栈（如果堆栈类型是满增、空减或空增，则后缀应该为FA，ED或EA）\n举例：\nSTMFD SP!,{R1-R7}\t;将R1~R7寄存器中的数压入堆栈\rLDMFD SP!,{R1-R7}\t;将堆栈中的数取出存入R1~R7寄存器\r6.3.10. PC相对寻址 PC相对寻址是一种特殊的基址变址寻址，常简称为相对寻址\nPC相对寻址以程序计数器PC寄存器的当前值作为基地址，指令中的地址标号作为偏移量，将两者相加获得操作数的地址\n偏移量的表示方法：\n 汇编语句标号（Label） 存储器代码区数据块（文本池）相对当前代码的位置  示例1：\n用BL指令跳转到“MY_SUB”标号对应的语句执行\nBL MY_SUB\t;相对寻址，跳转到MY_SUB处执行\r...\t;其他指令\rMY_SUB ADD R0,R0,R1\t;转移目标指令\r...\t;其他指令\r示例2：\n用ADR指令获取PC相对寻址结果\nstart MOV R0,#10\t;start是标号\r...\t;其他指令\rADR R2,start\t;将标号为“start”语句的地址送入R2\r示例3：\n利用LDR指令将相对当前代码位置后1-2字节位置的一个字数据（32位）传送到R0寄存器\nLDR R0,[PC,#0xC]\r6.4. Cortex-M3/M4指令集 6.4.1. 处理器内的数据传送指令 实现处理器内部不同电路单元之间的数据传送\n 将数据从一个寄存器送到另外一个寄存器 通用寄存器和特殊功能寄存器之间传送数据 将立即数送到寄存器  \u0026lt;image-20200519185821229.png\u0026rdquo; alt=\u0026ldquo;image-20200519185821229\u0026rdquo; style=\u0026ldquo;zoom:67%;\u0026rdquo; /\u0026gt;\nMOVW：把16位任意立即数传送到目的寄存器的低16位，高16位清0\nMOVT：把16位任意立即数传送到目的寄存器的高16位，低16位不变\n使用MOVW和MOVT指令可以将任意的32位立即数传送到32位寄存器\n 有些汇编器会根据立即数的大小，如果是9-16位，MOV和MOVS会自动转成MOVW  6.4.2. 存储器访问指令 \u0026lt;image-20200519190212972.png\u0026rdquo; alt=\u0026ldquo;image-20200519190212972\u0026rdquo; style=\u0026ldquo;zoom:67%;\u0026rdquo; /\u0026gt;\n有多条Load/Store指令用于存储器访问\n寻址模式：立即数寻址、寄存器寻址、寄存器移位寻址、寄存器间接寻址、基址变址寻址、多寄存器寻址（块拷贝寻址）、堆栈寻址、PC相对寻址\n安全性增强：即使是特权访问等级程序，如果使用非特权的LDRT或者STRT指令，也只能访问非特权访问等级才能访问的区域，否则将引起Fault异常\n排他访问增强\n操作数类型\n操作数类型：\n 无符号：字节（8bits）、半字（16bits）、字（32bits）、双字（64bits）、多字 有符号：字节（8bits）、半字（16bits）、字（32bits）、双字（64bits）  可存储的数据类型：字节、半字、字\n读/写存储器操作支持的数据类型：\n  32-bit指针\n  无符号/有符号的32位整数\n  无符号的16-bit或8-bit整数，需要零扩展\n  有符号的16-bit或8-bit整数，需要符号扩展\n  无符号/有符号的64-bit整数，由2个寄存器保存的多个32-bit数\n  零扩展：在高位补零，如1000 1010 → 0000 0000 1000 1010\n符号扩展：用于保护有符号数的符号位，如\n 0000 1010 → 0000 0000 0000 1010 1000 1010 → 1111 1111 1000 1010  使用LDRSB或LDRSH将一个字节或半字数据加载到32位寄存器，会对被加载数据自动执行符号位扩展，如\n LDRSB R7, 0x83，数据加载前会被转换为0xFFFF FF83 LDRSB R7,0x03，数据加载前会被转换为0x0000 0003  不同的寻址方式——以LDRB为例\n  偏移寻址（Offsetaddressing）模式\nLDRBRd,[Rn,#offset]\r;从存储器位置[Rn]+offset读取字节\r\r  前变址（Pre-indexedaddressing）寻址模式\nLDRBRd,[Rn,#offset]!\r;从[Rn]+offset读取字节，然后更新Rn为Rn+offset\r\r  后变址（Post-indexedaddressing）寻址模式\nLDRBRd,[Rn],#offset\r;读取[Rn]处的字节到Rd，然后更新Rn为Rn+offset\r\r  寄存器移位寻址（Shiftsappliedtoaregister）模式\nLDRBRd,[Rn,Rm,LSL#n)]\r;从存储器位置Rn+(Rm\u0026lt;\u0026lt;n)处读取字节\r\r  多加载和多存储指令\n\u0026lt;image-20200519204621901.png\u0026quot; alt=\u0026ldquo;image-20200519204621901\u0026rdquo; style=\u0026ldquo;zoom: 50%;\u0026rdquo; /\u0026gt;\nARM处理器的一个重要特性，可以读（LDM指令）或者写（STM指令）存储器中的多个连续数据\n Cortex-M3/M4只支持IA和DB两种地址变更方式 只能支持32位传送 EA和FD表示“空递增”和“满递减”两种堆栈类型  堆栈操作\n  对于FD型堆栈，以下两条指令等价（Equivalent）\nPUSH\u0026lt;cond\u0026gt;\u0026lt;q\u0026gt;\u0026lt;registers\u0026gt;\rSTMDB\u0026lt;cond\u0026gt;\u0026lt;q\u0026gt;SP!,\u0026lt;registers\u0026gt;\r\r* 例如：\r```\rPUSH{R0,R4-R6,R8}\r;将R0、R4、R5、R6和R8压入栈中\r```\r  对于FD型堆栈，以下两条指令等价\nPOP\u0026lt;cond\u0026gt;\u0026lt;q\u0026gt;\u0026lt;registers\u0026gt;\rLDMIA\u0026lt;cond\u0026gt;\u0026lt;q\u0026gt;SP!,\u0026lt;registers\u0026gt;\r\r* 例如：\r```\rPOP{R1,R2}\r;将栈中内容存入R1和R2\r```\r  PC相对寻址模式\n如果使用PC寄存器作为基地址，再加上偏移量形成待访问操作数地址。常用于将立即数加载到寄存器中，如前述的文本池（Literal Pool）访问\n\u0026lt;image-20200519210913939.png\u0026quot; alt=\u0026ldquo;image-20200519210913939\u0026rdquo; style=\u0026ldquo;zoom: 50%;\u0026rdquo; /\u0026gt;\n非特权等级加载和存储\nARM中提供了一组特殊的加载和存储指令，在特权访问等级程序中使用这些指令加载或保存的数据，如同非特权访问等级程序的访问效果\n\u0026lt;image-20200519210951907.png\u0026quot; alt=\u0026ldquo;image-20200519210951907\u0026rdquo; style=\u0026ldquo;zoom:67%;\u0026rdquo; /\u0026gt;\n排他式访问\nLDREX Rx,[Ry]\r;排他加载，[Ry]→Rx，同时对Ry指向的内存区域标记独占访问，如果执行时发现已被标记，对指令执行没有影响\rSTRRx,Ry,[Rz]\r;排他存储，Ry→[Rz]，如果成功，则将Rx更新为0；若不成功，则将Rx置1\r\u0026lt;image-20200519211214076.png\u0026quot; alt=\u0026ldquo;image-20200519211214076\u0026rdquo; style=\u0026ldquo;zoom:67%;\u0026rdquo; /\u0026gt;\n6.4.3. 算术运算指令 \u0026lt;image-20200519211528964.png\u0026quot; alt=\u0026ldquo;image-20200519211528964\u0026rdquo; style=\u0026ldquo;zoom: 67%;\u0026rdquo; /\u0026gt;\n 后缀不同，进位方式以及对APSR标志位的影响不一样，对应的二进制机器码也不同 按照传统的Thumb汇编语法，在使用16位Thumb代码时，ADD指令将修改APSR中的标志 32位Thumb-2指令可以修改这些标志，也可以不修改 为区分这两种操作，建议使用统一汇编语言UAL语法，如需更新ASPR标志位，应使用S后缀  ADD R0,R0,R1\t;R0=R0+R1，不修改APSR\rADDS R0,R0,0x12\t;R0=R0+0x12，更新APSR\rADC R0,R1,R2\t;R0=R1+R2+进位，不修改APSR\rCortex-M3/M4都支持具有32位和64位结果的32位乘法指令和乘加（MAC）指令，APSR标志不受这些指令的影响。Cortex-M4处理器还支持额外的快速MAC指令\n\u0026lt;image-20200519211737448.png\u0026quot; alt=\u0026ldquo;image-20200519211737448\u0026rdquo; style=\u0026ldquo;zoom: 50%;\u0026rdquo; /\u0026gt;\n6.4.4. 逻辑运算指令 \u0026lt;image-20200519212527480.png\u0026quot; alt=\u0026ldquo;image-20200519212527480\u0026rdquo; style=\u0026ldquo;zoom: 50%;\u0026rdquo; /\u0026gt;\nBIC（位清除）指令的一般格式：\nBIC{条件}{S} Rd,Rn,Operand2\r 该指令将Rn与Operand2的反码按位相“与”，结果存入Rd，该指令常用于将Rn的某些位清零  例1：BIC R1,R1,#0xF0000000\t;将R1高4位清零 例2：BIC R2,R3,#0x0F;将R3低4位清0结果存入R2   说明：如果使用16位指令，只要2个操作数，目的操作数必须是源操作数之一，而且只能是低位寄存器(R0~R7)  ORN（按位或非）没有16位指令，该指令将源操作数按位取反后，再执行按位进行逻辑或运算\n6.4.5. 移位运算 \u0026lt;image-20200519212737889.png\u0026quot; alt=\u0026ldquo;image-20200519212737889\u0026rdquo; style=\u0026ldquo;zoom:50%;\u0026rdquo; /\u0026gt;\n若使用S后缀，循环和移位指令也会更新APSR中的进位标志位；多位移位运算之后，进位位为最后移出寄存器的哪一位\n只有循环右移而没有循环左移的原因：\n 循环左移可以使用一定次数的循环右移代替 例如，循环左移6位可以使用循环右移26位代替，目的寄存器中的内容相同，执行时间也相同，只是标志位可能不同  除了RRX（包含进位位的循环右移）指令以外，移位与运算指令还有16位版本，但是16位版本只能使用低位寄存器（R0~R7）\n6.4.6. 数据格式转换 符号扩展与无符号扩展\n\u0026lt;image-20200519212930533.png\u0026quot; alt=\u0026ldquo;image-20200519212930533\u0026rdquo; style=\u0026ldquo;zoom: 50%;\u0026rdquo; /\u0026gt;\n  上述指令也有16位和32位两种形式，16位指令只能访问低位寄存器，32位可以访问高位寄存器\n  例：若R0为0x55AA8765，以下指令执行后R1的数值:\nSXTB Rl,R0`;R1=0x00000065，只转换R0中的0x65\rSXTH R1,R0`;R1=0xFFFF8765，只转换R0中的0x8765\rUXTB Rl,R0`;R1=0x00000065，只转换R0中的0x65\rUXTH R1,R0`;R1=0x00008765，只转换R0中的0x8765\r\r  上述指令的32位形式还可以选择在有符号扩展运算之前将Rn循环右移\n\u0026lt;image-20200519213131492.png\u0026quot; alt=\u0026ldquo;image-20200519213131492\u0026rdquo; style=\u0026ldquo;zoom:50%;\u0026rdquo; /\u0026gt;\n数据反转指令：常用于大小端数据转换\n\u0026lt;image-20200519213155423.png\u0026quot; alt=\u0026ldquo;image-20200519213155423\u0026rdquo; style=\u0026ldquo;zoom:50%;\u0026rdquo; /\u0026gt;\n示例：\n\u0026lt;image-20200519213223339.png\u0026quot; alt=\u0026ldquo;image-20200519213223339\u0026rdquo; style=\u0026ldquo;zoom:50%;\u0026rdquo; /\u0026gt;\n  例：假设R0为0x12345678，则有：\nREV R1,R0\t;R1变为0x78563412\rREVH R2,R0\t;R2则会变为0x34127856\rREVSH R3,R0\t;R3则会变为0x0000785684\r\r  6.4.7. 位域处理指令 位域处理指令用于控制类用于\n\u0026lt;image-20200519213959567.png\u0026quot; alt=\u0026ldquo;image-20200519213959567\u0026rdquo; style=\u0026ldquo;zoom:50%;\u0026rdquo; /\u0026gt;\n  BFC（位域清除）指令：清除Rd中位置由\u0026lt;lsb\u0026gt;指定的宽度位\u0026lt;width\u0026gt;的相邻域\n  例：假设R0=0x1234FFFF\nBFC R0,#4,#8\t;执行后R0=0x1234F00F\r\r    BFI（位域插入）指令：将Rn中的1~31位（#width）插入到Rd中由#lsb（最低位）指定的位置\n  例：假设R0=0x24681357，R1=0x89ABCDEF\nBFI R0,R1,#8,#16\t;将R1的[15:0]插入R0[23:8]中\r;执行后R0=0x24CDEF57\r\r    CLZ指令：计算Rn中前导零的个数，结果存入Rd\n 常用于数据归一化处理之前，确定需要移位的位数 如果Rn全为1，Rd=0；若Rn全为0，Rd=32    RBIT（反序）指令：将Rn中的字数根据反序后存入Rd\n  例如：假设R1=0b1100 0011 1010 0101 1011 1101 1000 0001\nRBIT R0,R1\t;R0=0b1000 0001 1011 1101 1010 0101 1100 0011\r\r    SBFX/UBFX指令：将Rn中从#lsb起提取宽度为#width的位域复制到Rd中，并进行符号展开/零展开\n  6.4.8. 比较和测试指令 \u0026lt;image-20200519215511378.png\u0026quot; alt=\u0026ldquo;image-20200519215511378\u0026rdquo; style=\u0026ldquo;zoom:50%;\u0026rdquo; /\u0026gt;\n上述指令运行后将更新APSR而不保存运算结果\n这些指令的后续指令往往是条件跳转和条件执行指令\n6.4.9. 程序流控制指令 包括无条件跳转和函数调用、条件跳转、比较和条件组合跳转、条件执行（IF-THEN）、以及表格跳转等\n6.4.9.1. 无条件跳转和函数调用指令 \u0026lt;image-20200519215727674.png\u0026quot; alt=\u0026ldquo;image-20200519215727674\u0026rdquo; style=\u0026ldquo;zoom:50%;\u0026rdquo; /\u0026gt;\n 更新PC的数据处理指令（如MOV、ADD），或写入PC的加载指令（如LDR、LDM、POP）也可以引起跳转，但不常用 关于函数调用指令的说明  BL和BLX指令将返回地址存入LR（R14）之后，会覆盖LR原来的内容，如果原来LR的内容需要保护，则应在执行函数调用指令之前将LR的内容压栈保存 如果调用的是按照AAPCS（ARM架构过程调用标准）编写的C语言函数，可能还会用到R0~R3和R12寄存器，这些寄存器的内容也需要压栈保存 注意：传统ARM处理器中有一条BLX\u0026lt;label\u0026gt;指令，（不同于Cortex-M3/M4的BLX\u0026lt;Rm\u0026gt;），该指令执行跳转并总是切换状态。由于Cortex-M3/M4只有Thumb状态，所以不支持BLX\u0026lt;label\u0026gt;指令    6.4.9.2. 条件跳转 基于APSR当前的标志位决定是否跳转\n\u0026lt;image-20200519224029807.png\u0026quot; alt=\u0026ldquo;image-20200519224029807\u0026rdquo; style=\u0026ldquo;zoom:50%;\u0026rdquo; /\u0026gt;\ncond为以下14个可能的条件后缀之一\n\u0026lt;image-20200519224050978.png\u0026quot; alt=\u0026ldquo;image-20200519224050978\u0026rdquo; style=\u0026ldquo;zoom:50%;\u0026rdquo; /\u0026gt;\n6.4.9.3. 比较和跳转 ARMv7架构增加了两条比较跳转指令\n\u0026lt;image-20200519224127890.png\u0026quot; alt=\u0026ldquo;image-20200519224127890\u0026rdquo; style=\u0026ldquo;zoom:50%;\u0026rdquo; /\u0026gt;\n说明：相当于CMP和BEQ/BNE的组合。只能向前跳转，不能向后跳转，跳转范围为当前指令后的4~130字节，且只能使用R0~R7，常用于小范围的循环控制，如：\n\u0026lt;image-20200519224301282.png\u0026quot; alt=\u0026ldquo;image-20200519224301282\u0026rdquo; style=\u0026ldquo;zoom:50%;\u0026rdquo; /\u0026gt;\n6.4.9.4. 条件执行 IT指令允许跟随其后的最多四条指令是条件执行的，IT指令后的几条指令被称作一个IT块\nIT指令的汇编语法为：\nIT {x{y{z}}} cond\r cond为IT块中第1条指令使用的条件码 x指定IT块中第2条指令的是否执行的开关 y指定IT块中第3条指令的是否执行的开关 z指定IT块中第4条指令的是否执行的开关  x，y和z对应有两种开关：\n T-Then，条件成立则执行 E-Else，条件不成立则执行  增加不同位数后缀的IT指令（IT+T和E的各种组合）\n 只有1个条件：IT，“If-Then”，以下1条指令条件执行 有2个条件：ITT、ITE，以下2条指令条件执行 有3个条件：ITTT、ITTE、ITET、ITEE，以下3条指令条件执行 有4个条件：ITTTT、ITTTE、ITTET、ITETT、ITTEE、ITEET、ITETE、ITEEE，以下4条指令条件执行  示例：\n  例1\nIT EQ\t;意为“If-Then”，下条指令条件执行\rADDEQ R0,R1,R2\t;若Z=1，则(R1+R2)→R0\r\r  例2\nITETT NE\t;“If-Then-Else-Then-Then”，随后四条指令条件执行\rADDNE R0,R0,R1\t;若Z=0（不等），则（R0+R1）→R0\rADDEQ R0,R0,R3\t;若Z=1，则（R0+R3）→R0\rADDNE R2,R4,#1\t;若Z=0，则（R4+1）→R0\rMOVNE R5,R3\t;若Z=0，R3→R5\r\r  注意：\n 对于多个汇编工具，代码中无需使用IT指令！只要给普通指令增加条件后缀，汇编器（如MS-5以及KeilMDK-ARM）会在前面自动加入IT B指令的二进制编码格式中预留了4比特的条件码，故与一般的条件执行指令（如MOVEQ）不同，不需要与IT指令配合，条件跳转指令也可以执行  6.4.9.5. 按跳转表跳转 跳转表的意义：\n 汇编编程直接实现类似C语言中switch(case)的多分支跳转控制十分困难，因为跳转目标地址与某个变量有关 如果预先定义一个数组（跳转表），每个数组元素是一个目标地址，那么通过改变数组下标，就可以通过数组元素得到不同的目标地址  Cortex-M3/M4支持两条表格跳转指令：\n TBB：按照字节为单位的跳转表进行跳转 TBH：按照半字为单位的跳转表进行跳转  6.4.10. 饱和运算 定点运算中经常遇到运算结果溢出的情况，有上溢和下溢两种\n溢出运算：\n 传统运算方式（环绕式运算）的处理通常是自动回到计数零点 饱和运算：当达到最大值/最小值时不再增加/减少，而是保持在这个最大值/最小值上 只要加、减指令才有饱和方式 例如：在图像和图形处理中，用8位无符号数表示一个象素值或颜色分量值，最大数255表示亮度的最大值，如果运算结果超出这个范围，仍然表示为“最亮”是符合实际情况的  Cortex-M3支持以下两条饱和运算指令：\n SSAT：有符号数饱和运算指令 USAT：无符号数饱和运算指令  \u0026lt;image-20200519230650888.png\u0026quot; alt=\u0026ldquo;image-20200519230650888\u0026rdquo; style=\u0026ldquo;zoom:67%;\u0026rdquo; /\u0026gt;\n 除了以上两条饱和运算指令以外，Cortex-M4还拥有十多条饱和运算指令，其中有些指令还支持SIMD  SSAT和USAT的汇编格式：\nSSAT\u0026lt;Rd\u0026gt;,#\u0026lt;immed\u0026gt;,\u0026lt;Rn\u0026gt;,{,\u0026lt;shift\u0026gt;};有符号饱和\rUSAT\u0026lt;Rd\u0026gt;,#\u0026lt;immed\u0026gt;,\u0026lt;Rn\u0026gt;,{,\u0026lt;shift\u0026gt;};无符号饱和\r 其中：  \u0026lt;Rn\u0026gt;为输入值 \u0026lt;shift\u0026gt;为饱和前可选的移位操作，可为LSL #n或ASR #n \u0026lt;Rn\u0026gt;为目的寄存器 #immed为执行饱和的位的位置   如果运算过程中出现了饱和，ASPR中的Q位置1  示例：\n  例1：如果需要将一个32位有符号数饱和为16位有符号数，可以使用如下指令\nSSAT R1,#16,R0\r\r  例2：如果需要将一个32位有符号数饱和为16位无符号数，可以使用如下指令\nUSAT R2,#16,R0\r\r  当R0为不同数值时，SSAT和USAT指令执行后，R1和R2的值以及Q位如下表所示\n\u0026lt;image-20200519231026494.png\u0026quot; alt=\u0026ldquo;image-20200519231026494\u0026rdquo; style=\u0026ldquo;zoom:50%;\u0026rdquo; /\u0026gt;\n6.4.11. 其他杂项指令 \u0026lt;image-20200519231053285.png\u0026quot; alt=\u0026ldquo;image-20200519231053285\u0026rdquo; style=\u0026ldquo;zoom:50%;\u0026rdquo; /\u0026gt;\n6.4.11.1. 休眠模式指令  WFI指令会使处理器立即进入休眠模式，中断、复位或调试操作可以将处理器从休眠中唤醒 WFE会使处理器有条件地进入休眠。在Cortex-M3/M4处理器内部，有一个只有一位的寄存器会记录事件。若该寄存器置位，WFE指令不会进入休眠而只是清除事件寄存器并继续执行下一条指令；若该寄存器清零，则处理器会进入休眠而且会被事件唤醒，事件可以是中断、调试操作、复位或外部事件输入的脉冲信号 SEV指令可用于发送事件，多处理器系统中可用于向其他处理器传递信号。Cortex-M处理器的接口信号包括一个事件输入和一个事件输出。处理器的事件输入可由多处理器系统中其他处理器的事件输岀产生，因此，处于WFE休眠的处理器可由其他的处理器唤醒  6.4.11.2. 异常相关指令 管理调用（SVC）指令用于产生SVC异常（异常类型为11）。SVC一般用于嵌入式操作系统（OS），其中，非特权应用可以请求使用具有特权OS提供的服务（类似于x86系统中的系统功能调用）\n SVC指令要求SVC的优先级高于当前优先级，并且没有被PRIMASK等寄存器屏蔽 SVC指令格式：SVC #\u0026lt;immed\u0026gt;  其中immed为8位立即数，是OS定义的系统功能调用号   另一个和异常相关的指令是CPS指令，用于改变处理器状态。使用这条指令可以设置或清除PRIMASK和FAULTMASK等中断屏蔽寄存器  6.4.11.3. 空指令和断电指令  Cortex-M支持NOP指令，用于产生指令对齐或延时  注意，NOP指令产生的延时在不同系统间可能会存在差异。若需精确延时，应使用硬件定时器   在软件开发/调试过程中，断点（BKPT:Breakpoint）指令用于实现应用程序中的软件断点  若程序在SRAM中执行，则该指令一般由调试器插入以替换原有的指令 当到达断点时，处理器会被暂停，然后调试器就会恢复原有的指令，用户也可以通过调试器执行调试任务 BKPT指令也可以用于产生调试监控异常，它具有一个8位立即数，调试器或调试监控异常可以将该数据提取出来，并根据该信息确定要执行的动作    6.4.12. Cortex-M4特有指令 与Cortex-M3处理器相比，Cortex-M4支持的指令更多。新增的功能包括：单指令多数据（SIMD）、饱和指令、其他的乘法和MAC（乘累加）指令、打包和解包指令、可选的浮点指令等。这些指令可以让Cortex-M4可以更加高效地进行实时数字信号处理\n 往往对数组的不同元素做相同的运算 循环体内往往是两个操作数相乘之后进行累加 往往操作数动态范围很大，用的是浮点数  7. ARM程序设计 目前基于ARM处理器的程序大多采用C语言开发\n 无操作系统：while语句无限循环体内功能实现+中断 有操作系统：μC/OS、Linux、Android进行任务调度  特定场合下必须使用汇编语言（系统启动程序）\n7.1. ARM程序开发环境 7.1.1. 常用ARM程序开发环境 分类\n 基于Windows平台  SDT(ARM Software Development Kit)是ARM公司最早推出的开发工具 ADS (ARM Developer Suite)由ARM公司约1999年推出，用来代替SDT RealView Developer Suite，是ARM公司继ADS之后推出的集成开发工具 RealViewMDK(Microcontroller Development Kit) ARM Development Studio 5   基于Linux平台  ARM-Linux-GCC   其他分类方法  开源软件，典型如ARM-Linux-GCC 商业软件，ARM公司推出的软件工具    ARM官方提供的软件\n KeilMDK  Software development package for Arm-based microcontrollers   Arm Development Studio  Software development tool suite for any Arm-based project   Compiler  Embedded C/C++ toolchain, from Armv6 M to Armv8-A 64-bit   KeilRTX5  Real-time operating system implementing the CMSIS-RTOS APIv2   Software Test Libraries  Efficient processor specific test suites enabling on-line processor testing   FuSaRTS  Run-time system for embedded functional safety applications    ARM-Linux-GCC\n GNU Compiler Collection（GCC）是一套由GNU开发的编译器集，不仅支持C语言编译，还支持C++、Ada、Object C等许多语言。GCC还支持多种处理器架构，包括X86、ARM、和MIPS等处理器架构，是在Linux平台下被广泛使用的软件开发工具 GNU：是“GNU is Not Unix”的递归缩写，是一个自由软件工程项目。这些软件在GNU通用公共许可的保护下允许任何人免费使用和传播（但必须同时提供源程序），GNU软件许可相当宽松，有很多公司利用GNU软件进行商业活动 ARM-Linux-GCC是基于ARM目标机的交叉编译软件，所谓交叉编译简单来说就是在一个平台上生成另一个平台上的可执行代码  平台实际上包含两个概念：体系结构（Architecture）和操作系统（OS） 同一个体系结构可以运行不同的操作系统；同样，同一个操作系统也可以在不同的体系结构上运行 一个常见的例子是：嵌入式软件开发人员通常在个人计算机上为运行在基于ARM、PowerPC或MIPS的目标机编译软件   ARM-Linux-GCC使用命令行来调用命令执行  相比于RVDS和MDK等IDE而言上手较难。但由于ARM-Linux-GCC不需要授权费用，因而受到使用Linux开发嵌入式系统应用工程师的欢迎    MDK\n MDK由Keil公司推出  Keil公司是一家业界领先的MCU软件开发工具的独立供应商，最流行的单片机开发工具KeilC51就是Keil公司出品的   MDK主要特点：  支持内核：ARM7，ARM9，Cortex-M4/M3/M1，Cortex-R0/R3/R4等ARM微控制器内核，后续可能变化 IDE：μVision IDE 编译器：ARM C/C++编译器(armcc) 仿真器：μVision CPU \u0026amp; Peripheral Simulation 硬件调试单元：ULink/JLink    ARM Development Studio 5（DS-5）\nDS-5是一款支持开发所有ARM内核芯片的IDE，主要特点如下：\n 支持内核：全部 定制的Eclipse IDE 编译器：ARM Compiler 6、ARM Compiler 5、GCC（LinaroGNU GCCCompiler for Linux） 调试器：DS-5调试器支持ETM指令和数据跟踪、PTM程序跟踪 仿真器：DS-5支持ULINK2、ULINKPRO和DSTREAM仿真器  MDK vs DS-5\n 不同的应用领域  MDK可满足开发者基于ARM7/9，ARM Cortex-M处理器的开发需求，包括它自带的RTX实时操作系统和中间库，都是属于MCU应用领域的 DS-5是用于创建Linux/Andriod的复杂嵌入式系统应用和系统平台驱动接口，DS-5支持设备添加，包括多核调试和支持，主要针对复杂的多核调试、片上系统开发而推出的   使用经验  如果需要做MCU应用，推荐用KEILMDK 如果需要做片上系统、Linux/Android驱动和应用开发，推荐使用DS-5+DSTREAM 用户可以根据自己的功能需求、使用习惯（比如很多从单片机开发转到嵌入式开发的开发者更习惯使用MDK）、开发用途等选择不同的开发环境    7.1.2. MDK开发环境简介  MDK-ARM μVision IDE  Keil MDK的软件开发周期\n 创建工程，选择目标芯片，并且做一些必要的工程配置 编写C或者汇编源文件 编译应用程序 修改源程序中的错误 联机调试  μVision集成开发环境\nμVision IDE是一款集编辑、编译和项目管理于一身的基于窗口的软件开发环境\nμVision集成了C语言编译器，宏编译，链接/定位，以及HEX文件产生器。\nμVision特性：\n 功能齐全的源代码编辑器 配置开发工具的设备库 用于创建工程和维护工程的项目管理器 所有的工具配置都采用对话框进行 集成了源码级的仿真调试器，包括高速CPU和外设模拟器 用于往Flash ROM下载应用程序和Flash编程工具 完备的开发工具帮助文档，设备数据表和用户使用向导  ARM仿真器\n仿真器可以替代目标系统中的MCU，仿真其运行。它运行起来和实际的目标处理器一样，但是增加了其它功能，使用户能够通过计算机或其它调试界面来观察MCU中的程序和数据，并控制MCU的运行，它是调试嵌入式软件的一个经济、有效的手段\n具有以下优点：\n 不使用目标系统或CPU资源 硬件断点、跟踪功能 条件触发 实时显示存储器和I/O口内容 硬件性能分析  7.2. ARM汇编程序中的伪指令 在ARM汇编语言程序里，有一些特殊指令助记符，这些助记符与指令系统的助记符不同，没有相对应的操作码，通常称这些特殊指令助记符为伪指令，他们所完成的操作称为伪操作\n伪指令不像机器指令那样在处理器运行期间由机器执行，而是汇编程序对源程序汇编期间由汇编程序处理，包括：定义变量、分配数据存储空间、控制汇编过程、定义程序入口等，这些伪指令仅在汇编过程中起作用，一旦汇编结束，伪指令的使命就完成了\n7.2.1. 符号定义伪指令 符号定义伪指令用于定义ARM汇编程序中的变量、对变量赋值以及定义寄存器的别名等操作。常见的符号定义伪指令有如下几种：\n 用于定义全局变量的GBLA、GBLL和GBLS 用于定义局部变量的LCLA、LCLL和LCLS 用于对变量赋值的SETA、SETL、SETS 为通用寄存器列表定义名称的RLIST  GBLA、GBLL和GBLS\n语法格式：\nGBLA (GBLL或GBLS) 全局变量名;\rGBLA、GBLL和GBLS伪指令用于定义一个ARM程序中的全局变量，并将其初始化\n其中：\n GBLA伪指令用于定义一个全局的数字变量，并初始化为0 GBLL伪指令用于定义一个全局的逻辑变量，并初始化为F（假） GBLS伪指令用于定义一个全局的字符串变量，并初始化为空  以上三条伪指令用于定义全局变量，在整个程序范围内变量名必须唯一\n举例：\nGBLA Test1\t;定义一个全局的数字变量，变量名为Test1\rTest1 SETA 0xaa\t;将该变量赋值为0xaa\rGBLL Test2\t;定义一个全局的逻辑变量，变量名为Test2\rTest2 SETL{TRUE}\t;将该变量赋值为真\rGBLS Test3\t;定义一个全局的字符串变量，变量名为Test3\rTest3 SETS “Testing”;将该变量赋值为“Testing”\rLCLA、LCLL和LCLS\n语法格式：\nLCLA (LCLL或LCLS) 局部变量名;\rLCLA、LCLL和LCLS伪指令用于定义一个ARM程序中的局部变量，并将其初始化\n其中：\n LCLA伪指令用于定义一个局部的数字变量，并初始化为0 LCLL伪指令用于定义一个局部的逻辑变量，并初始化为F（假） LCLS伪指令用于定义一个局部的字符串变量，并初始化为空  以上三条伪指令用于声明局部变量，在其作用范围内变量名必须唯一\n举例：\nLCLA Test4\t;声明一个局部的数字变量，变量名为Test4\rTest3 SETA 0xaa\t;将该变量赋值为0xaa\rLCLL Test5\t;声明一个局部的逻辑变量，变量名为Test5\rTest4 SETL {TRUE}\t;将该变量赋值为真\rLCLS Test6\t;定义一个局部的字符串变量，变量名为Test6\rTest6 SETS “Testing”;将该变量赋值为“Testing”\rSETA、SETL和SETS\n语法格式：\n变量名 SETA (SETL或SETS) 表达式;\r伪指令SETA、SETL、SETS用于给一个已经定义的全局变量或局部变量赋值\n其中：\n SETA伪指令用于给一个数字变量赋值 SETL伪指令用于给一个逻辑变量赋值 SETS伪指令用于给一个字符串变量赋值  其中，变量名为已经被定义过的全局变量或局部变量，表达式为将要赋给变量的值\n举例：\nLCLA Test3\t;声明一个局部的数字变量，变量名为Test3\rTest3 SETA 0xaa\t;将该变量赋值为0xaa\rLCLL Test4\t;声明一个局部的逻辑变量，变量名为Test4\rTest4 SETL{TRUE}\t;将该变量赋值为真\rRLIST\n语法格式：\n名称 RLIST {寄存器列表};\rRLIST伪指令可用于对一个通用寄存器列表定义名称，使用该伪指令定义的名称可在ARM指令LDM/STM中使用。在LDM/STM指令中，列表中的寄存器访问次序为根据寄存器的编号由低到高，而与列表中的寄存器排列次序无关\n举例：\nRegList RLIST {R0-R5,R8,R10};将寄存器列表名称定义为RegList，可在ARM指令LDM/STM中通过该名称访问寄存器列表\r7.2.2. 数据定义伪指令 数据定义伪指令一般用于为特定的数据分配存储单元，同时可完成已存储单元的初始化。常见的数据定义伪指令有如下几种：\n DCB用于分配一段连续的字节存储单元并用指定的数据初始化 DCW（DCWU）用于分配一段连续的半字存储单元并用指定的数据初始化 DCD（DCDU）用于分配一段连续的字存储单元并用指定的数据初始化 DCFD（DCFDU）用于为双精度的浮点数分配一段连续的字存储单元并用指定的数据初始化 DCFS（DCFSU）用于单精度的浮点数分配一段连续的字存储单元并用指定的数据初始化 DCQ（DCQU）用于分配一段以8字节为单位的连续的存储单元并用指定的数据初始化 SPACE用于分配一段连续的存储单元 MAP用于定义一个结构化的内存表首地址 FIELD用于定义一个结构化的内存表的数据域  DCB\n语法格式：\n标号 DCB 表达式;\rDCB伪指令用于分配一段连续的字节（8位）存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为0~255的数字或字符串，DCB也可用“=”代替\n举例：\nStr DCB \u0026quot;This is a test!\u0026quot;\t;分配一段连续的字节存储单元并初始化\rDCW（或DCWU）\n语法格式：\n标号 DCW(或DCWU) 表达式;\rDCW（或DCWU）伪指令用于分配一段连续的半字（16位）存储单元并用伪指令中指定的表达式初始化。其中表达式可以为程序标号或数字表达式\n用DCW分配的字存储单元是半字对齐的，而用DCWU分配的字存储单元并不严格半字对齐\n示例：\nDataTest DCW 1,2,3\t;分配3个连续的半字存储单元并用1，2，3初始化\rDCD（或DCDU）\n语法格式：\n标号 DCD(或DCDU) 表达式;\rDCD(或DCDU)伪指令用于分配一段连续的字（32位）存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为程序标号或数字表达式，DCD也可用“\u0026amp;”代替\n用DCD分配的字存储单元是字对齐的，而用DCDU分配的字存储单元并不严格字对齐\n示例：\nDataTest DCD4,5,6\t;分配3个连续的字存储单元并用4，5，6初始化\rDCFD（或DCFDU）\n语法格式：\n标号 DCFD(或DCFDU) 表达式;\rDCFD(或DCFDU)伪指令用于为双精度的浮点数分配一段连续的字存储单元并用伪指令中指定的表达式初始化，每个双精度的浮点数占据两个字单元\n用DCFD分配的字存储单元是字对齐的，而用DCFDU分配的字存储单元并不严格字对齐\n示例：\nFDataTest DCFD 0.1,0.2,0.3\t;分配3个连续的双字存储单元并初始化为0.1,0.2,0.3的双精度数表达\rDCFS（或DCFSU）\n语法格式：\n标号 DCFS(或DCFSU) 表达式;\rDCFS（或DCFSU）伪指令用于为单精度的浮点数分配一段连续的字存储单元并用伪指令中指定的额表达式初始化，每个单精度的浮点数占据一个字单位\n用DCFS分配的字存储单元是字对齐的，而用DCFSU分配的字存储单元并不严格字对齐\n示例：\nFDataTest DCFS-0.1,-0.2,-0.3 ;分配3个连续的字存储单元并初始化为-0.1，-0.2，-0.3的单精度数表达\rDCQ（或DCQU）\n语法格式：\n标号 DCQ(或DCQU) 表达式;\rDCQ（或DCQU）伪指令用于分配一段以8个字节为单位的连续存储区域并用伪指令中指定的表达式初始化\n用DCQ分配的存储单元是字对齐的，而用DCQU分配的存储单元并不严格字对齐\n示例：\nDataTest DCQ 100,101,102;分配3个连续的双字内存单元，并用100D，101D，102D的16进制数据进行初始化\rSPACE\n语法格式：\n标号 SPACE 表达式;\rSPACE伪指令用于分配一片连续的存储区域并初始化为0，其中，表达式为要分配的字节数，SPACE也可用“%”代替\n示例：\nDataSpace SPACE 100\t;分配连续100字节的存储单元并初始化为0\rMAP\n语法格式：\nMAP 表达式 {,基址寄存器};\rMAP伪指令用于定义一个结构化的内存表的首地址，可以用“^”代替\n表达式可以为程序中的标号或数学表达式，基址寄存器可为可选项，当基址寄存器选项不存在时，表达式的值即为内存表的首地址，当该选项存在时，内存表的首地址为表达式的值与基址寄存器的和\n示例：\nMAP 0x100, R0\t;定义结构化内存表首地址的值为0x100+R0\rFIELD\n语法格式：\n标号 FIELD 表达式;\rFIELD伪指令常与MAP伪指令配合使用来定义结构化的内存表。MAP伪指令定义内存表的首地址，FIELD伪指令定义内存表中的各个数据域，并可以为每个数据域指定一个标号供其他的指令引用\n表达式的值为当前数据域在内存表中所占的字节数\n注意：MAP和FIELD伪指令仅用于定义数据结构，并不实际分配存储单元\n示例：\nMAP 0x100\t;定义结构化内存表首地址的值为0x100\rA FIELD 16\t;定义A的长度为16字节，起始位置为0x100\rB FIELD 32\t;定义B的长度为32字节，起始位置为0x110\rS FIELD 256\t;定义S的长度为256字节，起始位置为0x130\r7.2.3. 汇编控制伪指令 汇编控制伪指令用于控制汇编程序的执行流程，常用的汇编控制伪指令包括：\n IF、ELSE、ENDIF WHILE、WEND MACRO、MEND MEXIT  IF、ELSE、ENDIF\n语法格式：\nIF 逻辑表达式\r指令序列1\rELSE\r指令序列2\rENDIF\rIF、ELSE、ENDIF可嵌套使用\n示例：\nGBLL Test\t;声明一个全局的逻辑变量，变量名为Test\r......\rIF Test=TRUE\r指令序列1\rELSE\r指令序列2\rENDIF\rWHILE、WEND\n语法格式：\nWHILE 逻辑表达式\r指令序列\rWEND\rWHILE和WEND可以嵌套使用\nGBLA Counter\t;声明一个全局的数学变量，变量名为Counter\rCounter SETA 3\t;由变量Counter控制循环次数\r......\rWHILE Counter\u0026lt;10\r指令序列\rWEND\rMACRO、MEND\n语法格式：\nMACRO\r{$标号} 宏名 {$参数1, $参数2,......}\r指令序列\rMEND\rMACRO、MEND伪指令可以将一段代码定义为一个整体，两条指令称为宏指令，需要时可以在程序中通过宏指令多次调用这段代码\n其中，$标号在宏指令被展开时会被替换成用户定义的符号。宏指令可以使用一个或多个参数，当宏指令被展开时，这些参数被相应的值替换\n包含在MACRO和MEND之间的指令序列称为宏定义体，在宏定义体的第一行应声明宏的原型（包含宏名、所需的参数），然后就可以在汇编程序中通过宏名来调用该指令序列。在源程序被编译时，汇编器将宏调用展开，用宏定义中的指令序列代替程序中的宏调用，并将实际参数的值传递给宏定义中的形式参数\n宏指令的使用方式和功能与子程序有些香相似，子程序可以提供模块化的程序设计、节省存储空间并提高运行速度。但在使用子程序结构时需要保护现场，从而增加了系统开销。因此，在代码较短且需要传递的参数较多时，可以使用宏指令代替子程序\nMACRO、MEND伪指令可嵌套使用\n示例：\n MACRO\t;宏指令开始\r$label test $p1,$p2,$p3\t;宏的名称为test，有三个参数p1,p2,p3\r;宏的标号$label可用于构造宏定义体内的其他标号名称\rCMP $p1,$p2\t;比较参数p1和p2的大小\rBHI $label.save\t;无符号比较后若p1\u0026gt;p2，跳转到$label.save标号处，\r;$label.save为宏定义体的内部符号\rMOV $p3,$p2\rB $label.end\r$label.save MOV $p3,$p1\r$label.end\t;宏定义功能即将参数p1,p2无符号比较后的大值存入参数p3\rMEND\t;宏定义结束\r上述代码中，宏名为test，标号为$label，有三个参数$p1，$p2，$p3。标号和参数在实际调用中可根据需要替换成不同的符号，而宏名是唯一确定的\n调用上述宏的方法：\nabc test R0,R1,R2\t;通过宏的名称test调用宏，宏的标号为abc\r;三个参数为寄存器R0,R1,R2\r汇编处理宏时会展开还原成一段代码，结果如下：\nCMP R0,R1\rBHI abc.save\rMOV R2,R1\rB abc.end\rabc.save MOV R2,R0\rabc.end\r......\r采用宏定义的方法可以用一条语句代替一大段指令序列，提高编程效率\nMEXIT\n语法格式：\nMACRO\t;宏定义开始\r{$标号} 宏名 {$参数1,$参数2,......}\r指令序列;\rIF condition1\rMEXIT\rELSE\r指令序列;\rENDIF\r...\rMEND\r7.2.4. 其他常用的伪指令 AREA\n语法格式：\nAREA 段名 属性1,属性2,......\rAREA伪指令用于定义一个代码段或数据段，段名若以数字开头，则该段名需用“|”括起来，如|1_test|\n属性字段表示该代码段（或数据段）的相关属性，多个属性用逗号分隔。常用属性如：\n CODE属性：用于定义代码段，默认为READONLY DATA属性：用于定义数据段，默认READWRITE READONLY属性：指定本段为只读，代码段默认为READONLY READWRITE属性：指定本段为可读可写，数据段默认为READWRITE ALIGN属性：使用方式为ALIGN COMMON属性：该属性定义了一个通用的段，不包含任何的用户代码和数据。各个源文件中同名的COMMON段共享一段存储单元。一个汇编语言的程序至少要包含一个段，当程序太长时，也可以将程序分为多个代码段和数据段  示例：\nAREA RESET,CODE,READONLY\r...\r;该伪指令定义了一个代码段，段名为RESET，属性为只读\rALIGN\n语法格式：\nALIGN{表达式{,偏移量}};\rALIGN伪指令可以通过添加填充字节的方式，使当前位置满足一定的对齐方式\n表达式的值用于指定对齐方式，可能取值为2的幂，如1，2，4，8，16等。若未指定表达式，则将当前位置对齐到下一个字的位置\n偏移量也为一个数字表达式，若使用该字段，假设N=表达式，则当前位置的对齐方式为：2^N^+偏移量\n示例：\nAREA RESET,CODE,READONLY,ALIGN=3\t;指定后面的指令为8字节对齐\r......\rEND\rCODE16、CODE32\n语法格式：\nCODE16(或CODE32);\r CODE16：伪指令通知编译器，其后的指令序列为16位的Thumb指令 CODE32：伪指令通知编译器，其后的指令序列为32位的ARM指令  若在汇编源程序中同时包含有ARM指令和Thumb指令，可用CODE16伪指令通知编译器其后的指令序列为16位的Thumb指令，CODE32伪指令通知编译器其后的指令序列位32位的ARM指令\n在使用ARM指令和Thumb指令混合编程的代码中，可用这两条伪指令进行切换，注意他们只通知编译器其后指令的类型，并不能对处理器的状态进行切换\n示例：\nAREA RESET,CODE,READONLY\r......\rCODE32\t;通知编译器其后的指令为32位的ARM指令\rLDR R0,=NEXT+1\t;将跳转地址放入寄存器R0\rBX R0\t;程序跳转到新的位置执行，并将处理器切换到Thumb工作状态\r......\rCODE16\t;通知编译器其后的指令为16位的Thumb指令\rNEXT LDR R3,=0x3FF\r......\rEND\t;程序结束\rENTRY\n语法格式：\nENTRY;\rENTRY伪指令用于指定汇编程序的入口点。在一个完整的汇编程序中至少要有一个ENTRY，但在一个源文件里最多只能有一个ENTRY\n示例：\nAREA RESET,CODE,READONLY\rENTRY\t; 指定应用程序的入口点\r......\rEND\n语法格式：\nEND;\rEND伪指令用于通知编译器已经到达源程序的结尾\n示例：\nAREA RESET,CODE,READONLY\r......\rEND\t;指定应用程序的结尾\rEQU\n语法格式：\n名称 EQU 表达式{,类型};\rEQU伪指令用于为程序中的常量、标号等一个等效的字符名称，类似于C语言中的#define。其中EQU可用“*”代替\n示例：\nTest EQU 50\t;定义标号Test的值为50\rEXPORT（或GLOBAL）\n语法结构：\nEXPORT 标号 {[WEAK]};\rEXPORT伪指令用于在程序中声明一个全局的标号，该标号可在其他文件中引用。EXPORT可用GLOBAL代替。标号在程序中区分大小写，[WEAK]选项声明其他的同名标号优先于该标号被引用\n示例：\nAREA RESET,CODE,READONLY\rEXPORT Stest\t;声明一个全局的标号Stest\r.....\rEND\rIMPORT\n语法格式：\nIMPORT 标号 {[WEAK]};\rIMPORT伪指令用于通知编译器要使用的标号在其他源文件中的定义，但要在当前源文件中引用，而且无论当前源文件是否引用该标号，该标号均会被加入到当前源文件的符号表中\n标号在程序中区分大小写，[WEAK]选项表示当所有的源文件都没有定义这样一个标号时，编译器也不给出错误信息，在多数情况下将该标号置为0，若该标号被B或BL指令引用，则将B或BL指令置为NOP操作\n示例：\nAREA RESET,CODE,READONLY\rIMPORT MAIN\t;通知编译器当前文件要引用标号MAIN，但MAIN在其他源文件中定义\r......\rEND\rEXTERN\n语法格式：\nEXTERN 标号 {[WEAK]};\rEXTERN伪指令用于通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用。如果当前源文件实际并未引用该标号，该标号就不会被加入到当前源文件的符号表中\n示例：\nAREA RESET,CODE,READONLY\rEXTERN Main\t;通知编译器当前文件要引用标号Main，但Main在其他源文件中定义\r......\rEND\rGET（或INCLUDE）\n语法格式：\nGET 文件名;\rGET伪指令用于将一个源文件包含在当前的源文件中，并将被包含的源文件在当前位置进行汇编处理。可以使用INCLUDE代替GET\n汇编程序中常用的方法是在某源文件中定义一些宏指令，用EQU定义常量的符号名称，用MAP和FIELD定义结构化的数据类型，然后用GET伪指令将这个源文件包含到其他的源文件中。使用方法与C语言中的“INCLUDE”相似\nGET伪指令只能用于包含源文件，包含目标文件需要使用INCLUDE伪指令\n示例：\nAREA RESET,CODE,READONLY\rGET a1.s\t;通知编译器当前源文件包含当前目录下的a1.s文件\rGET C:/a2.s\t;通知编译器当前源文件包含C盘根目录下的a2.s文件\r......\rEND\rINCBIN\n语法格式：\nINCBIN 文件名;\rINCBIN伪指令用于将一个目标文件或数据文件包含到当前的源文件中，被包含的文件不作任何变动的存放到当前文件中，编译器不对文件内容进行编译，编译器从其后开始继续处理\n示例：\nAREA RESET,CODE,READONLY\rGET a1.s\rINCBIN a1.dat\t;通知编译器当前源文件包含a1.dat\rINCBIN C:/a2.txt\t;通知编译器当前源文件包含C盘根目录下文件a2.txt\r......\rEND\rRN\n语法格式：\n名称 RN 表达式;\rRN伪代码用于给一个寄存器定义一个别名\n其中，名称为给寄存器定义的别名，表达式为寄存器的编码\nTemp RN R0\t;将R0定义一个别名Temp\rROUT\n语法格式：\n{名称} ROUT\rROUT伪指令用于给一个局部变量定义作用范围\n在程序中未使用该伪指令时，局部变量的作用范围为所在的AREA，而使用ROUT后，局部变量的作用范围为当前ROUT和下一个ROUT之间\n7.2.5. 汇编语言中常用的符号 汇编语言程序设计的符号定义应遵循的约定：\n 符号区分大小写，同名的大、小写符号会被编译器认为是两个不同的符号 符号在其作用范围内必须唯一 自定义的符号不能与系统的保留字相同 符号名不应与指令或伪指令同名  程序中的变量\n程序中的变量是指其值在程序的运行过程中可以改变的量。ARM（Thumb）汇编程序所支持的变量有数字变量、逻辑变量和字符串变量。\n数字变量用于在程序的运行中保存数字值，但注意数字值的大小不应超出数字变量所能表示的范围。\n逻辑变量用于在程序的运行中保存逻辑值，逻辑值只有两种取值情况：真或假。\n字符串变量用于在程序的运行中保存一个字符串，但注意字符串的长度不应超出字符串变量所能表示的范围\n在ARM汇编语言程序设计中，可以使用GBLA、GBLL、BGLS伪指令声明全局变量，使用LCLA、LCLL、LCLS伪指令声明局部变量，并可使用SETA、SETL、SETS进行初始化\n示例：\nLCLS S1\t;\rLCLS S2\t;定义局部字符串变量S1和S2\rS1 SETS \u0026quot;Test!\u0026quot;\t;字符串变量S1的值为\u0026quot;Test!\u0026quot;\rS2 SETS \u0026quot;Hello!\u0026quot;;字符串变量S2的值为\u0026quot;Hello!\u0026quot;\r程序中的常量\n程序中的常量是指其值在程序的运行过程中不能被改变的量。ARM（Thumb）汇编程序所支持的常量有数字常量、逻辑常量和字符串常量\n数字常量一般为32位的整数，当作为无符号数时，其取值范围为0~2^32^-1，当作为有符号数时，其取值范围为-2^31^~2^32^-1\n逻辑常量只有两种取值情况：真或假\n字符串常量为一个固定的字符串，一般用于程序运行时的信息提示\n示例：\nNUM EQU 64\rabcd EQU 2\t;定义abcd符号的值为2\rabcd EQU label+16\t;定义abcd符号的值为(label+16)\rabcd EQU 0x1c,CODE32\t;定义abcd的符号的值为绝对地址值0x1c，而且此处为ARM32指令\r对比：EQU指令 vs “=”\n 使用EQU伪指令定义的符号名不能与其他符号名重合，符号名必须唯一，且不能被重新定义；而使用等号伪指令“=”定义的符号名可以重名，可以被重新定义，可被重新赋值 使用EQU伪指令定义的符号名不仅可以代表某个常数或常数表达式，还可以代表字符串、关键字、指令码、一串符号（如：WORD、，PTR），等等；而使用等号伪指令“=”定义的符号名仅仅用于代表数值表达式  程序中的变量代换\n程序中的变量可以通过代换操作取得一个常量。代换操作符为\u0026quot;$\u0026quot;\n如果在数字变量前面有一个代换操作符“$”，编译器会自动将该数字的值转换为十六进制的字符串，并将十六进制的字符串代换“$”后的数字变量\n如果在逻辑变量前面有一个代换操作符\u0026quot;$\u0026quot;，编译器会将该逻辑变量代换为它的取值（真或假）\n如果在字符串变量前面有一个代换操作符“$”，编译器会将该字符串变量的值代换“$”后的字符串变量\n示例：\nLCLS S1\t;定义局部字符串变量S1和S2\rLCLS S2\rS1 SETS \u0026quot;Test!\u0026quot;\rS2 SETS \u0026quot;This is a $S1\u0026quot;\t;字符串变量S2的值为\u0026quot;This is a Test!\u0026quot;\r7.2.6. 汇编语言中常用运算符和表达式 运算次序与优先级：\n 优先级相同的双目运算符的运算顺序为从左到右 相邻的单目运算符的运算顺序为从右到左，且单目运算符的优先级高于其他运算符 括号运算符的优先级最高  数学表达式及运算符\n   运算符 用法 作用     + X+Y X与Y的和   - X-Y X与Y的差   x XxY X与Y的乘积   / X/Y X除以Y的商   MOD X:MOD:Y X除以Y的余数   ROL X:ROL:Y 将X循环左移Y位   ROR X:ROR:Y 将X循环右移Y位   SHL X:SHL:Y 将X左移Y位   SHR X:SHR:Y 将X右移Y位   AND X:AND:Y 将X和Y按位作逻辑与的操作   OR X:OR:Y 将X和Y按位作逻辑或的操作   NOT :NOT:Y 将Y按位作逻辑非的操作   EOR X:EOR:Y 将X和Y按位作逻辑异或的操作    逻辑表达式及运算符\n   运算符 用法 作用     = X=Y X等于Y   \u0026gt; X\u0026gt;Y X大于Y   \u0026lt; X\u0026lt;Y X小于Y   `\u0026gt;=` X\u0026gt;=Y X大于等于Y   `\u0026lt;=` X\u0026lt;=Y X小于等于Y   /= X/=Y X不等于Y   \u0026lt;\u0026gt; X\u0026lt;\u0026gt;Y X不等于Y   LAND X:LAND:Y 将X和Y作逻辑与操作   LOR X:LOR:Y 将X和Y作逻辑或操作   LNOT :LNOT:Y 将Y作逻辑非操作   LEOR X:LEOR:Y 将X和Y作逻辑异或操作    字符串表达式及运算符\n   运算符 用法 作用     LEN :LEN:X 返回字符串长度   CHR :CHR:M 将0~255之间的整数转换为一个字符   STR :STR:X 将一个数字表达式或逻辑表达式转换为一个字符串   LEFT X:LEFT:Y 返回某个字符串左端的一个字串   RIGHT X:RIGHT:Y 返回某个字符串右端的一个字串   CC X:CC:Y 用于将两个字符串连接成一个字符串    与寄存器和程序计数器PC相关的表达式及运算符\n   运算符 用法 作用     BASE :BASE:X 返回基于寄存器的表达式中寄存器的编号   INDEX :INDEX:X 返回基于寄存器的表达式中相对于其基址寄存器的偏移量    其他运算符\n   运算符 用法 作用     ? ?X 返回某代码行所生成的可执行代码的长度   DEF :DEF:X 判断是否定义某个符号    7.3. ARM汇编语言程序设计 7.3.1. ARM汇编语言的语句格式 RM汇编中语句中所有标号必须在一行的顶格书写，其后面不要添加“:”，而所有指令均不能顶格书写。ARM汇编器对标识符大小写敏感，书写标号及指令时字母大小写要一致，在ARM汇编程序中，一个ARM指令、伪指令、寄存器名可以全部为大写字母，也可以全部为小写字母，但不要大小写混合使用\nARM汇编语句的格式如下：\n[LABEL] OPERATION [OPERAND] [;COMMENT]\r;标号域 ;操作助记符域 ;操作数域 ;注释域\r 标号域  标号域用来表示指令的地址、变量、过程名、数据的地址和常量 标号是可以自己起名的标识符，语句标号可以是大小写字母混合，通常以字母开头，由字母、数字、下划线等组成 语句标号不能与寄存器名、指令助记符、伪指令(操作)助记符、变量名同名 ARM汇编规范规定：语句标号必须在一行的开头书写，不能留空格；指令则在行开头必须要留出空格   操作助记符域  操作助记符域可以为指令、伪操作、宏指令或伪指令的助记符。 ARM汇编器对大小写敏感，在汇编语言程序设计中，每一条指令的助记符可以全部用大写、或全部用小写，但不允许在一条指令中大、小写混用。 所有的指令都不能在行的开头书写，必须在指令的前面有空格，然后再书写指令 指令助记符和后面的操作数或操作寄存器之间必须有空格，不可以在这之间使用逗号   操作数域  操作数域表示操作的对象，操作数可以是常量、变量、标号、寄存器名或表达式，不同对象之间必须用逗号“,”分开    7.3.2. ARM汇编语言程序结构 在ARM（Thumb）汇编语言程序中，通常以段为单位来组织代码段是具有特定名称且功能相对独立的指令或数据序列根据段的内容，分为代码段和数据段\n一个汇编程序至少应该有一个代码段，当程序较长时，可以分割为多个代码段和数据段\n一个汇编语言程序段的基本结构如下所示：\nAREA Buf, DATA, READWRITE\t;定义一个可读写属性的数据段\rNum DCD 0x11\rNums DCD 0x22\t;分配一片连续存储单元并初始化\r;本节及下节所有汇编代码程序都是利用MDKIDE编写，Device设置为STM32F407ZG，\r;代码段放在IROM中起始地址为0x08000000，数据段放在IRAM中起始地址为0x20000000\rAREA RESET，CODE，READONLY\t;只读的代码段，RESET为段名\rENTRY\t;程序入口点\rSTART LDR R0，= Num\t;取Num地址赋给R0\rLDRR1，[R0] ;取Num中内容赋给R1\rADD R1，#0x9A; R1=R1+0x9A\tSTR R1，[R0] ;R1内容赋给Num单元\rLDR R0，= Nums\t;......\rLDR R2，[R0]\rADD R2，#0xAB\rSTR R2，[R0]\rLOOP B LOOP ;无限循环反复执行\rEND\t;段结束\r7.3.3. ARM汇编程序设计实例 顺序结构\n顺序结构是一种最简单的程序结构，这种程序按指令排列的先后顺序逐条执行\n示例：对数据段中数据进行寻址操作\n\tAREA BUF,DATA,READWRITE\t;定义数据段Buf\rArray DCB 0x11,0x22,0x33,0x44\rDCB 0x55,0x66,0x77,0x88\rDCB 0x00,0x00,0x00,0x00\t;定义12个字节的数组Array\rAREA RESET,CODE,READONLY\rENTfRY\rLDR R0,=Array\t;取得数组Array首地址\rLDR R2,[R0]\t;从数组第1字节取32位数据给R2即R2=0x44332211\rMOV R1,#1\t;R1=1\rLDR R3,[R0,R1,LSL#2]\t;将存储器地址为R0+R1x4的32位数据读入寄存器R3,\r;R3=0x88776655\rLOOP B LOOP\rEND\r分支结构\n一般情况下，程序按指令的先后顺序逐条执行，但经常要求程序根据不同条件选择不同的处理方法，利用条件指令或条件转移指令根据当前CPSR中的状态标志值选择路径，使用带有条件码的指令实现的分支程序段\n分支结构中经常使用的条件码助记后缀：\n HI：无符号数大于 LS：无符号数小于或等于 GT：带符号数大于 LE：带符号数小于或等于  例如寄存器中R0和R1分别保存两个数，如果R0小于R1，将R1值传给R0，实现代码如下：\nCMP R0,R1\t;比较R0和R1\rMOVLT R0,R1\t;MOVLT=MOV+LT LT是有符号数比较小于\r分支结构的几种实现方法：\n  利用条件码可以很方便地实现IF ELSE分支结构地程序\nMOV R0，#76\t;初始化R0的值\rMOV R1，#88\t;初始化R1的值\rCMP R0，R1\t;判断R0\u0026gt;R1？\rMOVHI R2，#100\t;R0\u0026gt;R1时，R2=100\rMOVLS R2，#50\t;R0\u0026lt;=R1时，R2=50\r......\r`\n  B（Branch）条件转移及衍生指令实现分支结构\n  B指令\n  格式：\nB(条件)+目标地址\r\r  用法：B指令是最简单的跳转指令，一旦遇到一个B指令，ARM处理器将立即跳转到给定的目标地址，从那里继续执行\n  示例：\nB Label\t;程序无条件跳转到标号Label处执行\r\r  示例：\nCMP R1, #0\rBEQ Label\t;当CPSR寄存器中Z条件码置位时，程序跳转到标号Label处执行\r......\r\r    BL指令\n  格式：\nBL{条件}+目标地址\r\r  用法：BL是一个跳转指令，但跳转之前，会在寄存器R14中保存PC当前的内容。因此，可以通过将R14的内容重新加载到PC中，来返回到跳转指令之后的那个指令处执行。这个指令是实现子函数调用的一个基本且常用的手段\nBL Label ;让程序无条件跳转到标号是Label处执行，同时将当前的PC值保存到R14（LR）中。\r\r  BL实现子函数调用时完成如下的三个操作：\n 将子程序的返回地址（当前PC）保存在R14（LR）中 将PC指向子程序的入口即跳转（也即BL后面的目标指令） 子程序执行完毕之后需要返回时，只需将R14中的LR赋给PC    使用BL调用子程序后，通常在子程序的尾部添加MOV PC，LR来返回\n      循环结构\n循环结构可以减少源程序重复书写的工作量，用来描述重复执行某段算法的问题，这是程序设计中最能发挥计算机特长的程序结构\n  for循环结构实现\nC语言形式：\nfor(int i=0;i\u0026lt;1-;i++)\rx++;\r`\nARM汇编语言形式：R0为x，R2为i，均为无符号整数\nMOV R0,#0\t;初始化R0=0\rMOV R2,#0\t;初始化R2=0\rLOOP CMP R2,#0\t;判断R2\u0026lt;10?\rBCS FOR_E\t;若条件失败（即R\u0026gt;=10）,退出循环\rADD R0,R0,#1\t;执行循环体，R0=R0+1,即x++\rADD R2,R2,#1\t;R2=R2+1,即i++\rB LOOP\rFOR_E......\r`\n  while循环结构实现\nC语言形式：\nwhile(x\u0026lt;=y)\rx*=2;\r`\nARM汇编语言形式：x为R0，y为R1，均为无符号整数\n MOV R0,#1\t;初始化R0=1\rMOV R1,#20\t;初始化R1=20\rW1 CMP R0,R1\t;判断R0\u0026lt;=R1,即x\u0026lt;=y\rMOVLS R0,R0,LSL#1\t;循环体，R0*=2\rBLS W1\t;若R0\u0026lt;=R1，继续循环体\rW_END\r`\n  子程序调用与返回\n在ARM汇编语言中，子程序的调用一般是通过BL指令来完成的\nBL指令的语法格式如下：\nBL SUB\rSUB是被调用的子程序的名称\nBL指令完成2个操作，即将子程序的返回地址放在LR寄存器中，同时将PC寄存器指向子程序的入口点，当子程序执行完毕需要返回主程序时，只需将存放在LR中的返回地址重新赋给指令指针寄存器PC即可。通过调用子程序，能够完成参数的传递和从子程序返回运算的结构（通常使用寄存器R0-R3来完成）\nBL调用子程序的经典用法如下：\n\tBL NEXT\t;跳转NEXT\r......\rNEXT\r......\rMOV PC, LR\t;从子程序返回\r当子程序需要使用的寄存器与主程序使用的寄存器发生冲突（即子程序与主程序都要使用同一组寄存器时），为了防止主程序这些寄存器中的有用数据丢失，在子程序的开始应该把这些寄存器数据压入堆栈以保护现场，在子程序返回之前需要把保护到堆栈的数据自堆栈中弹出以恢复现场\n  保存和恢复数据可以用PUSH/POP指令实现，PUSH{R4，LR}将寄存器R4入栈，LR也入栈。POP{R4，PC}将堆栈中的数据弹出到寄存器R4及PC中\n  如果需要保存数据较多即需要入栈和出栈多个寄存器时，可以用PUSH{R0-R7，LR}将寄存器R0-R7全部入栈，LR也入栈；POP{R0-R7，PC}将堆栈中的数据弹出到寄存器R0-R7及PC中\n  ARM汇编指令中还有与PUSH/POP功能类似的压栈和出栈指令：STMFD SP!,{R0-R7,LR};功能是满递减入栈，将寄存器R0-R7、LR压栈，SP不断减4，执行后SP=SP-9*4[SP]=R0，[SP+4]=R1，\u0026hellip;.，[SP+4*8]=LR\n    LDMFD SP!,{R0-R7,PC};满递减出栈，给寄存器R0-R9出栈，并使程序跳转回函数的调用点，SP不断增4；同理，LDMFD是STMFD的逆操作，[SP]-\u0026gt;R0，[SP+4]-\u0026gt;R1，\u0026hellip;，[SP+4*8]-\u0026gt;PCSP=SP+4*9\n  注意：BLSUB\u0026hellip;MOVPC，LR这种调用子程序结构在一些情况下是会出现问题的，例如当出现子程序嵌套调用时，LR寄存器中内容在第二次子程序调用时会被覆盖，如果仍使用常用调用方式会出现无法返回现场的问题，这个时候使用STMFD/LDMFD指令可以有效避免LR被覆盖而出现错误\n示例：\nAREA RESET,CODE,READONLY\rENTRY\rSTART LDR SP,=0x20000460\rMOV R0,#0x03\rMOV R1,#0x04\rMOV R7,#0x07\rBL POW\rLOOP\tB LOOP\rPOW\tSTMFD SP!, {R0-R7,LR}\tMOVS R2,R1\rMOVEQ\tR0,#1\rBEQ\tPOW_END\rMOV R1,R0\rSUB\tR2,R2,#1\rPOW_L1\tBL\tDO_MUL\t;子程序调用嵌套,这个时候如果不用指令会出现LR覆盖，FD/LDMF,影响子程序调用返回\rSUBS\tR2,R2,#1\rBNE\tPOW_L1\rPOW_END\tLDMFD SP!,{R0-R7,PC}\rDO_MUL\tMUL\tR0,R1,R0\rMOV\tPC.LR\rEND\r7.4. ARM汇编语言与C/C++的混合编程 7.4.1. C语言与汇编语言之间的函数调用 ATPCS概述\n 为了使单独编译的C语言程序和汇编程序之间能够相互调用，必须为子程序之间的调用制定一定的规则。ATPCS就是ARM程序和Thumb程序中子程序调用的基本规则 ATPCS（ARM-ThumbProcedureCallStandard，基于ARM指令集和Thumb指令集过程调用规则）规定了一些不同语言撰写的函数之间相互调用（mixcalls）的基本规则，这些基本规则包括子程序调用过程中寄存器的使用规则、数据栈的使用规则、以及参数的传递规则 TPCS规定了在子程序调用时的一些基本规则，主要包括以下3方面的内容：  各寄存器的使用规则及其相应的名字； 数据栈的使用规则（FD）； 参数传递的规则；  当参数个数不超过4个时，可以使用寄存器R0~R3来传递参数，如果参数多于4个，则将剩余的字数据通过堆栈传递，入栈顺序与参数传递顺序相反，即最后一个字数据先入栈，第一个字数据最后入栈      C程序调用汇编函数实例\nARM编译器使用的函数调用规则就是ATPCS标准，也是设计可被C程序调用的汇编函数的编写规则。为了保证程序调用时参数传递正确，C程序调用的汇编函数时必须严格按照ATPCS规则\n如果汇编函数和调用函数的C程序不在同一个文件中，则需要在汇编语言中用EXPORT声明汇编语言起始处的标号为外部可引用符号，该标号应该为C语言中所调用函数的名称\n例：调用汇编函数，实现把字符串srcstr复制到dsstr中\n//main.c\rextern void strcopy(char*d,char*s);//需要调用的汇编函数原型并加extern关键字\rint main()\r{\rchar* srcstr=\u0026quot;0123456\u0026quot;;\rchardststr[]=\u0026quot;abcdefg\u0026quot;;\rstrcopy(dststr,srcstr);\rreturn 0;\r}\r汇编语言源程序Scopy.s，汇编文件和*.c文件在同一工程中\nAREA Scopy,CODE,READONLY\rEXPORTstrcopy\rstrcopy;必须与EXPORT后面标号一致\rLOOP LDRB R2,[R1],#1;R1指向源地址\rSTRB R2,[R0],#1;R0指向目标地址\rCMP R2,#0\rBNE LOOP;先执行后判断，源字符串的终止符‘\\0’\r;也复制到目的字符串\rMOV PC,LR\rEND\r汇编程序调用C函数实例\n在汇编程序中调用C语言函数，需要在汇编程序中利用IMPORT说明对应的C函数名，按照ATPCS的规则保存参数。完成各项准备工作后利用跳转指令跳转到C函数入口处开始执行。跳转指令后所跟标号为C函数的函数名\n例：汇编程序中调用C函数实现求5个整数相加的和；test.s，工程设置为基于汇编的工程，不需要从main函数启动，代码段名称必须设为RESET\nPRESERVE8\rAREA RESET,CODE,READONLY\rENTRY\rIMPORT CAL;\rLDR SP,=0x20000460;设置堆栈指针\rMOV R0，#1;R0=1\rADD R1，R0，R0;R1=2\rADD R2，R1，R0;R2=3\rADD R3，R0，R2;R3=4\rADD R4，R0，R3;R4=5\rSTR R4，[SP，#-4]!\rBL CAL LDR R4,=0x20000000;结果R0存入内存单元\rSTR R0,[R4]\rEND\r//C源程序example.c和汇编文件在同一个工程中\rint CAL(int a, int b, int c, int d, int e)\r{\rreturn (a+b+c+d+e);\r}\r7.4.2. C/C++语言与汇编语言的混合编程 嵌入式系统开发中，目前使用的主要编程语言是C和汇编，C++已经有相应的编译器，但是现在使用还是比较少的。在稍大规模的嵌入式软件中，大部分的代码都是用C编写的\nC语言中使用内嵌汇编代码，可以在C/C++程序中实现C/C++不能完成的一些操作，同时程序的代码效率也会更高\n在C语言程序中嵌入汇编指令\n如果要在C程序中嵌入汇编有两种方法：内联汇编和内嵌汇编。嵌入汇编使用的标记是__asm或者asm关键字，用法如下：\n__asm\r{\rinstruction [;instruction]\r...\r[instruction]\r}\rasm(“instruction[;instruction]”);\r  内联汇编的示例代码如下：\nint Add(int i)\r{\rint R0;\r__asm\r{\rADD R0,i,1\rEOR i,R0,i\r}\rreturn i;\r}\r`\n  内嵌汇编的示例代码如下：\n#include\u0026lt;stdio.h\u0026gt;\r__asm void my_strcpy(const char*src,char*dst)\r{\rLOOP LDRB R2,[R0],#1;R0保存第一个参数\rSTRB R2,[R1],#1;R1保存第二个参数\rCMP R2,#0\rBNE LOOP BLX LR;返回指令须要手动加入\r}\r`\nint main(void)//主程序\r{\rconstchar*a=\u0026quot;Helloworld!\u0026quot;;\rchar b[20];\rmy_strcpy(a,b);//调用内嵌汇编程序\rreturn 0;\r}\r`\n  由两种方法的示例可以看出：内联汇编可以直接嵌入C代码使用，而内嵌汇编更像一个函数。由于内联式汇编只能在ARM状态中进行，而Cortex-M3/M4只支持Thumb-2，所以Cortex-M3/M4只能使用内嵌汇编的方式，也就是第二种方法\n在C语言中内嵌汇编指令与汇编程序中的指令有些不同，存在一些限制，主要有下面几个方面：\n 不能直接向PC寄存器赋值，程序跳转要使用B或者BL指令 在使用物理寄存器时，不要使用过于复杂的C表达式，避免物理寄存器冲突 R12和R13可能被编译器用来存放中间编译结果，计算表达式值时可能将R0到R3、R12及R14用于子程序调用，因此要避免直接使用这些物理寄存器 一般不要直接指定物理寄存器，而让编译器进行分配  示例：在C程序中使用内联汇编代码实现字符串复制\n#include\u0026lt;stdio.h\u0026gt;\rvoid my_strcpy(constchar*src，char*dest)\r{\rcharch;__asm//注意是双下划线\r{\rLOOP:\rLDRB ch,[src],#1\rSTRB ch,[dest],#1\rCMP ch,#0\rBNE LOOP\r}\r}\rint main()\r{\rchar* a=\u0026quot;ok!\u0026quot;;\rchar b[64];\rmy_strcpy(a,b);\rreturn 0;\r}\r在汇编中调用C语言定义的函数和全局变量\n 使用内联或者内嵌汇编不用单独编辑汇编语言文件使用起来比较方便，但是有诸多限制 当汇编文件较多的时候就需要使用专门的汇编文件编写汇编程序，在C语言和汇编语言进行数据传递的最简单的形式是使用全局变量  8. 基于ARM微处理器硬件与软件系统设计开发 8.1. 嵌入式硬件与软件系统设计与开发综述 8.1.1. 概述  硬件平台：  嵌入式处理器 存储器：SDRAM、ROM、Flash等 通用设备接口和I/O接口：A/D转换器、D/A转换器、I/O接口控制卡   核心控制模块：嵌入式处理器+电源电路、时钟电路、存储器电路 软件平台：应用层、操作系统OS层、驱动层  8.1.2. 嵌入式生态系统 硬件\n 仿真器，如：J-LINK、ULINK 开发板，如：ARM/KEIL的STM32专用评估板  软件\n 开发工具(如：ARM/KEIL MDK和IAR EWARM) 软件资源，包括：  底层驱动（如：标准外设驱动库、DSP库等） 固件协议 应用模块（如：电机控制、音频应用等）    文档\n8.1.3. 开发环境、开发工具和调试方式 开发环境\n 宿主机(如：通用PC，用于：编写、编译、链接等，生成可在目标机上执行的二进制代码) 目标机(系统实际运行环境，如：ARM处理器) 宿主机和目标机之间的连接  物理连接(如：串口、以太网接口和JTAG) 逻辑连接(如：通信协议)    开发工具\n 硬件（如：PCB、PCL等设计开发） 软件（编辑器、交叉编译器、链接器、调试下载工具；集成开发环境IDE；如：KEIL MDK）  嵌入式软件开发阶段及其工具：\n集成开发工具KEIL MDK的组成\n调试方法\n 软件模拟器（分为：指令集和系统调用级模拟器） ROM监控器。由三部分构成：宿主机的调试器、目标机的监控器及两者间物理/逻辑连接 ROM仿真器。替代目标机上ROM芯片(映射、仿真）两端分别与目标机和宿主机相连 在线仿真器ICE。模拟目标机上CPU(含RAM/ROM） 片上调试OCD。内置于目标板CPU芯片内的调试模块；如：JTAG仿真器ULINK和J-LINK  片上调试OCD图示：\n基于JTAG的嵌入式调试环境：\n8.1.4. 嵌入式系统开发过程  需求分析（系统规格说明书,含功能性/非功能性需求） 系统设计（也称总体/概要设计）  体系架构设计 软硬件划分 硬件划分（处理器、外设、器件及开发工具的选择） 软件设计（软件架构设计和软件模块划分）   系统实现（又称详细设计，包括硬件和软件实现） 系统测试（包括：测试方法、工具及步骤） 系统发布  8.2. ARM内核常用微处理器 8.2.1. 三星S3C2440A 8.2.2. 恩智浦LPC2132 特性：\n 小型LQFP64封装，可在系统/在应用编程(ISP/IAP) 嵌入式跟踪接口可实时调试 47个GPIO、1个A/D、2个UART、2个I2C、SPI、NVIC 片内晶振频率1~30MHz，PLL实现最大60 MHz 2个低功耗模式：空闲和掉电 可禁止外部功能和降低外部时钟频率优化功耗 通过外部中断从掉电模式中唤醒 单电源供电，CPU电压范围3.0~3.6 V  结构原理\n 支持仿真的ARM7 TDMI-S CPU、与片内存储器控制器接口的ARM7局部总线、与中断控制器接口的AHB和连接片内外设功能的VPB。默认访问模式为小端字节顺序 AHB连接VIC、外存储器访问控制器EMC；AHB外设共分配2 MB地址范围，位于4GB存储器空间最顶端；每个AHB外设分配16KB地址空间；AHB桥用于微处理器与AHB总线信号与时序协议的桥接与适配 VPB连接其他外设；VPB外设共分配2MB地址范围，从3.5GB地址点开始；每个VPB外设分配16KB地址空间AHB到VPB的桥将VPB总线与AHB总线相连 片内外设与器件引脚的连接由引脚连接模块控制，须由软件控制以符合应用中的需求  引脚及连接模块\n 引脚：引脚功能复用，将某几个功能分配到一个引脚 引脚连接模块结构原理：配置引脚具体功能；利用PINSELx，可控制多路开关，连通引脚与某功能模块  端口寄存器与操作\n3个32位用于引脚功能选择寄存器，即：\n PINSEL0：选择P0[15:0]各引脚功能；每2个对应一个引脚，选择约定具体应用功能 PINSEL1：选择P0[31:16]各引脚功能，每2位一个 PINSEL2：选择P1[31:26]、P1[25:16]两引脚簇功能  控制寄存器操作时，建议采用：“读→修改→写回”方式\n好处是：\n 不会改变原来不相关引脚的功能属性 不会影响到寄存器中保留位的数据  8.2.3. 意法半导体STM32 系统总线\n  I-Code总线；指令预取\n  D-Code总线；数据加载和调试访问\n  系统总线\n  DMA总线\n  总线矩阵；含：\n4个驱动部件(CPU的D-Code、系统总线、DMA1/2总线)\n4个被动部件(FLITF、SRAM、FSMC和AHB-APB桥)\n  AHB-APB桥；共两个，AHB和两个APB总线间连接\n  程序、数据存储器、所有外设都统一编址(4GB）；各自有固定存储空间区域，使用不同总线进行访问\nCortex-M3内核，视为CPU，通过相应总线再经总线矩阵与程序、数据存储器、所有外设相接并控制其读写访问\n外设分为高速/低速两类，各自通过桥接再通过AHB系统总线连至总线矩阵，实现与内核的接口；外设时钟可各自配置；两种访问操作方式：CPU直接操作和DMA方式\n系统时钟，均由复位与时钟控制器RCC产生，为系统和各外设提供所需时钟以确定各自工作速度\n功能模块\n  系统模块\n辅助和维护正常工作，如：电源、外部晶振、内部RC振荡器、锁相环PLL、复位和时钟控制RCC、实时时钟、看门狗Watchdog和循环冗余校验CRC等\n  通信模块\n与标准通信接口外设间数据交换，如：USART、SPI、I2C、USB、CAN和SDIO\n  虚拟模块\n对模拟信号的处理，如：ADC、DAC\n  控制模块\n对电机等设备控制和操作，如：定时器\n  性能简介\n 基于ARM Cortex-M3核心，32位，LQFP-144封装 512KB片内Flash(类似硬盘，程序存储)，64KB片内RAM(类似内存，数据存储) 72MHz系统频率，片内双RC晶振(8MHz/40kHz)，片外高速晶振(8MHz)/低速晶振(32kHz) 数据、指令分别走不同流水线 带后备电源引脚，用于掉电后时钟行走；42个16位后备寄存器，利用外置电池，实现掉电数据保存功能 支持JTAG、SWD调试；在线程序烧写(ISP) 80个GPIO；4个通用定时器，2个高级定时器，2个基本定时器；3个SPI；2路I2S；2个I2C；5个USART；1个USB；1个CAN；1个SDIO；可兼容SRAM、NOR和NAND Flash16位总线可变静态存储控制器FSMC 3个16通道12位ADC，2个2通道12位DAC，支持片外独立电压基准 CPU工作电压范围：2.0~3.6V  8.3. 最小硬件系统 8.3.1. 微处理器最小硬件系统 8.3.2. S3C2440A最小硬件系统  电源模块；内核和IO接口能量来源，电压、纹波、内阻、驱动能力、防干扰等性能直接影响系统工作稳定性 时钟模块；提供同步工作信号，频率较高系统主时钟和频率较低实时时钟，倍频和同步处理后不同频率时钟信号，供各模块使用 复位模块；3种：加电和手动复位(信号来自外部复位电路，从nRESET引脚输入)，内部复位(信号来自系统内部事务处理，如看门狗复位) JTAG调试接口模块；完成基本调试工作 外部存储器模块；保存和运行系统程序，如SRAM(引导)、SDRAM(程序运行)、NAND Flash(存放程序)  8.3.3. STM32最小硬件系统 8.3.4. MCU及其周围电路设计 8.3.4.1. 电源电路 8.3.4.2. 复位电路   系统复位\n复位除备份区域的寄存器以外所有寄存器\n(时钟控制状态寄存器RCC_CSR中复位标志不会复位)\n触发一个系统复位有数种方式：\n WWDG看门狗复位(窗口看门狗计数终止) IWDG(Independent Watch Dog)看门狗复位(独立看门狗计数终止) 软件复位(SW复位) 低功耗管理复位 外部手动复位    电源复位\n 当上电/掉电复位POR和PDP（V~DD~小于特定阈值V~POR~/V~PDR~时）发生或从待机模式返回时，产生电源复位 复位除备份区域外的所有寄存器 复位源最终作用于复位引脚，并在复位过程中保持低电平 复位入口矢量被固定在地址0x00000004    备份区域复位\n仅影响备份区域，有两个专门的复位：\n 在软件复位时，设定RCC_BDCR.BDRST位产生 当电源V~DD~和电池V~BAT~都掉电前提下，V~DD~或V~BAT~重新上电时产生    复位电路：延时，使CPU保持复位，暂不进入工作状态(防止执行错误指令)，确保其及各部件处于确定的初始状态，直至电压稳定复位电路直接影响系统稳定性和可靠性\n8.3.4.3. 时钟电路   内部RC振荡器与外部晶振的选择\n 内部RC振荡器：可为PLL提供时钟，不够准确稳定，误差1%左右，精度通常比外部晶振低10倍以上 外部主时钟源：高速外部时钟HSE，两种时钟源产生  外部晶体/陶瓷谐振器(常选用8MHz)和负载电容组成精确而稳定，首选 用户提供的外部时钟信号(可为占空比50%的方波/正弦波/三角波，可达25MHz），须连至OSC32_IN引脚，OSC32_OUT引脚悬空      STM32时钟树\n时钟树图中的序号解释：\n①：输入，外部晶振HSE，可选为2~16MHZ\n②：第一个分频器PLLXTPRE，可选1分频/2分频\n③：时钟源选择，开关PLLSRC，可选其输出为：外部高速时钟HSE或内部高速时钟HSI\n④：锁相环PLL，具有倍频功能(2~16)，经过PLL的时钟称为PLLCLK(若设9倍频，即从8MHz的HSE变为72MHz)\n⑤：开关SW，经过SW后即系统时钟SYSCLK。SW可选SYSCLK时钟源为：HSI、PLLCLK、HSE\n⑥：AHB预分频器(分频系数为1/2/4/8/16/64/128/256/512)\n⑦：APB2预分频器(分频系数为1/2/4/8/16)。若为1，则高速外设APB2(PCLK2)为72MHz(AHB输出为72MHz时)\n时钟树从左至右，相关时钟可依次分为：\n  输入时钟\n从时钟频率分：高速/低速时钟；从芯片角度分：内部时钟(片内时钟)/外部时钟源(片外时钟)。有以下5种：\n 高速外部时钟HSE：①→②→③→④→⑤得SYSCLK 高速内部时钟HSI：片内RC振荡器产生，不稳定，上电开始作为初始系统时钟，8MHz 低速外部时钟LSE：外部晶振，提供给实时时钟,32kHz 低速内部时钟LSI：片内RC振荡器产生，提供给实时时钟和看门狗，40kHz 锁相环倍频输出PLL：输入源可选HSI/2、HSE或HSE/2,倍频2~16倍，输出最大72MHz    系统时钟SYSCLK\n 由SW根据用户设置，选择PLLCLK、HSE或HSI中的一路输出而得，最高可达72MHz(通常即72MHz) 大部分部件时钟来源，由AHB预分频器分配至各部件 通常，上电开始，选用HSI作为初始系统时钟，完成初始化后，选用更加稳定可靠的HSE作为系统时钟来源 为了能实时检测时钟系统是否运行正常，专门提供引脚MCO(主时钟输出)，通过软件编程，选择SYSCLK、PLLCLK、HSE或HSI中的一路在MCO上输出    由系统时钟分频所得其他时钟（即SYSCLK经过AHB预分频器输出）\n HCLK：AHB时钟(通常，预分频系数为1，常为72MHz)，最高72MHz；为内核、存储器和DMA时钟信号 FCLK：内核“自由运行”时钟，与HCLK互相同步，最大72MHz；HCLK停止时仍能继续运行，保证内核睡眠时也能采样到中断和跟踪休眠事件 PCLK1：外设时钟；再经APB1预分频器(系数常为2)后得到，最高36MHz(常为36MHz)；为APB1总线上(低速)外设时钟(如需使用外设，须先开启其时钟) PCLK2：外设时钟；类似PCLK1，最高72MHz(常为72MHz)，为APB2总线上(高速)外设时钟信号 SDIOCLK：SDIO外设时钟 FSMCCLK：可变静态存储控制器时钟 STCLK：系统时间定时器SYSTICK的外部时钟源；AHB输出再经过8分频后得到，等于HCLK/8 TIMXCLK：定时器2~7内部时钟源，PCLK1经过倍频(*1或*2，由APB1分频系数是否为1判断得出)所得 TIMxCLK：定时器1/8内部时钟源，PCLK2经过倍频(*1或*2，由APB2分频系数是否为1判断得出)所得 ADCCLK：ADC1~ADC3时钟，PCLK2经过ADC预分频器(/2,4,6,8)所得      时钟输出的使能及其流程\n 连接在APB1上的设备(低速外设)有：电源接口、备份接口、CAN、USB、I2C1、I2C2、UART2~5、SPI2/I2S、SPI3/I2S、BKP、IWDG、WWDG、RTC、CAN、DAC、PWR、TIM2~7 连接在APB2上的设备(高速外设)有：GPIOA~G、TIM1、TIM8、USART1、ADC1~ADC3、SPI1、EXTI、AFIO  假设，使用HSE及ST库函数，配置时钟（参数）流程如下：\n① 将RCC重新设置为默认值，RCC_DeInit\n② 打开HSE，RCC_HSEConfig(RCC_HSE_ON)\n③ 等待HSE工作，HSEStartUpStatus=RCC_WaitForHSEStartUP\n④ 设置AHB时钟，RCC_HCLKConfig\n⑤ 设置高速/低速AHB时钟，RCC_PCLK2Config/RCC_PCLK1Config\n⑥ 设置PLL，RCC_PLLConfig；打开PLL，RCC_PLLCmd(ENABLE)\n⑦ 等待PLL工作，while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY)==RESET))\n⑧ 设置系统时钟，RCC_SYSCLKConfig\n⑨ 判断PLL是否是系统时钟，while(RCC_GetSYSCLKSource()!=0x08)\n⑩ 打开要用外设时钟，RCC_APB2PeriphClockCmd/RCC_APB1PeriphClockCmd\n  时钟管理寄存器\n  时钟控制寄存器RCC_CR：使能外部时钟和内部时钟，使能PLL功能；在各种时钟就绪时，置位其中就绪标志并可配置内部时钟的校准和设置偏移量\n  时钟配置寄存器RCC_CFGR：配置某时钟作为系统时钟SYSCLK；显示当前系统时钟源；配置AHB、APB、ADC的预分频(即配置其时钟频率)；选择PLL时钟源，设置倍频系数；选择MCO时钟源\n  时钟中断寄存器RCC_CIR：使能PLL、HSE、HIS、LSE、LSI就绪中断，显示/清除其就绪中断标志\n  APB2外设复位寄存器RCC_APB2RSTR\nAPB1外设复位寄存器RCC_APB1RSTR\nAHB外设时钟使能寄存器RCC_AHBENR\nAPB2外设时钟使能寄存器RCC_APB2ENR\nAPB1外设时钟使能寄存器RCC_APB1ENR\n备份域控制寄存器RCC_BDCR，各位分别为：\n LSEON，外部低速时钟振荡器使能 LSEBYP，外部低速时钟振荡器旁路 RTCSEL，实时时钟RTC时钟源选择 RTCEN，实时时钟RTC使能  控制/状态寄存器RCC_CSR，各位分别为：\n LPWRRSTF，低功耗复位标志 WWDGRSTF，窗口看门狗复位标志 IWDGRSTF，独立看门复位标志 SFTRSTF，软件复位标志 PORRSTF，上电/掉电复位标志 PINRSTF，NRST引脚复位复位标志 RMVF，软件将此位置1，可清除各复位标志 LSIRDY，内部低速时钟LSI就绪标志 LSION，使能内部低速时钟振荡器  各复位标志由硬件置1，由电源复位或软件置RMVF位为1清除；系统复位可清除其余位\n  时钟系统相关库函数\n存放于stm32f10x_rcc.h和stm32f10x_rcc.c中\n RCC_GetSYSCLKSource：返回用作系统时钟的时钟源 RCC_GetClocksFreq：返回不同片上总线时钟频率 RCC_AHBPeriphClockCmd：使能/禁止AHB总线上外设时钟 RCC_APB2PeriphClockCmd：使能/禁止APB2总线上外设时钟 RCC_APB1PeriphClockCmd：使能/禁止APB1总线上外设时钟    8.3.4.4. 调试和下载电路 8.3.4.5. 启动电路 8.3.4.6. 启动代码和启动过程  启动代码：上电后程序执行的真正入口，通常包括初始化：异常向量表、时钟、存储器、堆栈，跳转到main函数等，为系统运行做好准备 启动过程：  根据BOOT0和BOOT1引脚，选择启动存储器映射 从地址0x0000 0000处，取出栈顶指针值放入MSP 从地址0x0000 0004处，取出复位异常服务程序入口地址放入PC 执行复位异常服务程序，跳转至main()函数    复位时，STM32F103存储空间和重要寄存器\n复位异常服务程序Reset_Handler的执行过程\n8.4. 嵌入式软件系统设计 8.4.1. 系统结构及工作流程 嵌入式软件系统结构\n  驱动层\n板级初始化程序及与系统/应用软件相关的驱动\n  操作系统层\n嵌入式内核、文件系统、TCP/IP网络系统、GUI系统和电源管理等\n  中间件层\n嵌入式CORBA、Java等中间件软件\n  应用层\n多个相对独立应用任务（如I/O、计算和通信等）组成\n  常使用操作系统作为软件平台，由专用引导程序在系统上电时进行系统引导，对底层硬件采用驱动程序方式进行调用，各类应用程序运行于操作系统之上\n嵌入式软件系统工作流程\n  上电复位、板级初始化：堆栈指针寄存器、BSS段及CPU芯片级(如中断控制器和内存等)初始化\n  系统引导/升级：多种方式\n  系统初始化：\n操作系统等所需：堆栈空间、数据空间，接口和外设等\n按特定顺序：内核 → 网络、文件系统 → 中间件\n  应用初始化：应用任务、信号量和消息队列等创建\n  多任务应用：多任务状态，操作系统进行任务调度\n  嵌入式软件系统引导和加载\n 功能：初始化硬件，建立内存空间映射图，调用操作系统内核 过程：（一般指Bootloader的运行）  依赖于CPU体系结构的硬件初始化代码(汇编)，依次任务为：硬件设备初始化、准备RAM空间、设置堆栈、跳转至步骤2入口(准备下一步) 加载操作系统内核映像与根文件系统，调用操作系统运行(C语言，但不能用glibc库中函数)，依次任务为：初始化本阶段用到的硬件设备、检查系统内存映射、将核与根文件映像从Flash读入RAM、设置内核启动参数、调用操作系统内核    嵌入式软件特点\n 强调软硬件协同，理解系统和外围设备性能、结构、资源，高效发挥硬件性能，节约成本，易维护、移植 常需固化在目标系统存储器或处理器内部存储资源中 开发需使用：交叉编译环境及仿真器等开发工具、目标系统、示波器等测试设备支持 对实时性要求高，能对异常事件或命令做出迅速反应 对抗干扰性、稳定性和可靠性要求较高 需考虑代码大小(因存储空间有限)，提高运行速度，降低系统功耗和成本  8.4.2. 嵌入式操作系统 EOS，屏蔽底层硬件差异，为运行其上的应用程序提供统一调用接口，主要完成：内存、多任务及外围设备等的管理\n一般，嵌入到微处理器或其他存储载体中，负责全部软硬件资源的分配、调度、控制、协调，提供必要运行环境(各种系统服务供调用，如文件系统、内存分配、I/O存取、中断、任务服务、时间服务、多种通信协议和用户接口函数库等)\n与硬件关系紧密，一般需移植/配置\n核心体积很小，常需加载/卸载某些模块满足不同功能\n（嵌入式系统将所有程序，包括操作系统、驱动及应用程序等均烧写进ROM里执行。EOS更像一套函数库）\nEOS的特点：\n 强稳定性，弱交互性；运行后不需过多干预，因此需具有很强稳定性 较强实时性；用于各种设备控制 可伸缩性；具有开放、可伸缩性体系结构 外设接口统一性；提供各种设备驱动接口  RTOS（嵌入式实时操作系统ERTOS）\n 实时，能够在确定时间内完成特定系统功能或中断响应；当外界事件或数据产生时，能够接受并快速处理，其处理结果能在规定时间内控制或响应生产过程 特征主要包括：允许多任务、带有优先级的任务调度、资源的同步访问、任务间通信、定时时钟、所有实时任务受控协调一致运行等 应用RTOS的一般背景：  需并行运行多个较复杂任务，任务间需要进行实时交互 需为应用程序提供统一API，实现应用软件与硬件驱动独立开发，便于应用程序开发与维护 需满足工业控制、军事设备、航空航天等领域对系统响应时间的苛刻要求 硬件具备足够处理能力    8.4.3. 程序开发模式 基于寄存器\n 与硬件关系密切，直接面对底层部件、寄存器和引脚 程序代码比较紧凑，冗余较少，生成机器码较小 开发难度较大、效率较低、周期较长、调试烦琐、程序可读性差、维护升级较难、移植性较差 可帮助更加清晰了解和掌握STM32的架构、原理  基于（ST）固件库\n 底层硬件接口部分被封装(为函数)，不需太关注硬件 库函数是位于寄存器与用户层间预定义代码API(包括一系列宏、数据结构和函数等)，向下实现寄存器直接相关操作，向上为应用程序提供(配置寄存器的)标准接口 易上手、阅读、维护，开发难度降低，开发周期缩短 封装后程序更易编写、理解、维护、移植  基于操作系统\n  基于操作系统的API接口函数，完成开发\n  需较好把握操作系统、多任务等理论及应用\n  中间件\n如STM32Cube，统一集成化开发平台，整合图形式配置器和初始化C代码生成器，向导功能帮助有效配置微处理器引脚、时钟树和外设接口。配置完成，自动生成初始化C代码\n8.4.4. 软件开发流程 循环轮询系统架构\n最简单的，由一个初始化函数和一个无限循环构成\n 周而复始依次检查每个输入条件，一旦满足某条件就进行相应处理 结构简单，易理解编程，但无法及时响应紧急事件(需等下轮循环) 适于规模较小简单嵌入式系统  前后台系统架构\n 前后台：在循环轮询基础上增加中断功能，又称中断驱动系统，由一个后台程序和多个前台程序构成 后台：循环轮询，不断依次检测条件并做相应处理 前台：由一些中断服务程序ISR组成，负责处理需快速响应的异步事件 后台持续运行(也称任务级/主程序)，某前台事件(通常是外部事件)发生时，产生某中断，转入某前台(即中断程序)处理，完成后返回后台，继续执行 大多前台只完成基本操作，如标记、向后台发信号等；后台完成其他操作，如数据运算、存储和显示等  工程方式\n 从ST官网下载STM32F10x标准外设库 下载安装嵌入式开发工具(如KEIL MDK等) 以官方工程模板为基础，根据所用微处理器型号和软件编译设置，更改相关配置选项 编写程序代码，主要是User组中的main.c和stm32f10x_it.c 编译和链接工程 使用软件模拟仿真或下载硬件运行(仿真器跟踪运行)等方式调试程序 将可执行程序下载至目标微处理器内置ROM中，复位，运行  8.5. ARM中的GPIO 8.5.1. 概述  通用输入输出端口，实现数字交换及对外围设备(如LED和按键等)最简单直观监控，还可用于串行和并行通信、存储器扩展等 可提供最多112个多功能双向I/O引脚，分布在GPIOA、GPIOB、\u0026hellip;、GPIOF和GPIOG等端口中 端口号以大写字母命名，A~G(最多7个) 每个端口有16个引脚，以数字命名，从0开始，依次，到15为止 例如，STM32F103RCT6的GPIOA有16个引脚，分别为PA0，PA1，PA2，\u0026hellip;，PA15  8.5.2. 工作原理 8.5.2.1. 内部结构 输出驱动器：多路选择器、输出控制和一对互补的MOS管组成\n输入驱动器：TTL肖特基触发器、带开关的上拉电阻电路和带开关的下拉电阻电路组成\n输出驱动器\n 多路选择器：根据设置决定该引脚是普通输出(来自GPIO的输出数据寄存器)还是复用功能AF输出(可能来自多个不同片上外设，同一时刻，一个引脚只能使用这些复用功能中的一个，其他复用功能都处于禁止状态) 输出控制逻辑和一对互补的MOS管：输出控制逻辑根据设置通过控制PMOS管和NMOS管的状态(导通/关闭)决定GPIO输出模式(推挽、开漏还是关闭)  推挽结构：一般指两个三极管分别受两个互补信号控制，总是一个导通时另一个截止，各负责正、负半周期的波形放大任务；导通损耗小、效率高；输出既可向负载灌电流，也可从负载抽取电流(拉电流)；相比普通输出，推挽输出提高负载能力和开关速度 开漏输出：可提供灵活电平输出方式，即改变外接上拉电源的电压，便可改变输出电平电压高低；吸收电流能力相对较强(可达20mA)，适合做电流型驱动(如驱动继电器)    输入驱动器\n与输出驱动器不同，输入驱动器没有多路选择开关，输入信号送到输入数据寄存器的同时也送给片上外设，所以输入没有复用功能选项\n根据TTL肖特基触发器、上拉电阻端和下拉电阻端两个开关的状态，GPIO的输入可分为以下4种：\n 模拟输入：TTL肖特基触发器关闭 上拉输入：GPIO内置上拉电阻，此时，上拉电阻端的开关闭合，下拉电阻端的开关打开。该模式下，引脚在默认情况下输入为高电平 下拉输入：GPIO内置下拉电阻，此时，下拉电阻端的开关闭合，上拉电阻端的开关打开。该模式下，引脚在默认情况下输入为低电平 浮空输入：GPIO内部既无上拉电阻也无下拉电阻，此时上拉和下拉电阻端的开关都处于打开状态。该模式下，引脚在默认情况下为高阻态(即悬空)，其电平高低完全由外部电路决定  8.5.2.2. 工作模式  普通推挽输出PP：可输出低0/高VDD电平，较大功率驱动 普通开漏输出OD：只能输出低电平0；若想输出高电平(外接上拉电源的电压)需外接上拉电阻和电源；通常，连接到不同电平器件、线与输出或模拟I^2^C通信的I/O引脚 复用推挽输出AF_PP：不再是普通I/O，不仅具有推挽输出特点，还使用片内外设功能；常用作USART的Tx或SPI的MOSI、MISO、SCK 复用开漏输出AF_OD：不再是普通I/O，不仅具有开漏输出特点，还使用片内外设功能；常用作I^2^C的SCL或SDA 上拉输入IPU：默认上拉至高电平输入 下拉输入IPD：默认下拉至低电平输入 浮空输入IN_FLOATING：用于不确定高低电平输入；例如，连接外部按键或作为USART接收端Rx、I^2^C等 模拟输入AIN：用于外部模拟信号输入  注意事项：\n  对于复用输入功能，端口须配置成输入模式(浮空、上拉或下拉)且输入引脚须由外部驱动\n  对于复用输出功能，须配置成复用功能输出模式(推挽或开漏)\n  对于双向复用功能，须配置成复用功能输出模式(推挽或开漏)输入驱动器被配置成浮空输入模式\n  若端口配置成复用输出功能，则引脚和输出寄存器断开，并和片上外设的输出信号连接，若此外设未被激活，其引脚输出将不确定\n  GPIO的锁定机制允许冻结I/O配置。当在一个端口上执行了锁定(LOCK)程序，下一次复位前，将不能再更改端口配置\n  通过对GPIO寄存器编程，可设置每个端口工作模式，包括\n 端口配置低寄存器CRL 端口配置高寄存器CRH 端口输入寄存器IDR 端口输出寄存器ODR 端口位设置清除寄存器BSRR(又称置位/复位) 端口位清除寄存器BRR(又称复位) 端口锁定寄存器LCKR  例如，GPIOB_CRL就是B组GPIO端口的配置低寄存器，GPIOC_CRH即C组GPIO端口配置高寄存器\n  8.5.2.3. 输出速度  输出模式下，常需设置其输出速度(指I/O口驱动电路响应速度，非输出信号速度) 有多个响应速度不同的输出驱动电路，根据需要选择，达到最佳噪声控制和降低功耗目的 一般推荐I/O引脚的输出速度是其输出信号速度的5~10倍 3种选择：2MHz、10MHz和50MHz。常见应用参考：  2MHz：LED、蜂鸣器普通输出、USART复用功能输出 10MHz：I^2^C复用功能输出 50MHz：SPI、FSMC复用功能输出    8.5.2.4. 复用功能重映射  引脚复用有几种情况：  某I/O引脚除通用功能外，还可设置为一些片上外设的复用功能 某I/O引脚除可作为某默认外设复用引脚外，还可作为其他多个不同外设的复用引脚 某片上外设，除默认复用引脚外，还可有多个备用的复用引脚   引脚复用重映射：可把某外设复用功能从(某默认)引脚转移至(某备用)引脚上 可分时复用外设，虚拟增加端口数量，优化引脚配置和布线设计PCB，同时减少信号交叉干扰 复用重映射需设置：复用重映射和调试I/O配置寄存器AFIO_MAPR  复用功能重映射典型举例：\n 从I/O引脚角度看  如，引脚PB10，主功能是PB10，默认复用功能是I2C2时钟端SCL和USART3发送端Tx，重定义功能是TIM2_CH3。上电复位后，PB10默认为普通输出 若想使用PB10的默认复用功能USART3，则需编程配置PB10为复用推挽输出模式，同时使能USART3并保持I^2^C2禁止状态 若要使用PB10的重定义复用功能TIM2_CH3，则需编程对TIM2进行重映射，然后再按复用功能方式配置   从外设复用功能角度看  如，USART2，发送端Tx和接收端Rx默认映射到引脚PA2和PA3 若此时PA2已被另一复用功能TIM2_CH3占用，就需对USART2进行重映射，将Tx和Rx重新映射到引脚PD5和PD6    复用功能重映射的实现：\n8.5.2.5. 外部中断映射和事件输出   外部中断映射\n 当某I/O引脚被映射为外部中断线后(须配置成输入模式)就可作为一个外部中断输入源，在其上产生外部中断 所有I/O引脚均具有输入外部中断能力，每个外部中断线EXTIn和所有GPIO端口GPIOA~Gn共享    事件输出\n几乎每个I/O引脚（除端口F和G外）都可用作事件输出如，使用SEV指令产生脉冲，通过事件输出信号将STM32F103从低功耗模式中唤醒\n  8.5.2.6. STM32F10x的GPIO主要特性  提供最多112个多功能双向I/O引脚，80%利用率 除ADC外，均兼容5V，具有20mA驱动能力 最高18MHz翻转速度，50MHz输出速度 8种工作模式，在复位时和刚复位后，复用功能未开启，被配置成浮空输入模式 所有引脚均具备复用功能 某些复用引脚可通过复用功能重映射用作另一复用功能 所有引脚均可作为外部中断输入，同时可有16个 每个引脚(除端口F和G外)均可用作事件输出 PA0可作为从待机模式唤醒引脚;PC13，入侵检测引脚  8.5.3. 相关库函数及寄存器 8.5.3.1. 库函数 存放于stm32f10x_gpio.h和stm32f10x_gpio.c中\n常用库函数\n GPIO_DeInit：将GPIOx端口的寄存器恢复为复位启动时的默认值 GPIO_Init：根据GPIO_InitStruct中指定的参数初始化GPIOx端口 GPIO_SetBits：将指定的GPIO端口的一个或多个指定引脚置位 GPIO_ResetBits：将指定的GPIO端口的一个或多个指定引脚复位 GPIO_Write：向指定的GPIO端口写入数据 GPIO_ReadOutputDataBit：读取指定GPIO端口的指定引脚输出值(1b) GPIO_ReadOutputData：读取指定GPIO端口的输出值(16b) GPIO_ReadInputDataBit：读取指定GPIO端口的指定引脚的输入值(1b) GPIO_ReadInputData：读取指定GPIO端口的输入值(16b) GPIO_EXTILineConfig：选择被用作外部中断/事件线的GPIO引脚  初始化结构体\n典型库函数——初始化函数GPIO_Init\n8.5.3.2. 常用寄存器  每个GPIO端口(以x区分)共有7个寄存器，均为32位 两个配置寄存器(低CRL，高CRH)、两个位数据寄存器(输入IDR，输出ODR)、置位/复位寄存器BSRR、复位寄存器BRR和锁定寄存器LCKR 每个端口位可自由编程，但寄存器须按32位字被访问(不允许半字、字节或位访问)  端口配置低寄存器CRL\n 偏移地址0x00；复位值0x4444 4444 每个GPIO端口有16位，对应芯片16个引脚，CRL用于控制端口低8位(0~7引脚)，CRH控制端口高8位(8~15引脚) CRL中每4位为1组，每组控制1个引脚的配置(输入/输出模式)，32位共控制8个引脚  其余寄存器\n IDR，只读，仅低16位[15:0]有效，其值为对应I/O口(即端口引脚)的状态(0或1) ODR，读/写，仅低16位有效；写时：其值影响对应I/O口(即端口引脚)的输出(0或1，即输出低/高电平)；读时：为上一次写出数据 BSRR，只写，设置某特定引脚输出电平(0/1)，保持其他引脚输出不变；可分别对各ODR位独立设置/清除(即置位1/复位0)；高16位[31:16]复位对应引脚(15~0)为0，低16位[15:0]置位对应引脚(15~0)为1 BRR，只写，清除某特定引脚输出电平(为0)，保持其他引脚输出不变；仅低16位有效，复位对应引脚(15~0)为0  举例：\n  GPIOD引脚4:50MHz推挽输出，引脚15:上拉下拉输入模式\n寄存器设置：CRL.CNF4为00，CRL.MODE4为11，CRL.CNF7为10，CRH.MODE7为00\nGPIOD_CRL\u0026amp;=0XFFF0FFFF;\t//清掉对位4的配置\rGPIOD_CRL|=0X00030000;\t//写位4的配置为0011b(即3)\rGPIOD_CRH\u0026amp;=0X0FFFFFFF;\t//清掉对位15的配置\rGPIOD_CRH|=0X8000000;\t//写位15的配置为1000b(即8)\r\r  假设GPIOD位4、位5（即引脚4、5）端口50MHz频率推挽输出\n  现将位4置1输出高电平，可如下：\nGPIOD_ODR| =1\u0026lt;\u0026lt;4；//等同于GPIOD_ODR| =0x10；\r`\n若写成GPIOD_ODR=0x10,将PD其他位都清0了，会引发不可预测后果\n  使位4端口再输出低电平，可如下：\nGPIOD_ODR\u0026amp;=(~(1\u0026lt;\u0026lt;4));\t//等同于GPIOD_ODR\u0026amp; =0xEF(11101111B)\r`\n  若使位4端口输出低电平，位5端口输出高电平，可如下：\nGPIOD_ODR\u0026amp;=(~(1\u0026lt;\u0026lt;4));GPIOD_ODR|=1\u0026lt;\u0026lt;5；\r`\n需两条语句，且均有回读操作，不适合高实时性。可用BSRR完成：\nGPIOD_BSRR=0x00100020\r`\n避免回读(\u0026amp;=或|=)，且一次实现2个引脚操作，效率高，速度快\n用BRR完成位4端口输出低电平：\nGPIOD_BRR=1\u0026lt;\u0026lt;4\r`\n    8.5.3.3. AFIO寄存器  事件控制寄存器AFIO_EVCR：将事件输出重映射到PA0~15、PB0~15、PC0~15、PD0~15、PE0~15 复用重映射和调试I/O配置寄存器AFIO_MAPR：配置SWJ和跟踪复用的I/O口；ADCx/TIMx/USARTx/SPI1/I^2^C1等的重映射 外部中断配置寄存器1~4，AFIO_EXTICR1~AFIO_EXTICR4：用于配置I/O口作为外部中断源输入  8.5.4. 应用与举例 GPIO开发三部曲\ngraph TB\r开始 --\u0026gt; 使能APB2总线上该引脚所属GPIO端口时钟\r使能APB2总线上该引脚所属GPIO端口时钟 --\u0026gt; 通过GPIO_InitTypeDef结构体变量配置GPIO引脚\r通过GPIO_InitTypeDef结构体变量配置GPIO引脚 --\u0026gt; 操作该引脚\r操作该引脚 --\u0026gt; 结束\r  使用任何一个片上外设，此步都不可少，一般在初始化一开始就进行\n  GPIO_InitTypeDef结构体是引脚配置关键，由其成员可快速了解GPIO特性；将指定工作模式和输出速度等写入对应成员，用此结构体变量初始化指定引脚，可实现对引脚真正配置\n  若引脚设置为输出，操作引脚是往该引脚输出高/低电平\n若引脚设置为输入，操作引脚是从该引脚读取高/低电平\n  8.6. 定时器 8.6.1. 概述 STM32F103可编程定时器主要类型：\n 具有延时、信号频率测量、信号PWM测量、PWM输出、三相六步电机控制及编码接口等功能 从功能上看，基本定时器是通用定时器的子集，通用定时器是高级定时器的子集 基本TIM6和TIM7  16位时基计数器，可用于产生DAC触发信号   通用TIM2、TIM3、TIM4和TIM5  均由一个16位可编程预分频器驱动的一个16位自动装载递加/递减计数器构成 均具有4个独立通道(CH1~4)，每个通道均可用于输入捕获、比较输出、PWM和单脉冲模式输出 可用于测量输入信号的脉冲长度(输入捕获)或产生输出波形(比较输出和PWM) 使用时，一般需配置一个时基单元，确定时间基准，其核心部件为16位预分频器   高级TIM1和TIM8  可视为分配到6个通道的三相PWM发生器，常用于电机控制(另具死区控制/紧急制动等特性) 均可作为完整的通用定时器 可产生PWM(边缘或中心对齐)、互补PWM和单脉冲 可被当成完整的通用定时器使用   独立的看门狗  基于一个12位递减计数器和一个8位预分频器 由一个内部独立的40kHz RC振荡器提供时钟(独立于主时钟)，可运行于停机和待机模式 发生问题时复位系统 也可作为一个自由定时器，为应用程序提供超时管理 通过选择字节可配置为软件或硬件启动 调试模式，计数器可被冻结   窗口看门狗  内有一个7位递减计数器，可设置成自由运行 发生问题时复位系统 由主时钟驱动，具有早期预警中断功能 调试模式，计数器可被冻结   系统时间定时器SysTick  常用于操作系统 可作为一个标准24位递减计数器    8.6.2. 基本定时器TIM6和TIM7 8.6.2.1. 内部结构 构成：\n 触发控制器 可编程16位预分频器 带自动重装装载寄存器的16位计数器CNT  计数器是核心，由预分频器驱动，自动重装载预设值\nTIM6和TIM7只有最基本的定时功能(提供时间基准)，即累计时钟脉冲数超过预设值时，产生定时器溢出事件\n如果使能了中断或DMA操作，将产生中断或者DMA操作\n8.6.2.2. 时钟源 定时器时钟源路径：\nAPB1预分频 → TIMxCLK → CK_INT → 预分频（PSC）→ CK_CNT\n 定时器时钟CK_CNT，控制计数基准频率 只有一种时钟源，内部时钟CK_INT CK_INT来自RCC的TIMxCLK(不同定时器来源不全相同) TIMxCLK来源于APB1预分频器的输出 上电复位后，APB1预分频系数为2，APB1时钟频率PCLK1为36MHz，因此，TIMxCLK为72MHz  8.6.2.3. 计数模式   基本定时器仅有向上计数模式，自动重装载寄存器ARR保存定时器溢出值/预设值\n  工作过程：计数器从0开始，在CK_CNT触发下不断累加计数；当计数器CNT计数值等于ARR中预设值时，产生溢出事件，可触发中断或DMA请求(已使能时)；然后，CNT计数值被清零，重新开始向上计数\n  延时时间=(ARR+1)*(PSC+1)/TIMxCLK\n其中，ARR(预设值)和PSC(预分频系数)都是16位，取值范围0~65535；TIMxCLK为72MHz(上电复位后，通常值)\n  8.6.2.4. 基本工作原理   更新事件UEV（Update Event）\n 指这个事件发生后，定时器寄存器将进行更新(以工作于新配置)；如定时周期结束(计数器上溢)或其他事件(如，软件产生)均为UEV 发生UEV时：硬件依据CR1.URS位设置，设置更新中断标记SR.UIF状态(0/1：是/否产生中断或DMA请求)，同时所有寄存器均被更新(重复计数器重新装载RCR值；自动重装载寄存器重新置入ARR值，预分频器重置为PSC值) 设置CR1.UDIS=1，可禁止更新事件(用来避免在写入新寄存器值时更新影子寄存器)，在CR1.UDIS被清零之前，将不产生更新事件。此时，在应产生更新事件时，计数器及预分频器的计数仍被清零，但预分频器数值不变 设置EGR.UG=1(通过软件方式或使用从模式控制器)，同样也可产生一个UEV 若设置了CR1.URS=1(选择更新请求)，当置EGR.UG=1时，将产生一个更新事件，但硬件不设置SR.UIF(即仍为0)，即不产生中断或DMA请求，以避免捕获模式下清除计数器时，同时产生更新和捕获中断    预分频寄存器PSC：存放分频系数，16位\n  计数器CNT：存放当前计数值，16位\n  自动重装载寄存器ARR：决定定时器的上溢时刻（定时周期），当计数器在（向上）计数过程中，计数值达到ARR值，计数器就要归零\n  时基单元：包含CNT、PSC、ARR三部分（通用和高级定时器另有RCR），这些寄存器均可由软件任意读/写\n  定时（周期）计算公式：\nTout(μs)=((ARR+1)*(PSC+1))/T~CLK~(MHz)\n  影子寄存器shadow和预装载寄存器preload\n 物理上，某寄存器对应2个寄存器：一个是可写入/读出的寄存器，称为预装载寄存器；另一个是看不见、无法真正对其读写操作，但在使用中真正起作用的寄存器，称为影子寄存器 具此特性寄存器如下几种：PSC、ARR、RCR、自动捕获寄存器CCR1~4(基本定时器无RCR和CCR1~4) 影子寄存器未提供开放给用户，仅提供与之相对应的预装载寄存器 PSC、ARR、RCR、CCRx均不是影子寄存器，而是对应的预装载寄存器 用户能修改或读取的都是预装载寄存器 影子寄存器的值来自预装载寄存器 值从预装载寄存器传送到影子寄存器，有两种方式：一是立刻更新，另一是等触发事件之后更新；具体方式的选择取决于相应控制寄存器里控制位的设置(是否允许影子寄存器，即是否有缓冲区) 影子寄存器又称(对应某寄存器的)缓冲区    ARR(作为预装载寄存器)和影子寄存器的关系\n  根据CR1.APRE的设置，ARR内容：可随时传送到影子寄存器，即两者是连通的(permanently)；或在每次更新事件UEV时，才传送到影子寄存器，具体：\n CR1.APRE=0，当ARR值被修改时，同时更新影子寄存器的值(无预装功能) CR1.APRE=1，ARR值被修改时，须在下次UEV发生后，才更新影子寄存器值(即有缓冲区，预装功能)    如需立刻更改影子寄存器的值，而不是等待下一个事件，可有如下两种方法：\n  使CR1.APRE=0，即：\nTIM_ARRPreloadConfig(ch1_Master_Tim, DISABLE)\r\r  使CR1.APRE=1时，更改完ARR后，立刻设置UEV(主动发生UEV)，即更改EGR.UG=1：\nTIM_GenerateEvent(TIM1,TIM_EventSource_Update)\r\r      定时/计数工作过程\n 计数器由CK_CNT驱动，仅当设置了CR1.CEN(计数器使能位)时，CK_CNT才有效 预分频器可将CK_CNT时钟频率按1~65536之间任意值分频 设置了CR1.CEN=1的一个时钟周期后，计数器开始计数；当计数器达到溢出条件并当CR1.UDIS=0时，产生更新事件，若中断允许，可同时触发中断或DMA请求    8.6.2.5. 主要特性  具有自动重装载功能的16位累加计数器，其内部时钟CK_CNT的来源TIMxCLK来自APB1预分频器输出具有16位可编程可实时修改的预分频器，分频系数为1~65535之间任意值 有更新事件(如计数器溢出)时，可产生中断/DMA请求 可触发DAC的同步电路  8.6.3. 通用定时器TIM2~TIM5 8.6.3.1. 内部结构 每个通用定时器：\n 完全独立 不共享任何资源 可一起同步操作  测量输入脉冲频率/宽度\n可输出PWM脉冲\n计数器CNT核心构成类似，主要增加：捕获/比较功能\n捕获/比较寄存器CCR（Capture/Compare Register）\n 包括输入捕获部分（数字滤波、多路复用和预分频器）和比较输出部分（比较器和输出控制） CCR，共用，在输入和输出模式中含义和作用不同：  输入捕获：输入时，当捕获的输入脉冲在电平发生翻转时，CCR加载CNT当前计数值，实现脉冲频率测量；此时，CCR是个捕获寄存器 比较输出：输出时，CCR用来存储一个数值，将此数值与CNT当前计数值比较，根据比较结果进行不同的电平输出；此时，CCR是个比较寄存器    8.6.3.2. 时钟源 有多种选择，可由以下四种时钟源提供：\n  内部时钟CK_INT\n与基本定时器相同，来自RCC的TIMxCLK，APB1预分频器输出(通常为72MHz)。如果禁止了从模式(SMCR.SMS=000)，则CR1.CEN、CR1.DIR及EGR.UG是事实上的控制位，且只能被软件修改(EGR.UG位仍会被自动清除)\n  内部触发输入ITRx\nITRx来自芯片内部其他定时器的触发输入，使用一个定时器作为另一定时器的预分频器例如，可配置TIM1作为TIM2的预分频器\n  外部输入捕获引脚TIx\nTIx来自外部输入捕获引脚上的边沿信号；计数器可在选定的输入端(引脚1：TI1FP1或TI1F_ED，引脚2：TI2FP2)的每个上升沿或下降沿计数；也称外部时钟模式1(之一)\n配置向上计数器在TI2输入端的上升沿技术，步骤如下，设置：\nCCMR1.CC2S=01;\t//配置通道2检测TI2输入的上升沿\rCCMR1.IC2F=0000;\t//不需要滤波器；\rCCER.CC2P=0;\t//选定上升沿极性；\rSMCR.SMS=111;\t//选择定时器外部时钟源模式1；\rSMCR.TS=110;\t//选定TI2作为触发输入源；\rCRl.CEN=1;\t//启动计数器。\r`\n 捕获预分频器不用做触发，所以不需进行配置 当上升沿出现在TI2时，计数器计数一次，且SR.TIF被设置    外部触发输入引脚ETR\nETR信号来自外部引脚ETR，计数器能在外部触发输入ETR的每个上升沿或下降沿计数，也称外部时钟模式2\n配置在ETR下每2个上升沿计数一次的向上计数器，步骤如下，设置：\nSMCR. ETP=0;\t//选择ETR的上升沿检测\rSMCR. ETF=0000;\t//不需要滤波器\rSMCR. ETPS=01;\t//设置预分频器\rSMCR. ECE=1;\t//开启外部时钟源模式2\rSMCR.TS=110;\t//选定TI2作为触发输入源\rCRl.CEN=1;\t//启动计数器。\r`\n  8.6.3.3. 计数模式  16位计数器CNT有3中工作模式：向上、向下、双向计数（向上/向下，也称中央对齐） 若使用了重复计数器功能，只要溢出次数达到重复计数（RCR值）时，才产生更新事件；否则每次计数溢出时即产生更新事件  双向计数模式\nPSC值为0(内部分频系数为1)，ARR预设值为6\n(CR1.CEN=1)使能计数时，计数器在CK_CNT驱动下减1计数\n当计数值到达1时，产生计数器下溢事件，然后继续从0开始加1计数。当计数值到达5时，产生计数器上溢事件，然后继续从6开始减1计数\n计数器在CK_CNT驱动下从0开始计数到ARR的预设值-1，然后产生一个计数器溢出事件，再向下计数到1并且产生一个计数器下溢事件，接着再从0开始重新计数\n此模式不能写入CR1.DIR，由硬件更新并指示当前计数方向，更新事件产生在每次计数上溢和每次计数下溢\n8.6.3.4. 普通输入捕获模式 可用来测量(输入信号)脉冲宽度或频率\n通过检测CHx上的边沿信号，在其发生跳变(如上升沿/下降沿)时，(利用中断功能)将当前定时器CNT值，锁存到对应通道的捕获/比较寄存器CCRx中，把前后两次捕获到的CCR值相减，即可算出脉宽或频率\n除了TIM6和TIM7，其他定时器均有输入捕获功能\n捕获过程信号流程：输入信号由CHx经采样、滤波后所得信号TIxF，由边沿检测器产生信号TIxFPx(可作为从模式控制器的输入触发或作为捕获控制)，再通过预分频成为ICxPS进入捕获寄存器CCR，即：\nCHx→TIxF→TIxFPx→ICxPS→CCR\n  输入通道\n待测量信号从外部引脚CH1~4进入，常称为TI1~4\n  输入滤波和边沿检测\n 输入信号存在高频干扰时，需对其进行滤波，即重新采样(根据采样定律，采样频率须大于2倍输入信号) 滤波器配置由CR1.CKD和CCMR.ICxF控制，采样频率f~SAMPLE~可由f~CK_INT~(内部时钟)或f~DTS~分频后提供 滤波器实质是一个事件计数器，记录到N个事件后会产生一个输出的跳变（即连续采样N次，以确认一次真实的边沿变换）。N大小可设，称为滤波器带宽/长度 边沿检测器设置信号被捕获时有效边沿，可为上升沿/下降沿/双边沿，由CCER.CCxP和CCER.CCxNP决定    捕获通道\n 捕获通道即IC1~4，每个通道均对应一个CCR1~4，发生捕获时，CNT值会被锁存到CCRx中 捕获通道和输入通道有区别：输入通道用来输入信号，捕获通道用来捕获输入信号，一个输入信号(的通道)可同时输入给两个捕获通道(比如TI1信号经滤波边沿检测器后的TI1FP1和TI1FP2可分别进入IC1和IC2) 测量输入信号脉宽时，用一个捕获通道即可；两者映射关系由CCMR.CCxS配置    预分频器\nICx的输出信号会经过预分频器，决定发生多少个事件时进行一次捕获；事件个数由CCMR.ICxPSC配置\n  捕获寄存器CCR\n 经过预分频器后的信号ICxPS是最终被捕获信号 第一次捕获发生时，CNT值被锁存在CCR中，并产生中断CCxI，相应中断位SR.CCxIF被置1，通过软件或读取CCR值可将SR.CCxIF清0 若发生第二次捕获(即CCR已捕获CNT值且SR.CCxIF已置1)，则捕获溢出标志SR.CCxOF会被置位(对其清零只能通过软件) 捕获寄存器实际由预装载和影子寄存器组成；读/写过程仅操作预装载寄存器；捕获模式下，捕获发生在影子寄存器上，然后再复制到预装载寄存器中    输入捕获过程描述\n IC1~4可分别通过软件设置将其映射到TI1~4；每次检测到ICx信号上相应边沿后，CNT当前值被锁存到CCRx中(即捕获事件发生)，SR.CCxIF被置1(若已使能中断/DMA操作，会产生中断/DMA操作) 外部事件发生的触发信号由对应引脚输入 输入捕获可用来捕获外部事件，并为其赋予时间标记以说明此事件的发生时刻；时间标记可用来计算频率，占空比及信号的其他特征，以及为事件创建日志 例如，捕获上升沿，(前后两次值)相减，代表这两个上升沿中间那段电平的时间  设置在TI1输入的上升沿时捕获计数器CNT值到CCR1中，如下：\nCCMR1.CC1S=01;\t//CC1被设置为输入，IC1映射在TI1上\rCCMR1.IC1F=0011;\t//配置输入滤波器所需带宽，连续采样8次\rCCER.CC1P=0;\t// TI1通道选择上升沿有效\rCCMR1.IC1PSC=00;\t//输入无分频器，每一个边沿都触发一次捕获\rCCER.CC1E=1;\t//允许捕获计数器的值到捕获寄存器中\rDIER.CC1IE=0;\t//允许中断请求\rDIER.CC1DE=0;\t//允许DMA请求\r`\n测量脉冲宽度(捕获高电平脉宽)：\n 首先设置输入捕获为上升沿触发，然后记录发生上升沿时CNT值 其后，设置捕获信号为下降沿，在下降沿到来时，记录此时CNT值 两次CNT值之差即为脉冲宽度  示例：利用ST库函数实现TIM设置，使用TIM2的1/3通道进行频率测量，设置过程如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  TIM_ICInitStructure.TIM_ICMode=TIM_ICMode_ICAP;//配置为输入捕获模式 TIM_ICInitStructure.TIM_Channel=TIM_Channel_1;\t//选择通道 1TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;//输入上升沿捕获 TIM_ICInitStructure.TIM_ICSelection=TIM_ICSelection_DirectTI;//通道方向选择 TIM_ICInitStructure.TIM_ICPrescaler=TIM_ICPSC_DIV1;//每检测到捕获就触发一次捕获 TIM_ICInitStructure.TIM_ICFilter=0x0; TIM_ICInit(TIM2,\u0026amp;TIM_ICInitStructure); TIM_ICInitStructure.TIM_ICMode=TIM_ICMode_ICAP; TIM_ICInitStructure.TIM_Channel=TIM_Channel_3;//选择通道3 TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising; TIM_ICInitStructure.TIM_ICSelection=TIM_ICSelection_DirectTI; TIM_ICInitStructure.TIM_ICPrescaler=TIM_ICPSC_DIV1; TIM_ICInitStructure.TIM_ICFilter=0x0; TIM_ICInit(TIM2,\u0026amp;TIM_ICInitStructure); TIM_SelectInputTrigger(TIM2,TIM_TS_TI1FP1); //选择滤波后TI1作为输入触发源，触发下面程序的复位 TIM_SelectSlaveMode(TIM2,TIM_SlaveMode_Reset); //复位模式-选中的触发输入（TRGI）的上升沿初始化计数器，并且产生一个更新信号 TIM_SelectMasterSlaveMode(TIM2,TIM_MasterSlaveMode_Enable);//主从模式选择   `\n  8.6.3.5. PWM输入捕获模式  普通输入捕获模式的一种特殊应用 将同一输入映射两个ICx信号(IC1和IC2)，其中一个捕获上升沿，另一个捕获下降沿，在中断中读上升沿和下降沿分别对应的CNT值，得到周期和占空比，具体即：  一个捕获通道计算两次上升沿间隔时间，即周期T 另一通道计算下降沿和之前上升沿之差，即高电平时长 由周期T及高电平时长得出占空比   PWM输入捕获与普通输入捕获区别  2个ICx信号被映射至同一个TIx输入 2个ICx信号为边沿有效但极性相反 其中一个TIxFP作为触发输入(SMCR设为复位模式)      将待测PWM输入信号通过GPIO引脚输入到定时器PWM检测通道TI1，设置CNT向上计数(ARR预设值足够大)\n  输入脉冲TI1上升沿到达时，触发IC1和IC2输入捕获中断，CNT值复位为0随后，CNT在CK_CNT驱动下从0开始累加计数\n  TI1下降沿到来时，触发IC2捕获事件，CNT当前值被锁存到CCR2中，CNT继续累加。(设TCK_CNT为CK_CNT周期)\n待测脉冲高电平时间为(CCR2+1)*TCK_CNT\n  TI1第二个上升沿到达时，触发IC1中断，CNT当前值锁存到CCR1中，同理待测脉冲周期为(CCR1+1)*TCK_CNT\n  由周期和高电平时间，可算出占空比为(高电平时间/脉冲周期)*100%=(CCR2+1)/(CCR1+1)\n  8.6.3.6. 比较输出模式  常用于控制输出一个波形或指示一段给定时间已到 当CNT计数值(变动至)与CCR值相等时：  相应输出引脚可根据所设置编程模式选择以下赋值(并输出)：置位、复位、翻转或不变 状态寄存器SR中相应标志位置位 如果相应中断屏蔽位置位且中断使能，则产生中断 如果DMA请求使能置位，则产生DMA请求   CCR能在任何时候通过软件进行更新以控制输出波形，前提条件是不使用预装载寄存器(即CCMR.OCxPE=0)，否则只能在发生下一次更新事件时被更新  比较输出模式下翻转OC1的时序图：\n  比较输出寄存器\n当CNT值跟CCR值相等时，输出参考信号OCxREF会发生改变(再经过一系列控制后成为真正输出信号OCx/OCxN)，并产生比较中断CCxI，SR.CCxIF置1\n  死区发生器\n仅高级定时器才有；在OCxREF基础上，插入死区时间，用于生成两路互补的输出信号OCx和OCxN\n  输出控制\n进入输出控制电路的信号被分成两路，原始和被反向信号(通过设置CCER.CCxP和CCER.CCxNP控制极性选择)；由OCx输出到外部引脚CHx/CHxN(通过设置CCER.CxE和CCER.CxNE控制是否输出)\n  输出引脚\n比较输出的输出信号最终通过定时器外部IO输出，分别为CH1~4(前三通道还有互补的输出通道CH1~3N)\n  比较输出模式种类\n共8种：冻结、匹配时输出有效/无效电平、翻转、强制为有效/无效电平、PWM1/2；(通过设置CCMR.OCxM选择模式)。其中，\n PWM1/2：是比较输出的特例，使用也最多 强制输出有效/无效：直接由软件强制为有效(高电平)或无效(低电平)，不依赖于比较结果(但仍可有中断和DMA请求)    比较输出原理\n即通过(计数值和CCR比较后)定时器外部引脚输出受控的波形。可认为有两部分实现信号(的受控)输出：\n 一是计数部分，将计数器CNT设为某工作模式并初始化后，CNT不停自动计数 一是比较部分，设置匹配值CCR，并在CNT计数过程中，不停将当前计数值与CCR值进行比较，二者相等时产生一个匹配，然后根据(输出的)具体设置，输出高/低电平信号，从而在输出端生成预期波形  比较输出模式的说明：\n 匹配发生时，会产生比较中断(中断已使能时) 设置CCMRx.CCxS=00,即选择相应通道为输出模式 CCMRx.OCxPE选择CCRx是否需要使用预装载寄存器 比较输出模式下，UEV对OCxREF和OCx输出没有影响 比较输出精度可达到计数器的一个计数周期 比较输出模式(在单脉冲模式下)也可输出一个单脉冲    PWM输出模式\n  PWM的定义和应用\n脉冲宽度调制(简称脉宽调制)，指对脉冲宽度的控制，利用数字输出对模拟电路进行控制。在电力电子中应用广泛，包括：测量、通信、功率控制与变换、电机控制、伺服控制、调光、开关电源等\n  PWM的实现\n 传统数字电路方式：电路设计较复杂，体积大，抗干扰能力差，系统控制周期较长 微处理器普通I/O模拟方式：通过CPU操控普通I/O口实现PWM输出，时间消耗大，CPU效率低，精度低 微处理器PWM直接输出方式：简单配置后即可在(具有PWM输出功能)微处理器指定引脚上输出PWM脉冲    PWM输出模式的工作过程\n假设：CNT向上计数，ARR预设值N，CNT当前计数值X，CCR预设值A，时钟周期TCK_CNT。工作过程：\n  X在CK_CNT驱动下从0开始不断累加计数\n  X(在计数同时)与A进行比较：\n若X\u0026lt;A，输出高/低电平；若X≥A，输出低/高电平\n  当X大于N时，X清零并重新开始计数\n  循环往复，所得PWM输出信号：周期为(N+1)*TCK_CNT，脉冲宽度为A*TCK_CNT，占空比为A/(N+1)\n  PWM输出模式的说明\n 对外输出脉宽可调方波信号，ARR值确定频率，CCR值确定占空比；占空比=(CCR+1)/(ARR+1) 设置CCMRx.OCxM=110(PWM模式1)或=111(PWM2)，能独立设置每个OCx输出通道产生一路PWM 设置CCMRx.OCxPE=1，可使能相应CCR预装载寄存器 开始计数之前，须设置EGR.UG=1来初始化所有寄存器 OCx极性通过设置CCER.CCxP实现(高/低电平) OCx输出使能通过CCER.CCxE、CCER.CCxNE、BDTR.MOE、BDTR.OSSI、BDTR.OSSR的组合控制 PWM模式1/2下，依据计数方向，确定是否CCRx≤CNT，并根据CR1.CMS状态，选择边沿或中央对齐模式      单脉冲模式OPM\n 众多模式的一个特例 允许计数器响应一个激励，在可编程延时后产生一脉宽可程序控制的脉冲 软件可设定选用两种单脉冲模式波形:单脉冲或重复脉冲    编码器接口\n 编码器常用于测量运动系统(直线和圆周运动)位置和速度 编码器接口模式用作对外部设置的方向选择 计数器提供当前位置信息(如电动机转子旋转角度) 为获取动态信息(速度、加速度)，须通过另一定时器测量产生两个周期性事件之间的计数值    主要特性（相比基本定时器所增加特性）\n 自动重装载16位递增/递减计数器，具备3种计数模式 时钟来源，除内部时钟，另有：内部触发输入ITRx、外部输入捕获TIx、外部触发输入ETR 4独立通道，均可用于输入捕获、比较输出、PWM输入和输出(边沿或中央对齐模式)及单脉冲模式输出 在更新事件(上溢/下溢、软件或内部/外部触发引起计数器初始化)、触发事件(计数器启动/停止/初始化或内部/外部触发计数)、输入捕获、比较输出等发生时，可产生中断/DMA请求 支持针对定位的增量(正交)编码器和霍尔传感器电路 使用外部信号控制定时器和定时器互连的同步电路    8.6.4. 高级定时器TIM1和TIM8 除具有通用定时器所有功能外，还可视为一个分配到6个通道的三相PWM发生器，具有嵌入死区时间的互补PWM输出\n完全独立，不共享任何资源，可同步操作\n  内部结构\n与通用定时器相比，主要多了BRK和DTG两个结构，因而具有死区时间控制功能\n  时钟源\n与通用定时器唯一的不同在于：内部时钟CK_INT的来源TIMxCLK来自APB2预分频器输出，上电复位后，APB2预分频系数为1，TIMxCLK是APB2时钟PCLK2(通常为72MHz)\n  功能描述\n相比通用定时器，另具有三相六步电机的接口、刹车功能及用于PWM驱动电路的死区时间控制，非常适于控制电机\n  主要特性\n 内部时钟CK_CNT来源TIMxCLK来自APB2预分频器输出 具有重复计数器，允许在指定数目的计数器周期之后更新 触发输入作为外部时钟或按周期的电流管理 中止(也称刹车)输入信号可将输出信号置于复位状态或一个已知状态 死区时间可编程的互补输出    8.6.5. 主从模式、触发与同步 所有TIMx均在内部相连，用于同步或级联\n定时器一般通过软件设置启动，也可由另一定时器触发或通过外部信号触发而启动，还可通过另一定时器某一条件被触发而启动(某一条件可为：定时到时、定时器超时、比较成功等)\n通过一个定时器触发另一定时器的工作方式，有时也称为定时器的同步\n发出触发信号的定时器工作于主模式，接受触发信号而启动的定时器工作于从模式\n8.6.5.1. 主从模式 定时器工作于主模式时，能产生触发输出(并作为其它定时器的触发输入)信号，还可对另一处于从模式的定时器进行复位、启动、停止或提供时钟等操作\n定时器工作于从模式时，受到外来触发信号的影响或控制，其具体工作模式又可分为多种\n定时器处于主从双角色模式：既受外来触发信号影响或控制，同时又能输出触发信号影响或控制其他从定时器\n8.6.5.2. 触发 触发输出信号（TRGO）\nTIM输出(至其它TIM或外设的)触发信号；一般有数种方式产生：\n 软件方式对定时器复位：置位EGR.UG=1 使能计数器：置位CR1.CEN=1 定时器更新事件、捕获/比较事件 输出通道输出参考信号OCxREF  触发输入信号（TRGI）\n从外部引入(到TIM)的触发信号，根据SMCR.TS设置，分为3类，共8个，如下：\n 来自TIM自身：TI1/2输入信号，经过极性选择和滤波后的触发信号TI1FP1/TI2FP2以及TI1输入信号经过双沿检测后再逻辑相或后的触发信号TI1F_ED(双沿脉冲信号) 来自外部触发引脚ETR：由ETR引入的信号经过极性选择、分频、滤波(分频和滤波并非必需)后的触发信号ETRF 来自其它TIM：由其他TIM定时器的触发输出信号，通过内部线路连接引入的触发信号ITRx(一般最多4路内部输入选择端)  来自定时器外部的各种触发输入信号TRGI ，均须经过触发输入选择器连接至从模式控制器SMCR(控制或影响计数器工作)，此时TIM工作于从模式\n8.6.5.3. 从模式下的工作模式 从模式控制器检测到触发输入信号时，有多种控制方式(以控制或影响TIM工作)，形成相应工作模式，如下：\n 复位模式(ResetMode)：对计数器复位 触发模式(TriggerMode)：使能计数器的工作 门控模式(GateMode)：启动或停止计数器的计数动作 外部时钟模式1(ExternalClockMode1)：利用触发信号为计数器提供时钟源 编码器模式(EncodeMode)  8.6.5.4. 定时器级联及同步   使用一个定时器作为另一个定时器的预分频器\n配置定时器1作为定时器2的预分频器，TIM2由TIM1周期性的上升沿（即TIM1的计数器溢出）信号驱动\nTIM1_CR2. MMS=010;\t//TIM1为主模式；设定UEV作为触发输出，每产生\r//一个UEV时(即每次计数器溢出)，在TRGO1上输出一个周期性上升触发信号\rTIM2_SMCR.TS=000;\t//主从模式对应主TIM2，从TIM1；\r//ITR0作为内部触发，TIM2从TIM1获得触发输入\rTIM2_SMCR.SMS=111;\t//TIM2使用外部时钟源模式1配置TIM1的ARR;//定时周期\rTIM1_CR1.CEN=1;\rTIM2_CR1.CEN=1;\t//使能TIM1、TIM2\r`\n  使用一个外部触发同步地启动2个定时器\n定时器1的TI1输入上升时使能定时器1，使能定时器1的同时使能定时器2\nTIM1_CR2. MMS=001；\t//TIM1为主模式；设定它的使能作为触发输出\rTIM1_SMCR.TS=100；\t//TIM1为从模式，从TI1获得输入触发\rTIM1_SMCR.SMS=110；\t//TIM1为触发模式\rTIM1_SMCR.MSM=1；\t//TIM1为主/从模式；对TI1为从，对TIM2为主\rTIM2_SMCR.TS=000；\t//TIM2从TIM1获得输入触发\rTIM2_SMCR.SMS=110；\t//TIM2为触发模式\rTIM1_CR1.CEN=1；\t//使能TIM1\r`\n当TIM1的TI1上出现一个上升沿时，TIM1和TIM2同步地按照内部时钟开始计数两个TIF标志也同时被设置。为保证计数器对齐，TIM1须配置为主/从模式(既是主也是从)\n  8.6.6. 相关库函数及寄存器 8.6.6.1. 库函数 存放于stm32f10x_tim.h和stm32f10x_tim. c文件中\n常用库函数\n TIM_TimeBaseInit：根据TIM_TimeBaseInitStruct初始化TIMx TIM_ARRPreloadConfig：使能或禁止ARR上的预装载寄存器 TIM_Cmd：使能或禁止TIMx TIM_ITConfig：使能或禁止指定TIMx中断 TIM_GenerateEvent：设置TIM事件由软件产生 TIM_GetITStatus：检查指定TIMx中断是否发生 TIM_ETRClockMode1Config：配置TIM外部时钟源模式1 TIM_CounterModeConfig：设置TIM计数器模式 TIM_SelectInputTrigger：选择TIM输入触发源 TIM_CCxCmd：使能或禁止TIM捕获/比较通道x TIM_SelectSlaveMode：选择TIM从模式  初始化结构体\n基本初始化结构体TIM_TimeBaseInitTypeDef\n1 2 3 4 5 6 7 8  typedefstruct { uint16_t TIM_Prescaler;\t//预分频：0~0xFFFF  uint16_t TIM_CounterMode;\t//计数模式：Up/Down向上/向下CenterAligned1/2/3中央1/2/3  uint16_t TIM_Period;\t//ARR值：0~0xFFFF  uint16_t TIM_ClockDivision;\t//采样分频系数：DIV1/2/4  uint8_t TIM_RepetitionCounter;//重复定时器值(计数周期数) }TIM_TimeBaseInitTypeDef;\t//TIM初始化各参数定义   输入捕获初始化结构体TIM_ICInitTypeDef\n1 2 3 4 5 6 7 8 9  typedefstruct { uint16_t TIM_Channel; //通道，共4个，1~4：通道1~4  uint16_t TIM_ICPolarity;\t//边沿触发：Rising上升沿,Falling下降沿  uint16_t TIM_ICSelection;\t//输入：TRC，与TRC相连；DirectTI，TI1/2/3/4与IC1/2/3/4相连；  //IndirectTI，TI1/2/3/4与IC2/1/4/3相连  uint16_t TIM_ICPrescaler;\t//输入预分频，每N(1/2/4/8)个事件执行一次捕获：DIV1/2/4/8  uint16_t TIM_ICFilter;\t//滤波器：0x0~0x0F }TIM_ICInitTypeDef;   比较输出初始化结构体TIM_OCInitTypeDef\n1 2 3 4 5 6 7 8 9 10 11  typedefstruct { uint16_t TIM_OCMode;//输出模式  uint16_t TIM_OutputState; //输出使能  uint16_t TIM_OutputNState;//互补输出使能  uint16_t TIM_Pulse;//占空比：0x0000~0xFFFF  uint16_t TIM_OCPolarity;//输出极性，High：高，Low：低  uint16_t TIM_OCNPolarity;//互补输出极性  uint16_t TIM_OCIdleState;//空闲状态输出电平  uint16_t TIM_OCNIdleState;//空闲状态互补输出电平 }TIM_OCInitTypeDef;   典型库函数\n8.6.6.2. 常用寄存器  高级计数器具有全部20个寄存器；通用计数器有19个(无BDTR)；基本定时器有CR1、CR2、DIER、SR、EGR、CNT、PSC、ARR共8个寄存器 控制寄存器有：CR1~2、SMCR、SR、EGR、DIER、CCMR1~2、CCER等 常用寄存器有：ARR、CNT、PSC、CCR1~4等 CR1(最重要及常用)，主要控制位有：使能计数器CEN、使能ARR缓冲区ARPE、允许或禁止产生更新事件UDIS、设置分频系数CKD、设置计数方向DIR、选择能产生中断或DMA请求的UEV源URS、选择边沿或中央对齐模式CMS、选择单脉冲模式OPM等8种功能 CR2，选择在主模式下送到从模式定时器的同步信息(TRGO)的8种方式 SMCR，各位用于：计数器同步时触发输入选择TS、选择从模式下工作模式SMS、启用外部时钟源模式2ECE、主从模式MSM SR，各位保存：捕获/比较匹配/更新/中止/触发器/COM等事件发生标记(CCxIF/UIF/BIF/TIF/COMIF)及重复捕获发生标记(CCxOF)；标记均由硬件置1(可由软件清零，即写0清除)；同时会发起中断请求 EGR ，各位用于产生各种事件：更新UG /触发TG/捕获及比较CCxG/中止BG/捕获及比较使能更新COMG等事件；均由软件置1，以产生相应事件，由硬件自动清零 DIER，各位用于使能：更新/触发/捕获比较/COM的DMA请求(UDE/TDE/CCxDE/COMDE)及中断请求(UIE/TIE/CCxIE/COMIE) CCMR1~2，各位用于设置：通道CC1~4的输入捕获和比较输出工作模式：定义通道方向(选择输入或输出)CCxS、选择各种输出模式OCxM、比较输出预装载使能OCxPE、比较输出清零使能OC2CE、比较输出快速使能OCxFE、输入捕获滤波器ICxF、输入捕获预分频器ICxPSC CCER，各位用于设置输入/捕获通道n(1~3/4)的：互补输出极性CCnNP、互补输出使能CCnNE、输出极性CCnP、输出使能CCnE  8.6.7. 小结及应用要点 8.6.7.1. 定时器配置要点 频率设置\n 定时器本质是计数器，即对一定周期/频率脉冲进行计数(向上/向下/双向)，到设定值则溢出，输出设定信号 频率设置重点有二：计数用的脉冲频率(周期)和计数值 即，设置：PSC(预分频值)，对定时器所用时钟进行分频；ARR(自动重装溢出值)，设置计数目标 此前，还需用TIMIntemalClockConfig等函数选择时钟  时钟来源\n4类共8个触发源，可作为定时器时钟源\n 1个，来自RCC内部时钟TIMx_CLK，产生内部时钟CK_INT，即：内部时钟源 共4个，来自片内其他定时器的触发输入ITR1~ITR4，使用一个定时器作为另一定时器的分频输入(TIMx之间有确定的主从关系)；即：内部触发输入(ITRx)时钟源 共2个，来自捕获引脚上的边沿信号：CH1的TI1FP1/TI1F_ED和CH2的TI2FP2；即：外部输入脚(TIx)时钟源(也称外部时钟源模式1) 1个，来自引脚ETR；即：外部触发输入(ETR)时钟源(也称外部时钟源模式2)  计数器模式\n 向上：从0计数到ARR，然后重新从0开始计数 向下：从ARR计数到0，然后重新从ARR开始计数 双向：二者结合(先向上再向下) 计数转折时，均会产生一个计数器溢出事件  编程步骤\n 配置系统时钟 配置NVIC 配置GPIO 配置TIM  8.6.7.2. PWM程序实现步骤 实质上，PWM就是定时器的一个比较功能，利用翻转输出，形成一个具有一定脉冲宽度的高/低电平周期波\nPWM频率取决于ARR，占空比取决于CCR\n  配置输出通道\n 选择使用某个/某几个通道作为PWM输出通道，其对应引脚(其实就是GPIO)须进行时钟和引脚输出方式配置 一般为复用推挽输出AF_PP 应用中，可选不同引脚(即，改变GPIO与输出通道默认映射关系)，此时须使用重定向功能Remap，即：  引脚配置时，打开AFIO时钟(复用时钟使能)，调用Remap函数进行引脚重定向      配置定时器\n 计算并设置ARR、PSC、CCR值，以确定频率及占空比 选择时钟源、配置其余参数，与前述类似 配置PWM相关寄存器，设置某一通道CHx为PWM模式，并使能其输出    配置PWM模式（即输出特性）\n配置TIM3_CCMR1相关位来控制TIM3_CH3模式，利用TIM_OC3Init实现，其原型：\n1  void TIM_OC3Init(TIM_TypeDef* TIMx,TIM_OCInitTypeDef* TIM_OCInitStruct)   `\n1 2 3 4 5 6 7 8  TIM_OCStructInit(\u0026amp;TIM_OCInitStructure); //设置默认值  TIM_OCInitStructure.TIM_OCMode=TIM_OCMode_PWM1;\t// PWM模式1输出 TIM_OCInitStructure.TIM_Pulse=400-1;\t//占空比=(CCR/(ARR+1))或Pulse/(Period+1) TIM_OCInitStructure.TIM_OCPolarity=TIM_OCPolarity_High; //输出极性：高 TIM_OCInitStructure.TIM_OutputState=TIM_OutputState_Enable; //输出状态使能 TIM_OC3Init(TIM3,\u0026amp;TIM_OCInitStructure); //TIM3的CH3输出 TIM_CtrIPWMOutputs(TIM3,ENABLE); //TIM3的PWM输出为使能   `\n  8.6.7.3. PWM程序实现的3个要点 PWM两种输出模式\n模式1(PWM1)和模式2(PWM2)，由CCMR.OCxM值确定(110 为模式1，111为模式2)；模式1和2正好互补，互为相反，运用差别不大\n动态调整占空比\n修改CCR可控制输出占空比，库函数TIM_SetComparex用于修改占空比(x为1~4，代表相应通道)，其原型为：\n1  void TIM_SetComparex(TIM_TypeDef* TIMx,uint16_t Compare2)   PWM输出基本步骤\n 设置RCC时钟 设置GPIO 设置TIMx相关寄存器 设置TIMx的PWM相关寄存器 动态调整PWM占空比  8.7. 中断控制器 8.7.1. 中断系统综述 8.7.1.1. 嵌套向量中断控制器NVIC  NVIC集成于内核中，控制并统一管理整个芯片(向量）中断 核心功能：中断优先级分组及配置、读及清除中断请求标志、使能/禁止中断等  8.7.1.2. 中断优先级 决定一个中断是否能被屏蔽及何时可响应（未屏蔽时）\n优先级分组\n 抢占优先级，又称主/组/占先优先级，标识某中断抢占式优先响应能力高低，决定是否发生中断嵌套。具有高抢占先优先级中断会打断当前正执行的中断服务程序 子优先级，又称从优先级，仅在抢占优先级相同时才有影响，标识某中断非抢占式优先响应能力高低。在抢占优先级相同时，高子优先级中断须等待而不能打断正执行的低子优先级中断；若没有中断正被处理，高子优先级中断将优先被响应  优先级实现\n 每个中断源有4位优先级，具有16级可编程异常优先级 可按需编程设定4位优先级中抢占优先级位数  中断响应顺序\n 先比较抢占优先级，抢占优先级高的中断优先响应 抢占优先级相同时，比较子优先级，子优先级高的中断优先响应 抢占优先级和子优先级都相同时，比较中断向量表中位置，位置低的中断优先响应  8.7.1.3. 中断向量表  统一存放各中断对应的中断服务程序ISR入口地址，一般默认位于存储器开头(0地址处)，运行过程中无须修改 标准的异常和中断向量表可参阅startup_stm32f10x_hd.s，已标明中断处理函数名称，不能随意定义 NVIC支持68个可屏蔽中断通道NVIC_IRQChannel(即类型)在stm32f10x.h中进行了宏定义，通道常以中断号表示，优先级可设置(个别除外) 优先级7~66(中断号0~59)代表60个中断，号越小，优先级越高 中断被触发，将通过其在表中对应地址处所存放的一条跳转指令，跳转至相应中断服务函数处执行  8.7.1.4. 中断服务函数ISR  一般无参数及返回值，中断发生时被自动隐式调用执行 每个中断都有对应ISR，中断发生后执行相应处理 所有ISR在启动代码中预定义，常以XXX_IRQHandler命名(XXX是中断对应外设名，如TIM1、USART1等)。应用时，可添加/修改相关中断ISR(stm32f10x_it.c中)，链接时替代启动代码中同名默认程序(不能随意定义函数名称) ISR均预置弱定义(WEAK)属性(除复位程序外)，便于其他文件中编写同名函数替代(启动代码中默认ISR) ISR中首尾无须保护和恢复现场(寄存器)，此工作由硬件(在中断处理过程中)自动完成  8.7.1.5. 中断设置过程   建立中断向量表\n 可按需，在Flash或RAM中建立中断向量表，且须在应用程序执行前完成(通常在启动过程中完成) 在Flash中；不须重定位中断向量表；运行过程中，每个中断对应固定的ISR不能更改；这也是默认设置 在RAM中；需重定位中断向量表；运行过程中，可动态改变ISR    分配栈空间并初始化\n 执行ISR时，进入Handler模式，会使用主堆栈的栈顶指针MSP；此步须在应用程序执行前完成(通常启动过程中完成) 分配栈空间：栈空间通常位于启动代码起始位置；空间须够大，以保证中断响应/返回时保护和恢复现场(xPSR、PC、LR、R12、R3~R0共8个)，避免中断发生/嵌套时主堆栈溢出 初始化栈：通常在上电复位后执行复位服务程序时完成    设置中断优先级\n  设置中断优先级分组(的位数)\n4位中，抢占优先级和子优先级各占几位(二者和为4)，可有5种方式：抢占优先级0~4位/子优先级4~0位NVIC_PriorityGroup_0~4\n  设置抢占优先级和子优先级，根据上一步中分组情况，分别设置抢占和子优先级(即在各自取值范围中设置优先级确定值)\n    使能中断\n通过失效中断总屏蔽位和分屏蔽位，可使能对应中断\n  编写对应ISR代码\nISR最后，退出程序前应清除对应中断标志位（表示该中断已处理完毕），否则，该中断请求始终存在，该ISR将被反复执行\n  8.7.2. 外部中断/事件控制器EXTI 8.7.2.1. 内部结构 组成：\n 19根外部输入线 19个产生中断/事件请求的边沿检测器 APB外设接口  外部中断/事件输入线\n 19根(EXTI0~EXTI18)；除EXTI16(PVD输出)、EXTI17(RTC闹钟)和EXTI18(USB唤醒)外，EXTI0~15(其他16根)可分别对应16个引脚Px0~Px15(x为A~G) EXTI0~15连接/映射方式如下：任一端口0号引脚(如PA0、PB0、\u0026hellip;、PG0)映射到EXTI0上，任一端口1号引脚(如PA1、\u0026hellip;、PG1)映射到EXTI1上\u0026hellip;，任一端口15号引脚(如PA15、\u0026hellip;、PG15)映射到EXTI15上 同一时刻，只能有一个端口(即A~G中仅选一个)的n号引脚映射到EXTIn上(n为0~15)  APB外设接口\n通过此接口访问各功能模块。若使用引脚的外部中断/事件映射功能，须打开APB2总线上该引脚对应端口时钟及AFIO功能时钟\n边沿检测器\n共19个，用来连接19个外部中断/事件输入线，是EXTI主体部分。由边沿检测电路、控制寄存器、门电路和脉冲发生器组成\n8.7.2.2. 工作原理 外部中断/事件请求的产生和传输\n从输入(外部输入线)到输出(外部中断/事件请求信号)，过程依次\n 外部信号从①引脚进入 经过②边沿检测电路；此电路受上升沿/下降沿触发选择寄存器(两个平行寄存器)控制，可配置选择上升沿/下降沿/双边沿(同时选择上升沿和下降沿)产生中断/事件 经过③或门；此或门另一输入是软件中断/事件寄存器，软件可优先于外部信号产生一个中断或事件请求(即当软件中断/事件寄存器对应位为1时，不管外部信号如何，或门都会输出有效信号)；至此，无论中断或事件，外部请求信号传输路径一致 外部请求信号进入④与门；此与门另一输入是事件屏蔽寄存器(其对应位为0，则屏蔽某外部事件，该外部请求信号不能传输到与门另一端；为1，则与门产生有效输出并送至⑤脉冲发生器)；脉冲发生器把一个跳变信号转变为一个单脉冲，输出到其他功能模块；此为外部事件请求信号传输路径，即：①→②→③→④→⑤ 外部请求信号进入请求挂起寄存器(记录外部信号电平变化)；然后进入⑥与门；此与门功能和④与门类似，引入中断屏蔽寄存器控制(仅当其对应位为1时，该外部请求信号才被送至NVIC，从而发出一个中断请求，否则，屏蔽之)；此为外部中断请求信号传输路径，即：①→②→③→⑥  事件与中断\n从外部激励信号看，中断和事件的请求信号没有区别，只是在STM32F103内部将它们分开：\n 中断：会被送至NVIC，向CPU产生中断请求，其后由应用程序/ISR决定如何响应，须CPU介入，属于软件级 事件：会向其他功能模块(如TIM/USART/DMA等)发送脉冲触发信号(电路级别)，其后由此模块决定如何响应(如触发DMA、ADC采样等)，无须CPU干预，一般无对应服务函数，属于硬件级  主要特性\n 每个EXTI线都可独立配置其触发事件(上升沿/下降沿/双边沿)，并能单独被屏蔽 每个外部中断都有专用标志位(请求挂起寄存器)，保持其中断请求 可将112个GPIO引脚映射为16个EXTI线  8.7.3. 相关库函数及寄存器 8.7.3.1. 库函数 常用NVIC库函数\n存放于标准外设库的misc.h和misc.c文件中\n NVIC_PriorityGroupConfig设置优先级分组 NVIC_Init根据NVIC_InitStruct中指定参数初始化NVIC NVIC_DeInit将NVIC寄存器恢复为复位启动时默认值  常用EXTI库函数\n存放于stm32f10x_exti.h和stm32f10x_exti.c文件中\n EXTI_DeInit将EXTI寄存器恢复为复位启动时默认值 EXTI_Init根据EXTI_InitStruct中指定参数初始化EXTI EXTI_GetFlagStatus检查指定外部中断/事件线标志位 EXTI_ClearFlag清除指定外部中断/事件线标志位 EXTI_GetITStatus检查指定EXTI线触发请求发生与否 EXTI_ClearITPendingBit清除指定EXTI线中断挂起位  使用EXTI前，需先使用GPIO库函数\nGPIO_EXTILineConfig，将指定GPIO引脚设置为EXTI线\n初始化结构体\nNVIC初始化结构体NVIC_InitTypeDef\n1 2 3 4 5 6 7  typedef struct { uint8_t NVIC_IRQChannel;\t//中断通道  uint8_t NVIC_IRQChannelPreemptionPriority;\t//抢占/主优先级  uint8_t NVIC_IRQChannelSubPriority;\t//子/从优先级  FunctionalState NVIC_IRQChannelCmd; }NVIC_InitTypeDef;   AFIO结构体AFIO_TypeDef\n1 2 3 4 5 6  typedef struct { vu32 EVCR; vu32 MAPR; vu32 EXTICR[4];//IO复用里的外部中断配置寄存器EXTICR } AFIO_TypeDef;   EXTI初始化结构体EXTI_InitTypeDef\n1 2 3 4 5 6 7  typedefstruct { uint32_t EXTI_Line;//中断/事件线，可选EXTI0~EXTI19  EXTIMode_TypeDef EXTI_Mode;//模式选择，产生Interrupt中断或Event事件  EXTITrigger_TypeDef EXTI_Trigger;//触发方式，Rising上升沿/Falling下降沿/Rising_Falling双向  FunctionalState EXTI_LineCmd;//EXTI 使能，使能ENABLE，禁用DISABLE } EXTI_InitTypeDef;   EXTI控制寄存器定义结构体EXTI_TypeDef\n1 2 3 4 5 6 7 8 9  typedefstruct { vu32 IMR; //中断屏蔽，偏移量0x00  vu32 EMR;\t//事件屏蔽，偏移量0x04  vu32 RTSR;\t//上升沿触发选择，偏移量0x08  vu32 FTSR;\t//下降沿触发选择，偏移量0x0C  vu32 SWIER;\t//软件中断事件，偏移量0x10  vu32 PR;\t//挂起，偏移量0x14 }EXTI_TypeDef;   典型库函数\n8.7.3.2. 常用寄存器   EXTI的，所有(共6个)32位寄存器中，位[31:19]保留，位[18:0]需定义，如下(x为0~18，对应19个外部中断)\n IMR中断屏蔽寄存器，位[18:0]：MRx，线x上的中断屏蔽；0：屏蔽；1开放；开启相应线上事件触发 EMR事件屏蔽寄存器，位[18:0]：MRx，线x上的事件屏蔽；0：屏蔽；1开放；开启相应线上中断 RTSR上升沿触发选择寄存器，位[18:0]：TRx，线x上的上升沿触发配置(中断和事件)；0：禁止；1：允许；用于允许相应线上上升沿触发中断/事件 FTSR下降沿触发选择寄存器，类似RTSR，下降沿触发；若下降/上升沿同时设置，则为任意边沿触发 SWIER软件中断事件寄存器，位[18:0]：SWIERx，线x上的软件中断；为0时，写1将设置PR中相应挂起位(若IMR和EMR允许产生该中断，则此时将产生一个中断)；通过清除PR对应位(写1)，可清除该位为0；用于产生一个软件中断，效果等同于外部中断触发 PR挂起寄存器，位[18:0]：PRx，挂起位；0：未发生触发请求；1：发生所选触发请求；当外部中断线上发生了所选定边沿事件，该位被置1；向该位写1可清除其(为0)。也可通过改变边沿检测极性清除。可用于查询中断    NVIC，共有7种控制寄存器组，除IPR/IR外，其余6种/组，每组共60个有效位，每位分别对应60个可编程可屏蔽中断\n ISER中断使能寄存器组，两个字，共63位，用了60位，一个位对应一个中断，写1中断有效，写0无意义 ICER中断除能寄存器组，两个字，用了60位，类似；和使能寄存器功能相反，写1中断失效，写0无意义 ISPR中断挂起控制寄存器组，两个字，类似；写1有效，可将正在运行的中断挂起，从而执行同级别或更高级别的中断；写0 无意义 ICPR中断解挂寄存器组，两个字，类似；和挂起寄存组功能相反；写1有效，写0无意义 IABR中断激活标志位寄存器组，两个字，类似；只读，通过读取，可知哪个中断正在被执行(对应的位被置1)；中断执行完后对应位清零 IPR/IR中断优先级寄存器，15个字，共60个字节，每字节对应一个中断，高4位有效(低4位保留)，又分为抢占优先级(在前)和子优先级(在后)，各占几位需根据SCB(System Control Block Structure)中应用程序中断及复位控制寄存器AIRCR(Application Interrupt and Reset Register)的中断分组设置决定；AIRCR的PRIGROUP[10:8]用于指定优先级(即分配preemption和sub优先级，共分5组，取值及含义如前述) STIR软件触发寄存器，两个字；用于软件触发(置1)    AFIO_EXTICR1~4外部中断配置寄存器1~4\n 为将I/O口设置为外部中断入口以作为中断源，须利用GPIO复用功能，将I/O口映射到相应外部事件，即： EXTICRx(x=1~4)，可由软件读写，选择外部中断的输入源；其映射规则如下：  4个32位EXTICRx，每个仅用低16位，每4位分成1组，4个寄存器共16组，依次从低到高，对应16个I/O口(0~15)，每组的4位数取值从0~6，对应A~G      8.7.4. 小结及应用要点 中断、异常、外部中断及EXTI\n 中断指，系统停止当前正在运行的程序转到其他服务，可能是接收了(比自身优先级高的)请求，或人为设置引起 异常指，所有能打断正常执行的事件，但常指由于CPU本身故障、程序故障或请求服务等引起的错误。异常包含中断(即中断是异常的子集)，异常与中断都有硬件支持 STM32F103异常系统，含16个系统异常(也称，内核中断/异常，编号0~15，优先级为-3到6)和60个“外部中断”(M3内核的定义，编号16以上，此时，不是指EXTI中断，而是所有中断) 外部中断EXTI，概念要小得多，特指，EXTI中断。NVIC支持19个EXTI中断/事件请求(即19条外部中断线)，线0~15：对应外部I/O口输入中断；线16~18：特定中断。每个PAx~PGx均可被配置为外部中断源输入 STMF10x架构里，常把非EXTI的其他中断(如外设TIM/USART/DMA/ADC等产生的中断)称为内部中断，以示区分  EXTI中断向量及中断服务函数\n EXTI外部IO输入中断源在中断向量表中只分配7个中断向量(即只能使用7个中断服务函数) 外部中断线5~9分配一个中断向量，共用一个服务函数；外部中断线10~15分配一个中断向量，共用一个中断服务函数；外部中断线0~4则各自单独使用一个中断服务函数  相应中断服务函数名称(在启动文件startup_stm32f10x_hd.s中)：EXTI0_IRQHandler；EXTI1_IRQHandler；EXTI2_IRQHandler；EXTI3_IRQHandler；EXTI4_IRQHandler；EXTI9_5_IRQHandler；EXTI15_10_IRQHandler\n配置及应用外部中断步骤要点\n 初始化I/O口为复用AFIO输入GPIO_Init 开启I/O口复用时钟RCC_APB2PeriphClockCmd 设置I/O口与中断线映射关系GPIO_EXTILineConfig 初始化线上终端，设置触发条件EXTI_Init 配置中断分组NVIC_PriorityGroup，使能中断NVIC_Init 编写中断服务函数EXTIx_IRQHandler 清除中断标志位EXTI_ClearITPendingBit  EXTI及NVIC的初始化\n1 2 3 4 5 6 7 8 9 10 11  void EXTI_Config (void) { EXTI_InitTypeDef EXTI_InitStructure; RCC_APB2PeriphClockCmd (RCC_APB2Periph_AFIO, ENABLE) ; GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource5); EXTI_InitStructure.EXTI_Line= EXTI_Line5; EXTI_InitStructure.EXTI_Mode= EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger=EXTI_Trigger_Falling; EXTI_InitStructure.EXTI_LineCmd= ENABLE; EXTI_Init(\u0026amp;EXTI_InitStructure); }   1 2 3 4 5 6 7 8 9 10 11  void NVIC_Config (void) { NVIC_InitTypeDef NVIC_InitStructure; NVIC_PriorityGroupConfig (NVIC_PriorityGroup_1) ; NVIC_InitStructure.NVIC_IRQChannel= EXTI9_5_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority= 0; NVIC_InitStructure.NVIC_IRQChannelSubPriority= 1; NVIC_InitStructure.NVIC_IRQChannelCmd= ENABLE; NVIC_Init( \u0026amp;NVIC_InitStructure) ; }   中断服务程序\n1 2 3 4 5 6 7 8 9 10 11 12  void EXTI9_5_IRQHandler(void) { unsigned char temp=LED0_IsOn () ; if (EXTI_GetITStatus (EXTI_Line5) ! = RESET) { if (temp) LED0_Off (); else LED0_On(); EXTI_ClearITPendingBit (EXTI_Line5) ; } }   8.8. USART 8.8.1. 主要特性  USART1位于APB2上，其他USART和UART位于APB1上 全功能可编程串行接口特性：数据位(8/9位)；校验位(奇/偶/无)；停止位(1/2位)；支持硬件流控制(CTS和RTS) 可编程波特率发生器(整数12位，小数4位)，最高速率4.5Mbps 两个独立带中断标志位：发送TXE(发送数据寄存器空)和接收RXNE(接收数据寄存器非空) 支持DMA传输：发送/接收DMA请求 单线半双工通信；多处理器通信 LIN主发送同步断开符及从检测断开符能力(配置成LIN时，生成13位断开符、检测10/11位断开符) 智能卡模拟功能：支持异步智能卡协议  8.8.2. 内部结构 相关引脚简介\n TX，发送数据输出引脚 RX，接收数据输入引脚 SW_RX，数据接收引脚，只用于单线和智能卡模式，属于内部引脚，没有具体外部引脚 nRTS，请求以发送(Request To Send)，n表示低电平有效。如果使能RTS流控制，当USART 接收器准备好接收新数据时就会将nRTS 变成低电平；当接收寄存器已满时，nRTS 将被设置为高电平。该引脚只适用于硬件流控制 nCTS，清除以发送(Clear To Send)，n表示低电平有效。如果使能CTS 流控制，发送器在发送下一帧数据之前会检测nCTS 引脚，如果为低电平，表示可以发送数据；如果为高电平，则在发送完当前数据帧之后停止发送。该引脚只适用于硬件流控制 IRDA_OUT，输出引脚，用于发送红外数据 IRDA_IN，输入引脚，用于接收红外数据 SCLK，发送器时钟输出引脚，仅适用于同步模式  数据发送过程\n 内核指令或DMA外设先将数据从内存(变量)写入发送数据寄存器TDR 发送控制器适时地自动把数据从TDR加载到发送移位寄存器，将数据一位一位地通过Tx引脚发送出去 当数据完成从TDR到发送移位寄存器的转移后，会产生TDR已空事件TXE 当数据从发送移位寄存器全部发送到Tx后，会产生数据发送完成事件TC；可在SR中查询这些事件  数据发送，须设置相关寄存器各位，过程如下：\n CR1.UE置位1，激活USART CR1.M定义字长 CR2.STOP定义停止位位数 若采用多缓冲器通信，配置CR3.DMAT使能DMA 利用BRR选择波特率 置位CR1.TE，发送一个空闲帧作为第一次数据发送 将要发送数据写入DR(此动作会清除SR.TXE)；一个缓冲区情况下，重复7  数据接收过程\n 数据从Rx引脚一位一位地输入到接收移位寄存器中 接收控制器自动将接收移位寄存器的数据转移到接收数据寄存器RDR中 内核指令或DMA将RDR数据读入内存(变量)中。接收移位寄存器数据转移到RDR后，会产生RDR非空/已满事件RXNE  配置过程：\n CR1.UE置位1，激活USART CR1.M定义字长 CR2.STOP定义停止位位数 若采用多缓冲器通信，配置CR3.DMAT使能DMA 利用BRR选择波特率 置位CR1.RE，激活接收器，开始寻找起始位 接收到一个字符时，SR.RXNE被置位，并产生中断(已使能时，即CR1.RXNEIE=1)；若检测到帧/溢出/噪声错误，相应标志会置位(供查询) SR.RXNE清零(多缓冲由DMA读SR/单缓冲由软件读SR/通过对其写0:完成),须在下一字符接收结束前完成,避免溢出错  8.8.3. USART中断 8.8.4. 相关库函数及寄存器 8.8.4.1. 库函数 常用库函数\n存放于stm32f10x_usart.h和stm32f10x_usart.c文件中\n USART_DeInit将USARTx寄存器恢复为复位启动时默认值 USART_Init根据USART_InitStruct中指定参数初始化USART寄存器 USART_StructInit把USART_InitStruct中的每个参数按默认值填入 USART_Cmd使能或禁止指定USART USART_SendData通过USART发送单个数据 USART_ReceiveData返回指定USART最近接收到数据 USART_GetFlagStatus查询指定USART标志位状态 USART_ClearFlag清除指定USART标志位 USART_ITConfig使能或禁止指定USART中断 USART_GetITStatus查询指定USART中断是否发生 USART_ClearITPendingBit清除指定USART中断挂起位 USART_DMACmd使能或禁止指定USART的DMA请求  初始化结构体\nUSART初始化结构体USART_InitTypeDef\n1 2 3 4 5 6 7 8 9 10 11 12 13  typedefstruct { uint32_t USART_BaudRate; //波特率  uint16_t USART_WordLength;//传输字长=数据+检验位数：8b/9b  uint16_t USART_StopBits;//停止位数：1、1_5、2、0_5  uint16_t USART_Parity; //校验：No无；Odd奇；Even偶  uint16_t USART_HardwareFlowControl;//硬件流控：None无；RTS请求发送；CTS清除发送；RTS_CTS发送和接收都用流控  uint16_t USART_Mode;//模式(可组合)：Tx发送；Rx接收  uint16_t USART_Clock;//时钟使能：Enable高；Disable低  uint16_t USART_CPOL;//SLCK引脚时钟输出极性：High高；Low低  uint16_t USART_CPHA;//SLCK引脚时钟输出相位，配合CPOL产生时钟/数据采样关系：1Edge时钟第一个边沿数据捕获；2Edge第二个  uint16_t USART_LastBit;//同步模式下，SLCK输出最后一位数据对应时钟脉冲使能：Enable最后一位数据的时钟脉冲从SLCK输出；Disable不输出 } USART_InitTypeDef;   典型库函数\n例：需设置参数为波特率，字长，停止位，奇偶校验位，硬件数据流控制，模式（收/发）\n1 2 3 4 5 6  USART_InitStructure.USART_BaudRate = bound; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.USART_Parity = USART_Parity_No; USART_InitStructure.USART_HardwareFlowControl= USART_HardwareFlowControl_None; USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; USART_Init(USART1, \u0026amp;USART_InitStructure); //初始化串口   在接收到数据时(RXNE读数据寄存器非空)，要产生中断，开启中断方法：\n1  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);   在发送数据结束时(TC发送完成)，要产生中断，开启中断方法：\n1  USART_ITConfig(USART1,USART_IT_TC, ENABLE);   某中断发生时，会置位SR中某标志位，中断处理函数中，可调用此函数判断该中断是否发生。如，串口发送完成时，产生中断，对其判断：\n1  USART_GetITStatus(USART1, USART_IT_TC)   若返回值是SET，说明中断发生判断读寄存器是否非空(RXNE)：\n1  USART_GetFlagStatus(USART1, USART_FLAG_RXNE);   判断发送是否完成(TC)：\n1  USART_GetFlagStatus(USART1, USART_FLAG_TC);   8.8.4.2. 常用寄存器 共7个：状态寄存器SR、数据寄存器DR、波特率寄存器BRR、控制寄存器CR1~3、保护时间和预分频寄存器GTPR\n  SR，标识USART各种状态，均由硬件置位，大都由软件序列(先读SR，再相关读写)清零，部分状态标志被置1同时会产生中断(已使能时)\n  DR，包含发送或接收的数据，接收时称为RDR，发送时称为TDR(二者共用一片物理空间)，提供内部总线和输入/输出移位寄存器间的并行接口，因此兼具读写功能。仅低9位[8:0]有效(其他位保留)。使能校验位(CR1.PCE=1)时：发送，写入MSB值(根据数据长度不同，MSB是第7位或第8位)被校验位取代；接收，读到的MSB值是校验位\n  BRR，装载分频器整数和小数部分；若TE或RE分别被禁止，波特计数器停止计数；其中，DIV_Fraction[3:0] 定义USARTDIV小数部分；DIV_Mantissa[15:4]为整数；其余位保留\n  CR1 ，多由软件置位/清零(除：RWU及SBK，硬件也可复位)\n  8.8.5. 小结及应用要点 8.8.5.1. 库函数开发STM32F103外设过程 初始化外设PPP\n 常置于主函数main的无限循环体外，上电复位进入main时，执行一次 可分为配置PPP复用引脚和配置PPP两步；每步又可分为使能时钟(片上外设，均须先打开其时钟才能使用)和参数设置(通过设置对应结构体成员实现)两小步 (以外设名开头的)各种结构体PPP_InitTypeDef，用以配置各种不同外设(涵盖外设特牲和功能)  操作外设PPP\n外设PPP输入/输出，常置于main的无限循环体或相应中断服务函数中；运行期间，条件满足时将反复执行\n8.8.5.2. STM32F10x标准外设库函数的分类和命名  各种外设PPP(PPP可为GPIO、TIM、NVIC、EXTI、USART、SPI和I2C、DMA、ADC等)通常都包含以下函数，每个函数的输入参数，均包含PPPx(意为指定的外设PPPx，是外设PPP的细分表示，PPP若是GPIO，PPPx可以是GPIOA、GPIOB、GPIOC等；PPP若是TIM，PPPx可以是TIM1、TIM2等) PPP_DeInit以系统默认参数初始化PPPx的寄存器 PPP_Init根据PPP_InitTypeDef结构体变量中指定参数初始化PPPx的寄存器；输入参数：PPP_InitStruct，指向PPP_InitTypeDef结构体变量的指针，包含PPPx配置信息 PPP_Cmd使能/禁止PPPx；输入参数：NewState，PPPx的新状态(ENABLE，使能PPPx；DISABLE，禁止) PPP_SendData通过PPPx发送数据(常见于USART、SPI和I2C等外设)；输入参数：Data，待发送的数据 PPP_ReceiveData返回PPPx最新收到数据(常见同上)；返回值：PPPx最新收到数据 PPP_GetFlagStatus查询PPPx的指定标志位；输入参数：PPP_FLAG，PPPx的指定(待查询)标志位；返回值：最新状态(SET或RESET，即1/0) PPP_ClearFlag清除PPPx的指定标志位；输入参数：PPP_FLAG，PPPx的指定(待清除)标志位 PPP_ITConfig使能或禁止PPPx的指定中断；输入参数：PPP_IT，待使能或禁止的PPPx中断源；NewState，新状态(ENABLE，使能；DISABLE，禁止)  8.8.5.3. USART配置的一般步骤  GPIO时钟及串口时钟使能RCC_APB2PeriphClockCmd 串口复位(非必须)USART_DeInit GPIO端口模式(Rx/Tx)设置GPIO_Init；引脚复用映射(非必须)GPIO_PinAFConfig 串口初始化USART_Init 开启中断并初始化NVIC(非必须)NVIC_Init；USART_ITConfig 使能串口USART_Cmd 编写中断处理函数(非必须)USARTx_IRQHandler 串口数据收/发USART_ReceiveData；USART_SendData 串口传输状态获取(并判断处理)USART_GetFlagStatus；USART_ClearITPendingBit  8.8.5.4. 注意事项  中断处理函数中，一般先判断中断状态位，再进行后续处理 应用中串口可能设置不止一处中断(但每个中断进入的中断处理函数相同)可用USART_GetITStatus读取状态位以区分 发送/接收数据后通常也需判断(通过读取状态标志实现) 串口传输时，通过软件读/写数据(即DR)，会相应清零SR.RXNE/SR.TXE/SR.TC；直接向该位写0，也可清除SR.RXNE/SR.TC 接收数据：Rx引脚设置为浮空，适于在高/低电平间被动地快速转换，其状态由发送端传来的电平高低决定；发送数据：Tx引脚设置为推挽输出 发送数据即，往TDR中写数据(赋值语句)，然后TDR(通过并行通信)将数据传给移位寄存器，此时SR.TXE会置1，再后，移位寄存器一位一位发送，完毕时若TDR为空(即未写入新数据)，即SR.TXE仍为1，说明发送过程全部完成，则SR.TC置1硬件流量控制(RTS/CTS流)实质即握手通信，控制数据传输过程，防止数据丢失USART相比UART的增强主要在同步模式下能提供时钟(来触发数据传输)同步模式下，SCLK同Tx引脚联合工作，需配置CR2.LBCL位、CR2.CPOL位、CR2.CPHA位  8.9. SPI 8.9.1. SPI工作原理 可与外部设备以半双工/全双工、同步、串行方式通信(含CRC)；使用一条双向数据线的双线单工同步传输\n常为主模式(可多主)，为各从设备提供通信时钟SCK\n主要应用于：EEPROM，FLASH，实时时钟，AD转换器，数字信号处理器和解码器等\n8.9.1.1. 主要特性  SPI1位于高速API2总线上，SPI2、SPI3位于APB1上 可作为SPI主设备或从设备 主/从模式下均可由软件/硬件进行NSS管理，动态改变主/从操作模式 可编程的SPI时序，由时钟极性和时钟相位决定 可编程SPI数据格式，8/16位数据帧，LSB或MSB在前的数据顺序 可编程SPI传输速率(最高18MHz) 可触发中断的两个标志位：发送标志位TXE(发送缓冲区空)和接收标志位RXNE(接收缓冲区非空) 支持DMA功能的1B发送和接收缓冲区，分别产生发送和接收请求 带或不带第三根双向数据线的双线单工同步传输 支持以多主配置方式工作  8.9.1.2. 内部结构 8.9.1.3. SPI主模式 作为主设备，产生SCK时钟信号；MOSI输出，MISO输入\n配置步骤\n 设置串行时钟波特率CR1.BR[2:0] 设置SPI协议CR1.CPOL和CR1.CPHA 设置数据格式CR1.DFF和CR1.LSBFIRST 设置NSS工作模式：  NSS作为输出：置位CR2.SSOE位(可调用SPI_SSOutputCmd实现)时，开启主模式下NSS输出(输出低电平)，此时，当其他SPI的NSS引脚与其相连，会收到低电平，即片选成功，成为从设备 NSS作为输入：硬件模式下，整个数据帧传输期间应把NSS脚连接到高电平；软件模式下，需将CR1.SSM和CR1.SSI置1；此时，NSS引脚被释放出来，可作他用(如，可作为普通GPIO引脚，驱动从设备片选信号)   设置CR1.MSTR和CR1.SPE：仅当NSS脚连到高电平，这些位才能保持置位  数据发送过程\n 数据被程序写入至发送缓冲区时，发送过程开始 发送第一个数据位时，数据通过内部总线被并行传入移位寄存器 根据指定顺序(MSB或LSB在先)串行地移出到MOSI脚上 当数据完成从发送缓冲区到移位寄存器的传输时，SR.TXE被置位，并产生中断(若CR2.TXEIE已被置1) 一旦传输开始，若下一个将发送的数据被放进了发送缓冲器，就可维持一个连续传输流  数据接收过程\n MISO上数据位随SCK一位位依次传入移位寄存器 SCK最后一个采样边沿后，SR.RXNE标志被置位，移位寄存器中接收到的数据被全部传送到接收缓冲区，并产生中断(若CR2.TXEIE已被置1) 读取DR时，得到接收缓冲区数值，并清除SR.RXNE  小结\n SPI主模式最为常用，通过MOSI引脚发送数据同时，也会在另一引脚MISO上收到来自SPI从设备发来的数据 若只对SPI从设备进行写操作，将接收到字节忽略即可 若要对SPI从设备进行读操作，须发送一个空字节来触发从设备的数据传输  8.9.1.4. SPI从模式 作为从设备，SCK接收主设备时钟，MOSI输入，MISO输出\n主设备发送时钟前，应先使能从设备(否则可能会发生意外的数据传输)，且通信时钟第一个边沿到来之前或正进行的通信结束之前，从设备的数据寄存器须就绪\n配置步骤\n 设置SPI协议CR1.CPOL和CR1.CPHA(须和主设备配置相同，保证正确数据传输) 设置数据格式CR1.DFF和CR1.LSBFIRST(和主设备配置相同) 设置NSS工作模式：  NSS只能作为输入(不能作为输出) 硬件模式下，在完整的8/16位数据帧传输过程中，NSS引脚须为低电平 软件模式下，需置位CR1.SSM并清除CR1.SSI   清除CR1.MSTR，置位CR1.SPE,引脚工作于SPI模式下  数据发送过程\n 数据先被并行地写入发送缓冲区 收到时钟信号SCK并在MOSI引脚上出现第一个数据位时，数据发送过程开始(此时第一个位被发送出去) 余下的位(对于8位数据帧格式，还有7位；对于16位数据帧格式，还有15位)被装进移位寄存器 发送缓冲区中数据完成向移位寄存器的传输时，SR.TXE被置位，并会产生中断(若CR2.TXEIE已被置位)  数据接收过程\n MISO引脚上数据位随时钟SCK被一位一位依次传入移位寄存器，并转入接收缓冲区 SCK最后一个采样时钟边沿后，SR.RXNE被置位，移位寄存器中接收的数据被全部传送到接收缓冲区(若CR2.RXNEIE已被置1)并产生中断 读取DR时，得到接收缓冲区数值，并清除SR.RXNE  8.9.1.5. SPI状态标志和中断 状态标志\n TXE(发送缓冲区空闲标志)；被置位1时，表示发送缓冲区为空(可写下一个待发送数据进入发送缓冲区中)；写DR时，该标志被清0；写发送缓冲区前，应确认SR.TXE被置位 RXNE(接收缓冲区非空标志)；被置位1时，表示接收缓冲区中包含有效接收数据；读DR时，该标志被清0 BSY(忙标志)；由硬件设置与清除(对该位执行写操作无任何效果)；被置位1时，表示SPI正忙于通信(有一例外：主模式的双向接收模式下，接收期间BSY保持为低)；软件要关闭SPI并进入停机模式(或关闭设备时钟)前，可用BSY检测传输是否结束(避免破坏最后一次传输)  SPI中断\n同一SPI各种中断事件都被连接到同一中断向量，不同SPI有不同中断向量\n中断事件中，最常用：\n TXE(发送缓冲区空闲中断请求)；数据完成从发送缓冲区到移位寄存器的转换和传输时，SR.TXE标志被置位；此时，若设置了CR2.TXEIE，将产生中断 RXNE(接收缓冲区非空中断请求)；移位寄存器中接收到的数据字节被全部转换并传送到接收缓冲区时，SR.RXNE标志被置位；此时，若设置了CR2.RXNEIE，将产生中断  8.9.1.6. SPI发送/接收数据 8.9.2. SPI相关库函数及寄存器 8.9.2.1. 库函数 常用库函数\n存放于stm32f10x_spi.h和stm32f10x_spi.c中\n SPI_I2S_DeInit将SPI寄存器恢复为复位启动时默认值 SPI_Init根据SPI_InitStruct中指定参数初始化指定SPI寄存器 SPI_StructInit把SPI_InitStruct每个参数按默认值填入 SPI_Cmd使能或禁止指定SPI SPI_I2S_SendData通过SPI发送单个数据 SPI_I2S_ReceiveData返回指定SPI最近接收到的数据 SPI_I2S_GetFlagStatus查询指定SPI标志位状态 SPI_I2S_ClearFlag清除指定SPI标志位 SPI_I2S_ITConfig使能或禁止指定的SPI中断 SPI_I2S_GetITStatus查询指定的SPI中断是否发生 SPI_I2S_ClearITPendingBit清除指定SPI中断挂起位 SPI_I2S_DMACmd使能或禁止指定SPI的DMA请求  初始化结构体\nSPI初始化结构体SPI_InitTypeDef\n1 2 3 4 5 6 7 8 9 10 11 12  typedefstruct { uint16_t SPI_Direction;//通讯方向：2Lines_FullDuplex双线全双工；2Lines_RxOnly双线只接收；1Line_Rx单线只接收；1Line_Tx单线只发送  uint16_t SPI_Mode;//主/从模式：Master主模式；Slave从模式  uint16_t SPI_DataSize;//数据帧长度：8b，8位；16b，16位  uint16_t SPI_CPOL;//时钟极性：High高电平；Low低电平  uint16_t SPI_CPHA;//时钟相位：1Edge奇/前沿采样；2Edge偶/后沿  uint16_t SPI_NSS;//NSS引脚使用：Hard硬件控制模式；Soft软件  uint16_t SPI_BaudRatePrescaler;//时钟分频因子：2/4/8/.../128/256  uint16_t SPI_FirstBit;//先行：MSB高位数据在前；LSB低位在前  uint16_t SPI_CRCPolynomial;// CRC校验表达式：大于1整数即可 }SPI_InitTypeDef;   典型库函数\n1 2 3 4 5 6 7 8 9 10 11  SPI_InitTypeDef*SPI_InitStructure; SPI_InitStructure.SPI_Direction=SPI_Direction_2Lines_FullDuplex;//双线双向全双工 SPI_InitStructure.SPI_Mode=SPI_Mode_Master;//主SPI SPI_InitStructure.SPI_DataSize=SPI_DataSize_8b;//SPI发送接收8位帧结构 SPI_InitStructure.SPI_CPOL=SPI_CPOL_High;//串行同步时钟空闲状态高电平 SPI_InitStructure.SPI_CPHA=SPI_CPHA_2Edge;//第二个跳变沿数据被采样 SPI_InitStructure.SPI_NSS=SPI_NSS_Soft;//NSS信号由软件控制 SPI_InitStructure.SPI_BaudRatePrescaler=SPI_BaudRatePrescaler_256; SPI_InitStructure.SPI_FirstBit=SPI_FirstBit_MSB; //数据传输从MSB位开始 SPI_InitStructure.SPI_CRCPolynomial=7;//CRC值计算的多项式 SPI_Init(SPI2,\u0026amp;SPI_InitStructure); //由上述参数初始化SPIx寄存器   8.9.2.2. 常用寄存器 8.9.3. SPI小结与应用要点 SPI配置一般步骤\n 配置相关引脚(复用)功能GPIO_Init 使能SPIx时钟RCC_APB2PeriphClockCmd 初始化SPIx，设置工作模式SPI_Init SPIx使能SPI_Cmd SPI传输数据SPI_I2S_SendData；SPI_I2S_ReceiveData 查看SPI传输状态SPI_I2S_GetFlagStatus  注意事项\n SPI两个设备间通信须由主设备Master来控制从设备Slave 主设备：通过SCK(信号由处理器总线时钟获得，自动产生8个时钟周期)引脚提供时钟给主/从设备；利用(从设备的片选)NSS引脚(低电平)控制选中多个从设备(主设备不同GPIO可连接驱动多个从设备NSS，非同时选中) 时钟信号通过时钟极性CR1.CPOL和时钟相位CR1.CPHA，控制两个SPI设备间数据交换及采样接收数据方式(共4种组合：上升沿/下降沿+前沿/后沿触发)，保证数据同步传输 SPI设备间数据传输实质为数据交换：每个时钟周期，每个SPI设备都会发送并接收一位数据(而非仅发送或接收)，即一次交换一位数据(没有读写说法，发一位数据必会收到一位数据；要收一位数据必须也要先发一位数据) MISO/MOSI/SCK/NSS引脚默认对应GPIOA的PA6/PA7/PA5/PA4引脚   主从设备环形总线结构，可构成数据链路回环DataLoop 优点：支持全双工，推挽驱动性能比开漏完整性更好；支持高速；字长不限于8位(可灵活选择)；硬件连接简单 缺点：比I2C多两根线；无寻址机制，靠片选选择不同设备；从设备接收无ACK(主设备不知发送是否成功)；典型应用只支持单主控；相比RS232/RS485/CAN总线，传输距离短  8.10. I^2^C 8.10.1. I^2^C工作原理 8.10.1.1 主要特性  所有I^2^C都位于APB1总线 支持标准100kbps和快速400kbps两种传输速率 可工作于主模式或从模式，可作为主发送器、主接收器、从发送器或从接收器 支持7位或10位寻址和广播呼叫 3个状态标志：发送器/接收器模式标志、字节发送结束标志、总线忙标志 2个中断向量：地址/数据通信成功；错误(处理) 具有单字节缓冲器的DMA 兼容系统管理总线SMBus 2.0  8.10.1.2. 内部结构 8.10.1.3. I^2^C主/从模式  I^2^C默认工作模式为从模式，当生成起始信号后，自动地由从模式切换到主模式 两种模式下，都可作为发送器或接收器(由SR2.TRA位标识)因此共有4种(主/从+收发器/发送器)  S：起始信号(Start) Sr：重复的起始信号(Start repeat) A：应答信号(Acknowledgement) NA：非应答信号(Non-Acknowledgement) P：停止信号(Pause) EV：表示事件(Event)；若此时12C_CR2的ITEVFEN=1，则产生中断 EV5：SR1.SB=1，读SR1然后将地址写入DR清除该事件 EV6：SR1.ADDR=1，地址发送结束，读SR1然后读SR2清除该事件 EV8_1：SR1.TXE=1，移位寄存器空，DR空，写DR EV8：SR1.TXE=1，移位寄存器非空，DR空，写入DR将清除该事件 EV8_2：SR1.TXE=1，SR1.BTF=1，请求设置停止位，产生停止条件时由硬件清除 EV9：SR1.ADD10=1，读SR1然后写入DR清除该事件    主发送器发送流程及事件说明：\n 控制产生起始信号S，发送S后，产生事件EV5(并会对SR1.SB置1，表示起始信号已经发送) 发送设备地址并等待应答信号，若有从机应答，则产生事件EV6及EV8(此时SR1.ADDR及SR1.TXE被置1，表示地址已经发送及数据寄存器为空) 对SR1.ADDR清零后，待发送数据写入DR(SR1.TXE被重置0,表示数据寄存器非空)，通过SDA一位位发送数据，完毕，产生EV8事件(SR1.TXE被置1),重复此过程，可发送多个字节数据 发送数据完成后，主设备发出一个停止信号P，产生EV8_2 事件(SR1.TXE及SR1.BTF均被置1，表示通信结束)  8.10.1.4. I^2^C中断 8.10.2. I^2^C相关库函数及寄存器 8.10.2.1. 常用库函数 存放于stm32f10x_i2c.h和stm32f10x_i2c.c中\n I2C_DcInit将I^2^Cx的寄存器恢复为复位启动时默认值 I2C_Init根据I2C_InitStruct中指定的参数初始化指定I^2^C的寄存器 I2C_Cmd使能或禁止指定I^2^C I2C_GenerateSTART产生I^2^Cx传输的起始信号 I2C_Send7bitaddress发送地址信息选中指定的I^2^C从设备 I2C_SendData通过I^2^C发送单字节数据 I2C_ReceiveData返回指定I^2^C最近接收到的字节数据 I2C_CheckEvent查询I^2^Cx最近一次发生的事件是否是I^2^C_EVENT指定的事件 I2C_AcknowledgeConfig使能或者禁止指定I^2^C的应答功能 I2C_GenerateSTOP产生I^2^Cx传输的结束信号 I2C_GetFlagStatus查询指定I^2^C的标志位状态 I2C_ClearFlag清除指定I^2^C的标志位 I2C_ITConfig使能或禁止指定的I^2^C中断 I2C_GetITStatus查询指定的I^2^C中断是否发生 I2C_ClearITPendingBit清除指定的I^2^C中断请求挂起位 I2C_DMACmd使能或禁止指定I^2^C的DMA请求  8.10.2.2. 初始化结构体 I^2^C初始化结构体I2C_InitTypeDef\n1 2 3 4 5 6 7 8 9  typedefstruct { uint16_t I2C_InitStructure.I2C_ClockSpeed;//时钟频率，标准100K;快速400K  uint16_t I2C_InitStructure.I2C_Mode;//工作模式，I2C，I2C模式；SMBusDevice，SMBus设备模式；SMBusHost，SMBus主控模式  uint16_t I2C_InitStructure.I2C_DutyCycle;//快速模式下,占空比,16_9,2  uint16_t I2C_InitStructure.I2C_OwnAddress1;//第一个设备自身地址，7/10位  uint16_t I2C_InitStructure.I2C_Ack;//使能或禁止ACK，Enable;Disable  uint16_t I2C_InitStructure.I2C_AcknowledgedAddress;//应答7/10位地址 }I2C_InitTypeDef;   8.10.2.3. 典型库函数 1 2 3 4 5 6 7 8 9  I2C_InitTypeDef* I2C_InitStructure; I2C_InitStructure.I2C_Mode=I2C_Mode_I2C; I2C_InitStructure.I2C_DutyCycle=I2C_DutyCycle_2; I2C_InitStructure.I2C_ClockSpeed=I2C_Standard_Speed; I2C_InitStructure.I2C_OwnAddress1 = 0x00; I2C_InitStructure.I2C_Ack = I2C_Ack_Enable; I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit; I2C_Init(I2C1,\u0026amp;I2C_InitStructure);//初始化 I2C_Cmd(I2C1,ENABLE);//使能I2C   8.10.3. I^2^C小结及应用要点 I^2^C配置的一般步骤\n 配置相关引脚(复用)功能GPIO_Init 使能I2Cx时钟RCC_APB1PeriphClockCmd 初始化I2Cx，设置工作模式I2C_Init I2Cx使能I2C_Cmd 发起始信号及地址I2C_GenerateSTART；I2C_Send7bitaddress I2C传输数据I2C _SendData；I2C _ReceiveData 查看I2C传输状态I2C_GetFlagStatus  I^2^C应用要点及细节\n I^2^C串行总线有两根信号线：一根双向数据线SDA、一根时钟线SCL 所有I^2^C设备的SDA都接到总线的SDA上，SCL接到总线的SCL上；各设备须是漏极/集电极开路OC/OD输出 总线的运行(数据传输)由主机控制 主机，指启动数据传送(发出启动信号)、发出时钟信号及传送结束时发出停止信号的设备(常为微处理器) 每个设备均有一唯一地址(便于主机寻访) 发送数据到总线的设备称为发送器，从总线接收数据的设备称为接收器 I^2^C总线上允许连接多个微处理器及各种设备(如存储器、LED、LCD、A/D、D/A等) 任一时刻总线只能由某一主机控制以保证数据可靠传送 数据从最高位开始，传输序列：(主机)开始S→地址Address→读写R/W→得到应答A→数据Data→应答A→\u0026hellip;→停止P SCL=1(高电平)时，SDA不要随便跳变(下跳视为“起始信号S”，上跳视为“停止信号P”)，即数据传输时应保持稳定 SCL须由主机发送，从机收到/听到自己地址时才能发送应答信号(必须应答)表示在线，其他地址从机则禁止应答；如果是广播状态(即主机对所有从机呼叫，0号地址为群呼地址)，此时从机只能接收不能发送 常用I^2^C接口器件地址由器件类型码(4位，公司固定)+寻址码(3位，用户定义)组成，共7位，称为从地址 I^2^C总线须通过合适上拉电阻接电源正极(总线空闲时，两根线均为高电平) 应用时，最好将I2C中断优先级提升到最高，工作模式是中断/DMA(或两者结合)而非查询POLLING；程序中应加入有效容错机制(如：总线状态判断、超时处理、应答机制、事件及状态标志的查询清除处理等) I^2^C与SPI区别：I^2^C数据输入/输出用同一根线，SPI输入输出分开；I^2^C占用端口更少，但因数据线双向，隔离与协议较复杂，SPI较易；一般系统内部通信用I^2^C，外部通信最好用SPI带隔离(提高抗干扰能力)  附录 中英文术语对照表    英文简称 英文全称 中文译名     ENIAC Electronic Numerical Integrator And Calculator 电子数字积分器和计算器   EDVAC The Electronic Discrete Variable Automatic Computer 离散变量自动电子计算机   EDSAC Electronic Delay Storage Automatic Calculator 存储程序式电子计算机   PA Physic Address 物理地址   ALU Arithmetic and Logic Unit 算术逻辑单元   IR Instruction Register 指令寄存器   ID Instruction Decoder 指令译码器   OC Instruction Controller 指令控制器   LSI Large Scale Integrated 大规模集成电路   VLSI Very Large Scale Integration 甚大规模集成电路   ULSI Ultra Large Scale Integration 超大规模集成电路   EMPU Embedded Microprocessor Uni 嵌入式微处理器   EMCU Embedded Microcontroller Unit 嵌入式微控制器   DSP Digital Signal Processor 数字信号处理器   SOC System On Chip 片上系统   SOPC System on a Programmable Chip 可编程片上系统   CISC Complex Instruction Set Computer 复杂指令集计算机   RISC Reduced Instruction Set Computer 简化指令集计算机   RAM Random Access Memory 随机存取存储器   DRAM Dynamic Random Access Memory 动态随机存取存储器   ACC Accumulator 累加器   FR Flag Register 标志寄存器   PSR Program State Register 程序状态寄存器   PSW Program State Word 程序状态字   CU Control Unit 控制单元   EU Execution Unit 执行单元   ISA Instruction Set Architecture 指令集架构   PC Program Counter 程序计数器   EPIC Explicitly Parallel Instruction Computers 精确并行指令计算机   IPC Instruction Per Clock 每一时钟周期内所执行的指令多少   BTB Branch Target Buffer 转移/分支目标缓冲器   SISD Single Instruction Single Data 单指令流单数据流   SIMD Single Instruction Multiple Data 单指令流多数据流   CMP Chip Multiprocessor 片上多处理器   VA Virtual Address 虚拟地址   JTAG Joint Test Action Group 联合测试组   EPI Energy Per Instruction 每条指令的耗能   MIPS Million Instructions Per Second 单字长定点指令平均执行速度   ROM Read Only Memory 只读存储器   DRAM Dynamic Random Access Memory 动态随机存取存储器   SRAM Static Random Access Memory 静态随机存取存储器   EEPROM Electrically Erasable Programmable Read Only Memory 电可擦除可编程只读存储器   IDE Integrated Device Electronics 电子集成驱动器   ATA Advanced Technology Attachment 高级技术连接   SCSI Small Computer System Interface 小型计算机系统接口   SATA Serial ATA 串行ATA   SAS Serial Attached SCSI 串行连接SCSI接口   eMMC embedded Multi Media Card 嵌入式多媒体卡   UFS Universal Flash Storage 通用闪存存储   RAS Row Address Strobe 行地址选通信号   CAS Column Address Strobe 列地址选通信号   PLD Programmable Logical Device 可编程逻辑器件   SPD Serial Presence Detect 模组存在的串行检测   FPM Fast Page Mode 快速页面模式   EDO Extended Data Out 扩展数据输出   SDRAM Synchronous DRAM 同步动态随机存取内存   MMU Memory Manage Unit 内存管理单元   DMA Direct Memory Access 直接存储访问   AMBA Advanced Microcontroller Bus Architecture 高级微控制器总线架构   AHB Advanced High-performance Bus 高级高性能总线   ASB Advanced System Bus 高级系统总线   APB Advanced Peripheral Bus 高级外设总线   PCI Peripheral Component Interconnect 外部设备互连   NVIC Nested Vectored Interrupt Controller 嵌套中断控制器   IVT Interrupt Vector Table 中断向量表   SPI Serial Peripheral Interface 串行外设接口   I^2^C Inter Integrated Circuit 集成电路总线   ISA Instruction Set Architecture 指令集体系结构   TCM Tightly Coupled Memory 紧耦合内存   WIC Wake-up Interrupt Controller 唤醒中断控制器   PMU Power Management Unit 电源管理单元   ETM Embedded Trace Macro-cell 嵌入式跟踪宏单元   ITM Instrumentation Trace Macro-cell 指令跟踪宏单元   DWT Data Watchpoint and Trace 数据观察点和跟踪单元   FPB Flash Patch and Breakpoint Unit Flash地址重载和断点单元   TPIU Trace Port Interface Unit 跟踪端口接口单元   SCS System Control Space 系统控制空间   CMSIS Cortex Microcontroller Software Interface Standard 微控制器软件接口标准   SCB System Control Block 系统控制块   CCR Configuration Control Register 配置控制寄存器   DBM Data Memory Barrier 数据存储器屏障   DSB Data Synchronization Barrier 数据同步屏障   ISB Instruction Synchronization Barrier 指令屏障   MSP Main Stack Pointer 主栈指针   PSP Process Stack Pointer 进程栈指针   ISER Interrupt Set-enable Registers 中断设置使能寄存器   ICER Interrupt Clear-enable Registers 中断清除使能寄存器   ISPR Interrupt Set-pending Registers 中断设置挂起寄存器   ICPR Interrupt Clear-Pending Registers 中断清除挂起寄存器   IABR Interrupt Active Bit Registers 中断激活位寄存器   IPR Interrupt Priority Registers 中断优先级寄存器   STIR Software Trigger Interrupt Registers 软件触发中断寄存器   ICSR Interrupt Control and State Register 中断控制和状态寄存器   AIRCR Application Interrupt and Reset Control Register 应用中断和复位控制寄存器   SHPR System Handler Priority Register 系统处理优先级寄存器   SHCSR System Handler Control and State Register 系统处理控制和状态寄存器    ","description":"微机原理与嵌入式系统学习要点","id":21,"section":"posts","tags":["Embedded System"],"title":"嵌入式系统学习要点","uri":"https://chaphlagical.github.io/zh/posts/computer/embedded_system/"},{"content":"我将在这里分享有趣的知识与技术\n","description":"My Blog","id":22,"section":"","tags":null,"title":"简介","uri":"https://chaphlagical.github.io/zh/about/"},{"content":"第一章 计算机网络与互联网络 一、什么是互联网络 1、从构成角度看  节点：端系统（=主机），网络应用程序+网络交换设备（路由器、交换机等） 边：通信链路（接入网链路：主机-互联网、主干链路：路由器-路由器） 互联网络：网络的网络  2、从服务角度看 互联网络=能够为应用提供通信服务的通信架构（已连接可靠服务和无连接不可靠服务）+使用通信服务相互配合工作的应用\n3、协议 协议：对等层实体在通信过程中所遵循的规则集合，控制发送和接收消息\n协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输和/或接收或其他事件方面所采取的动作\n协议=语法+语义+时序\n二、网络边缘 1、网络结构 网路结构=网络边缘（主机、应用程序）+网络核心（路由器、网络的网络）+接入网与通信链路\n2、 网络边缘：运行应用的端系统（端系统中的应用交互方式）  C/S模式：客户端向服务器请求、接收服务 P2P模式：很少（甚至没有）专门的服务器  3、利用网络的服务  采用网络设施的面向连接服务：TCP  可靠的、按顺序的传输数据 流量控制 拥塞控制 HTTP、FTP、Telnet、SMTP   采用基础设施的无连接服务：UDP  无连接 不可靠数据传输 无流量控制 无拥塞控制 流媒体、远程会议、DNS、网络电话    三、网络核心 1、网络核心  组成：路由器+链路 功能：数据交换  2、数据交换方式及比较   电路交换\n  特点：网络资源（如带宽）被分成片，独享资源，建立呼叫连接\n  分片方式：\n  频分FDM：\n  时分TDM：\n  波分WDM\n    举例：电话网络\n    分组交换\n 特点：以分组为单位存储-转发方式；传输时使用全部带宽；在转发之前，节点必须收到整个分组（延迟、排队）；路由器缓存用完时，分组将被抛弃；统计多路复用（时分复用） 虚电路网络VC：  每个分组带虚电路标识VC ID，标签决定下一跳 在呼叫建立时决定路径，在整个呼叫中路径保持不变 路由器维持每个呼叫的状态信息 X.25和ATM    数据报网络Datagram  分组的目标地址决定下一跳 在不同的阶段，路由可以改变 在通信之前，无须建立起一个连接，有数据就能传输 每一个分组都有独立路由 Internet    举例：IP网络    分组交换vs电路交换\n 分组交换是“突发数据的胜利者” 分组交换  缺点：  不适合实时服务（如电话和视频会议），因为其端到端时延是可变的和不可预测的 分组在目的主机需要重新进行排序 每个分组需要携带额外的首部信息   优点：  提供比电路交换更好的带宽共享 比电路交换更简单、更有效，实现成本更低        四、接入网与物理媒介 将端系统连接到边缘路由器的链路或网路\n1、住宅接入网络：点到点接入  调制解调器 modem  原理：将上网数据调制加载音频信号上，在电话线上传输，在局端将其中的数据解调出来：调频、调幅、调相位、综合解调 不能同时上网和打电话，不能总是在线   接入网 DSL  采用现存的到交换局DSLAM的电话线  DSL线路上的数据被传到互联网 DSL线路上的语音被传到电话网   \u0026lt;2.5Mbps上行传输速率 \u0026lt;24Mbps下行传输速率    线缆网络（混合光纤同轴网络HFC）   有线电视信号电缆双向改造 非对称：最高30Mbps下行传输速率，2Mbps上行传输速率   FTTH（光纤到户）  主动光纤网络AON 被动光纤网络PON   家庭网络      2、机构接入：LAN  以太网络 Ethernet  10Mbps，100Mpbs，1Gbps，10Gbps的传输率 端系统经常直接接到以太网络交换机上    无线接入网络 WLAN  各无线端系统共享无线接入网络     3、物理链路 在每个传输-接收对，跨越一种物理媒体\n 导向型介质：信号沿着固体媒介被导引：同轴电缆、光纤、双绞线 非导引型媒体：信号自由传播（如无线电）  4、常用介质  双绞线（TP）  两根绝缘铜线 5类：100Mbps Ethernet 6类：10Gbps   同轴电缆  两根同心的铜导线 双向 基带电缆：  电缆上一个单个信道 Ethernet   宽带电缆  电缆上有多个信道 HFC     光纤  光脉冲：每个脉冲表示一个比特在玻璃纤维中传输 高速：点到点10Gbps~100Gbps 低误码率：两个中继器之间可以有很长的距离，不受电磁噪声的干扰 安全   无线链路  开放空间传输电磁波，携带需要传输的数据 无需物理线缆 双向 传播环境效应：反射、吸收、干扰    五、互联网结构和ISP 1、近似层次型结构  T-1 ISP  中心 国家/国际覆盖，速率极快 直接与其他第一层ISP相连 与大量的第二层ISP和其他客户网络相连   T-2 ISP  通常是区域性的ISP 与一个或多个第一层ISPs，也可能与其他第二层ISP相连   Local ISP  2、ISP之间的连接   POP：高层ISP面向客户网络的接入点，涉及费用结算\n  对等连接：2个ISP对等互接，不涉及费用结算\n  IXP：多个对等ISP互联互通，通常不涉及费用结算\n  3、内容提供商网络  在全球部署DC 内容提供商网络在多处与各个ISP相联 内容提供商自己部署网络将全球的DC相联  内容提供商DC自己之间的访问，通过自己部署的专网 用户接入后通过用户最近的DC为之服务    六、分组交换网络中的延迟与丢失 1、延迟的原因（4个） （1）处理延迟  检查bit级差错 检查分组首部和决定将分组导向何处  （2）排队延迟  在输出链路上等待传输的时间 依赖于路由器的拥塞程度  （3）传输延时  R=链路带宽（bps） L=分组长度（bits） 将分组发送到链路上的时间=L/R 存储转发延迟  （4）传播延时  d=物理链路的长度 s=在媒体上的传播速度（~$2\\times 10^8m/sec$） 传播延迟=d/s  节点延迟的计算：\n$$\nd_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}\n$$\n $d_{proc}$=处理延时，通常是微秒数量级或更少（固定） $d_{queue}$=排队延时，取决于拥塞程度（变化） $d_{trans}$=传输延时=L/R，对低速率的链路而言很大，通常为微秒级到毫秒级（固定） $d_{prop}$=传播延时，几微秒到几百毫秒（固定）  2、流量强度  假设：  R=链路带宽（bps） L=分组长度（bits） a=分组到达队列的平均速率 流量强度=La/R    有以下规律：  La/R~0：平均排队延时很小 La/R-\u0026gt;1：延时变得很大 La/R\u0026gt;1：bit到达队列速率超过从该队列输出的呃速率，平均排队延时趋于无穷    3、丢失原因  链路的队列缓冲区容量有限 当分组到达一个满的队列时，该分组将会丢失 丢失的分组可能会被钱一个节点或源端系统重传或根本不重传  4、吞吐量 在源端和目标端之间传输的速率（数据量/单位时间）\n 瞬间吞吐量：在一个时间点的速率 平均吞吐量：在一个长时间内的平均值 瓶颈链路决定了主机之间的吞吐量 端到端的平均吞吐=min{$R_1$, $R_2$, \u0026hellip; ,$R_n$}  七、协议层次与服务模型 1、分层的原因 网络比较复杂，分层实现比较容易设计，调试和实现\n2、分层 将复杂网络的功能划分成功能明确的层次，上层利用下层提供的服务来实现本层的协议，从而为上层提供更复杂的功能\n3、相关术语与概念  服务：底层实体向上层实体提供它们之间的通信的能力，通过原语来操作，垂直  服务用户 服务提供者   服务访问原语：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语进行交互 服务访问点SAP：上层使用下层提供的服务通过层间接口（如端口、地址） 面向连接的服务：  连接：两个通信实体为进行通信而建立的一种结合 过程：建立连接，通信，拆除链接 例子：网络层的连接为虚电路 适用范围：对于大的数据块要传输，不适合小的零星报文 特点：报序 服务类型：  可靠的信息流：传送页面 可靠的字节流：远程登陆 不可靠的连接：数字化声音     无连接的服务  无连接服务：两个对等层实体在通信前不需要建立一个连接，不预留资源；不需要通信双方都是活跃 特点：不可靠、可能重复、可能失序 IP分组，数据包 适用范围：适合传送零星的数据 服务类型：  不可靠的数据报：电子方式的函件 有确认的数据报：挂号信 请求回答：信息查询     协议：对等层实体之间在相互通信的过程中，需要遵循的规则的集合，水平 协议数据单元     服务与协议的联系：  本层协议的实现要靠下层提供的服务来实现 本层实体通过协议为上层提供更高级的服务    4、互联网络分层模型及每一层的功能  应用层：网络应用  作用：为用户或其他应用进程提供网络应用服务 举例：FTP，SMTP，HTTP，DNS 数据单元：报文Message   传输层：主机之间的数据传输  作用：在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠的通信变成可靠的通信 举例：TCP，UDP 数据单元：报文段Segment   网络层：为数据报从源到目的选择路由  作用：主机-主机之间的通信，端到端的通信，不可靠 举例：IP，路由协议 数据单元：分组packet（无连接方式：数据报datagram）   链路层：相邻网络节点间的数据传输  作用：2个相邻2点的通信，点到点通信，可靠或不可靠 举例：点对点协议PPP，802.11（wifi），Ethernet 数据单元：帧Frame   物理层：在线路上传送bit  数据单元：位bit    5、封装和解封装 八、历史  ARPANET：美国军方资助的分组交换实验网，由于 TCP/IP 架构的包\n容性、免费使用、架构便于应用创新吸引更多的用户等原因，用户数量、\n节点数量和应用数量越来越多。 NSF 建立 ARPANET 的访问网 民用网络从军用网络脱开，成为现在的互联网。 IETF（ITU， IEEE）：国际互联网工程任务组（研发因特网标准） RFC：Request For Comments（RFC），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件  第二章 应用层 一、网络应用原理 1、应用架构 （1） 客户-服务器（C/S）体系结构  服务器  一直运行 固定的IP和周知的端口号 扩展性：服务器场  数据中心进行扩展 扩展性差     客户端  主动与服务器通信 与互联网有间歇性的连接 可能是动态IP地址 不直接与其他客户端通信    （2）对等体（P2P）体系结构  几乎没有一直运行的服务器 任意端系统之间可以进行通信 每一个节点既是客户端又是服务器  自扩展性   参与的主机间歇性连接且可以改变IP地址 例子：Gnutella，迅雷  （3）C/S和P2P体系结构混合体  Napster  文件搜索：集中  主机在中心服务器上注册其资源 主机向中心服务器查询资源位置   文件传输：P2P  任意peer节点之间     即时通信  在线监测：集中  当用户上线时，向中心服务器注册其IP地址 用户与中心服务器联系，以找到其在线好友的位置   两个用户之间聊天：P2P    2、进程通信   同主机：使用进程间通信机制通信（由操作系统定义）\n  不同主机：通过交换报文来通信\n 使用OS提供的通信服务  按照应用协议交换报文\n  3、SOCKET  一个整数，OS用于标识应用通信关系所采用的本地标示 TCP：连接的本地标示，四元组（源IP，源port，目标IP，目标port），TCP服务器需要两个套接字      UDP：端节点的本地标示，二元组（本IP，本port），UDP服务器需要一个套接字  传输报文时需要提供对方的IP和port 接收报文时，传输层需要上传对方的IP和port     4、进程编址 IP+port\n5、 应用所需要的服务需要考虑的因素  丢失率、可靠性 延迟 带宽 安全性  6、传输层协议  TCP：提供的服务特性，可靠的字节流服务，面向连接，流量控制，拥塞控制 UDP：提供的服务特性，无连接，不可靠的服务  区分不同进程 无需建立连接，节省时间，适合事务性的应用 不做可靠性的工作，适合对实时性要求比较高而对正确性要求不高的应用 无拥塞控制和流量控制，应用能按照设定的速度发送数据   都能提供进程的标示，区分不同的进程  二、WEB和HTTP 1、WEB应用包括  HTTP协议 HTML Client，Server  2、术语  网页：由一些对象组成 对象：HTML文件，JPEG文件，Java小程序，声音视频文件 引用URL：包括访问协议，用户名，口令字，端口等；对每个对象进行引用  3、HTTP协议 （1）作用 定义了client和server之间通信的报文格式，解释和时序 （Port 80）\n（2）HTTP连接   持久HTTP\n 多个对象可以在一个TCP连接上传输（HTTP/1.1默认使用持久连接） 服务器在发送响应后，仍保持TCP连接 在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送 客户端在遇到一个引用对象的时候，就可以尽快发送该对象的请求 分类：  非流水方式的持久HTTP：  客户端只能在收到前一个响应后才能发出新的请求 每个引用对象花费一个RTT   流水方式的持久HTTP：  HTTP/1.1的默认模式 客户端遇到一个引用对象就立即产生一个请求 所有引用对象只花费一个RTT是可能的        非持久HTTP\n  最多只有一个对象在TCP链接上发送\n  下载多个对象需要多个TCP连接\n  HTTP/1.0使用非持久连接\n  缺点：\n 每个对象需要2个RTT OS必须为每个TCP连接分配资源 浏览器通常打开并行TCP连接，以获取引用对象    举例：\n注意： 应对每一个对象重复操作\n    4、往返延迟RTT和对象的抓取时间  往返时间RTT：一个小的分组从客户端到服务器，再回到客户端的时间（传输时间忽略） 响应时间：  一个RTT用于发起TCP连接 一个RTT用于HTTP请求并等待HTTP响应 文件传输时间 总共：2RTT+传输时间    5、报文格式   请求报文\n   ASCII 方法：  GET：输入通过请求行的URL字段上载 POST：提交表单输入，包含在实体主体中的输入被提交到服务器 HEAD：要求服务器在响应报文中不包含请求对象（用于故障跟踪） PUT：将实体主体中的文件上载到URL字段规定的路径 DELETE：删除URL字段规定的文件      响应报文\n  Date：首部行指示服务器产生并发送该响应报文的日期和时间   响应状态码：  200 OK：请求成功，请求对象包含在响应报文的后续部分 301 Moved Permanently：  请求的对象已经被永久转移，新的URL再响应报文的Location：首部行中指定 客户端软件自动用新的URL去获取对象   400 Bad Request：表示该请求不能被服务器解读 404 Not Found：请求的文档再该服务上没有找到 505 HTTP Version Not Supported      6、COOKIES   组成部分：\n 在HTTP响应报文中有一个cookies的首部行 在HTTP请求报文中由一个cookies的首部行 在用户端系统中保留有一个cookies文件，由用户的浏览器管理 在web站点有一个后端数据库    维护状态：  应用：用户验证、购物车、推荐、用户状态\n  7、WEB缓存   目的：不访问原始服务器，就满足客户的请求\n  原理\n 用户设置浏览器：通过缓存访问Web 浏览器将所有的HTTP请求发给缓存  在缓存中的对象：缓存直接返回对象 若对象不在缓存中，缓存请求原始服务器，然后将对象返回给客户端      作用：\n 通过本地命中，减少这些对象的访问延迟 进一步减少接入链路的流量强度，从而降低对延迟，带来的总体平均延迟减少 减轻服务器的负担（能减少对所有对象的时延） 互联网大量使用了缓存，可以使较弱的ICP也能有效提供内容    条件GET方法：如果缓存器中的对象拷贝是最新的，就不要发送对象\n  缓存器：在HTTP请求中指定缓存拷贝的日期\nIf-modified-since:\u0026lt;date\u0026gt;\r\r  服务器：如果缓存拷贝陈旧，则响应报文没包含对象\nHTTP/1.0 304 Not Modified\r\r    三、FTP*（不要求） 四、EMAIL 1、电子邮件应用的构成  用户代理  又名“邮件阅读器” 撰写、编辑和阅读邮件 如Outlook，Foxmail 输入和输出邮件保存在服务器上   邮件服务器  邮箱中管理和维护发送给用户的邮件 输出报文队列保持待发送邮件报文 邮件服务器之间的SMTP协议：发送Email报文   SMTP  使用TCP在客户端和服务器之间传送报文，Port：25 直接传输：从发送方服务器到接收方服务器 传输三个阶段：  握手 传输报文 关闭   命令/响应交互  命令：ASCII文本 响应：状态码和状态信息   报文必须为7位ASCII码 SMTP vs HTTP  HTTP：拉 SMTP：推 二者都是ASCII形式的命令/响应交互、状态码 HTTP：每个对象封装在各自的响应报文中 SMTP：多个对象包含在一个报文中   举例：    2、邮件报文格式解析   报文头\n  To：\n  From：\n  Subject：\n与SMTP命令不同\n    报文体：报文，ASCII码字符\n  MIME：邮件多媒体扩展，可以在邮件中编解码多媒体内容\n  3、邮件存取协议  作用  SMTP：传送到接收方的邮件服务器（推协议） 邮件访问协议：从服务器访问邮件   常用  POP3：邮局访问协议，用户身份确认（代理\u0026lt;\u0026ndash;\u0026gt;服务器）并下载  用户确认阶段  客户端命令：user（申明用户名），pass（口令） 服务器响应：+OK，-ERR   事务处理阶段，客户端：  list：报文号列表 retr：根据报文号检索报文 dele：删除 quit   会话中无状态 本地管理文件夹   IMAP：Internet邮件访问协议  IMAP服务器将每个报文与一个文件夹联系起来 允许用户用目录来组织报文 允许用户读取报文组件 IMAP在会话过程中保留用户状态：目录名、报文ID与目录名之间的映射 远程管理文件夹   HTTP：Yahoo，Hotmail等（方便）    五、DNS 1、DNS的作用  完成域名到IP地址的转换（UDP Port53） 主机别名到规范名字的转换：Host aliasing 邮件服务器别名到邮件服务器的正规名字的转换：Mail server aliasing 负载均衡：load distribution  2、DNS的概念：分布式、层式数据库  命名是分层的 域名信息存储和服务是分布的，每个域名服务器担任一个区域的名字到IP地址的权威转换，也缓存名字-ip信息的转换  3、DNS的构成  解析器：本地应用（UDP） 域名服务器  权威DNS服务器 顶级域（TLD）服务器   DNS协议  报文：查询和响应报文的报文格式相同      资源记录（RR）  作用：维护域名-IP地址（其他）的映射关系 位置：Name Server的分布式数据库 RR的格式：（domain_name，ttl，type，class，value）  Domain_name：域名 Class类别：对于Internet，值为IN Value值：可以是数字，域名或ASCII串 Type类别：资源记录的类型  Type=A  Name为主机、 Value为IP地址   Type=NS  Name为域名 Value为该域名的权威服务器的域名   Type=CNAME  Name为规范名字的别名 value为规范名字   Type=MX  Value为name对应的邮件服务器的名字     TTL：生存时间，决定了资源记录应当从缓存中删除的时间        4、域名解析的过程 解析器-\u0026gt;本地DNS服务器-\u0026gt;上层域名服务器-\u0026gt;\u0026hellip;-\u0026gt;权威域名服务器，返回\n 递归查询   名字解析负担都放在当前联络的名字服务器上 问题：根服务器的负担太重 解决：迭代查询   迭代查询   根（以及各级域名）服务器返回的是下一个NS的地址 最后由权威域名服务器给出解析结果 当前联络的服务器给出可联系的服务器的名字    5、DNS缓存  作用：提高效率，使得根服务器不用经常被访问 问题：若情况变化，缓存结果可能和权威资源记录不一致 解决方法：TTL（默认2天） 本地缓存+服务器缓存  6、新增一个域  在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名 和 域名服务器的地址 在新增子域 的名字服务器上运行名字服务器，负责本域的名字解析： 名字-\u0026gt;IP地址 举例：  7、攻击DNS  DDoS攻击  对根服务器进行流量轰炸攻击：发送大量ping  没有成功 根目录服务器配置了流量过滤器，防火墙 Local DNS服务器缓存了TLD服务器的IP地址，因此无需查询根服务器   向TLD服务器流量轰炸攻击：发送大量查询  可能更危险 效果一般，大部分DNS缓存了TLD     重定向攻击  中间人攻击  截获查询，伪造回答，从而攻击某个站点   DNS中毒  发送伪造的应答给DNS服务器，希望它能缓存该虚假结果   技术上较困难：分布式截获和伪造   利用DNS基础设施进行DDoS  伪造某个IP进行查询，攻击这个目标IP 查询放大，响应报文比查询报文大 效果有限    六、P2P 1、P2P概念：每个对等体既是客户端又是服务器   P2P网络是这些peer构成的应用层面上的逻辑网络\n  P2P网络比C/S分发内容快的原因：这些peer节点参与到内容的上载，流量和服务都是分布的，可扩展性\n  分发时间$D$\n  假设：\n $u_s$表示服务器接入链路的上载速率，$u_i$表示第$i$对等方接入链路的上载速率，$d_i$表示第$i$对等方接入链路的下载速率。$F$表示被分发的文件长度，$N$表示要获得该文件副本的对等方数量    服务器向$N$个对等方传输该文件的一个副本，分发时间$D_{cs}=NF/u_s$。对于P2P架构网络，服务器至少在其接入链路上发送文件一次，故最小分发时间至少为$F/u_s$\n  令$d_{min}$表示具有最小下载速率的对等方的下载速率，则最小分发时间至少为$F/d_{min}$\n  系统整体的总上载能力等于服务器的上载速率加上每个单独的对等方的上载速率，即$u_{total}=u_s+u_1+\u0026hellip;+u_N$，则最小分发时间至少为$NF/(u_s+u_1+\u0026hellip;+u_N)$\n  对于C/S体系网络，$D_{cs}=max{\\frac{NF}{u_s},\\frac{F}{d_{min}}}$\n对于P2P体系网络，$D_{P2P}=max{\\frac{F}{u_s},\\frac{F}{d_{min}},\\frac{NF}{u_s+\\sum\\limits^N_{i=1}u_i}}$\n    应用：文件分发、流媒体、VoIP\n  2、典型P2P应用及其原理  Napster Gnutella KaZaA BT DHT  七、视频流化服务和CDN 1、服务器向客户端进行视频流化的方式  UDP流化 http流化 DASH  2、DASH流化过程  服务器  将视频文件分割成多个块 每个块独立存储，编码于不同码率 告示文件：提供不同块的URL   客户端  先获取告示文件 周期性测量服务器到客户端的带宽 查询告示文件，在一个时刻请求一个块，HTTP头部指定字节范围  若带宽足够，选择最大码率的视频块 会话中的不同时刻，可以切换请求不同的编码块     智能客户端  什么时候去请求块 (不至于缓存挨饿，或者溢出) 请求什么编码速率的视频块 (当带宽够用时，请求高质量的视频块) 哪里去请求块 (可以向离自己近的服务器发送URL，或者向高可用带宽的服务器请求)    3、CDN   单个服务器，或者服务器群向客户端提供海量内容并发服务的问题：扩展性差\n  CDN的原理\n 应用层面的协作服务网络 在全网部署缓存节点，内容预先部署到CDN缓存节点上 用户请求通过域名解析重定向向离自己最近的节点请求内容    缓存节点放置的方式\n Enter Deep Bring Home    举例：\n  八、TCP的SOCKET编程 1、SOCKET的概念 TCP连接的本地标示，向这个SOCKET写就是发送给对方的进程；从SOCKET中读，就是读取对方发送过来的数据\n2、SOCKET API  创建 使用（读和写） 关闭  3、TCP SOCKET数据传输的特点  面向连接 可靠的字节流服务  4、TCP SOCKET编程 服务器首先运行，等待连接建立\n 服务器进程必须先处于运行状态  创建欢迎socket 和本地端口捆绑 在欢迎socket上阻塞式等待接收用户的连接    客户端主动和服务器建立连接\n  创建客户端本地套接字（隐式捆绑到本地port）\n 指定服务器进程的IP地址和端口号，与服务器进程连接    当有与客户端连接的请求到来时\n 服务器接受来自用户端的请求，接触阻塞式等待，返回一个新的socket（与欢迎socket不同），与客户端通信  允许服务器与多个客户端通信 使用源IP和源端口来区分不同的客户端      连接API调用有效时，客户端与服务器建立了TCP连接\n  5、面向连接的套接字通信工作流程  服务器先用socket函数来建立一个套接字，用这个套接字完成通信的监听 用bind函数来绑定一个端口号和IP地址。因为本地计算机可能有多个IP，每一个IP有多个端口号，需要指定一个IP和端口进行监听 服务器调用listen函数，使服务器的这个端口和IP出于监听状态，等待客户机的连接 客户端用socket建立一个套接字 客户端调用connect函数，通过远程IP和端口号连接远程计算机指定的端口 服务器用accept函数来接收远程计算机的连接，建立起与客户端之间的通信 建立连接以后，客户端用write函数向socket中写入数据。也可用read函数读取服务器发送来的数据 服务器用read函数读取客户端发送来的数据，也可用write函数发送数据 完成通信以后，用close函数关闭socket连接  九、UDP SOCKET编程 1、UDP SOCKET数据传输的特点  没有握手 发送端在每一个报文中明确的指定目标的IP地址和端口号 服务器必须从收到的分组中提取出发送端的IP地址和端口号  2、UDP SOCKET 编程   建立SOCKET\n  使用\n  关闭\n  第三章 传输层 一、传输层服务 1、传输服务 为运行在不同主机上的应用进程提供逻辑通信\n2、传输协议 运行于端系统的两个对等传输层实体相互通信应该遵守的规则集合\n 发送方：将应用层的报文分成报文段，然后传递给网络层 接收方：将报文段重组成报文，然后传递给应用层  3、传输服务与网络服务的区别  网络服务：主机-主机之间的逻辑通信 传输服务：进程-进程之间的逻辑通信  依赖于网络层服务（延时，带宽） 对网络层服务进行增强（数据丢失、顺序混乱、加密）    4、互联网络传输层协议  TCP：有连接，可靠保序数传服务  多路复用、解复用 拥塞控制 流量控制 建立连接   UDP：不可靠、不保序的传输  多路复用、解复用 没有为尽力而为的IP服务添加更多的其他额外服务    二、复用与解复用 1、复用 源端多个上层应用收集数据：应用报文，封装报文\n2、解复用 接收端将数据按照端口号（结合IP地址）给相应的SOCKET对应的应用\n3、复用和解复用的工作原理：IP PORT  TCP有连接情况：SOCKETS为4元组（源IP，源port，目的IP，目的port）  两个具有不同源IP地址或源端口号的到达TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带了初始创建连接的请求   UDP无连接情况：SOCKETS为2元组（目的IP，目的port）  两个具有不同源IP或源端口号的到达UDP报文段，但具有相同的目的IP地址和目的端口地址，则两个报文段将通过相同的目的套接字被定向到相同的目的进程    三、无连接传输协议UDP 1、必要性  对实时性比较在乎，对可靠性要求不高 简单：在发送端和接收端没有连接状态 报文段头部开销很小（TCP：20字节；UDP：8字节） 无拥塞控制和流量控制，UDP可以尽可能快的发送报文段  2、UDP报文（数据报）格式  UDP校验和  目的：检测在被传输报文段中的差错 发送方：  将报文段的内容视为16比特的整数 校验和：报文段的加法和（1的补运算） 发送方将校验和放在UDP的校验和字段   接收方：  计算接收到的报文段的校验和 检查计算出的校验和与校验和字段的内容是否相等  不相等——检测到差错 相等——可能有残存错误     Internet校验和的例子：    四、可靠数据传输的原理 1、Rdt服务 （1）Rdt1.0：在可靠信道上的可靠数据传输  下层的信道是完全可靠的  没有比特出错 没有分组丢失   发送方和接收方的FSM  发送方将数据发送到下层信道 接收方从下层信道接收数据     （2） Rdt2.0：具有比特差错的信道  下层信道可能会出错：将分组中的比特翻转  用校验和来检测比特差错   从差错中恢复：  确认（ACK）：接收方显式地告诉发送方分组已经被正确接收 否定确认（NAK）：接收方显式地告诉发送方分组发生了差错，发送方收到NAK后，发送方重传分组   新机制：采用差错控制编码进行差错检测  发送方差错控制编码、缓存 接收方使用编码检错 接收方的反馈：控制报文（ACK,NAK） 发送方收到反馈相应的动作   FSM描述：      （3）Rdt2.1：处理Rdt2.0的缺陷  引入序号 处理重复：  发送方在每个分组中加入序号 若ACK/NAK出错，发送方重传当前分组 接收方丢弃重复分组   发送方处理出错的ACK/NAK     接收方处理出错的ACK/NAK     讨论：  发送方：  在分组中加入序列号（两个（0，1）即可，一次只发送一个未经确认的分组）（区分到达的数据包是重传的还是新数据，也可以用来判断数据包顺序是否正确） 必须检测ACK/NAK是否出错（需要EDC） 状态数变成了两倍   接收方：  必须检测接收到的分组是否是重复的  状态会指示希望接收到的房租的序号为0还是1   接收方不知道它最后发送的ACK/NAK是否被正确地收到  发送方不对收到地ACK/NAK给确认 接收方发送ACK，若接收方收到：  下一个分组——则ACK被正确收到 老分组——则ACK没有被正确地传到发送方         rdt2.1的运行      （4）Rdt2.2：无NAK的协议  特点：  功能同rdt2.1，但只使用ACK 接收方对最后正确接收的分组发ACK,以代替NAK  接收方必须显式地包含被正确接收分组地序号   当收到重复的ACK时，重传当前分组   rdt2.2的运行       FSM描述      （5）rdt3.0：具有比特差错和分组丢失的信道  方法：发送方等待ACK一段合理的时间  发送端超时重传：若时间到未收到ACK—\u0026gt;重传 需要一个倒计时定时器（防止丢包现象）   FSM描述     rdt3.0的运行：      rdt3.0的性能  在链路容量较大情况下性能很差    rdt3.0的停-等操作     流水线：提高链路利用率      2、技术机制  校验和，正向确认，反向确认 序号：检查重复 只有正向确认的机制 检错重发和超时重发：处理丢失  滑动窗口    3、利用率计算 （1）停止等待技术 链路带宽延迟积（容量）效率低\n（2）管道技术 在未经对方确认的情况下，可以连续发送多个PDU\n  通用：滑动窗口（slide window）协议\n  发送缓冲区\n 形式：内存中的一个区域，落入缓冲区的分组可以发送 功能：用于存放已发送，但是没有得到确认的分组 必要性：需要重发时可用    发送窗口的移动——前沿移动\n 发送窗口前沿移动的极限：不能超过发送缓冲区      发送窗口的移动——后沿移动\n 条件：收到老分组的确认 结果：发送缓冲区罩住新的分组，来了分组可以发送 移动的极限：不能够超过前沿      发送窗口\n 前沿移动：有新的分组落入发送缓冲区范围，发送 后沿移动：来了老的低序号分组的确认，后沿向前滑动，新的分组可以落入发送缓冲区的范围     接收窗口\n  接收窗口=接收缓冲区\n 只有收到的分组序号落入接收窗口内才允许接收 若序号在接收窗口之外，则丢弃    接收窗口尺寸Wr=1，只能顺序接收\n接收窗口尺寸Wr\u0026gt;1，则可以乱序接受\n  接收窗口的滑动与发送确认\n 滑动：低序号的分组要来，接收窗口移动；高序号分组乱序到，缓存但不交付（rdt不允许失序），不滑动 发送确认：  接收窗口尺寸=1：发送连续收到的最大的分组确认（累计确认） 接收窗口尺寸\u0026gt;1：收到分组，发送哪个分组的确认（非累计确认）            Go-back-N（GBN）协议\n  特点：发送窗口大于1，接收窗口=1（只能顺序接收；发送方设置一个超时定时器，一旦出错，返回到出错的哪一个PDU重发）\n  发送方：\n 分组头部有k比特的序列号，一次发送多个分组 窗口大小为N，发送缓冲区：允许未确认的连续多个分组 ACK(n)：发送端收到确认n，即序号为n之前的所有分组进行确认（累计确认） 只对后沿分组设定时器 timeout(n)：重传发送窗口中所有序号大于等于n的分组  超时只有可能是最老的分组   扩展的FSM：    接收方：\n 只发送ACK：对顺序接收的最高序号的分组  可能会产生重复的ACK 接收窗口=1   对乱序的分组：  丢弃 对顺序接收的最高序号的分组进行确认（累计确认）      运行实例：    选择重传（SR）\n 特点：发送窗口大于1，接收窗口大于1（能够乱序接收；发送方为每个发送出去的PDU；设置超时定时器，哪个超时重发哪个） 发送方：  从上层接收数据：如果下一个可用与该分组的序号可在发送窗口中，则发送 timeout(n)：重新发送分组n，重新设定定时器 ACK(n) in [sendbase, sendbase+N]：将分组n标记为已接收，如果n为最小为确认分组序号，将base移到下一个未确认序号   接收方：  分组n [rcvbase, rcvbase+N-1]  发送ACK(n) 乱序：缓存 顺序正确：该分组及以前缓存的序号连续的分组交付给上层，然后将窗口移到下一个仍未被接收的分组   分组n [rcvbase-N, rcvbase-1]  ACK(n)   其他：  忽略该分组     SR的运行    窗口的最大尺寸（n为序号空间大小，例如：n=2，序列号：0、1、2、3）\n GBN：$2^n-1$ SR：$2^{n-1}$    五、有连接的传输层协议：TCP 1、TCP服务特性  点对点：一个发送方，一个接收方 可靠的、按顺序的字节流：没有报文边界 管道化（流水线）：TCP拥塞控制和流量控制设置窗口大小 发送和接收缓存 全双工数据  在同一连接中数据流双向流动 MSS：最大报文段大小   面向连接：在数据交换之前，通过握手（交换控制报文）初始化发送方、接收方的状态变量 有流量控制：发送方不会淹没接收方  2、TCP段结构  序号：报文段首字节的在字节流的编号（偏移量）32bits 确认号（对顺序收到的最后一个字节+1）32bits：  期望从另一方收到的下一个字节的序号 累计确认   接收窗口：指示接收方愿意接受的字节数量，用于流量控制 16bits 标志字段：  RST、SYN、FIN用于连接建立和拆除 PSH被置位时，指示接收方立即将数据交给上层 URG比特用于指示报文段里存在着被发送端的上层实体置为“紧急”的数据。紧急数据的最后一个字节由16bits的紧急数据指针字段指出     3、RTT时间估计和重发超时时间估计  设置TCP的超时：  比RTT长 太短：太早超时，造成不必要的重发 太长：对报文段丢失的反应太慢，消极   估计RTT：  SampleRTT：测量从报文段发出到确认的时间（若有重传，忽略此次测量） 移动平均计算：对几个最近测量值求平均值 指数加权移动平均：$EstimatedRTT=(1-\\alpha)EstimatedRTT+\\alphaSampleRTT$  过去样本的影响呈指数衰减 推荐值：$\\alpha=0.125$     设置超时：  EstimatedRTT+安全边界时间 当前SampleRTT与EstimatedRTT的偏差：$DevRTT=(1-\\beta)DevRTT+\\beta|SampleRTT-EstimatedRTT|$（推荐值$\\beta=0.25$） 超时时间间隔：$TimeoutInterval=EstimatedRTT+4*DevRTT$    4、TCP的可靠数据传输原理   TCP在IP不可靠服务的基础上建立了rdt\n 管道化的报文段  GBN or SR   累计确认（像GBN） 单个单传定时器（像GBN） 是否可以接受乱序，没有规范    通过以下时间触发重传\n  超时（只重发最老的一个段：SR）\n  重复的确认\n    快速重传：在没有超时的情况下，收到对方对于某一个段的重复三次（一共4个）ACK\n 超时周期往往太长：在重传丢失报文段之前的延时太长 通过重复的ACK来检测报文段丢失  发送方通常连续发送大量的报文段 如果报文段丢失，通常会引起多个重复的ACK   如果发送方收到同一数据的三个冗余ACK，重传最小序号的段  在定时器过时之前重发报文段 它假设跟在被确认的数据后面的数据丢失了  第一个ACK正常 收到第二个该段的ACK，表示接收端收到一个该段后的乱序段 收到第3、4个该段的ACK，表示接收方收到该段之后的2、3个乱序段，段丢失的可能性非常大          5、流量控制   目的：防止淹没接收方\n  方法：将接收窗口大小捎带方式传递给发送端\n  接收方在其向发送方的TCP段头部的rwnd字段通告其空闲buffer大小\n RcvBuffer大小通过socket选项设置（典型默认大小为4096字节） 很多操作系统自动调整RcvBuffer    发送方限制未确认字节个数$\\leq$接收方发送过来的rwnd值\n  缓存中可用的空间\n=RcvWindow\n=RcvBuffer-[LastByteRcvd-LastByteRead]\n    6、连接管理   连接建立：3次握手技术，对双方选择的初始序号给予确认，准备好缓冲区\n  过程：  第一次握手：SYN=1，ACK=0；发起段序号 第二次握手：SYN=1，ACK=1；被呼叫方序号 第三次握手：SYN=0，ACK=1   三次握手FSM    连接拆除：对称\n 客户端，服务器分别关闭自己一侧的连接  发送FIN bit=1的TCP段   一旦接收到FIN，用ACK回应  接到FIN段，ACK可以和它自己发出的FIN段一起发送   可以处理同时的FIN交换    六、拥塞控制原理 1、拥塞的概念及原因   拥塞：太多的数据需要网络传输，超过了网络的处理能力\n  拥塞的表现：\n 分组丢失（路由器缓冲区溢出） 分组经历比较长的延迟（在路由器的队列中排队）    拥塞的原因：\n  场景1\n 假定：  两个发送端，两个接收端 一个路由器，无限大缓冲 输出链路带宽：R 没有重传       场景2\n 假定：  一个路由器，有限的缓冲 分组丢失时，发送端重传  应用层的输入=应用层的输出：$\\lambda_{in}=\\lambda_{out}$ 传输层的输入包括重传：$\\lambda^*{in}\\geq \\lambda{in}$     理想化：发送端有完美的信息  发送端知道什么时候路由器的缓冲可用  只在缓冲可用时发送 不会丢失：$\\lambda^*{in}=\\lambda{in}$      理想化：掌握丢失信息  分组可以丢失，在路由器由于缓冲器满而被丢弃 若知道分组丢失了，发送方重传分组    现实情况：重复  分组可能丢失，由于缓冲器满而被丢弃 发送端最终超时，发送第2个拷贝，2个分组都被传出   拥塞的代价：  为达到一个有效输出，网络需要做更多的工作（重传） 没有必要的重传，链路中包括多个分组的拷贝      场景3\n  假定：\n 4个发送端 多重路径 超时/重传    拥塞的代价\n  当分组丢失时，任何“关于这个分组的上游传输能力”被浪费\n        2、拥塞控制的手段  端到端的拥塞控制  没有来自网络的显式反馈 端系统根据延迟和丢失事件推断是否有拥塞 TCP采用这种方法   网络辅助的拥塞控制  路由器提供给端系统以反馈信息  单个bit置位，显示有拥塞 显式提供发送端可以采用的速率      七、TCP的拥塞控制原理 1、TCP拥塞控制原理   检测拥塞\n 某个段超时了（事件丢失）：拥塞  原因1：网络拥塞（某个路由器缓冲区没空间了，被丢弃）——概率大 原因2：出错被丢弃（未通过校验，被丢弃）——概率小   有关某个段的3次重复ACK：轻微拥塞    速率控制方法\n  维持一个拥塞窗口的值：CongWin\n  发送端限制已发送但是未确认的数据量（的上限）：\nLastByteSent-LastByteAcked$\\leq$ CongWin\n  粗略控制网络速率：\n$$\nrate\\approx\\frac{CongWin}{RTT}byte/sec\n$$\n  CongWin是动态的，是感知到网络拥塞程度的函数：\n 超时或者3个重复ack，CongWin↓  CongWin降为1MSS，进入SS阶段后再倍增到CongWin/2（每个RTT），从而进入CA阶段 CongWin降为CongWin/2（3个重复ACK），CA阶段   正常收到ACK：  SS阶段：加倍增加 CA阶段：线性增加        拥塞控制机制：\n  慢启动\n 连接刚建立时，CongWin=1MSS 当连接开始时，指数性增加发送速率直到丢失事件发生  每一个RTT，CongWin加倍 每收到一个ACK时，CongWin加一 慢启动阶段：只要不超时或3个重复ACK，一个RTT，CongWin加倍   总结：初始速率很慢，但指数级加速，SS时间很短，长期可以忽略    AIMD\n 乘性减：丢失事件后将CongWin降为1，将CongWin/2作为阈值，进入慢启动阶段（倍增至CongWin/2） 加性增：当CongWin\u0026gt;阈值时，一个RTT如果没有发生丢失事件，将CongWin加1MSS 当收到3个重复的ACKs（丢失）：  CongWin减半 窗口（缓冲区大小）之后线性增长   当超时事件发生时：  CongWIn被设置成1MSS，进入SS阶段 窗口指数增长 增长到一个阈值（上次发生拥塞的窗口的一半）时，再线性增加      总结（Reno方法）：\n  当CongWin\u0026lt;Threshold，发送端处于慢启动阶段（slow-start），窗口指数型增长\n  当CongWIn\u0026gt;Threshold，发送端处于拥塞避免阶段（congestion-avoidance），窗口线性增长\n  当收到三个重复的ACKs，Threshold设置成CongWin/2，CongWin=Threshold\n  当超时事件发生时（timeout），Threshold=CongWin/2，CongWin=1MSS，进入SS阶段\n    举例：\n注意： 重复ACK过程中，CongWin和Threshold不变，收到三个重复ACK后，Threshold=CongWin/2，CongWin=Threshold+3MSS\n    2、TCP拥塞控制算法  Tahoe：超时事件和3个冗余ACK处理一样（无快速恢复）  无条件将CongWin减至1   Reno：超时事件和3个冗余ACK处理不一样  超时事件（丢包）：Threshold=CongWin/2，CongWin=1MSS，进入SS阶段 3个冗余ACK：快速重传，Threshold设置成CongWin/2，CongWin=Threshold    3、TCP的吞吐量   设W为发生丢失事件时的窗口尺寸，则平均吞吐量：\n$$\n一条连接的平均吞吐量=\\frac{0.75W}{RTT}\n$$\n  设L为丢包率，则平均吞吐量：\n$$\n一条连接的平均吞吐量=\\frac{1.22\\times MSS}{RTT\\sqrt{L}}\n$$\n  4、TCP的公平性  公平性目标：如果K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为R/K TCP公平的原因：  对于两个竞争的TCP会话：  加性增加，斜率为1，吞吐量增加 乘性减，吞吐量比例减少      第四章 网络层：数据平面 一、简介 1、网络层的主要服务和功能  网络层服务  在发送主机和接受主机之间传送段 在发送端将段封装到数据报中 在接收端，将段上交给传输层实体 网络层协议存在于每一个主机和路由器 路由器检查每一个经过它的IP数据报的头部   网络层功能  转发：将分组从路由器的输入接口转发到合适的输出接口 路由：使用路由算法来决定分组从发送主机到目标接收主机的路径  路由选择算法 路由选择协议      2、实现网络层功能的方式：  传统方式  控制平面和数据平面的功能垂直集成在每个设备上（路由器） 控制平面功能：路由协议实体分布式地计算路由表  本地，每个路由器的功能 决定从路由器输入端口到达的分组如何转发到输出端口 转发功能   数据平面：IP协议按照路由表进行分组的转发  全网范围内的逻辑 决定数据报如何在路由器之间路由，决定数据报从源到目标主机之间地端到端路径     SDN通用转发方式  控制平面和数据平面分离，在不同设备上实现 SDN控制器集中式计算、下发流表实现控制平面地功能 SDN分组交换机按照流表对到来的分组进行转发，实现数据平面的功能    3、网络层提供服务的一些重要指标  带宽 延迟，延迟差 丢包与否，丢包率  二、路由器结构和工作原理 1、路由器的2大功能  路由协议：运行路由选择算法/协议（RIP，OSPF，BGP）——生成路由表 转发分组：从输入到输出链路交换数据报——根据路由表进行分组的转发  2、构成   输入端口：线路终端实现物理层功能、链路协议实体实现链路层功能，网络层功能实现分布式分组转发\n 基于目标的转发：仅仅依赖于IP数据报的目标IP地址 最长前缀匹配：当给定目标地址查找转发表时，采用最长地址前缀的目标地址表项 对于N个输入端口：交换机构的交换速度是输入线路速度的N倍比较理想，才不会成为瓶颈    交换结构\n  通过内存交换\n 在CPU直接控制下的交换，采用传统的计算机 分组被拷贝到系统内存，CPU从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口 转发速率被内存的带宽限制 一次只能转发一个分组    通过总线交换\n 数据报通过共享总线，从输入端口转发到输出端口 总线竞争：交换速度受限于总线带宽 1次处理一个分组 对于接入或企业级路由器，速度足够，但不适合区域或骨干网络    通过互联网络的交换\n 同时并发转发多个分组，克服总线带宽限制 Banyan（榕树）网络，crossbar和其它的互联网络被开发，将多个处理器连接成多处理器 当分组从端口A到达，转给端口Y；控制器短接相应的两个总线 高级设计：将数据报分片为固定长度的信元，通过交换网络交换 能够并行发送多个分组      输出端口\n  实现分组的调度（选择下一个要通过链路传输的分组）\n  FIFO：按照分组到来的次序发送\n 丢弃策略：如果分组到达一个满的队列，丢弃哪个分组  tail drop：丢弃刚刚到达的分组 priority：根据优先权丢失/移除分组 random：随机地丢弃/移除      优先权：发送最高优先权的分组\n 多类，不同类别有不同的优先权  类别可能依赖于标记或其他的头部字段 先传高优先级的队列中的分组，除非没有 高/低优先权中的分组传输次序：FIFO      Round Robin（RR）scheduling\n 多类 循环扫描不同类型的队列，发送完一类的一个分组，再发送下一个类的一个分组，循环所有类    加权队列Weighted Fair Queuing（WFQ）\n 一般化的Round Robin 在一段时间内，每个队列得到的服务时间是：$W_i/(XIGMA(W_i))*t$，与权重成正比 每个类在每一循环中获得不同权重的服务量      输出端口排队\n 设有N个流，链路容量为C，缓存大小等于\n$$\n\\frac{RTT\\times C}{\\sqrt{N}}\n$$      路由处理器：控制各部分的协调工作\n  三、互联网网络层协议 1、IP网络提供的网络模型：尽力而为  含义：丢包、乱序、不可靠、重复  2、网络层构成   路由协议 路由选择协议 ICMP协议\n  转发表\n 获得IP数据报的目标地址 对于转发表中的每一个表项  若(IP Des addr)\u0026amp;(mask)==destination，则按照表项对应的接口转发该数据报 若都没有找到，则使用默认表项转发数据报      3、IP数据报格式  分片和重组  原因：网络链路有MTU（最大传输单元）——链路层帧所携带的最大数据长度  不同的链路类型 不同的MTU   大的IP数据报在网络上被分片（fragmented）  一个数据报被分割成若干个小的数据报  相同的ID 不同的偏移量 最后一个分片标记为0   重组只在最终得目标主机进行 IP头部信息用于标识，排序相关分片   举例    4、IP编址   IP地址：主机或路由器和网络接口得32位标识\n 接口：主机/路由器与网络链路得连接处  路由器通常有多个接口 主机也有可能有多个接口 IP地址和每一个接口关联      一个IP地址和一个接口相关联  子网\n IP地址：子网部分（高位bits），主机部分（低位bits） 在一个子网内得设备之间通信的特点：  通信无需借助路由器 子网前缀一样   要判断一个子网,将每一个接口从主机或者路由器上分开,构成了一个个网络的孤岛，每一个孤岛（网络）都是一个都可以被称之为子网    IP地址分类\n Class A：126 networks，16 million hosts Class B：16382 networks，64K hosts Class C：2 million networks，254 hosts Class D：multicast Class E：reserved for future    特殊的IP地址\n 子网部分：全为0——本网络 主机部分：全为0——本主机 主机部分：全为1——广播地址，这个网络的所有主机 专用IP地址  永远不会被当做公用地址来分配,不会与公用地址重复 路由器不对目标地址是专用地址的分组进行转发 专用地址范围：  Class A 10.0.0.0-10.255.255.255 MASK 255.0.0.0 Class B 172.16.0.0-172.31.255.255 MASK 255.255.0.0 Class C 192.168.0.0-192.168.255.255 MASK 255.255.255.0        子网掩码和CIDR\n 子网掩码  32bits：  1：bit位置表示子网部分 0：bit位置表示主机部分   A，B，C类网络的子网掩码：  A：255.0.0.0 B：255.255.0.0 C：255.255.255.0   另一种表示方法：  /#（/24：表示前面24个bit为子网部分）     CIDR（Classless InterDomain Routing无类域间路由）  子网部分可以在任意位置 分配IP地址块时应以$2^n$为基准分配 地址格式：a.b.c.d/x，其中x是地址中子网号的长度      5、DHCP协议（Dynamic Host Configuration Protocol ）  目的：允许主机在加入网络的时候，动态地从服务器那里获得IP地址 工作概况  主机广播“DHCP discover”报文 DHCP服务器用“DHCP offer”提供报文响应 主机请求IP地址：发送“DHCP request”报文 DHCP服务器发送地址：“DHCP ack”报文   DHCP返回：  IP地址 第一跳路由器地IP地址（默认网关） DNS服务器的域名和IP地址 子网掩码（指示地址部分的网络号和主机号）   实例  6、路由聚集 连续的子网前缀的子网可达信息可以做聚集，减少向外部传输路由的数量，减少路由计算的负担。7、IPv6   IPv6数据报格式\n 头部：  Priority：标示流中数据报的优先级 Flow Label：标示数据报在一个“flow” Next header：标示上层协议   特点：  固定的40字节头部 数据报传输过程中，不允许分片      IPv6的变化\n Checksum：被移除，降低在每一段中的处理速度 Options：允许，但是在头部之外，被“Next Header”字段标示 ICMPv6：ICMP的新版本  附加了报文类型 多播组管理功能      IPv4到IPv6的迁移\n  隧道：在IPv4路由器之间传输的IPv4数据报中携带IPv6数据报\n    四、通用转发和SDN 1、SDN方式控制平面和数据平面分离的优点  集中在控制器上实现控制逻辑，网络可编程，可以实现各种复杂的网络功能、新功能（一次部署，持续升级）、方便管理 形成开发生态（控制器，分组交换机，网络应用，在一个开放的框架下协作） SDN分组交换机按照计算出的流表进行分组转发、通用、便于升级  2、分组交换机的工作原理  模式匹配+行动（转发，组播，修改字段和阻塞等） 进来分组，按照各级字段匹配流表，按照相应的行动动作分组 按照优先权进行判断；之后，统计计数  3、OpenFlow数据平面抽象  流：由分组（帧）头部字段所定义 通用转发：简单的分组处理规则  模式：将分组头部字段和流表进行匹配 行动：对于匹配上的分组，可以是丢弃、转发、修改、将匹配的分组发送给控制器 优先权：几个模式匹配了，优先采用哪个，消除歧义 计数器：#bytes 以及 #packets    第五章 网络层：控制平面 一、概述 1、实现控制平面的方法  每个路由器控制功能实现（传统方法） 逻辑上集中的控制功能实现（SDN）  2、传统方式 在每个路由器中的单独路由器算法元件，在控制平面进行交互3、SDN方式 一个不同的（通常是远程的）控制器与本地控制代理（CAs）交互二、路由选择算法 1、路由协议的目标 根据收集到的路由信息（拓扑、链路代价等），计算出源到目标较好的路径，代价比较低的路径\n 主机-主机的路径==路由器-路由器的路径 路由的目的实际上是计算出节点的汇集树 路由原则：完整正确，简单，健壮，稳定公平，最优  2、路由分类  静态和动态  静态：路由随时间变化缓慢 动态：路由变化很快（周期性更新、根据链路代价的变化而变化）   全局和局部  全局：所有的路由器拥有完整的拓扑和边的代价信息（link state 算法） 分布式：路由器只知道与它有物理连接关系的邻居路由器，和到相应邻居路由器的代价值，迭代的与邻居交换路由信息、计算路由信息（distance vector 算法）    3、LS算法（全局的路由选择算法）   配置LS路由选择算法的路由工作过程\n 各点通过各种渠道获得整个网络拓扑，网络中所有链路代价等信息 使用LS路由算法，计算本站点到其他站点的最优路径，得到路由表 按照该路由表转发分组    LS路由的基本工作原理\n  发现相邻节点，获知对方网络地址\n 一个路由器上电之后，向所有线路发送HELLO分组 其他路由器收到HELLO分组，回送应答，在应答分组中，告知自己的名字 在LAN中，通过广播HELLO分组，获得其他路由器的信息    测量到相邻节点的代价（延迟、开销）\n 实测法：发送一个分组要求对方立即响应 回送一个ECHO分组 通过测量时间可以估算出延迟情况    组装一个LS分组，描述它到相邻节点的代价情况\n 发送者名称 序号，年龄 列表：给出它相邻的节点，和它到相邻节点的延迟    将分组通过扩散的方法发到所有其他路由器\n 顺序号：用于控制无穷的扩散，每个路由器都记录源路由器和顺序号，发现重复的或老的就不扩散    通过Dijkstra算法找出最短路径（路由算法）\n 初始化  除了源节点，所有节点都为临时节点（未找到从源节点到此节点的最优路径的节点） 节点代价除了与源节点代价相邻的节点外，都为∞   从所有临时节点中找到一个节点代价最小的临时节点，将之变为永久节点（当前节点）W 对此节点的所有在临时节点集合中的邻节点（V）  如D(v)\u0026gt;D(w)+c(w,v)，则重新标注此点，(D(w)+c(w,v),w) 否则，不重新标注   开始一个新的循环      Dijkstra算法举例：\n       Dijkstra算法的讨论\n 算法复杂度：n节点  每一次迭代：需要检查所有不在永久集合N中的节点 n(n+1)/2次比较：O($n^2$) 有效实现：O(nlogn)   可能的震荡    4、DV算法（局部的路由选择算法）   基本思想\n 各路由器维护一张路由表   各路由器与相邻路由器交换路由表 根据获得的路由信息，更新路由表    代价及相邻节点间代价的获得：\n 跳数、延迟、队列长度 相邻节点间代价的获得：实测    路由信息的更新：\n 根据实测得到本节点到相邻站点的代价（如延迟） 根据各相邻站点声称它们到目标站点的代价 计算出本站点经过各相邻站点到目标站点的代价    找到一个最小的代价，和相应的下一个节点\n  水平分裂算法\n  目的：解决无穷计算问题（当源节点作为下一跳到目的节点的中间节点时会出现循环）\n  举例：C知道要经过B才能到达A，所以C向B报告它到A的距离为INF；C告诉D它到A的真实距离\n  特例：\n    距离矢量算法\n  $D_x(y)=节点x到y的代价最小值$\n x节点维护距离矢量$D_x=[D_x(y)|y\\in N]$    节点x：\n 知道到所有邻居v的代价：$c(x,v)$ 维护一个它的邻居的距离矢量集，对于每个邻居，x维护$D_v=[D_v(y)|y\\in N]$    每个节点定时或DV有变化时，将自己的距离矢量估计值传送给邻居，邻居收到DV时更新自己的距离矢量\n  Bellman-Ford方程\n$$\nD_x(y)=min_v{c(x,v)+D_v(y)}对于每个节点y\\in N\n$$\n$D_x(y)$：x往y的代价\n$c(x,v)$：x到邻居v的代价\n$D_v(y)$：v声称到y的代价\n  $D_x(y)$估计值最终收敛于实际的最小代价值$d_x(y)$\n    举例：\n  迭代方式\n 异步式：被以下事件触发  本地链路代价发生变化 从邻居来了DV的更新消息   分布式：  每个节点只是在自己的DV改变后向邻居通告        链路代价变化\n 节点检测到本地链路发生变化 更新路由信息，重新计算DV 若DV发生变化，通告其邻居 毒性逆转：  若Z需要通过Y才能路由到X：Z告诉Y，Z到X的距离无穷大（因此Y不会经过Z路由到X）      4、LS和DV算法的比较  消息复杂度（DV胜出）  LS：有n个节点，E条链路，发送报文O(nE)个  局部的路由信息，全局传播   DV：只和邻居交换信息  全局的路由信息，局部传播     收敛时间（LS胜出）  LS：O($n^2$) DV：收敛较慢  可能存在路由环路 无穷计算问题     健壮性（LS胜出）  LS：  节点会通告不正确的链路代价 每个节点只计算自己的路由表 错误信息影响较小，局部，路由较健壮   DV：  DV节点可能通告对全网所有节点的不正确路径代价 每一个节点的路由表可能被其他节点使用      5、层次路由  一个平面解决路由的问题：计算、运输和存储路由信息的量太大，不具备可扩展性，也不满足不同网络运营方不同的管理需求 分成AS，AS内部之间的节点路由有内部网关协议解决；AS之间的路由，分层解决（路由到网关，由网关路由到目标网关，到了目标AS内部，采用AS内部的路由解决） 优势：分层路由，解决了规模性问题，管理性问题  三、互联网络的路由协议 1、内部网关协议IGP   RIP\n 特点：  DV：在邻居之间每30秒交换通告报文  定期，且在改变路由的时候发送通告报文 在对方请求下可以发送通告报文   每一个通告至多AS内部的25个目标网络的DV（25个子网，最大跳数为16）   链路失效与恢复（若180秒没有收到通告信息——邻居或链路失效）  发现经过这个邻居的路由已失效 新的通告报文会传递给邻居 邻居因此发出新的通告 链路失效在全网中传播 使用毒性逆转阻止ping-pong回路（不可达距离：跳数无限=16段）   进程处理  RIP以应用进程的方式实现 通告报文通过UDP报文传送，周期性重复 网络层的协议使用了传输层的服务，以应用层实体的方式实现      OSPF\n  使用LS算法\n  OSPF通告信息中携带L每一个邻居路由器的一个表项\n  通告信息会传遍AS全部（通过泛洪）\n 在IP数据报上直接传送OSPF报文（而不是通过UDP和TCP）    高级特性：\n 安全 允许有多个代价相同的路径存在（RIP协议中只有一个） 对每一个链路，对于不同的TOS有多重代价矩阵 对单播和多播的集成支持 在大型网络中支持层次性OSPF    层次性的OSPF路由\n  两个级别的层次性：本地，骨干\n 链路状态通告仅仅在本地区域范围内进行 每一个节点拥有本地区域的拓扑信息    区域边界路由器（area border router）：汇总到自己区域内网络的距离，向其他区域边界路由器通告\n  骨干路由器（backbone router）：仅仅在骨干区域内，运行OSPF路由\n  边界路由器（boundary router）：连接其他AS‘s\n      IGRP\n  2、外部网关协议EGP   BGP\n  简介\n 网关路由器参与AS内部路由计算，收集AS内部子网可达信息 网关路由器通过AS间路由向其他AS网关通告子网可达信息 网关路由器可转发“过手”子网可达信息，但AS路径要加上自己AS编号（防止形成回路） 网关路由器通过iBGP向AS内部所有路由通告收集到的子网可达信息 网关路由器通过eBGP从相邻的区域获得子网的可达信息 内部路由器，通过AS内路由和AS间路由共同决定向AS外部子网的下一跳（内部网关协议决定如何往网关，外部网关协议决定通过哪个网关可到达AS外部子网）    eBGP，iBGP连接\n  BGP会话\n  2个BGP路由器在一个半永久的TCP连接上交换BGP报文，通告向不同目标子网前缀的“路径”\n  举例：\n    路径的属性\n AS-PATH：前缀的通告所经过的AS列表  检测环路：多路径选择 在向其他AS转发时，需要将自己的AS号加在路径上   NEXT-HOP：从当前AS到下一跳有多个链路，在NEXT-HOP属性中，告诉对方通过哪个转发 其他属性：路由偏好指标，如何被插入的属性    BGP路由\n 基于策略的路由：  当一个网关路由器接收到了一个路由通告，使用输入策略来接受或过滤 策略决定了是否向它的别的邻居通告收到的这个路由信息      BGP路径通告\n      BGP报文\n 使用TCP协议交换BGP报文 BGP报文：  OPEN：打开TCP连接，认证发送方 UPDATE：通告新路径（或撤销原路径） KEEPALIVE：在没有更新时保持连接，也用于对OPEN请求确认 NOTIFICATION：报告以前消息的错误，也用来关闭连接      BGP路径选择\n 本地偏好值属性：偏好策略决定 最短AS-PATH：AS的跳数 最近的NEXT-HOP路由器：热土豆路由 附加的判据：使用BGP标示      3、内部网关协议和外部网关协议的对比  策略  Inter-AS：管理员需要控制通信路径，谁在使用它的网络进行数据传输 Intra-AS：一个管理者，无需策略  AS内部的各子网的主机尽可能地利用资源进行快速路由     规模  Inter-AS：路由必须考虑规模问题，以便支持全网的数据转发 Intra-AS：路由规模不是一个大的问题  若AS太大，可将AS分成小的AS；规模可控 AS之间只不过多了一个点而已 又或AS内部路由支持层次性，层次性路由节约表空间，降低了更新的数据流量     性能  Intra-AS：关注性能 Inter-AS：策略可能比性能更重要    四、SDN控制平面 1、优势  网络管理更加容易：避免路由器的错误配置，对于通信流的弹性更好 基于流表的转发，集中计算流表然后分发 控制平面的开放实现  2、SDN控制器  维护网络状态信息 通过上面的北向API和网络控制应用交互 通过下面的南向API（openflow）和网络交换机交互（下发流表，上报设备状态） 逻辑上集中，但是在实现上通常由于性能、可扩展性、容错性以及鲁棒性采用分布式方法  3、OpenFlow协议  控制器和SDN交互的协议 采用YCP来交换报文  加密可选   3种OpenFlow报文类型  控制器\u0026gt;交换机  特性：控制器查询交换机特性，交换机应答 配置：交换机查询/设置交换机的配置参数 修改状态:增加删除修改OpenFlow表中的流表 packet-out：控制器可以将分组通过特定的端口发出   异步（交换机\u0026gt;控制器）  分组进入：将分组传给控制器 流移除：在交换机上删除流表项 端口状态:通告控制器端口的变化   对称    五、ICMP协议 1、作用  错误报告：主机不可达、网络、端口、协议 Echo请求和回复（ping）  2、报文类型  ICMP处在网络层，但在IP协议上面  ICMP消息由IP数据报承载   ICMP报文  类型 编码 加上IP数据报的头8B    3、举例：Traceroute and ICMP 第六章 数据链路层与局域网 一、引论 1、链路层提供的服务  成帧，链路存取控制（链路访问控制）  将数据报封装在帧中，加上帧头、帧尾部 若采用共享性介质，信道接入获得信道访问权 在帧头部使用MAC地址来标示源和目的   在相邻节点完成可靠数据传递  在低出错率的链路上（光纤和双绞线电缆）很少使用 在无线链路经常使用：出错率高   流量控制  使得相邻的发送和接收方节点的速度匹配   错误检测  差错由信号衰减和噪声引起 接收方检测出错误：  通知发送端进行重传或丢弃帧     差错纠正  接收端检查和纠正bit错误，不通过重传来纠正错误   全双工和半双工服务  半双工：链路可以双向传输，但一次只有一个方向    2、链路层网络节点的连接方式  点到点方式：适合广域 多点连接的方式：比较适合局域、联网方便，但需要解决MAC问题  3、链路层实现位置  在每一个主机上  路由器 交换机的每一个端口   链路层的功能在适配器上实现  以太网卡 实现链路层和相应的物理层功能   接到主机的系统总线上 硬件、软件和固件的综合体  4、适配器通信  发送方  在帧中封装数据报 加上差错控制编码，实现RDT和流量控制功能   接收方  检查有无出错，执行rdt和流量控制功能等 解封装数据报，将至交给上层    5、数据链路层和局域网  WAN：网络形式采用点到点链路  带宽大、距离远（延迟大） 若采用多点连接方式：  竞争方式：一旦冲突代价大 令牌等协调方式：在其中协调节点的发送代价大     LAN：一般采用多点连接方式  连接节点非常方便 接到共享型介质上（或网络交换机），就可以连接所有其它节点    二、检错与纠错 1、检错原理   奇偶校验（发送方附加一个bit，选择它的值，偶校验：使得所有比特中1的总数为偶数；奇校验：使得所有比特中1的总数为奇数）\n  单bit奇偶校验：检测单个bit级错误\n  2维奇偶校验：检测和纠正单个bit错误\n    循环冗余校验CRC\n 将数据比特D看成二进制的数据 生成多项式G：双方协商的r+1位模式（r次方）  生成和检查所使用的位模式   目标：选择r位CRC附加位R，使得  \u0026lt;D, R\u0026gt;正好被G整除（modulo 2） 接收方知道G，将\u0026lt;D, R\u0026gt;除以G，若非0余数，则检查出错误 能检查出所有少于r+1位的突发错误（适当假设下，长度大于r+1比特的突发差错以概率$1-0.5^r$被检测到）   举例：    三、多路访问协议 1、多路访问协议的必要性  分布式算法决定节点如何使用共享信道 关于共享控制的通信必须用借助信道本身传输  没有带外的信道，各节点使用其协调信道使用 用于传输控制信息    2、媒体访问控制（MAC）协议 （1）信道划分  TDMA  轮流使用信道，信道的时间分为周期 每个站点使用每周期中固定的时隙（长度=帧传输时间）传输帧 若站点无帧传输，时隙空闲——浪费   FDMA  信道的有效频率范围被分成一个个小的频段 每个站点被分配一个固定的频段 分配给站点的频段如果没有被使用，则空闲   CDMA  所有站点在整个频段上同时传输，采用编码原理加以区分 完全无冲突 假定：信号同步好，线性叠加    （2）RAP：随机访问协议   时隙ALOHA 假设  所有帧等长 时间被划分为相等的时隙，每个时隙可以发送一帧 节点只在时隙开始时发送帧 节点在时钟上是同步的 如果两个或多个节点在一个时隙传输，所有的站点都能检测到冲突   运行  当节点获取新的帧，在下一个时隙传输 传输时没有检测到冲突，成功  节点能够在下一时隙发送新帧   检测时如果检测到冲突，失败  节点在每一个随后的时隙以概率p重传帧直到成功     优点  节点可以以信道带宽全速连续传输 高度分布：仅需要节点之间在时隙上的同步 简单   缺点  存在冲突，浪费时隙 即使有帧要发送，仍然也可能存在空闲的时隙 节点检测冲突的时间\u0026lt;帧传输的时间  必须完成   需要时钟上同步   效率  假设有N个节点，每个节点都有很多帧要发送，在每个时隙中传输概率为p 一个节点成功传输概率为$p(1-p)^{N-1}$ 信道上，任何一个节点的成功概率是$Np(1-p)^{N-1}$ N为无穷大时的极限为1/e=0.37  最好情况：信道利用率为37%        纯ALOHA  简单、无须节点之间在时间上同步\n  当有帧需要传输：马上传输\n  冲突的概率增加：\n 帧在$t_0$发送，和其他在$[t_0-1,\\ t_0+1]$区间内开始发送的帧冲突 和当前帧冲突的区间增大了一倍    纯ALOHA的效率：\n    CSMA（载波侦听多路访问）\n 基本思想：在传输前先侦听信道  如果侦听到信道空闲，传送整个帧 如果侦听到信道忙，推迟传送   CSMA冲突原因：传播延迟。两个节点可能侦听不到正在进行的传输    CSMA/CD（冲突检测）\n  CSMA/CD：\n 载波侦听CSMA：和在CSMA中一样发送前侦听信道 没有传完一个帧就可以在短时间内检测到冲突 冲突发生时则传输终止，减少对信道的浪费    冲突检测技术：\n 有线局域网中容易实现：  检测信号强度，比较传输与接收到的信号是否相同 通过周期的过零点检测   无线信道：在传输时接收是关闭的  本站点发送的信号强度远远大于来自其他节点的信号强度 本站点周边信号有冲突，不意味着接收节点处有冲突 无法一边发送一边进行冲突检测      以太网CSMA/CD算法\na. 适配器获取数据报，创建帧\nb. 发送前：侦听信道CS\n 闲：开始传送帧 忙：一直等到闲再发送  c. 发送过程中，冲突检测CD\n 没有冲突：成功 检测到冲突：放弃，之后尝试重发  d. 发送方适配器检测到冲突，除放弃外，发送一个Jam信号，所有听到冲突的适配器也是如此（强化冲突：让所有站点都知道冲突）\ne. 如果放弃，适配器进入指数退避状态：在第m次失败后，适配器随机选择一个${0,1,2,\\ \u0026hellip;\\ ,2^{m-1}}$中K，等待K*512位时（512位时，对于100Mbps来说，即5.12ms），然后转至b\n  CSMA/CD效率\n$t_{prop}$=LAN上2个节点的最大传播延迟\n$t_{trans}$=传输最大帧的时间\n$$\nefficiency=\\frac{1}{1+5t_{prop}/t_{trans}}\n$$\n当效率变为1\n 当$t_{prop}$变成0时 当$t_{trans}$变成无穷大时      CSMA/CA（冲突避免，IEEE802.11 MAC协议）\n 发送方：  若站点侦测到信道空闲持续DIFS长，则传输整个帧 若检测到信道忙碌，则选择一个随机回退值，并在信道空闲时递减该值；若信道忙碌，回退值不会变化 到数到0时，发送整个帧 若没有收到ACK，增加回退值，重复等待   接收方  若帧正确，则在SIFS后发送ACK   冲突原因：  两个站点相互隐藏 选择非常靠近的随机回退值   RTS-CTS交换  思想：允许发送方“预约”信道，而不是随机访问该信道（避免长数据帧的冲突 ） 发送方首先使用CSMA向BS发送一个小的RTS分组  RTS可能会冲突（但是由于比较短，浪费信道比较少）   BS广播 clear-to-send CTS，作为RTS的响应 CTS能够被所有涉及到的节点听到  发送方发送数据帧 其它节点抑制发送         （3）轮流MAC协议   轮询\n 主节点邀请从节点依次传送 缺点：  轮询开销：轮询本身消耗信道带宽 等待时间：每个节点需要等到主节点轮询后开始传输，即使只有一个节点，也需要等到轮询一周后才能发送 单点故障：主节点失效时造成整个系统无法工作      令牌传递\n 控制令牌循环从一个节点到下一个节点传递 令牌报文：特殊的帧 缺点：  令牌开销：本身消耗带宽 延迟：只有等到抓住令牌，才可传输 单点故障：  令牌丢失系统级故障，整个系统无法传输 复杂机制重新生成令牌        四、链路层编地址 1、MAC地址  作用：用于使帧从一个网卡传递到与其物理连接的另一个网卡（同一物理网络中） 格式：48bit（e.g.：1A-2F-BB-76-09-AD ） 分配：链理论上全球任何两个网卡的MAC地址都不相同  2、MAC地址与网络层IP地址的区别  格式  32bit IP地址  网络层地址 用于使数据报到达目的IP子网：前n-1跳 从而到达子网中的目标节点：最后一跳   LAN（MAC/物理/以太网）地址  用于使帧从一个网卡传递到与其物理连接的另一个网卡\n(在同一个物理网络中) 48bit MAC地址固化在适配器的ROM，有时也可以通\n过软件设定 理论上全球任何2个网卡的MAC地址都不相同     作用  IP地址：分层  一个子网的所有站点网络号一致，路由聚集，减少路由表，便于计算路由 网络层地址是配置的：IP地址完成网络到网络的交付   MAC地址：平面  网卡的唯一标示，用于区分一个网络内部不同的网卡即可 可以完成一个物理网络内部的节点到节点的数据交付      3、ARP协议   目的：完成物理网络范围内IP地址到MAC地址的转换\n  ARP表：包括一些LAN节点IP/MAC地址的映射\n  工作原理：\n 广播查询 单播应答    在同一LAN网络内的ARP协议\n A要发送帧给B（B的IP地址已知），但B的MAC地址不在A的ARP表中 A广播包含B的IP地址的ARP查询包（广播查询）  LAN上的所有节点都会收到该查询包   B接收到ARP包，回复A自己的MAC地址  帧发送给A 用A的MAC地址（单播应答）   A在自己的ARP表中，缓存IP-to-MAC地址映射关系，直到信息超时  软状态：靠定期刷新维持的系统状态 定期刷新周期之间维护的状态信息可能和原有系统不一样      路由到其他LAN的ARP协议\n  假定发送数据报：由A通过R到B，假设A知道B的IP地址\n  在R上有两个ARP表，分别对应两个LAN\n在源主机的路由表中，发现到目标主机的下一跳时111.111.111.110\n在源主机的ARP表中，发现其MAC地址是E6-E9-00-17-BB-4B，etc\n  A创建数据报，源IP地址：A；目标IP地址：B\n  A创建一个链路层的帧，目标MAC地址是R，该帧包含A到B的IP数据报\n  帧从A发送到R\n  帧被R接收到，从中提取出IP分组，交给上层IP协议实体\n  R转发数据报，数据报源IP地址为A，目标IP地址为B\n  R创建一个链路层帧，目标MAC地址为B，帧中包含A到B的IP数据报    五、以太网络 1、IEEE802.3标准：链路和物理层  相同的MAC协议（介质访问控制协议）和帧结构 不同的速率：2Mbps、10Mbps、100Mbps、1Gbps、10Gbps 不同的物理层标准 不同的物理层媒介：光纤，同轴电缆和双绞线  2、以太网络的帧结构  前导码（preamble）  7B 10101010 + 1B 10101011 用来同步接收方和发送方的时钟速率  使得接收方将自己的时钟调到发送端的时钟 从而可以按照发送端的时钟来接收所发送的帧     地址（dest/source address）：6字节源MAC地址，目标MAC地址 类型（type）：指出高层协议 CRC：在接收方校验（未通过校验则丢弃错误帧）  3、向上提供服务的特点  无连接：帧传输前，发送方和接收方之间没有握手 不可靠：接收方适配器不发送ACKs或NAKs给发送方  递交给网络层的数据报流可能有gap 如上层使用像运输层TCP协议的rdt，gap会被补上 否则，应用层就会看到gap    4、访问控制技术  CSMA/CD 指数后退  5、编码   Manchester编码\n 在10BaseT中使用 每一个bit的位时中间有一个信号跳变 允许在接收方和发送方节点之间进行时钟同步 10Mbps，使用20M带宽，效率50%    六、HUB和交换机 1、集线器（Hub）  本质上为物理层的中继器：  从一个端口收，转发到所有其他端口 速率一致 没有帧的缓存 在hub端口上没有CSMA/CD机制：适配器检测冲突 提供网络管理功能   所有以hub连在一起的站点处于同一网段（可以允许一个站点发送的网络范围），处在一个碰撞域  骨干hub将所有网段连在一起   通过hub可扩展节点之间的最大距离 通过hub，不能将10BaseT和100BaseT的网络连接在一起  2、交换机  工作原理  选择性转发  对到来的帧，检查帧头，根据目标MAC地址进行选择性转发   自学习  无需配置，即插即用 当接收到帧时，交换机学习到发送站点所在的端口 记录发送方MAC地址/进入端口映射关系，在交换表中   流量隔离  透明，主机对交换机的存在可以不关心 通过交换机相联的各节点就像直接相联一样 有MAC地址，无IP地址   专用接入  当帧需要向某个网段进行转发，需要使用CSMA/CD进行接入控制 通常一个交换机端口一个独立网段      3、路由器和交换机的区别  都是存储转发设备，但层次不同  交换机：链路层设备（检查链路层头部） 路由器：网络层设备（检查网络层头部）   都有转发表  交换机：维护交换表，按MAC地址转发  执行过滤、自学习和生成树算法 即插即用；二层设备，速率高 执行生成树算法，限制广播帧的转发 ARP表项随着站点数量增多而增多   路由器：维护路由表，执行路由算法  路由算法能够避免环路，无需执行生成树算法，可以以各种拓扑构建网络 对广播分组做限制 不是即插即用的，配置网络地址（子网前缀） 三层设备，速率低      第七章 网络安全 一、网络安全的含义 1、网络安全的含义  机密性：只有发送方和预订的接收方能够理解传输的报文内容  发送方加密报文 接收方解密报文   可认证性：发送方和接收方需要确认对方的身份 报文完整性：发送方、接收方需要确认报文在传输的过程中或者时候没有被改变 访问控制和服务可用性：服务可以接入以及对用户而言是可用的  2、网络安全威胁  截获：截获报文 插入：在连接上插入报文 伪装：可以在分组的源地址写上伪装的地址 劫持：将发送方或者接收方踢出，接管连接 拒绝服务（DOS）：阻止服务被其他正常用户使用  二、加密原理 1、加密技术   对称加密：发送方和接收方的密钥相同\n  替换（如单码替换密码：将一个字母替换成另外一个字母）\n  DES\n  US加密标准\n  56-bit对称密钥，64-bit明文输入\n  初始替换\n16轮一样的函数应用，每一轮使用不同的48bit密钥\n最终替换\n    AES\n 数据128bit成组加密 128，192或256 bit keys      公开密钥加密\n  RSA\n  要求：\n 需要$K^+_B(\\cdot)$和$K^-_B(\\cdot)$，满足$K^-_B(K^+_B(m))=m$ 给定一个公钥$K_B^+$推出私钥$K^-_B$计算上不可行    选择密钥\n1）选择2个很大的质数$p$，$q$（e.g., 1024 bits each）\n2）计算$n=pq$，$z=(p-1)(q-1)$\n3）选择一个$e$（要求$e\u0026lt;n$）和$z$没有一个公共因子，互素\n4）选择$d$使得$ed-1$正好能够被$z$整除即$ed\\ mod\\ z=1$\n5）公钥$K^+_B=(n,e)$，私钥$K^-_B=(n,d)$\n  加密\n公钥$K^+_B=(n,e)$，加密一个bit模式，m，如此计算：\n$c=m^e\\ mod\\ n$ （i.e., $m^e$除以$n$的余数）\n  解密\n私钥$K^-_B=(n,d)$，对接收到的密文$c$解密，如此计算：\n$m=c^d\\ mod\\ n$（i.e., $c^e$除以$n$的余数）\n  例子  特点\n $m=(m^e\\ mod\\ n)^d\\ mod\\ n$ 数论定理：若$p$，$q$都是素数，$n=pq$，那么：$x^y\\ mod\\ n=x^{y\\ mod\\ (p-1)(q-1)}\\ mod\\ n$ 公钥私钥可交换：$K^-_B(K^+_B(m))=m=K^+_B(K^-_B(m))$        三、认证原理 1、目的  证明身份  2、使用对称加密技术进行认证的工作原理  传送密码来认证  重放攻击：事先记录发送方的分组，事后向接收方重放   传送加密后的密码来认证  重放依然有效   接收方发送给发送方一个nonce，R，发送方必须返回加密之后的R，使用双方约定好的key（证明发送方的活跃性）  3、使用公开密钥加密体系进行认证的工作原理  使用nonce，公开密钥加密技术，$R=K^+_B(K^-_B(R))$  中间攻击    四、报文完整性 1、目的  可鉴别性 不可伪造性 不可抵赖性  2、手段：数字签名  Bob使用他自己的私钥对$m$进行签署，创建数字签名$K^-_B(m)$ 假设Alice收到报文$m$，以及数字签名$K^-_B(m)$ Alice使用Bob的公钥$K_B^+$对$K_B^-(m)$进行验证，判断$K^+_B(K^-_B(m))=m$是否成立 若$K^+_B(K^-_B(m))=m$成立，则签署该文件的人一定拥有Bob的私钥  3、报文摘要   原理：对$m$使用散列函数$H$，获得固定长度的报文摘要$H(m)$\n 散列函数的特性：  多对1 结果固定长度 给定一个报文摘要$x$，反向计算出原报文在计算上是不可行的$x=H(m)$      散列函数算法\n MD5散列函数  4个步骤计算出128-bit的报文摘要 给定一个任意的128-bit串x，很难构造出一个报文m具有相同的摘要x   SHA-1  US标准 160-bit报文摘要      四、改进 加密报文摘要\n五、密钥分发和证书 1、KDC工作原理  KDC在实体之间扮演可信赖中介的角色 服务器和每一个注册用户都分享一个对称式的密钥 Alice，Bob在和KDC通信的时候，知道他们自己的对称式密钥$K_{A-KDC}$和$K_{B-KDC}$ 通信前使用R1作为对称式的会话密钥  2、CA工作原理   CA将每一个注册实体E和他的公钥捆绑\n  E到CA那里注册他的公钥\n E提供给CA自己的身份证据 CA创建一个证书，捆绑了实体信息和他的公钥 Certificate包括了E的公钥，而且是被CA签署的（被CA用自己的私钥加了密）    当Alice需要拿到Bob的公钥\n 获得Bob的证书certificate（从Bob或其他地方） 对Bob的证书，使用CA的公钥来验证    证书结构：  信任树\n 根证书：根证书是未被签名的公钥证书或自签名的证书  拿到一些CA的公钥 渠道：安装OS自带的数字证书；从网上下载你信任的数字证书   信任树  信任根证书CA颁发的证书，拿到了根CA的公钥 由根CA签署的给一些机构的数字证书，包含了这些机构的数字证书      6、防火墙和IDS  作用  阻止拒绝服务攻击  SYN flooding（泛洪）：攻击者建立很多weizaoTCP链接，对于真正用户而言已经没有资源留下了   阻止非法的修改/对非授权内容的访问  e.g., 攻击者替换掉CIA的主页   只允许认证的用户能否访问内部网络资源（经过认证的用户/主机集合）   类型  网络级别：分组过滤器  内部网络通过配置防火墙的路由器连接到互联网上 路由器对分组逐个过滤，根据以下规则来决定转发还是丢弃：  源IP地址，目标IP地址 TCP/UDP源和目标端口 ICMP报文类别 TCP SYN和ACK bits     应用级别：应用程序网关  根据应用数据的内容来过滤进出的数据报 举例：允许内部用户登录到外部服务器，但不是直接登录  需要所有的telnet用户通过网关来telnet 对于认证用户而言，网关建立和目标主机的telnet connect，网关在2个连接上进行中继 路由器过滤器对所有不是来自网关的telnet的分组全部过滤掉       IDS：入侵检测系统  深入分组的检查：检查分组的内容（特征串、已知攻击数据库的病毒和攻击串等） 检查分组间的相关性，判断是否为有害的分组  端口扫描 网络映射 DoS攻击      7、多层次的安全   安全电子邮件\n1）Alice需要发送机密的报文m给Bob\n Alice：  产生随机的对称密钥，$K_S$ 使用$K_S$对报文加密 对$K_S$使用Bob的公钥进行加密 发送$K_S(m)$和$K_B(K_S)$给Bob   Bob：  使用自己的私钥解密$K_S$ 使用$K_S$解密$K_S(m)$得到报文    2）Alice需要提供源端的可认证性和报文完整性 Alice数字签署文件 发送报文（明文）和数字签名  3）Alice需要提供机密性，源端可认证性和报文的完整性\n Alice使用了3个keys：自己的私钥，Bob的公钥，新产生的对称式密钥    日常应用：连接到互联网 总结附录 一、常用缩写  P2P：Peer to peer点对点协议 TCP：Transmission Control Protocol传输控制协议 UDP：User Datagram Protocol用户数据报协议 FDM：Frequency division multiplexing频分 TDM：Time division multiplexing时分 WDM：Wave division multiplexing波分 VC：virtual circuit虚电路 DSL：digital subscriber line数字用户线路 HFC：Hybird fiber coax混合光纤同轴网络 TP：双绞线 ISP：Internet Sevice Providers网络服务提供商 SAP：Services Access Point服务访问点 HTTP：Hyper Text Transfer Protocol超文本传输协议 RTT：round-trip time往返时间 SMTP：Simple Mail Transfer Protocol简单邮件传输协议 MIME：multimedia mail extension多媒体邮件扩展 POP：Post Office Protocol邮局访问协议 IMAP：Internet Mail Access Protocol 邮件访问协议 DNS：Domain Name System域名系统 TLD：Top Level Domain顶级域 RR：Resource Records资源记录 DASH：Dynamic，Adaptive Streaming over HTTP CDN：Content Distribution Networks内容分发网络 SDN：Software Defined Networking软件定义网络 RDT：Reliable data transfering可靠数据传输 SR：Selective Repeat选择重传 GBN：Go Back N 回退N步 MSS：Maximum Segment Size最大报文段大小 RR：Round Robin轮询 WFQ：Weighted Fair Queuing加权队列 IP：Internet Protocol网络协议 DHCP：Dynamic Host Configuration Protocol动态主机配置协议 NAT：Network Address Translation网络地址转换 LS：Link State链路状态 DV：distance vector距离向量 RIP：Routing Information Protocol路由信息协议 OSPF：Open Shortest Path First开放的最短路径优先 AS：autonomous systems自治系统 BGP：Border Gateway Protocol边界网关协议 eBGP：External Border Gateway Protocol外部边界网关协议 iBGP：internal Border Gateway Protocol内部边界网关协议 ICMP：Internet Control Message Protocol网络控制报文协议 SNMP：Simple Networks Management Protocol简单网络管理协议 CRC：Cyclic Redundancy Check循环冗余校验 MAC：Media Access Control媒体访问控制 TDMA：Time Division Multiple Access时分多路访问 FDMA：Frequency Division Multiple Access频分多路访问 CDMA：Code Division Multiple Access码分多路访问 CSMA：Carrier Sense Multiple Access载波侦听多路访问 CD：Collision Detection冲突检测 CA：Collision Avoidance冲突避免 DOCSIS：Data Over Cable Service Interface Spec有线电缆数据服务接口规范 ARP：Address Resolution Protocol地址解析协议 DES：Data Encryption Standard数据加密规范 AES：Advanced Encryption Standard先进加密规范 KDC：Key Distribution Center密钥分发中心 CA：Certification Authority证书认证 IDS：Intrusion Detection System入侵检测系统 DoS：Denial of Service拒绝服务 CIDR：Classless Inter Domain Routing无类域间路由 AIMD：Additive Increase Multiplicative Decrease和式增乘式减 SYN：Synchronize Sequence Number同步序列编号 FTTH：Fiber to The Home 光纤到户 AON：Active Optical Network 主动光纤网络 PON：Passive Optical Network 被动光纤网络 SSL：Secure Sockets Layer 安全套接层 PDU：Protocol Data Unit 协议数据单元 MTU：Maximum Transmission Unit 最大传输单元  二、易错点总结   常用接入技术：DSL、FTTH、Ethernet 、WiFi、3G、LTE\n  1Byte=8bits\n1MB=1024KB=1024x1024B=1024x1024x8bits\nByte：字节\nbit：位、比特\n  节点延迟的计算：\n$$\nd_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}\n$$\n $d_{proc}$=处理延时，通常是微秒数量级或更少（固定） $d_{queue}$=排队延时，取决于拥塞程度（变化） $d_{trans}$=传输延时=分组长度/链路宽度=L/R，对低速率的链路而言很大，通常为微秒级到毫秒级（固定） $d_{prop}$=传播延时=物理链路长度/在媒体上的传播速度=d/s，几微秒到几百毫秒（固定） 带宽-时延积：$R\\cdot t_{prop}$ 衡量链路上能容纳的最大比特数量    SSL属于应用层服务，若是用 SSL 来强化 TCP，则需要在应用程序中包含 SSL 代码\n  一个机构的 Web 服务器和邮件服务器可以有完全相同的主机名别名\n 为了获取邮件服务器的规范主机名，DNS客户应当请求一条MX记录 为了获得其他服务器的规范主机名，DNS客户应当请求CNAME记录    使用 UDP 服务器时，没有欢迎套接字，来自不同客户端的所有数据都通过这个套接字进入服务器\n使用 TCP 服务器，有一个欢迎套接字，每次客户端启动与服务器的连接时，都会创建一个新套接字\n为了支持 n 个并行连接，TCP服务器需要 n + 1 个套接字\n  HTTP 响应报文的头部代码是： 304 时， 为空的报文体\n  周知端口号：0~1023\n  rwnd=接收缓存-主机 B 中已接收但未读取的数据量\n  主机A发送但未被确认的字节数不会超过接收缓存的大小\n  可靠数据传输协议中，窗口长度n与信道利用率$U_{sender}$的关系：$U_{sender}=\\frac{n\\times \\frac{L}{R}}{RTT+\\frac{L}{R}}$\n  TCP客户端建立连接的socket函数：socket-bind-listen-accept\n  TCP首部20字节，UDP首部8字节，IPv4数据报头部20字节，IPv6数据报头部40字节\n  三、重要例题 第二章 P10 易错点：持续连接每次下载引用对象需要发送请求，即一个$(\\frac{200}{150}+T_p)$\n第三章 P27 易错点：\n 第二组数据先于第一组到达，则快速重传：ACK=127不变 第一组数据的确认丢失，超时重发，ACK=247与第二组相同 第二组无需重传（新的一轮timeout内接收到）  第三章 P40 第四章 P5 a.b.c.d/x形式表示：\n易错点：1100001 1……应分到接口3\n第四章 P14 易错点：\n 片位移=当前分片之前所有分片数据长度（减去TCP首部20字节之后）之和/8 分片标识号相同 最后一块分片标志为0，其余为1  第四章 易错点： 分配地址以$2^n$为基准分配\n第四章 第四章 易错点：\n 子网掩码：1表示子网部分，0表示主机部分（和CIDR地址划分区分） 子网号为主机部分全为0时的地址  第四章 第五章 P3 **易错点：**Dijikstra算法每次选择距离最短点进路径进行迭代\n第五章 P5 **易错点：**DV表的计算\n第五章 P7 易错点： 链路代价变化对DV算法的影响\n第五章 P14 第五章 P15 第六章 P5 **易错点：**CRC的计算\n第六章 P15 第六章 P21 第六章 P17 第六章 P26 第六章 P27 第六章 P37 ","description":"计算机网络学习要点，教材：《计算机网络：自顶向下方法》","id":23,"section":"posts","tags":["Computer Network"],"title":"计算机网络学习要点","uri":"https://chaphlagical.github.io/zh/posts/computer/network/"}]