[{"content":"1. B样条基函数 为解决Bézier曲线的全局性、端点性等问题，我们引入了Bézier样条来实现曲线的局部编辑，但由于Bézier样条曲线本质上是分段Bézier曲线，数学表达不够优美，在构造、求交等计算上较为麻烦，为此我们又引入B样条基函数的工具，能够精确表达分段Bézier曲线。\n1.1. 单位B样条基函数 B样条基函数通过不同连续阶性的简单基函数进行混合得到连续性更强的高阶基函数，例如一阶单位B样条基函数定义为：\n$$\nN_i^1(t)=\\begin{cases}\n1,\u0026amp;\\mathrm {if}\\ i\\leq t\u0026lt; i+1\\\\\\\\\n0,\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n$$\n$N_i^1(t)$为$C^{-1}$连续，函数图像如下：\n通过平移与混合：\n可以得到$C^0$连续的基函数$N_i^2(t)$：\n$$\n\\begin{aligned}\nN_i^2(t)\u0026amp;=(t-i)N_i^1(t)+(i+2-t)N_{i+1}^1(t)\\\\\\\\\n\u0026amp;=\\begin{cases}\nt-i,\u0026amp;\\mathrm{if}\\ i\\leq t\\leq i+1\\\\\\\\\ni+2-t,\u0026amp;\\mathrm{if}\\ i+1\\leq t\\leq i+2\\\\\\\\\n0,\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n\\end{aligned}\n$$\n依次类推，继续混合：\n这样一来，可以定义$k$阶的单位均匀B样条基函数$N_i^k(t)$定义为：\n$$\n\\begin{aligned}\nN_i^1(t)\u0026amp;=\\begin{cases}\n1,\u0026amp;\\mathrm {if}\\ i\\leq t\u0026lt; i+1\\\\\\\\\n0,\u0026amp;\\mathrm{otherwise}\n\\end{cases}\\\\\\\\\nN_i^k(t)\u0026amp;=\\frac{t-i}{(i+k-1)-i}N_i^{k-1}(t)+\\frac{(i+k)-t}{(i+k)-(i+1)}N_{i+1}^{k-1}(t)\\\\\\\\\n\u0026amp;=\\frac{t-i}{k-1}N_i^{k-1}(t)+\\frac{i+k-t}{k-1}N_{i+1}^{k-1}(t)\n\\end{aligned}\n$$\n**$k$阶单位B样条基函数的性质**\n $N_i^k(t)\u0026gt;0$，$i\u0026lt;t\u0026lt;i+k$ $N_i^k(t)=0$，$t\\in(-\\infty,i]\\cup [i+k,+\\infty)$ $N_i^k(t)$为$C^{k-2}$阶连续 $N_i^k(t)$为分段$k-1$次多项式函数组成  1.2. 一般的B样条基函数 给定结序列$t_0\u0026lt;t_1\u0026lt;\\cdots\u0026lt;t_n\u0026lt;\\cdots\u0026lt;t_{n+k}$，$(t_0,t_1,\\cdots,t_{n+k})$称为结向量\n归一化的$k$阶（即$k-1$度）的单位B样条基函数$N_{i,k}(t)$定义为：\n$$\n\\begin{align}\nN_{i,1}(t)\u0026amp;=\\begin{cases}\n1,\u0026amp;t_i\\leq t\u0026lt;t_{i+1}\\\\0,\u0026amp;\\mathrm{otherwise}\n\\end{cases}\\\\\\\\\nN_{i,k}(t)\u0026amp;=\\dfrac{t-t_i}{t_{i+k-1}-t_i}N_{i,k-1}(t)+\\dfrac{t_{i+k}-t}{t_{i+k}-t_{i+1}}N_{i+1,k-1}(t)\n\\end{align}\n$$\n$k$阶B样条基函数的性质\n $i=0,1,\\cdots,n$，$k\\in\\mathbb Z^+$ 对$t\\in(t_i,t_{i+k})$，有$N_{i,k}(t)\u0026gt;0$ 对$t\\in(-\\infty,t_i]\\cup[t_{i+k},+\\infty)$，有$N_{i,k}(t)=0$ 对$t\\in(t_{k-1},t_{n+1})$，有$\\sum_{i=1}^nN_{i,k}(t)=1$ $N_{i,k}(t)$由分段多项式函数组成，次数为$k-1$，在$[t_i,t_{i+k}]$上$C^{k-2}$阶连续 区间$[t_i,t_{i+k}]$称为$N_{i,k}$的支撑区间  2. B样条曲线 2.1. B样条曲线的定义 给定：\n  $n+1$个控制点$\\pmb d_0,\\pmb d_1,\\cdots,\\pmb d_n\\in\\mathbb R^3$\n  结向量$T=(t_0,\\cdots,t_n,\\cdots,t_{n+k})$\n 这是由于$N_{n,k}$定义在区间$[n,n+k]$上\n   则$k$阶的B样条曲线$\\pmb x(t)$定义为：\n$$\n\\pmb x(t)=\\sum\\limits_{i=0}^nN_{i,k}(t)\\cdot\\pmb d_i\n$$\n其中，点$\\pmb d_i$称为de Boor点\n 注意该定义下，B样条曲线不插值de Boor点$\\pmb d_i$\n 示例：\n重复结向量\nB样条曲线允许重复结向量：$T=(t_0,\\cdots,t_n,\\cdots,t_{n+k})$，$t_0\\leq t_1\\leq \\cdots\\leq t_{n+k}$\n当重复$k$次以上时，函数值视为0，没有贡献。\n当$t_0=t_1=\\cdots=t_{k-1}$且$t_{n+1}=t_{n+2}=\\cdots=t_{n+k}$时，将插值$\\pmb d_0$和$\\pmb d_1$\n示例：\n2.2. B样条曲线的计算——de Boor算法 给定：\n de Boor点：$\\pmb d_0,\\pmb d_1,\\cdots,\\pmb d_n$ 结向量：$(t_0,\\cdots,t_{k-1}=t_0,t_k,t_{k+1},\\cdots,t_n,t_{n+1},\\cdots,t_{n+k}=t_{n+1})$  则B样条曲线的计算流程如下：\n中间系数$\\pmb d_i^j(t)$可以表示为一个下三角矩阵——de Boor图：\n$$\n\\begin{matrix}\n\\pmb d_{r-k+1}=\\pmb d^0_{r-k+1}\\\\\\\\\n\\pmb d_{r-k+2}=\\pmb d^0_{r-k+2}\u0026amp;\\pmb d_{r-k+2}^1\\\\\\\\\n\\vdots\\\\\\\\\n\\pmb d_{r-1}=\\pmb d_{r-1}^0\u0026amp;\\pmb d_{r-1}^1\u0026amp;\\cdots\u0026amp;\\pmb d_{r-1}^{k-2}\\\\\\\\\n\\pmb d_r=\\pmb d_r^0\u0026amp;\\pmb d_r^1\u0026amp;\\cdots\u0026amp;\\pmb d_r^{k-2}\u0026amp;\\pmb d_r^{k-1}=\\pmb x(t)\n\\end{matrix}\n$$\n2.3. B样条曲线的性质 2.3.1. B样条基函数 vs. Bernstein多项式 结向量$T=(t_0,t_1,\\cdots,t_{2k-1})=(\\underbrace{0,\\cdots,0}_k,\\underbrace{1,\\cdots,1}_k)$下的$k$阶B样条函数$N_{i,k}(i=0,\\cdots,k-1)$为$k-1$次Bernstein多项式$B_i^{k-1}$\n2.3.2. 基本性质 给定：\n 结向量：$T=(\\underbrace{t_0,\\cdots,t_0}{k\\ \\mathrm{times}},t_k,\\cdots,t_n,\\underbrace{t{n+1},\\cdots,t_{n+1}}_{k\\ \\mathrm{times}})$ de Boor多边形$\\pmb d_0,\\cdots,\\pmb d_n$  相应的B样条曲线$\\pmb x(t)$有如下性质：\n $\\pmb x(t_{n+1})=\\pmb d_n$，$\\pmb x(t_{n+1})=\\pmb d_n$（边界点插值） $\\dot{\\pmb x}(t_0)=\\dfrac{k-1}{t_k-t_0}(\\pmb d_1-\\pmb d_0)$（$\\pmb d_0$处的切线方向与$\\pmb d_n$处相似） $\\pmb x(t)$由$n-k+2$个$k-1$次多项式曲线段构成 多重内部结$\\Rightarrow$减小了$\\pmb x(t)$的连续阶数，$l$重内部结$(1\\leq l\u0026lt;k)$意味着$C^{k-l-1}$阶连续 de Boor点的局部影响：移动$\\pmb d_i$只会改变曲线的$[t_i,t_{i+k}]$区间部分 插入新的de Boor点不会改变曲线段的多项式阶数  2.4. B样条曲线插值 给定：\n 控制点：$\\pmb k_0,\\pmb k_1,\\cdots,\\pmb k_n$ 结序列：$s_0,s_1,\\cdots,s_n$  目标：\n 分段三次插值B样条曲线$\\pmb x(t)$，满足插值条件：\n$$\n\\pmb x(s_i)=\\pmb k_i,\\ \\ \\ \\ i=0,1,\\cdots,n\n$$  方法：\n  分段三次$\\Rightarrow$$k=4$\n  重复首尾结$k-1=3$，结向量共计$n+2k-1=n+7$个结，对应$n+7-k=n+3$个de Boor点，结向量为：\n$$\n\\begin{align}\nT\u0026amp;=(t_0,t_1,t_2,t_3,t_4,\\cdots,t_{n+2},t_{n+3},t_{n+4},t_{n+5},t_{n+6})\\\\\\\\\n\u0026amp;=(s_0,s_0,s_0,s_0,s_1,\\cdots,s_{n-1},s_n,s_n,s_n,s_n)\n\\end{align}\n$$\n  插值条件（$n+1$个条件）\n$$\n\\begin{align}\n\\pmb x(s_0)\u0026amp;=\\pmb k_0=\\pmb d_0\\\\\\\\\n\\pmb x(s_i)\u0026amp;=\\pmb k_i=N_{i,4}(s_i)\\pmb d_i+N_{i+1,4}(s_i)\\pmb d_{i+1}+N_{i+2,4}(s_i)\\pmb d_{i+2}\\\\\\\\\n\u0026amp;\\mathrm{for}\\ i=1,\\cdots,n-1\\\\\\\\\n\\pmb x(s_n)\u0026amp;=\\pmb k_n=\\pmb d_{n+2}\n\\end{align}\n$$\n  终值条件（2个自然终值条件）\n$$\n\\begin{align}\n\\ddot{\\pmb x}(s_0)\u0026amp;=0\\Leftrightarrow \\dfrac{\\pmb d_2-\\pmb d_1}{s_2-s_0}=\\dfrac{\\pmb d_1-\\pmb d_0}{s_1-s_0}\\\\\\\\\n\\ddot{\\pmb x}(s_n)\u0026amp;=0\\Leftrightarrow \\dfrac{\\pmb d_{n+2}-\\pmb d_{n+1}}{s_n-s_{n-1}}=\\dfrac{\\pmb d_{n+1}-\\pmb d_n}{s_n-s_{n-2}}\n\\end{align}\n$$\n  结果可以表示为求解对角系统方程：\n$$\n\\begin{pmatrix}\n1\\\\\\\\\n\\alpha_0\u0026amp;\\beta_0\u0026amp;\\gamma_0\\\\\\\\\n\u0026amp;\\alpha_1\u0026amp;\\beta_1\u0026amp;\\gamma_1\\\\\\\\\n\u0026amp;\u0026amp;\u0026amp;\\ddots\\\\\\\\\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\alpha_{n-1}\u0026amp;\\beta_{n-1}\u0026amp;\\gamma_{n-1}\\\\\\\\\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\alpha_n\u0026amp;\\beta_n\u0026amp;\\gamma_n\\\\\\\\\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;1\n\\end{pmatrix}\n\\begin{pmatrix}\n\\pmb d_0\\\\\\\\\\pmb d_1\\\\\\\\\\pmb d_2\\\\\\\\\\vdots\\\\\\\\\\pmb d_n\\\\\\\\\n\\pmb d_{n+1}\\\\\\\\\\pmb d_{n+2}\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\pmb k_0\\\\\\\\\\pmb 0\\\\\\\\\\pmb k_1\\\\\\\\\\vdots\\\\\\\\\\pmb k_{n-1}\\\\\\\\\n\\pmb 0\\\\\\\\\\pmb k_{n}\n\\end{pmatrix}\n$$\n其中，\n$$\n\\begin{align}\n\\alpha_0\u0026amp;=s_2-s_0\\\\\\\\\n\\beta_0\u0026amp;=-(s_2-s_0)-(s_1-s_0)\\\\\\\\\n\\gamma_0\u0026amp;=s_1-s_0\\\\\\\\\n\\\\\\\\\n\\alpha_n\u0026amp;=s_n-s_{n-1}\\\\\\\\\n\\beta_n\u0026amp;=-(s_n-s_{n-1})-(s_n-s_{n-2})\\\\\\\\\n\\gamma_n\u0026amp;=s_n-s_{n-2}\\\\\\\\\n\\\\\\\\\n\\alpha_i\u0026amp;=N_{i,4}(s_i)\\\\\\\\\n\\beta_i\u0026amp;=N_{i+1,4}(s_i)\\\\\\\\\n\\gamma_i\u0026amp;=N_{i+2,4}(s_i)\\\\\\\\\n\\mathrm{for}\u0026amp;\\ i=1,\\cdots,n-1\n\\end{align}\n$$\n  求解方法\n 使用Thomas算法——解决对角系统矩阵 仅适用于对角占优矩阵 复杂度$O(n)$     前向消除阶段\n  后向替换阶段\n     2.5. Bézier曲线转B样条曲线 给定：\n 控制点：$\\pmb k_0,\\pmb k_1,\\cdots, \\pmb k_n$ 结序列：$t_0,t_1,\\cdots,t_n$ 2个终值条件 $C^2$连续、插值条件 用于$C^2$连续插值的分段三次Bézier样条曲线的Bézier点$\\pmb b_0,\\pmb b_1,\\cdots,\\pmb b_{3n}$  目标：\n 求取相同曲线的B样条形式  结向量：\n$$\nT=(t_0,t_0,t_0,t_0,t_1,\\cdots,t_{n-1},t_n,t_n,t_n,t_n)\n$$\n 共$n+7$个顶点，$n+3$个de Boor点，即$\\pmb d_0,\\pmb d_1,\\cdots,\\pmb d_{n+2}$\n de Boor点满足：\n$$\n\\begin{align}\n\\pmb d_0\u0026amp;=\\pmb b_0\\\\\\\\\n\\pmb d_1\u0026amp;=\\pmb b_1\\\\\\\\\n\\pmb d_i\u0026amp;=\\pmb b_{3i-4}+\\frac{\\Delta_{i-1}}{\\Delta_{i-2}}(\\pmb b_{3i-4}-\\pmb b_{3i-5})\\ \\mathrm{for}\\ i=2,\\cdots,n\\\\\\\\\n\\pmb d_{n+1}\u0026amp;=\\pmb b_{3n-1}\\\\\\\\\n\\pmb d_{n+2}\u0026amp;=\\pmb b_{3n}\n\\end{align}\n$$\n其中，对于$i=0,\\cdots,n-1$，有$\\Delta_i=t_{i+1}-t_i$\n示例：\n逆问题同样可解\n3. 视频演示 IlumEngine中实现了自然边界条件的4阶（3 次）B曲线的$C^2$连续插值绘制，实际造型与Bézier样条曲线等价\n\n","description":"B样条曲线原理与实现","id":5,"section":"posts","tags":["Geometry"],"title":"几何造型(3)：B样条曲线","uri":"https://chaphlagical.github.io/zh/posts/geometry/b_spline/"},{"content":"因为有了《漫威复仇者联盟》的前车之鉴，许多人是不看好今年这款Crystal Dynamics开发的漫威IP新作，但游戏正式发布后评价却意外的好，趁之前七折赶紧入手冲一把。\n和漫威复联的刷刷刷不同，漫威银护选择走单人线性叙事路线，以星爵作为玩家唯一可操作角色，通过小队作战的战斗机制来使用银河护卫队其他成员的技能。但从玩法上确实没有太多新意，后期技能点满后战斗非常无脑与简单，收集要素很少（均为皮肤和可升级零件），解密难度极低，但是剧本非常扎实，对话量很大，演出效果也很好，很多彩蛋也让我这个漫威迷大呼过瘾，十多小时的大片级体验还是相当不错的。\n以下是我在游戏过程中截取的精彩画面：\n进入新手村前夕\n初遇科斯莫\n理查德·赖德彩蛋，萨姆·亚历山大能在下一部出现吗？\n星爵见老妈\n劝说Worldmind失败，Nova总部溜了\n初遇亚当\n光速跳跃\n全副武装\n封面图，全场最佳\n这个星爵和电影版的还是很不一样\n最终一战\n老板火箭\n","description":"通关了《漫威银河护卫队》，剧情还是相当不错的","id":6,"section":"posts","tags":["Gaming"],"title":"游戏通关：《漫威银河护卫队》","uri":"https://chaphlagical.github.io/zh/posts/gaming/marvel_guardians_of_the_galaxy/"},{"content":"1. 简介 之前我们已经介绍过Bézier曲线的原理与实现方法，但由于Bézier曲线的一些问题，例如：\n 高多项式次数  $n+1$个Bézier控制点将生成一条$n$次多项式表达的Bézier曲线   全局，伪局部性  Bézier曲线在始末两控制点进行插值，在中间控制点进行拟合，当控制点增加时，曲线形态难以控制    因此我们引入的Bézier样条曲线来解决上述两个问题。在了解Bézier样条曲线的工作原理之前，需要弄清楚几何设计中连续性的基本概念。\n1.1. 连续性的基本概念 1.1.1. 参数连续性 给定两条曲线：\n$$\n\\begin{align}\n\u0026amp;\\pmb x_1(t)\\ \\mathrm{over}\\ [t_0,t_1]\\\\\\\\\n\u0026amp;\\pmb x_2(t)\\ \\mathrm{over}\\ [t_1,t_2]\n\\end{align}\n$$\n若$\\pmb x_1$和$\\pmb x_2$在$t_1$处的0阶到$r$阶导数向量均重合，则若$\\pmb x_1$和$\\pmb x_2$在$t_1$处$C^r$连续\n常见的参数连续性有：\n $C^0$：位置变化连续 $C^1$：一阶导数在交界处连续（速度向量相同） $C^2$：二阶导数在交界处连续（加速度向量相同）  1.1.2. 几何连续性 给定两条曲线：\n$$\n\\begin{align}\n\u0026amp;\\pmb x_1(t)\\ \\mathrm{over}\\ [t_0,t_1]\\\\\\\\\n\u0026amp;\\pmb x_2(t)\\ \\mathrm{over}\\ [t_1,t_2]\n\\end{align}\n$$\n若$\\pmb x_1$和$\\pmb x_2$能够以某种方式重新参数化使得在$t_1$处$C^r$连续，则$\\pmb x_1$和$\\pmb x_2$在$t_1$处$G^r$连续\n常见的几何连续性有：\n $G^0=C^0$：位置变化连续性（连接性） $G^1$：切线方向变化连续性（相同切线）  正则化切线变化连续 等价于曲线能够重新参数化到$C^1$ 等价于单位速度参数化为$C^1$   $G^2$：曲率变化连续性（相同切线与曲率）  等价于曲线能够重新参数化到$C^2$ 等价于单位速度参数化为$C^2$    1.1.3. 参数连续性 vs. 几何连续性    参数连续性 几何连续性     在该曲线上运动的粒子是否有光滑的轨迹？（位置、速度、加速度） 曲线本身是否光滑   取决于参数化方式 独立于参数化方式   应用：动画（物体移动、摄像头轨迹） 与建模相关（曲线设计）    1.2. Bézier样条曲线的设计思想 既然Bézier曲线全局性太强、阶次太高，那么优化思路就是降低全局性、降低阶次，一个有效的方法就是进行分段，把一条长的曲线分段成若干条低阶的Bézier曲线，在衔接处满足某种连接性，即可使得曲线满足控制点插值、低次性和局部性等优点，这就是Bézier样条曲线的设计思路。\n设计Bézier样条曲线需要考虑的两个问题是：\n 参数化 连续性  2. Bézier样条参数化 在Bézier曲线的构造中，我们选择的参数为$t\\in[0,1]$，贯穿整条曲线，称之为全局参数。在Bézier样条曲线中，我们通过分段，将曲线分为$[t_0,t_1]$，$[t_1,t_2]$，……，$[t_{n-1},t_n]$的曲线段，每一段对应一条低阶Bézier曲线，这条低阶Bézier曲线使用的参数$u\\in[0,1]$则称为局部参数。当局部参数$u$从0变化到1时，全局参数从$t_i$变化到$t_{i+1}$。\n通常情况下，节序列$t_0,t_1,\\cdots,t_n$可以自定义，选取不同的节序列会得到不同的曲线形态，常用的参数化方法有以下几种：\n  Equidistant (Uniform) Parameterization\n $t_{i+1}-t_i=\\mathrm{const}$ 不考虑数据点之间的几何关系    Chordal Parameterization\n $t_{i+1}-t_i=\\Vert \\pmb k_{i+1}-\\pmb k_i\\Vert$ 参数间隔与相邻控制点的距离成正比    Centripetal Parameterization\n $t_{i+1}-t_i=\\sqrt{\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert}$ 参数间隔与相邻控制点的距离的开方成正比    Foley Parameterization\n 涉及控制多边形的角度  $$\nt_{i+1}-t_i=\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert\\cdot\\Big(1+\\dfrac{3}{2}\\dfrac{\\hat\\alpha_i\\Vert\\pmb k_i-\\pmb k_{i-1}\\Vert}{\\Vert\\pmb k_i-\\pmb k_{i-1}\\Vert+\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert}+\\dfrac{3}{2}\\dfrac{\\hat\\alpha_{i+1}\\Vert \\pmb k_{i+1}-\\pmb k_i\\Vert}{\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert+\\Vert\\pmb k_{i+2}-\\pmb k_{i+1}\\Vert} \\Big)\n$$\n 其中，$\\hat\\alpha_i=\\min\\Big(\\pi-\\alpha_i,\\dfrac{\\pi}{2}\\Big)$，且$\\alpha_i=\\mathrm{angle}(\\pmb k_{i-1},\\pmb k_i,\\pmb k_{i+1})$    3. Bézier样条的连续性 给定\n $\\pmb y(u)$：$[0,1]$上的Bézier曲线 $\\pmb x(u)$：$[t_i,t_{i+1}]$上的Bézier曲线  令$u(t)=\\frac{t-t_i}{t_{i+1}-t_i}$，则$\\pmb x(t)=\\pmb y(u(t))$\n对$\\pmb x(t)$进行求导有：\n$$\n\\begin{align}\n\\dot{\\pmb x}(t)\u0026amp;=\\dot{\\pmb y}(u(t))\\cdot\\dot u(t)=\\dfrac{\\dot{\\pmb y}(u(t))}{t_{i+1}-t_i}\\\\\\\\\n\\ddot{\\pmb x}(t)\u0026amp;=\\ddot{\\pmb y}(u(t))\\cdot(\\dot u(t))^2+\\dot{\\pmb y}(u(t))\\cdot\\ddot u(t)=\\dfrac{\\ddot{\\pmb y}(u(t))}{(t_{i+1}-t_i)^2}\\\\\n\\cdots\\\\\\\\\n\\pmb x^{[n]}(t)\u0026amp;=\\dfrac{\\pmb y^{[n]}(u(t))}{(t_{i+1}-t_i)^n}\n\\end{align}\n$$\n由Bézier曲线解析式：\n$$\n\\pmb f(t)=\\sum_{i=0}^nB_i^n(t)\\pmb b_i\n$$\n其端点值：\n$$\n\\begin{align}\n\\pmb f(0)\u0026amp;=\\pmb b_0\\\\\\\\\n\\pmb f(1)\u0026amp;=\\pmb b_1\n\\end{align}\n$$\n端点一阶导数：\n$$\n\\begin{align}\n\\pmb f'(0)\u0026amp;=n[\\pmb b_1-\\pmb b_0]\\\\\\\\\n\\pmb f'(1)\u0026amp;=n[\\pmb b_n-\\pmb b_{n-1}]\n\\end{align}\n$$\n端点二阶导数：\n$$\n\\begin{align}\n\\pmb f''(0)\u0026amp;=n(n-1)[\\pmb b_2-2\\pmb b_1+\\pmb b_0]\\\\\\\\\n\\pmb f''(1)\u0026amp;=n(n-1)[\\pmb b_n-2\\pmb b_{n-1}+\\pmb b_{n-2}]\n\\end{align}\n$$\n代入到$\\pmb x(t)=\\pmb y(u(t))$中，有：\n$$\n\\begin{align}\n\\pmb x(t_i)\u0026amp;=\\pmb b_0\\\\\\\\\n\\pmb x(t_{i+1})\u0026amp;=\\pmb b_1\\\\\\\\\n\\dot{\\pmb x}(t_i)\u0026amp;=\\dfrac{n(\\pmb b_1-\\pmb b_0)}{t_{i+1}-t_i}\\\\\\\\\n\\dot{\\pmb x}(t_{i+1})\u0026amp;=\\dfrac{n(\\pmb b_n-\\pmb b_{n-1})}{t_{i+1}-t_i}\\\\\\\\\n\\ddot{\\pmb x}(t_i)\u0026amp;=\\dfrac{n(n-1)(\\pmb b_2-2\\pmb b_1+\\pmb b_0)}{(t_{i+1}-t_i)^2}\\\\\\\\\n\\ddot{\\pmb x}(t_{i+1})\u0026amp;=\\dfrac{n(n-1)(\\pmb b_n-2\\pmb b_{n-1}+\\pmb b_{n-2})}{(t_{i+1}-t_i)^2}\\\n\\end{align}\n$$\n现有$m+1$段$n$阶Bézier样条$\\pmb x^{(0)},\\pmb x^{(1)},\\cdots,\\pmb x^{(m)}$构成一条完整曲线$\\pmb x$，Bézier样条$\\pmb x^{(i)}$的控制点为：$\\pmb b_0^{(i)},\\pmb b_1^{(i)},\\cdots,\\pmb b_n^{(i)}$，对应全局参数范围$[t_i,t_{i+1}]$\n$C^0$连续性\n每个样条线段插值两端控制点，因此相邻曲线段两端的控制点必须重合以获得$C^0$连续性，即：\n$$\n\\pmb b^{(i-1)}_{n}=\\pmb b^{(i)}_0\n$$\n$C^1$连续性\n$C^1$连续即该参数化下一阶导数相同，即：\n$$\n\\dot{\\pmb x}^{(i)}(t_{i+1})=\\dot{\\pmb x}^{(i+1)}(t_{i+1})\n$$\n代入表达式有：\n$$\n\\frac{\\pmb b^{(i)}_n-\\pmb b_{n-1}^{(i)}}{t_{i+1}-t_i}=\n\\frac{\\pmb b^{(i)}_{1}-\\pmb b_{0}^{(i)}}{t_{i+2}-t_{i+1}}\n$$\n$C^2$连续性\n$C^1$连续即该参数化下二阶导数相同，即：\n$$\n\\ddot{\\pmb x}^{(i)}(t_{i+1})=\\ddot{\\pmb x}^{(i+1)}(t_{i+1})\n$$\n代入表达式有：\n$$\n\\frac{\\pmb b_n^{(i)}-2\\pmb b_{n-1}^{(i)}+\\pmb b_{n-2}^{(i)}}{(t_{i+1}-t_i)^2}=\n\\frac{\\pmb b_2^{(i+1)}-2\\pmb b_1^{(i+1)}+\\pmb b_0^{(i+1)}}{(t_{i+2}-t_{i+1})^2}\n$$\n令\n$$\n\\pmb d^-=\\pmb b_{n-1}^{(i)}+\\frac{\\Delta_{i+1}}{\\Delta_i}(\\pmb b_{n-1}^{(i)}-\\pmb b_{n-2}^{(i)})\n$$\n和\n$$\n\\pmb d^+=\\pmb b_{1}^{(i+1)}-\\frac{\\Delta_{i}}{\\Delta_{i+1}}(\\pmb b_{2}^{(i+1)}-\\pmb b_{1}^{(i+1)})\n$$\n则有$C^2$连续性等价于$C^1$连续性且$\\pmb d^-=\\pmb d^+$\n$G^1$连续性\n满足在$t=t_i$处$G^1$连续的条件是：\n$$\n\\begin{aligned}\n\u0026amp;\\pmb x^{(i)}(t_i)=\\pmb x^{(i+1)}(t_i)\\\\\\\\\n\u0026amp;\\dot{\\pmb x}^{(i)}(t_i)=\\dot{\\pmb x}^{(i+1)}(t_i)\\\\\\\\\n\u0026amp;\\ddot{\\pmb x}^{(i+1)}(t_i)-\\ddot{\\pmb x}^{(i)}(t_i)\\parallel \\dot{\\pmb x}(t_i)\n\\end{aligned}\n$$\n$G^2$连续性\n满足在$t=t_i$处$G^2$连续的条件是：\n  $G^1$连续\n  $\\pmb b_{n-2}^{(i)},\\pmb b_{n-1}^{(i)},\\pmb b_{n}^{(i)}=\\pmb b_{0}^{(i+1)},\\pmb b_{1}^{(i+1)},\\pmb b_{2}^{(i+1)}$五个向量共面\n  且面积满足：\n$$\n\\dfrac{\\mathrm{area}(\\pmb b_{n-2}^{(i)},\\pmb b_{n-1}^{(i)},\\pmb b_{n}^{(i)})}{\\mathrm {area}(\\pmb b_{0}^{(i+1)},\\pmb b_{1}^{(i+1)},\\pmb b_{2}^{(i+1)})}=\\dfrac{a^3}{b^3}\n$$\n  4. 三次Bézier样条曲线 理论上，只要有足够的边界条件约束，我们可以选用任意阶的Bézier样条进行构造我们的曲线，但一般常用的Bézier样条不会超过三次（某些CAD/CAM软件可能会使用）：\n 零次：分段常数，不光滑 一次：分段线性，不够光滑 二次：二阶导数为常数，不够灵活 三次：图形学应用中最为常用  在IlumEngine中，也选用了三次Bézier样条曲线进行实现。\n对于给定的控制点$\\pmb k_0,\\pmb k_1,\\cdots,\\pmb k_n$，以及参数化节序列$t_0,t_1,\\cdots,t_n$，我们需要生成用于构造连续分段三次Bezier样条曲线的Bézier点$\\pmb b_0,\\cdots,\\pmb b_{3n}$\n该问题中，需要求解：\n $3n+1$个未知点 $C^0$连续：$\\pmb b_{3i}=\\pmb k_i$，$i=0,\\cdots,n$，共$n+1$个方程 $C^1$连续：$\\dfrac{\\pmb b_{3i}-\\pmb b_{3i-1}}{t_i-t_{i-1}}=\\dfrac{\\pmb b_{3i+1}-\\pmb b_{3i}}{t_{i+1}-t_{i}}$，$i=0,\\cdots,n$，共$n-1$个方程 $C^2$连续：$\\dfrac{\\pmb b_{3i}-2\\pmb b_{3i-1}+\\pmb b_{3i-2}}{(t_i-t_{i-1})^2}=\\dfrac{\\pmb b_{3i+2}-2\\pmb b_{3i+1}+\\pmb b_{3i}}{(t_{i+1}-t_{i})^2}$，$i=0,\\cdots,n$，共$n-1$个方程 两个端点条件  端点条件的选取，通常有两种：\n  Bessel End Condition\n  $\\pmb k_0$处的切向量等于插值${\\pmb k_0,\\pmb k_1,\\pmb k_2}$的抛物线在$\\pmb k_0$处的切向量\n  插值${\\pmb k_0,\\pmb k_1,\\pmb k_2}$的抛物线方程：\n$$\n\\pmb p(t)=\n\\dfrac{(t_2-t)(t_1-t)}{(t_2-t_0)(t_1-t_0)}\\pmb k_0+\n\\dfrac{(t_2-t)(t-t_0)}{(t_2-t_1)(t_1-t_0)}\\pmb k_1+\n\\dfrac{(t_0-t)(t_1-t)}{(t_2-t_1)(t_2-t_0)}\\pmb k_2\n$$\n  插值抛物线导数：\n$$\n\\dot{\\pmb p}(t_0)=\n-\\dfrac{(t_2-t_0)+(t_1-t_0)}{(t_2-t_0)(t_1-t_0)}\\pmb k_0+\n\\dfrac{(t_2-t_0)}{(t_2-t_1)(t_1-t_0)}\\pmb k_1-\n\\dfrac{(t_1-t_0)}{(t_2-t_1)(t_2-t_0)}\\pmb k_2\n$$\n  $\\pmb b_1$的位置：\n$$\n\\pmb b_1=\\pmb b_0+\\dfrac{t_1-t_0}{3}\\dot{\\pmb p}(t_0)\n$$\n    Natural End Condition\n$$\n\\begin{align}\n\\ddot {\\pmb x}(t_0)\u0026amp;=0\\Leftrightarrow \\pmb b_1=\\dfrac{\\pmb b_2+\\pmb b_0}{2}\\\\\\\\\n\\ddot{\\pmb x}(t_n)\u0026amp;=0\\Leftrightarrow \\pmb b_{3n-1}=\\dfrac{\\pmb b_{3n-2}+\\pmb b_{3n}}{2}\n\\end{align}\n$$\n  事实上，如果曲线闭合（首尾相连），则可以无需计算端点条件，继续在首尾处计算$C^1$、$C^2$条件即可\n5. 视频演示 IlumEngine中实现了三次Bézier样条曲线，使用Uniform参数化以及Natural端点条件\n\n","description":"Bézier样条曲线原理与实现","id":7,"section":"posts","tags":["Geometry"],"title":"几何造型(2)：Bézier样条曲线","uri":"https://chaphlagical.github.io/zh/posts/geometry/bezier_spline/"},{"content":"1. 基本原理 Bézier曲线于1962年，由法国工程师Pierre Bézier所提出，用于汽车的主体的几何造型设计。\n二阶Bézier曲线如下图所示：\n其几何构造流程如下：\n 依次选定控制点$A$、$B$、$C$ 在$AB$上选定一动点$D$，设参数$t=\\frac{AD}{AB}$，则$t\\in[0,1]$ 在$BC$上构造一点$E$，满足$\\frac{AD}{AB}=\\frac{BE}{BC}=t$ 连接$DE$ 在$DE$上构造一点$F$，满足$\\frac{DF}{DE}=\\frac{AD}{AB}=\\frac{BE}{BC}=t$ 当$t$从0到1变化时，点$F$构成的轨迹即为二阶Bézier曲线  从解析几何角度看，设控制点$A$、$B$、$C$坐标依次为$\\pmb p_1$、$\\pmb p_2$和$\\pmb p_3$，则点$D$可表示为$\\pmb p_4 = (1-t)\\pmb p_1+t\\pmb p_2$，点$E$表示为$\\pmb p_5=(1-t)\\pmb p_2+t\\pmb p_3$，点$F$表示为$\\pmb p_6=(1-t)\\pmb p_4+t\\pmb p_5=(1-t)^2\\pmb p_1+2(1-t)t\\pmb p_2+t^2\\pmb p_3$\n同理我们还可以构造三阶Bézier曲线：\n我们可以从中看出规律，给定$N$个控制点，将生成$N-1$阶的Bézier曲线，几何构造方式都是通过在控制点连线上按比例参数选取新的控制点，然后通过新的控制点再往下生成控制点，直到最终只生成一个控制点，该点则对应参数下Bézier曲线的取值。\n2. De Casteljau算法 2.1. 算法原理 De Casteljau算法是计算给定参数$t$下Bézier曲线上点的坐标的迭代求解方法。\n对于给定控制点$\\pmb b_0,\\pmb b_1,\\cdots,\\pmb b_n\\in\\mathbb R^3$，我们希望得到曲线$\\pmb x(t),t\\in[0,1]$，De Casteljau算法的迭代方程如下：\n$$\n\\begin{align}\n\\pmb b_i^0(t)\u0026amp;=\\pmb b_i,\\ \\ \\ \\ i=0,\\cdots,n\\\\\n\\pmb b_i^r(t)\u0026amp;=(1-t)\\pmb b_i^{r-1}(t)+t\\pmb b_{i+1}^{r-1}(t)\\\\\nr=\u0026amp;1,\\cdots,n\\ \\ \\ \\ i=0,\\cdots,n-r\n\\end{align}\n$$\n最后，$\\pmb b_0^n(t)$为所找的曲线点$\\pmb x(t)$在参数值$t$的取值，C++程序如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  glm::vec3 BezierCurve::value(const std::vector\u0026lt;glm::vec3\u0026gt; \u0026amp;control_points, float t) { size_t n = control_points.size(); std::vector\u0026lt;glm::vec3\u0026gt; br(control_points); std::vector\u0026lt;glm::vec3\u0026gt; br_1(control_points); for (size_t r = 1; r \u0026lt; n; r++) { for (size_t i = 0; i \u0026lt; n - r; i++) { br[i] = (1 - t) * br_1[i] + t * br_1[i + 1]; } br_1 = br; } return br_1[0]; }   2.2. 算法性质  控制点$\\pmb b_0,\\pmb b_1,\\cdots,\\pmb b_n\\in\\mathbb R^3$依次构成的多边形称为Bézier多边形 控制点$\\pmb b_i$也称为Bézier点 只使用凸组合，因此算法数值稳定 算法复杂度  时间复杂度$O(n^2)$ 空间复杂度$O(n)$    3. Bézier曲线的解析表达 3.1. Bernstein基描述 De Casteljau算法提供了一种迭代求解Bézier曲线的方法，同时我们也可以解析地写出Bézier曲线的基函数表达：\n$$\n\\pmb x(t)=\\sum_{i=0}^nC_n^it^i(1-t)^{n-i}\\pmb b_i\n$$\n其中$C_n^i$为组合数$C_n^i=\\frac{n!}{i!(n-i)!}$，Bernstein基定义为：\n$$\nB_i^n(t)=\n\\begin{cases}\nC_n^it^i(1-t)^{n-i}\u0026amp;t\\in[0,1],i\\in[0,n],i\\in\\mathbb N\\\\\\\\\n0\u0026amp;i\u0026lt;0\\ or\\ i\u0026gt;n\\\\\\\\\n1\u0026amp;i=0\\ and \\ n=0\n\\end{cases}\n$$\nBernstein基示例：\n3.2. Bernstein基的性质 光滑性\nBernstein基函数为$n$次多项式，显然光滑\n归一性\n$$\n\\sum\\limits_{i=0}^nB_i^{n}(t)=(t+(1-t))^n=1\n$$\n递推\n$$\nB_i^n(t)=(1-t)B_i^{n-1}(t)+tB^{n-1}_{i-1}(t)\n$$\n 证明：\n$$\n\\begin{align}\n(1-t)B_i^{n-1}(t)+tB^{n-1}_{i-1}(t)\u0026amp;=(1-t)C_{n-1}^{i}t^i(1-t)^{n-1-i}+tC_{n-1}^{i-1}t^{i-1}(1-t)^{n-i}\\\\\\\\\n\u0026amp;=(C_{n-1}^{i}+C_{n-1}^{i-1})t^i(1-t)^{n-i}\\\\\\\\\n\u0026amp;=C_n^it^i(1-t)^{n-i}\\\\\\\\\n\u0026amp;=B_i^n(t)\n\\end{align}\n$$\n 导数\n$$\n\\frac{\\mathrm d}{\\mathrm dt}B_i^{n}(t)=n\\left[B^{n-1}_{i-1}(t)-B_i^{n-1}(t)\\right]\n$$\n 证明：\n$$\n\\begin{align}\n\\frac{\\mathrm d}{\\mathrm dt}B^n_i(t)\u0026amp;=\\frac{\\mathrm d}{\\mathrm dt}\\left( C_n^it^i(1-t)^{n-i}\\right)\\\\\\\\\n\u0026amp;=iC_n^it^{i-1}(1-t)^{n-i}-(n-i)C_n^it^i(1-t)^{n-i-1}\\\\\\\\\n\u0026amp;=\\frac{n!}{(n-i)!i!}it^{i-1}(1-t)^{n-i}-\\frac{n!}{(n-i)!i!}(n-i)t^i(1-t)^{n-i-1}\\\\\\\\\n\u0026amp;=n\\left[\\frac{(n-1)!}{(n-i)!(i-1)!}t^{i-1}(1-t)^{n-i}-\\frac{(n-1)!}{(n-i-1)!i!}t^i(1-t)^{n-i-1} \\right]\\\\\\\\\n\u0026amp;=n\\left[C_{n-1}^{i-1}t^{i-1}(1-t)^{n-i}-C_{n-1}^i t^i(1-t)^{n-i-1} \\right]\\\\\\\\\n\u0026amp;=n\\left[B^{n-1}_{i-1}(t)-B_i^{n-1}\\right]\n\\end{align}\n$$\n 最值\n$B^n_i(t)$在$t=\\frac{i}{n}$处取得最大值\n 证明：\n由导数为0\n$$\n\\frac{\\mathrm d}{\\mathrm dt}B_i^{n}(t)=n\\left[B^{n-1}_{i-1}(t)-B_i^{n-1}(t)\\right]=0\n$$\n可得当$t=\\frac{i}{n}$时取得最大值\n 对称性\n$$\nB_i^n(t)=B_{n-i}^n(1-t)\n$$\n 证明：\n$$\n\\begin{align}\nB_i^n(t)\u0026amp;=C_n^it^i(1-t)^{n-i}\\\\\\\\\n\u0026amp;=\\frac{n!}{(n-i)!i!}t^i(1-t)^{n-i}\\\\\\\\\n\u0026amp;=\\frac{n!}{(n-(n-i))!(n-i)!}(1-t)^{n-i}t^{n-(n-i)}\\\\\\\\\n\u0026amp;=B_{n-i}^n(1-t)\n\\end{align}\n$$\n 非负性\n$$\n\\begin{align}\nB_i^n(t)\u0026amp;\\geq 0,t\\in [0,1]\\\\\\\\\nB_0^{(n)}(0)=1,\u0026amp;\\ \\ \\ \\ B_1^{(n)}(0)=\\cdots=B_n^{(n)}(0)=0\\\\\\\\\nB_0^{(n)}(1)=\u0026amp;\\cdots=B_{n-1}^{(n)}=0,\\ \\ \\ \\ B_n^{(n)}(1)=1\n\\end{align}\n$$\n4. Bézier曲线的性质 聊完Bézier曲线的构造方法以及Bernstein基函数的相关内容，我们再来聊聊Bézier曲线本身具有的几何性质。\n4.1. 仿射不变性 仿射变换定义为：\n$$\n\\pmb x\\rightarrow\\pmb A\\pmb x+\\pmb b\n$$\n包含线性部分和平移部分。\n线性不变性\nBézier曲线的线性不变性是显然的，Bézier曲线表示为基函数的线性组合：\n$$\n\\pmb f(t)=\\sum\\limits_{i=1}^nb_i(t)\\pmb p_i=\\sum\\limits_{i=1}^nb_i(t)\\begin{pmatrix}\np_i^{(x)}\\\\p_i^{(y)}\\\\p_i^{(z)}\n\\end{pmatrix}\n$$\n因此\n$$\nA(\\pmb f(t))=A\\Big(\\sum\\limits_{i=1}^nb_i(t)\\pmb p_i \\Big)=\\sum\\limits_{i=1}^nb_i(t)(A\\pmb p_i)\n$$\n平移不变性\n$$\n\\sum\\limits_{i=1}^nb_i(t)(\\pmb p_i+\\pmb b)=\\sum\\limits_{i=1}^nb_i(t)\\pmb p_i+\\sum\\limits_{i=1}^nb_i(t)\\pmb b=\\pmb f(t)+\\Big(\\sum\\limits_{i=1}^nb_i(t)\\Big)\\pmb b\n$$\n其中，由Bernstein基函数的归一性，$\\sum\\limits_{i=1}^nb_i(t)=1$，满足平移不变性。\n4.2. 凸包性质 点集${\\pmb p_1,\\cdots,\\pmb p_n}$的一个凸组合为如下形式：\n$$\n\\sum\\limits_{i=1}^n\\lambda_i\\pmb p_i\\ \\mathrm{with}\\sum\\limits_{i=1}^n\\lambda_i=1\\ \\mathrm{and}\\ \\forall i=1,\\cdots,n:0\\leq\\lambda_i\\leq 1\n$$\n因此Bézier曲线为Bernstein基函数的凸组合，能够避免不良震荡，将构造的曲线限制在控制点的凸包中。\n4.3. 导数性质 对于Bézier曲线\n$$\n\\pmb x(t)=\\sum_{i=0}^nB_i^n(t)\\pmb p_i\n$$\n一阶导数：\n$$\n\\begin{aligned}\n\\frac{\\mathrm d\\pmb x}{\\mathrm dt}\u0026amp;=n\\sum_{i=0}^{n}\\left[B^{n-1}_{i-1}(t)-B_i^{n-1}(t)\\right]\\pmb p_i\\\\\\\\\n\u0026amp;=n\\sum_{i=0}^nB_{i-1}^{n-1}(t)\\pmb p_i-n\\sum_{i=0}^n B_i^{n-1}(t)\\pmb p_i\\\\\\\\\n\u0026amp;=n\\sum_{i=-1}^{n-1}B_i^{n-1}(t)\\pmb p_{i+1}-n\\sum_{i=0}^nB_i^{n-1}(t)\\pmb p_i\\\\\\\\\n\u0026amp;=n\\sum_{i=0}^{n-1}B_i^{n-1}(t)\\pmb p_{i+1}-n\\sum_{i=0}^nB_i^{n-1}(t)\\pmb p_i\\\\\\\\\n\u0026amp;=n\\sum_{i=0}^{n-1}B_i^{n-1}(\\pmb p_{i+1}-\\pmb p_i)\n\\end{aligned}\n$$\n边界条件：\n$$\n\\begin{cases}\n\\pmb x'(0)=n(\\pmb p_1-\\pmb p_0)\\\\\\\\\n\\pmb x'(1)=n(\\pmb p_n-\\pmb p_{n-1})\n\\end{cases}\n$$\n高阶导数：\n$$\n\\frac{\\mathrm d^r}{\\mathrm dt^r}\\pmb x(t)=\\frac{n!}{(n-r)!}\\sum_{i=0}^{n-r}B_i^{n-r}(t)\\cdot\\Delta^r\\pmb p_i\n$$\n其中，\n一阶差分：$\\Delta \\pmb p_i=\\pmb p_{i+1}-\\pmb p_i$\n二阶差分：$\\Delta^2\\pmb p_i=\\Delta\\pmb p_{i+1}-\\Delta \\pmb p_i=\\pmb p_{i+2}-2\\pmb p_{i+1}+\\pmb p_i$\n高阶差分递推式：$\\Delta^r\\pmb p_i=\\Delta^{r-1} \\pmb p_{i+1}-\\Delta^{r-1} \\pmb p_i$\n归纳法有：$\\Delta^r\\pmb p_i=\\sum_{k=0}^r(-1)^kC_r^k\\pmb p_{i+r-k}$\n4.4. 杂项性质结论 一条 Bézier 曲线的弧长不大于其控制多边形的周长\n 证明：\n设Bézier曲线方程为$\\pmb f(t)$，曲线弧长为$L$，多边形周长为$C$，则Bézier曲线弧长为：\n$$\n\\begin{aligned}\nL\u0026amp;=\\int_0^1\\|\\pmb f'(t)\\|\\mathrm dt\\\\\\\\\n\u0026amp;=\\int_0^1\\left\\|n\\sum_{i=0}^{n-1}B_i^{(n-1)}(t)(\\pmb p_{i+1}-\\pmb p_i)\\right\\|\\mathrm dt\\\\\\\\\n\u0026amp;\\leq n\\sum_{i=0}^{n-1}\\|\\pmb p_{i+1}-\\pmb p_i\\|\\cdot \\int_0^1B_i^{(n-1)}(t)\\mathrm dt\n\\end{aligned}\n$$\n由Bernstein基函数的性质，有：\n$$\n\\frac{\\mathrm d}{\\mathrm dt}B_i^{(n)}(t)=n\\left[B_{i-1}^{(n-1)}(t)-B_i^{(n-1)}(t)\\right]\n$$\n从0到1积分得：\n$$\nB_i^{(n)}(1)-B_i^{(n)}(0)=n\\left[\\int_0^1B_{i-1}^{(n-1)}(t)-\\int_0^1B_i^{(n-1)}(t)\\right]=0\n$$\n依此类推有：\n$$\n\\int_0^1 B_0^{(n-1)}(t)\\mathrm dt=\n\\int_0^1 B_1^{(n-1)}(t)\\mathrm dt=\n\\cdots=\n\\int_0^1 B_{n-1}^{(n-1)}(t)\\mathrm dt=\\frac{1}{n}\n$$\n因此，有：\n$$\nL\\leq \\sum_{i=0}^{n-1}|\\pmb p_{i+1}-\\pmb p_i|=C\n$$\n结论得证\n 圆弧不能用Bézier曲线精确表示\n 设有一圆弧圆心为$\\pmb c$，半径为$r$，假设它能够用一Bézier曲线$\\pmb f(t)$进行表示，则有：\n$$\n\\left|\\pmb f(t)-\\pmb c\\right|\\equiv r\n$$\n其中，\n$$\n\\begin{aligned}\n\\pmb f(t)\u0026amp;=\\sum_{i=1}^{n}B_i^{n}(t)\\pmb p_i\\\\\\\\\n\u0026amp;=\\sum_{i=1}^{n}\\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}\\pmb p_i\n\\end{aligned}\n$$\n又\n$$\n\\left\\|\\sum_{i=1}^{n}\\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}\\pmb p_i-\\pmb c\\right\\|\\not\\equiv\\mathrm{const}\n$$\n因此假设不成立，圆弧不能用Bézier曲线精确表示\n 5. Bézier曲线的升阶(Degree Elevation) 给定$n+1$个Bézier控制点$\\pmb b_0,\\pmb b_1,\\cdots,\\pmb b_n$，生成Bézier曲线$\\pmb x(t)$\nBézier曲线的升阶即希望生成$n+2$个Bézier控制点$\\bar{\\pmb b}_0,\\bar{\\pmb b}_1,\\cdots,\\bar{\\pmb b}_n$，从而得到曲线$\\bar{\\pmb x}(t)$，满足$\\bar{\\pmb x}(t)=\\pmb x(t)$\n解决方法：\n$$\n\\begin{aligned}\n\\bar{\\pmb b}_0\u0026amp;=\\pmb b_0\\\\\\\\\n\\bar{\\pmb b}_{n+1}\u0026amp;=\\pmb b_n\\\\\\\\\n\\bar{\\pmb b}_j\u0026amp;=\\dfrac{j}{n+1}\\pmb b_{j-1}+\\Big(1-\\dfrac{j}{n+1}\\Big)\\pmb b_j\\ \\ \\ \\ \\ \\mathrm{for}\\ j=1,\\cdots,n\n\\end{aligned}\n$$\n 证明：\n$$\n\\begin{aligned}\n(1-t)B_i^n(t)\u0026amp;=(1-t)C_n^it^i(1-t)^{n-i}\\\\\\\\\n\u0026amp;=C_n^it^i(1-t)^{n+1-i}\\\\\\\\\n\u0026amp;=\\frac{n+1-i}{n+1}C_{n+1}^it^i(1-t)^{n+1-i}\\\\\\\\\n\u0026amp;=\\frac{n+1-i}{n+1}B_i^{n+1}(t)\n\\end{aligned}\n$$\n类似地，\n$$\ntB_i^n(t)=\\dfrac{i+1}{n+1}B_i^{n+1}(t)\n$$\n从而有：\n$$\n\\begin{align}\n\\pmb f(t)\u0026amp;=[(1-t)+t]\\pmb f(t)\\\\\\\\\n\u0026amp;=[(1-t)+t]\\sum\\limits_{i=0}^nB_i^n(t)\\pmb P_i\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\Big[(1-t)B_i^n(t)+tB_i^n(t)\\Big]\\pmb P_i\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\Bigg[\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)+\\dfrac{i+1}{n+1}B_{i+1}^{n+1}(t) \\Bigg]\\pmb P_i\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)\\pmb P_i+\\sum\\limits_{i=0}^n\\dfrac{i+1}{n+1}B_{i+1}^{n+1}(t) \\pmb P_i\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)\\pmb P_i+\\sum\\limits_{i=1}^n\\dfrac{i}{n+1}B_{i}^{n+1}(t) \\pmb P_{i-1}\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^{n+1}\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)\\pmb P_i+\\sum\\limits_{i=0}^n\\dfrac{i}{n+1}B_{i}^{n+1}(t) \\pmb P_{i-1}\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^{n+1}B_i^{n+1}(t)\\Bigg[\\dfrac{n+1-i}{n+1}\\pmb P_i+\\dfrac{i}{n+1}\\pmb P_{i-1} \\Bigg]\n\\end{align}\n$$\n 示例：\n6. Bézier曲线的划分(Subdivision) 给定$n+1$个Bézier控制点$\\pmb b_0,\\pmb b_1,\\cdots,\\pmb b_n$，生成Bézier曲线$\\pmb x(t)$\nBézier曲线的划分即希望得到两条曲线：\n $\\pmb{b}_0^{[1]},\\dots,\\pmb{b}_n^{[1]}\\to \\pmb{x}^{[1]}(t)$ $\\pmb{b}_0^{[2]},\\dots,\\pmb{b}_n^{[2]}\\to \\pmb{x}^{[2]}(t)$  且两条曲线合并可得$\\pmb{x}=\\pmb{x}^{[1]}\\cup \\pmb{x}^{[2]}$\n解决方法：\n$$\n\\begin{aligned}\n\\pmb b_i^{(1)}\u0026amp;=\\pmb b_0^i\\\\\\\\\n\\pmb b_i^{(2)}\u0026amp;=\\pmb b_0^{n-i}\\\\\\\\\n\\mathrm{for}\\ i\u0026amp;=0,\\cdots,n\n\\end{aligned}\n$$\n该方法的依据如下图所示：\n7. 视频演示 Bézier曲线已在IlumEngine中实现，使用De Casteljau算法进行构造。\n\n","description":"Bézier曲线原理与实现","id":8,"section":"posts","tags":["Geometry"],"title":"几何造型(1)：Bézier曲线","uri":"https://chaphlagical.github.io/zh/posts/geometry/bezier_curve/"},{"content":"鼠标拾取是引擎场景编辑器的一个非常基础的功能，通过点击屏幕像素选择场景中的物体，能够使用户更加方便地选择物体、编辑场景。利用空闲时间我将IlumEngine场景编辑器的鼠标拾取功能做了一个优化，从原来的基于Ray Casting方法到现在所使用的G-Buffer回读的方法，两种方法各有优劣，下面详细介绍这两种鼠标拾取的方法。\n1. 基于Ray Casting的鼠标拾取方法 基于Ray Casting的鼠标拾取是一种几何方法，其基本原理如下：\n 由鼠标点击的屏幕像素坐标，生成一条从摄像机发射的射线 对场景作求交计算（与Ray Tracing中的相交检测相同） 寻找与光线相交的最近包围盒，其对应的物体即为鼠标将选中的物体  已知我们已从窗口/UI系统中得到鼠标点击的像素坐标click_pos，首先将其转化为屏幕空间坐标：\n1 2  float x = (click_pos.x / scene_view_size.x) * 2.f - 1.f; float y = -((click_pos.y / scene_view_size.y) * 2.f - 1.f);   我们希望利用拾取点的屏幕空间坐标从相机发射一条射线，一种思路是计算拾取点的远近平面投影坐标，然后将它们连起来即可：\n1 2 3 4 5 6 7 8 9 10  glm::mat4 inv = glm::inverse(main_camera.view_projection); glm::vec4 near_point = inv * glm::vec4(x, y, 0.f, 1.f); near_point /= near_point.w; glm::vec4 far_point = inv * glm::vec4(x, y, 1.f, 1.f); far_point /= far_point.w; geometry::Ray ray; ray.origin = main_camera.position; ray.direction = glm::normalize(glm::vec3(far_point - near_point));   最后，用射线做与包围盒的求交，求交的计算也可用BVH、KD-Tree等加速结构进行加速，这里为了快速实现只是简单遍历并对每个包围盒进行求交：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  float distance = std::numeric_limits\u0026lt;float\u0026gt;::infinity(); const auto group = Scene::instance()-\u0026gt;getRegistry().group\u0026lt;\u0026gt;(entt::get\u0026lt;cmpt::MeshRenderer, cmpt::Transform\u0026gt;); group.each([\u0026amp;](const entt::entity \u0026amp;entity, const cmpt::MeshRenderer \u0026amp;mesh_renderer, const cmpt::Transform \u0026amp;transform) { if (!Renderer::instance()-\u0026gt;getResourceCache().hasModel(mesh_renderer.model)) { return; } auto \u0026amp;model = Renderer::instance()-getResourceCache().loadModel(mesh_renderer.model); float hit_distance = ray.hit(model.get().bounding_box.transform(transform.world_transform)); if (distance \u0026gt; hit_distance) { distance = hit_distance; Editor::instance()-\u0026gt;select(Entity(entity)); } }); }   具体求交的计算后续光线追踪模块的开发将会提到，这里不作具体阐述。\n2. 基于G-Buffer回读的鼠标拾取方法 基于G-Buffer的鼠标拾取是一种图像方法，在几何阶段生成G-Buffers时我们顺带生成一张带有场景物体实体ID的G-Buffer，格式为VK_FORMAT_R32_UINT。在得到鼠标响应时，将该G-Buffer的数据回读到CPU中，利用像素坐标查找相应的实体ID，得到拾取到的对象。完整过程的源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  ImageReference entity_id_buffer = Renderer::instance()-\u0026gt;getRenderGraph()-\u0026gt;getAttachment(\u0026#34;debug - entity\u0026#34;); CommandBuffer cmd_buffer; cmd_buffer.begin(); Buffer staging_buffer(static_cast\u0026lt;VkDeviceSize\u0026gt;(entity_id_buffer.get().getWidth() * entity_id_buffer.get().getHeight()) * sizeof(uint32_t), VK_BUFFER_USAGE_TRANSFER_DST_BIT, VMA_MEMORY_USAGE_GPU_TO_CPU); cmd_buffer.transferLayout(entity_id_buffer, VK_IMAGE_USAGE_SAMPLED_BIT, VK_IMAGE_USAGE_TRANSFER_SRC_BIT); cmd_buffer.copyImageToBuffer(ImageInfo{entity_id_buffer, VK_IMAGE_USAGE_TRANSFER_SRC_BIT, 0, 0}, BufferInfo{staging_buffer, 0}); cmd_buffer.transferLayout(entity_id_buffer, VK_IMAGE_USAGE_TRANSFER_SRC_BIT, VK_IMAGE_USAGE_SAMPLED_BIT); cmd_buffer.end(); cmd_buffer.submitIdle(); std::vector\u0026lt;uint32_t\u0026gt; image_data(entity_id_buffer.get().getWidth() * entity_id_buffer.get().getHeight()); std::memcpy(image_data.data(), staging_buffer.map(), image_data.size() * sizeof(uint32_t)); click_pos.x = glm::clamp(click_pos.x, 0.f, static_cast\u0026lt;float\u0026gt;(entity_id_buffer.get().getWidth())); click_pos.y = glm::clamp(click_pos.y, 0.f, static_cast\u0026lt;float\u0026gt;(entity_id_buffer.get().getHeight())); auto entity = Entity(static_cast\u0026lt;entt::entity\u0026gt;(image_data[static_cast\u0026lt;uint32_t\u0026gt;(click_pos.y) * entity_id_buffer.get().getWidth() + static_cast\u0026lt;uint32_t\u0026gt;(click_pos.x)])); Editor::instance()-\u0026gt;select(entity); staging_buffer.unmap();   由于G-Buffer的内存访问方式均为GPU_only的，我们需要使用一块GPU_to_CPU的Buffer进行暂存，最后Map到CPU内存中。\n3. 比较与选择  Ray Casting方法  优点  CPU实现，不依赖于渲染管线，能够很方便地集成   缺点  不够精确，由于是射线与包围盒求交，拾取的实际上是物体对应的包围盒而不是物体本身，有时候会带来误差，在场景复杂时效果不好 性能受场景规模影响较大，而使用加速结构进行求交加速实际上也增加了集成复杂度（需要引擎具有光追或物理模块支持）     G-Buffer方法  优点  精准，由于是直接把实体ID贴到纹理上，因此能够做到像素级的拾取   缺点  需要一张G-Buffer，增加了带宽开销 需要回读GPU数据，不过只有在鼠标点击时才会触发，影响并不大 需要渲染管线支持，需要配合整个渲染系统进行设计      在开发前期，Render Graph还不够完善，渲染管线扩展能力一般，为了简便，我先直接用Ray Casting的方法给IlumEngine加上一个基本能用的拾取方法，后来为了拾取精度的需要，将拾取算法改为了基于G-Buffer方法。\n最终实现效果如下：\n\n","description":"IlumEngine编辑器鼠标拾取原理","id":9,"section":"posts","tags":["IlumEngine"],"title":"场景编辑器：鼠标拾取","uri":"https://chaphlagical.github.io/zh/posts/rendering/mouse_picking/"},{"content":"前段时间初步完成了个人图形引擎IlumEngine的第一次性能优化。此次优化主要集中在几何渲染与纹理系统上，主要内容大致有：\n Vertex/Index Buffer Packing GPU Driven Rendering  GPU Based Culling  Frustum Culling Hierarchy Z Buffer Occlusion Culling Cone Back Face Culling   Multi Draw Indirect Bindless Texture System    利用现代API灵活的可操作性，解决了几何阶段大量DrawCalls带来的CPU压力，以及提高顶点、索引数据的利用率，并且该架构也有利于后续集成实时光线追踪等功能\n1. IlumEngine简介 IlumEngine是我目前正在开发的一个玩具图形引擎，名字取自*《星球大战》*中凯伯水晶的产地伊冷（后传中被第一军团改造为弑星者基地），引擎使用Vulkan作为图形API（后续或重构为RHI层以支持DX12甚至向下兼容OpenGL），目的是锻炼软件系统工程能力和作为学习图形学经典技术复现和前沿技术的实验平台，预期功能：\n  Render Graph高灵活度渲染管线架构\n  基于ImGui的交互友好的编辑器\n  异步资源加载系统（或进化至流式加载系统）\n  集成基本几何造型算法\n Bezier曲线 三次样条曲线 B样条曲线 有理样条曲线 有理样条曲面等    集成基本数字几何处理算法\n 网格参数化 网格简化与细分 网格变形等    集成基本物理模拟算法\n 刚体模拟 布料模拟 柔性体模拟 流体模拟    集成基本光栅渲染算法\n Forward/Deferred/Tile Based渲染管线 实时阴影  PCF、PCSS VSM CSM   环境光照：IBL、PRT 全局光照  DDGI VXGI等   屏幕空间后处理  Blooming SSGI SSR等      集成基本离线渲染算法\n PT PM BDPT等    目前已将基础的架构部分搭建完成，能够支持Disney PBR材质的延迟渲染管线：\n接下来几节将从存储优化、CPU负载优化、GPU负载优化方面来介绍此次引擎优化的主要内容。\n2. 几何缓存优化 在介绍引擎的几何缓存优化之前，先介绍一下目前引擎使用的场景图和几何模型存储结构。\n2.1. 场景图 场景图是渲染引擎中重要的一个部分，通常采用树状结构（有向无环图）进行组织，IlumEngine中使用基于entt的实体组件系统ECS来实现场景图：\n 每个实体（Entity）作为场景图中的一个结点 每个实体可以挂上若干个组件（Component） 实体只是拓扑关系的结点，不存储实际数据 组件仅存储数据，而不存储逻辑（函数、方法） 组件中的数据由系统（System）使用，实现场景图的更新  想让一个实体拥有几何数据，则将该实体挂载上MeshRenderer组件，在渲染循环系统中，将从所有实体的MeshRenderer中获取渲染所需的几何数据，以完成几何阶段的渲染。\n2.2. 几何模型存储结构 组件MeshRenderer定义如下：\n1 2 3 4 5 6  struct MeshRenderer { std::string model; std::vector\u0026lt;scope\u0026lt;IMaterial\u0026gt;\u0026gt; materials; inline static bool update = false; };   其中，\n model为模型数据的索引，这里使用模型文件所在位置的相对路径表示 materials为模型的材质，初始化时将拷贝为模型的默认材质，在编辑器中也可对某个实体的材质进行修改 update为全局静态更新变量，表示在某循环中与MeshRenderer相关的更新  为得到实际的几何数据，我们还需要利用索引model在资源管理器ResourceCache中查询几何模型，ResourceCache实现了模型与贴图的多线程异步加载和缓存查询等功能，这里不作展开。通过查询，将得到实际模型对象的引用ModelReference：\n1  using ModelReference = std::reference_wrapper\u0026lt;Model\u0026gt;;   而Model便是我们实际存储几何数据的对象了，Model中又有如下数据：\n1 2 3 4 5 6 7  struct Model { std::vector\u0026lt;SubMesh\u0026gt; submeshes; geometry::BoundingBox bounding_box; VertexInfo vertex_info; IndexInfo index_info; }   其中，Submesh为模型的子网格，为导入方便以及支持单个模型不同部分使用不同材质，IlumEngine采用了子网格的形式来组织大型模型，每个子网格拥有以下信息：\n1 2 3 4 5 6 7 8 9  struct Submesh { uint32_t index = 0; glm::mat4 pre_transform = glm::mat4(1.f); material::DisneyPBR material; geometry::BoundingBox bounding_box; VertexInfo vertex_info; IndexInfo index_info; }   其实和Model是差不多的，Submesh是目前几何数据渲染的最小独立单位。\n2.3. 几何存储方案 上文已介绍了几何模型的一个存储结构，但是并未涉及具体的几何数据存储方案，所谓的几何数据存储方案，一个是CPU端的存储，即顶点和索引数据的存储；一个是GPU端的存储，即Vertex Buffer与Index Buffer的存储。对于静态网格模型而已，完全可以将几何数据送入GPU后删除CPU端的数据，但由于本引擎后续需要加入几何处理的功能，为了方便起见依旧全部保留CPU端的几何信息。\n2.3.1. 极简方案 最简单的一种也是最直观的一种策略，便是每个子网格存一份位置的几何信息，即：\n1 2 3 4 5 6 7 8 9 10 11  struct Submesh { uint32_t index = 0; glm::mat4 pre_transform = glm::mat4(1.f); material::DisneyPBR material; geometry::BoundingBox bounding_box; std::vector\u0026lt;Vertex\u0026gt; vertices; std::vector\u0026lt;uint32_t\u0026gt; indices; Buffer vertex_buffer; Buffer index_buffer; }   这种方法最为简单直观，也方便编程，但在实际渲染过程中会有渲染状态频繁切换的问题。假设有$N$个模型，第$i$个模型具有$M_i$个子网格，那么在一个渲染循环内需要做以下操作：\n  遍历$N$个模型\n  遍历模型$i$中的$M_i$个子网格\n  绑定子网格对应的GPU资源\n1 2  vkCmdBindVertexBuffers(cmd_buffer, 0, 1, \u0026amp;vertex_buffer, 0); vkCmdBindIndexBuffer(cmd_buffer, index_buffer, 0, VK_INDEX_TYPE_UINT32);     执行渲染绘制操作\n1  vkCmdDrawIndexed(cmd_buffer, index_count, 1, 0, 0, 0);     因此在一个渲染循环中需要切换绑定$N*M$次顶点/索引缓冲，当模型数量增加时会明显影响效率，而且多块小存储空间也不是一种好的存储分配策略，容易带来内存碎片等问题，同时，当模型具有多个重复的子网格时，这种存储策略将造成数据冗余，降低存储资源的利用率\n2.3.2. 基于模型的优化方案 既然子网格存储所有的几何数据不太好，那我就每个模型存储一份几何数据，然后子网格只存偏移和长度咯。基于模型的优化方案也确实是这样的设计思路：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  struct Model { std::vector\u0026lt;SubMesh\u0026gt; submeshes; geometry::BoundingBox bounding_box; std::vector\u0026lt;Vertex\u0026gt; vertices; std::vector\u0026lt;uint32_t\u0026gt; indices; Buffer vertex_buffer; Buffer index_buffer; } struct Submesh { uint32_t index = 0; glm::mat4 pre_transform = glm::mat4(1.f); material::DisneyPBR material; geometry::BoundingBox bounding_box; uint32_t indices_offset; uint32_t indices_count; }   模型中存储了所有子网格的几何数据，通过顶点索引的偏移offset和顶点索引数量count即可绘制出相应的子网格。由于目前的索引均从顶点缓冲的开头开始，因此暂不需要vertex_offset的参与。\n假设有$N$个模型，第$i$个模型具有$M_i$个子网格，那么在一个渲染循环内需要做以下操作：\n  遍历$N$个模型\n  绑定模型对应的GPU资源\n1 2  vkCmdBindVertexBuffers(cmd_buffer, 0, 1, \u0026amp;vertex_buffer, 0); vkCmdBindIndexBuffer(cmd_buffer, index_buffer, 0, VK_INDEX_TYPE_UINT32);     遍历模型$i$中的$M_i$个子网格\n  执行渲染绘制操作\n1  vkCmdDrawIndexed(cmd_buffer, index_count, 1, index_offset, 0, 0);     因此在一个渲染循环中需要切换绑定$N$次顶点/索引缓冲，比前述的极简方案要好不少，同时模型存储也避免了多个重复子网格冗余的问题，相同的子网格只要有相同的索引偏移和数量即可。\n2.3.3. 统一存储的优化方案 基于模型的方案在渲染每个模型时依然需要切换绑定顶点索引缓冲，在模型数量很多时同样可能带来瓶颈，同时也不利于我们后面进行GPU Driven Rendering的single drawcall设计。所以这次一劳永逸，分配一个大块的GPU显存资源来存储所有的顶点和索引缓冲，而CPU端的几何数据则仍按基于模型的方案设计。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  struct Model { std::vector\u0026lt;SubMesh\u0026gt; submeshes; geometry::BoundingBox bounding_box; std::vector\u0026lt;Vertex\u0026gt; vertices; std::vector\u0026lt;uint32_t\u0026gt; indices; uint32_t indices_offset; uint32_t vertices_offset; } struct Submesh { uint32_t index = 0; glm::mat4 pre_transform = glm::mat4(1.f); material::DisneyPBR material; geometry::BoundingBox bounding_box; uint32_t vertex_offset; uint32_t indices_offset; uint32_t indices_count; } class Renderer { Buffer vertex_buffer; Buffer index_buffer; ... }   该方案的麻烦之处在于，每当有模型添加、修改或删除时需要对全局缓冲进行更新，同时也需要更新每个模型的偏移。下图为各个存储索引关系示例：\n现在，假设有$N$个模型，第$i$个模型具有$M_i$个子网格，那么在一个渲染循环内需要做以下操作：\n  绑定几何数据对应的GPU资源\n1 2  vkCmdBindVertexBuffers(cmd_buffer, 0, 1, \u0026amp;vertex_buffer, 0); vkCmdBindIndexBuffer(cmd_buffer, index_buffer, 0, VK_INDEX_TYPE_UINT32);     遍历$N$个模型\n  遍历模型$i$中的$M_i$个子网格\n  执行渲染绘制操作\n1  vkCmdDrawIndexed(cmd_buffer, index_count, 1, index_offset, vertex_offset, 0);     现在，我们彻底地将几何资源绑定次数降低至single bind，无论场景多大，模型数量多少我们均只需单次绑定开销，而在后续的GPU Driven Rendering的管线设计中，我们也会看到这种Vertex/Index Buffer packing的方法具有的巨大优势。\n3. GPU驱动渲染管线 GPU Driven Rendering Pipelien的概念最早在Siggraph2015上由育碧Ubisoft提出[1]，其相应技术也已在《刺客信条：大革命》中得以落地，在当时可以说是相当前卫的一种设计，但由于当年硬件条件所限，《刺客信条：大革命》却因为层出不穷的Bug被当时的玩家所诟病，一度将育碧和刺客信条系列推向低谷，不过回过头看，《刺客信条：大革命》确实在大型场景和复杂建筑、海量NPC、真实感渲染等方面都是前作所不能比拟的，可以算是3A大作进入画质内卷的一个分界线。\n在IlumEngine中，我也尝试了使用GPU Driven Rendering Pipeline的思想，来对引擎进行性能调优。\n3.1. 无绑定纹理 Bindless方法指不通过传统方法将资源通过bindTexture/bindBuffer的方式进行绑定，而是直接将Texture/Buffer等GPU资源的虚拟地址直接存储在Bindless Buffer中，在着色器中可以直接使用索引进行访问。Bindless技术最早来源于Nvidia提出的 AZDO（Approaching Zero Driver Overhead）技术框架，2008年Nvidia的Tesla架构就已经实现了Bindless Buffer，而在2012年的Kepler架构正式加入了Bindless Texture特性。\n对于传统的绑定模型，我们往往需要在着色器中声明所需要的纹理/缓冲资源，并且分配相应的槽位（slot）：\n1 2 3  layout (binding = 0) uniform sampler2D tex0; layout (binding = 1) uniform sampler2D tex1; layout (binding = 2) uniform sampler2D tex2;   在CPU端，需要显式绑定所有纹理资源：\n而使用Bindless绑定模型，在着色器中，我们相当于使用了一个无穷大的纹理数组：\n1  layout (binding = 0) uniform sampler2D textureArray[];   所有的纹理数据可以一次性全部灌入其中，需要用到时，我们只需要一个下标索引即可进行访问，而对于材质而言，也不再像下图那样的贴图绑定：\n1 2 3  layout (binding = 0) uniform sampler2D Albedo; layout (binding = 1) uniform sampler2D Metallic; layout (binding = 2) uniform sampler2D Roughness;   而是使用一个结构体，存储所有的材质贴图索引：\n1 2 3 4 5 6  struct Material { uint Albedo; uint Metallic; uint Roughness; }   访问时只需：\n1  vec4 albedo = texture(textureArray[nonuniformEXT(material.Albedo)], inUV);   即可。对于GLSL，记得开启扩展GL_EXT_nonuniform_qualifier\nBindless访问模型如下：\nBindless对GPU Driven Rendering Pipeline有至关重要的作用，它主要解决了传统API下绑定资源到管线的开销问题，同时突破了着色器的硬件访问限制，进一步降低CPU-GPU的交互，我们不需要在CPU端设置Bindless资源的绑定状态，是之后实现single drawcall for everything的基础。\nVulkan中与Bindless相关的技术叫descriptor_indexing，在Vulkan 1.0属于EXT特性，但在Vulkan 1.2中已升为Core特性。在Logical Device的创建时指定：\n1 2 3 4 5 6 7  VkPhysicalDeviceVulkan12Features vulkan12_features = {}; vulkan12_features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES; vulkan12_features.shaderSampledImageArrayNonUniformIndexing = VK_TRUE; vulkan12_features.runtimeDescriptorArray = VK_TRUE; vulkan12_features.descriptorBindingVariableDescriptorCount = VK_TRUE; vulkan12_features.descriptorBindingPartiallyBound = VK_TRUE;   其中，shaderSampledImageArrayNonUniformIndexing、runtimeDescriptorArray、descriptorBindingVariableDescriptorCount指定开启descriptor_indexing特性，descriptorBindingPartiallyBound解决了缺省绑定的问题。\n在创建Bindless Texture过程中，需要指定Bindless Texture的数组支持的最大容量，通常会指定为一个较大的数（如1024）以避免反复扩容，而大部分情况下场景中的纹理都不会填满最大容量，此时需要开启descriptorBindingPartiallyBound支持缺省绑定，以防止出错。\nBindless Texture可视化：\n至此，我们又将一个费时的操作从CPU端移走了。\n3.2. 多重间接绘制 此前的一章一节中，我们将几何数据资源绑定的CPU开销降至最低，将纹理资源绑定的CPU开销给完全移走了，在本节中，我们将要把绘制开销降至最低，实现心心念念的single drawcall for everything。\n在最开始的设计中，我以一种非常低效的方式进行几何阶段的渲染，流程如下：\n 绑定Pipeline、DescriptorSet、Vertex/Index Buffer 遍历模型 遍历子网格 收集材质信息，使用Push Constant操作将材质数据送往着色器 调用绘制命令  可以看到，每一个子网格都将贡献一次Push Constant开销和一次Drawcall的开销，更不用说其他的逻辑判断操作，结果可想而知，场景复杂度一上去，CPU开销裂开，非常不贴合现代图形API的设计初衷，我们需要更多类似Bindless Texture的低CPU开销设计。\n好在现代图形API已经帮我们考虑好了，多重间接绘制Multi Draw Indirect能够完美地满足我们的需求。不同于显式调用绘制命令，Multi Draw Indirect允许我们实现将绘制命令预存在GPU的显存中，在需要绘制时调用：\n1  vkCmdDrawIndexedIndirect(cmd_buffer, draw_buffer, buffer_size, draw_count, sizeof(VkDrawIndexedIndirectCommand));   一个Drawcall即可完成所有的绘制指令提交。\n下面介绍多重间接绘制相关的技术细节：\n3.2.1. 指令缓冲 前述中，Multi Draw Indirect使用我们预存在GPU显存中的绘制命令进行提交，这些绘制命令存储在指令缓冲。在Vulkan中，有结构体VkDrawIndexedIndirectCommand或VkDrawIndirectCommand帮助我们指定指令缓冲中需要存哪些信息，一般来讲我们使用索引进行绘制，因此用的是VkDrawIndexedIndirectCommand，其数据结构定义为：\n1 2 3 4 5 6 7  typedef struct VkDrawIndexedIndirectCommand { uint32_t indexCount; uint32_t instanceCount; uint32_t firstIndex; int32_t vertexOffset; uint32_t firstInstance; } VkDrawIndexedIndirectCommand;   是不是和我们显式绘制指令的参数不能说很像，只能说一模一样？\n1 2 3 4 5 6 7  void vkCmdDrawIndexed( VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance);   当然用法也一样，就是把之前要在渲染循环里指定的参数一一写入一个std::vector\u0026lt;VkDrawIndexedIndirectCommand\u0026gt;容器里，然后在把里面的数据传到GPU显存中，使用其缓冲句柄即可调用vkCmdDrawIndexedIndirect了。\n3.2.2. 材质缓冲 前文提到过，在一开始的实现中，我们将材质信息使用Push Constant的方法在几何遍历时传到着色器中，而使用多重间接绘制时我们不再需要遍历几何体，没办法使用Push Constant方法传送逐子网格数据，因此我们需要一种新的传送材质数据的方法。\n这里我也采用了一种比较暴力的方法，那就是将所有的材质数据都存在一个大的Storage Buffer，鉴于材质数据结构中只需存各个贴图的索引和一些简单的参数，需要的显存并不算多，在每帧循环时，根据需要进行更新。\n由于材质信息是每个子网格拥有一份（不支持多材质、分层材质等），连同如预变换（Pre-Transform，与模型变换矩阵相乘构成世界变换矩阵）、包围盒等信息组成PerInstanceData：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  struct PerInstanceData { mat4 world_transform; mat4 pre_transform; vec4 base_color; vec3 emissive_color; float metallic_factor; float roughness_factor; float emissive_intensity; uint albedo_map; uint normal_map; uint metallic_map; uint roughness_map; uint emissive_map; uint ao_map; vec3 min_; float displacement_height; vec3 max_; uint displacement_map; };   （变量顺序是为了内存对齐需要）\n在着色器中，通过扩展GL_ARB_shader_draw_parameters，能够获得当前绘制物体的索引gl_DrawIDARB，由此来访问相应的PerInstanceData。\n这样一来，我们也顺利地使用一个DrawCall完成了所有的绘制指令提交，实际实验结果也很让人满意，CPU开销有了显著的降低，耗时仅为原来的十分之一不到，CPU也不再成为了渲染的瓶颈。\n3.3. 基于GPU的剔除 在前面几节中，我们已经彻底完成了CPU端的瓶颈解除，但我们也不应止步于此，接下来将进行GPU端的性能优化。要想在不减少场景规模的前提下减少GPU的计算耗时，一个基本的想法就是告诉GPU哪些东西是需要渲染的、哪些东西是不需要渲染的，也就是本节的主角——剔除技术了。\n剔除的本质是一种可见性测试，最常见的剔除有两种：视锥体剔除和遮挡剔除，这两种剔除方法能够排除大量不可见的可渲染物体，当然还有小片元剔除、背面剔除等其他方法。\n在传统管线中，通常采用CPU进行剔除处理，通过SSIM等硬件加速手段提高求交检测来实现各种剔除技术。但在本GPU Driven Rendering Pipeline中，我们已经将所有渲染数据和参数放在显存上了，很自然地，我们将利用现代GPU的通用计算功能（GPGPU），使用计算着色器来帮助我们完成剔除的操作。\n3.3.1. 视锥剔除 在学习计算机图形学基础时，我们都会接触到相机投影等相关知识，简单来讲，相机投影定义了一个裁剪空间，对于正交相机，其平截头体是一个长方体：\n而对于透视相机，其平截头体是一个台体\n在平截头体（或视锥体）之外的顶点将在裁剪阶段被渲染管线丢弃，尽管这些顶点不会参与最后的光栅化阶段，但还是会在顶点着色器中进行计算处理，造成不必要的性能浪费。通过视锥剔除计算，在不可见物体送入渲染管线前就进行排除，能够提高我们的计算效率和计算资源利用率。\n视锥剔除的检测，即包围盒与视锥平面的求交检测，这里涉及两个步骤：视锥平面的求算与包围盒的求交。\n视锥平面的求算\n在IlumEngine中，视锥平面的计算使用了Gribb-Hartmann方法进行求解，其详细数学推导可参考[2]。\n已知当前场景主摄像机的投影矩阵为$M_{P}$，视图矩阵为$M_V$，定义投影视图矩阵：\n$$\nM_{PV}=M_PM_V=\\begin{bmatrix}\nm_{11}\u0026amp;m_{12}\u0026amp;m_{13}\u0026amp;m_{14}\\\\\nm_{21}\u0026amp;m_{22}\u0026amp;m_{23}\u0026amp;m_{24}\\\\\nm_{31}\u0026amp;m_{32}\u0026amp;m_{33}\u0026amp;m_{34}\\\\\nm_{41}\u0026amp;m_{42}\u0026amp;m_{43}\u0026amp;m_{44}\n\\end{bmatrix}\n$$\n则六个视锥面方程如下：\n$$\n\\begin{aligned}\n\\begin{matrix}\n\\mathrm{Left: }\u0026amp;(m_{41}+m_{11})x+(m_{42}+m_{12})y+(m_{43}+m_{13})z+(m_{44}+m_{14})=0\\\\\n\\mathrm{Right: }\u0026amp;(m_{41}-m_{11})x+(m_{42}-m_{12})y+(m_{43}-m_{13})z+(m_{44}-m_{14})=0\\\\\n\\mathrm{Bottom: }\u0026amp;(m_{41}+m_{21})x+(m_{42}+m_{22})y+(m_{43}+m_{23})z+(m_{44}+m_{24})=0\\\\\n\\mathrm{Top: }\u0026amp;(m_{41}-m_{21})x+(m_{42}-m_{22})y+(m_{43}-m_{23})z+(m_{44}-m_{24})=0\\\\\n\\mathrm{Near: }\u0026amp;(m_{41}+m_{31})x+(m_{42}+m_{32})y+(m_{43}+m_{33})z+(m_{44}+m_{34})=0\\\\\n\\mathrm{Far: }\u0026amp;(m_{41}-m_{31})x+(m_{42}-m_{32})y+(m_{43}-m_{33})z+(m_{44}-m_{34})=0\\\\\n\\end{matrix}\n\\end{aligned}\n$$\n包围盒的求交\nIlumEngine中使用了包围球和AABB包围盒两种包围结构，包围球具有旋转不变性、求交方便等优点，AABB包围盒的紧致性比包围球更胜一筹，可以提高更细粒度的剔除。\n对于点$\\pmb p(\\pmb p_x, \\pmb p_y,\\pmb p_z)$，设视锥平面为$a_ix+b_iy+c_iz+d_i=0$，$(i=0,1,\\cdots,6)$，则点$\\pmb p$处于视锥体内，当且仅当：\n$$\na_i\\pmb p_x+b_i\\pmb p_y+c_i\\pmb p_z+d_i\u0026lt;0,\\forall i=0,1,\\cdots,6\n$$\n成立。\n对于球心坐标为点$\\pmb p(\\pmb p_x, \\pmb p_y,\\pmb p_z)$，半径为$r$的包围球，当且仅当：\n$$\na_i\\pmb p_x+b_i\\pmb p_y+c_i\\pmb p_z+d_i+r\u0026lt;0,\\forall i=0,1,\\cdots,6\n$$\n成立时，物体不会被剔除，代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11  bool checkSphere(vec3 pos, float radius) { for (uint i = 0; i \u0026lt; 6; i++) { if (dot(camera.frustum[i], vec4(pos, 1)) + radius \u0026lt; 0.0) { return false; } } return true; }   对于两端点为$\\pmb p_{max}$和$\\pmb p_{min}$的AABB包围盒，我们可以组合出八个包围盒顶点和视锥体的六个平面分别求交，但这样计算量太大，也没必要，对于每个视锥平面，我们只需挑选出其中离它最远的那个顶点进行判断即可，最远顶点可有下述公式决定：\n$$\n\\begin{matrix}\n\\pmb p_x=\\begin{cases}\np_{min_x}\u0026amp;a_i\u0026lt;0\\\\\np_{max_x}\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n\u0026amp;\n\\pmb p_y=\\begin{cases}\np_{min_y}\u0026amp;b_i\u0026lt;0\\\\\np_{max_y}\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n\u0026amp;\n\\pmb p_z=\\begin{cases}\np_{min_z}\u0026amp;c_i\u0026lt;0\\\\\np_{max_z}\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n\\end{matrix}\n$$\n使用该点进行判断即可。代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  bool checkAABB(vec3 min_val, vec3 max_val) { for (uint i=0; i \u0026lt; 6; i++) { vec4 plane = camera.frustum[i]; vec3 plane_normal = { plane.x, plane.y, plane.z }; float plane_constant = plane.w; vec3 axis_vert = { 0.0, 0.0, 0.0 }; axis_vert.x = plane.x \u0026lt; 0.0 ? min_val.x : max_val.x; axis_vert.y = plane.y \u0026lt; 0.0 ? min_val.y : max_val.y; axis_vert.z = plane.z \u0026lt; 0.0 ? min_val.z : max_val.z; if (dot(axis_vert, plane_normal) + plane_constant \u0026gt; 0.0) { return false; } } return true; }   3.3.2. Hierarchy Z-Buffer遮挡剔除 除了视锥剔除，遮挡剔除也是一种重要的剔除技术，当场景中有大量体积较大的遮挡物时有比较好的性能提升效果。遮挡剔除的实现手段有很多种，有使用硬件的遮挡查询策略，不过开销较大一般不建议使用；有手动指定Occlude和Occluder，使用CPU低分辨率软光栅进行剔除（参考Battlefield 3实现）；也有通过离线烘培的方法来实现遮挡剔除。在IlumEngine中则利用帧间信息连续性的原理，使用前一帧的深度缓冲，利用计算着色器生成层级Mipmap，再通过屏幕空间包围结构在计算着色器中实现遮挡剔除。\nHierarchy Z-Buffer的生成\n有了深度缓冲，要计算某物体是否被遮挡，一个直接的想法就是在深度图中采样该物体所在的像素位置，比较深度图采样值和该物体实际的深度值，若采样值小于深度值，则认为物体在该像素下被遮挡，当然物体的实际深度和像素位置在光栅化之前是很难算出来的，我们可以用简单的几何体例如包围结构来代替实际的物体，但即便如此，进行全分辨率的搜索和比较也是一个相当耗时的操作，这也是我们为什么需要层级深度缓冲的原因：通过包围结构在屏幕空间的投影大小，能够计算出相应的MipLevel，使得在该MipLevel下一个像素刚好能够覆盖全分辨率下包围结构的大小，这样一来，搜索和比较操作从原来的需要对包围结构所占像素逐个比对，优化至只需要搜索相应的MipLevel，通过一次采样即可完成比对。当然下采样也会带来一定的信息量损失，带来剔除精度的损失，但在剔除精度与开销之间的权衡，我们更倾向于后者。\n在每一帧的几何阶段中，我们都将使用一个格式为VK_FORMAT_D32_SFLOAT_S8_UINT的纹理来作为我们的Depth Stencil Buffer，由于深度图格式无法直接进行Mipmap操作，我们需要自己手动生成相应的Mipmap。\n出于框架的局限性，需要在每个渲染流程的结尾将Deth Stencil Buffer拷贝到另外一张深度贴图Last_Frame.depth_buffer中，在HizPass中，首先我们需要准备好Last_Frame.hiz_buffer的各个层级的VkImageView，以方便后续数据的写入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  m_views.resize(Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer-\u0026gt;getMipLevelCount()); VkImageViewCreateInfo image_view_create_info = {}; image_view_create_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; image_view_create_info.viewType = VK_IMAGE_VIEW_TYPE_2D; image_view_create_info.format = VK_FORMAT_R32_SFLOAT; image_view_create_info.components = {VK_COMPONENT_SWIZZLE_R}; image_view_create_info.subresourceRange.layerCount = 1; image_view_create_info.image = *Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer; for (uint32_t i = 0; i \u0026lt; m_views.size(); i++) { image_view_create_info.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; image_view_create_info.subresourceRange.baseArrayLayer = 0; image_view_create_info.subresourceRange.layerCount = 1; image_view_create_info.subresourceRange.baseMipLevel = i; image_view_create_info.subresourceRange.levelCount = 1; vkCreateImageView(GraphicsContext::instance()-\u0026gt;getLogicalDevice(), \u0026amp;image_view_create_info, nullptr, \u0026amp;m_views[i]); }   出于保守剔除策略，在下采样过程中，我们不应使用线性过滤等方法进行处理，而是考虑选择一个$4\\times 4$ Texels中最大的值（不使用反向Z缓冲），在Vulkan中，可以使用Reduction Mode在VkSampler创建时指定VK_SAMPLER_REDUCTION_MODE_MAX：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  VkSamplerCreateInfo createInfo = {VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO}; createInfo.magFilter = VK_FILTER_LINEAR; createInfo.minFilter = VK_FILTER_LINEAR; createInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST; createInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE; createInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE; createInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE; createInfo.minLod = 0; createInfo.maxLod = 16.f; VkSamplerReductionModeCreateInfo createInfoReduction = {VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT}; createInfoReduction.reductionMode = VK_SAMPLER_REDUCTION_MODE_MAX; createInfo.pNext = \u0026amp;createInfoReduction; vkCreateSampler(GraphicsContext::instance()-\u0026gt;getLogicalDevice(), \u0026amp;createInfo, 0, \u0026amp;m_hiz_sampler);   接着生成好需要用到的descriptor_sets：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  for (uint32_t level = 0; level \u0026lt; m_views.size(); level++) { VkDescriptorImageInfo dstTarget; dstTarget.sampler = m_hiz_sampler; dstTarget.imageView = m_views[level]; dstTarget.imageLayout = VK_IMAGE_LAYOUT_GENERAL; VkDescriptorImageInfo srcTarget; srcTarget.sampler = m_hiz_sampler; if (level == 0) { srcTarget.imageView = Renderer::instance()-\u0026gt;Last_Frame.depth_buffer-\u0026gt;getView(ImageViewType::Depth_Only); srcTarget.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL; } else { srcTarget.imageView = m_views[level - 1]; srcTarget.imageLayout = VK_IMAGE_LAYOUT_GENERAL; } std::vector\u0026lt;VkWriteDescriptorSet\u0026gt; write_descriptor_sets(2); write_descriptor_sets[0] = {}; write_descriptor_sets[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET; write_descriptor_sets[0].dstSet = m_descriptor_sets[level]; write_descriptor_sets[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER; write_descriptor_sets[0].dstBinding = 0; write_descriptor_sets[0].pImageInfo = \u0026amp;srcTarget; write_descriptor_sets[0].pBufferInfo = nullptr; write_descriptor_sets[0].pTexelBufferView = nullptr; write_descriptor_sets[0].descriptorCount = 1; write_descriptor_sets[0].pNext = nullptr; write_descriptor_sets[1] = {}; write_descriptor_sets[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET; write_descriptor_sets[1].dstSet = m_descriptor_sets[level]; write_descriptor_sets[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE; write_descriptor_sets[1].dstBinding = 1; write_descriptor_sets[1].pImageInfo = \u0026amp;dstTarget; write_descriptor_sets[1].pBufferInfo = nullptr; write_descriptor_sets[1].pTexelBufferView = nullptr; write_descriptor_sets[1].descriptorCount = 1; write_descriptor_sets[1].pNext = nullptr; m_descriptor_sets[level].update(write_descriptor_sets); }   每个descriptor_set规定了需要读取和写入的数据，在第一轮中，读取的应为上一帧的深度图，写入MipLevel为0的Hi-Z Buffer，而之后的每一轮都是读取MipLevel为$i$的Hi-Z Buffer，写入MipLevel为$i+1$的Hi-Z Buffer。\n至此准备阶段已经结束了，在每一轮渲染循环中，需要进行以下更新：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  for (uint32_t level = 0; level \u0026lt; views.size(); level++) { { VkImageMemoryBarrier read_to_write{}; read_to_write.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER; read_to_write.oldLayout = VK_IMAGE_LAYOUT_GENERAL; read_to_write.newLayout = VK_IMAGE_LAYOUT_GENERAL; read_to_write.srcAccessMask = VK_ACCESS_SHADER_READ_BIT; read_to_write.dstAccessMask = VK_ACCESS_SHADER_WRITE_BIT; read_to_write.image = *Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer; read_to_write.subresourceRange = VkImageSubresourceRange{VK_IMAGE_ASPECT_COLOR_BIT, level, 1, 0, 1}; read_to_write.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; read_to_write.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; vkCmdPipelineBarrier( cmd_buffer, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_DEPENDENCY_BY_REGION_BIT, 0, nullptr, 0, nullptr, 1, \u0026amp;read_to_write); } vkCmdBindDescriptorSets(cmd_buffer, state.pass.bind_point, state.pass.pipeline_layout, 0, 1, \u0026amp;m_descriptor_sets[level].getDescriptorSet(), 0, nullptr); uint32_t level_width = std::max(1u, Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer-\u0026gt;getWidth() \u0026gt;\u0026gt; level); uint32_t level_height = std::max(1u, Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer-\u0026gt;getHeight() \u0026gt;\u0026gt; level); VkExtent2D extent = {level_width, level_height}; vkCmdPushConstants(cmd_buffer, state.pass.pipeline_layout, VK_SHADER_STAGE_COMPUTE_BIT, 0, sizeof(VkExtent2D), \u0026amp;extent); uint32_t group_count_x = (Renderer::instance()-\u0026gt;getRenderTargetExtent().width + 32 - 1) / 32; uint32_t group_count_y = (Renderer::instance()-\u0026gt;getRenderTargetExtent().height + 32 - 1) / 32; vkCmdDispatch(cmd_buffer, group_count_x, group_count_y, 1); { VkImageMemoryBarrier write_to_read{}; write_to_read.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER; write_to_read.oldLayout = VK_IMAGE_LAYOUT_GENERAL; write_to_read.newLayout = VK_IMAGE_LAYOUT_GENERAL; write_to_read.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT; write_to_read.dstAccessMask = VK_ACCESS_SHADER_READ_BIT; write_to_read.image = *Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer; write_to_read.subresourceRange = VkImageSubresourceRange{VK_IMAGE_ASPECT_COLOR_BIT, level, 1, 0, 1}; write_to_read.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; write_to_read.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; vkCmdPipelineBarrier( cmd_buffer, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_DEPENDENCY_BY_REGION_BIT, 0, nullptr, 0, nullptr, 1, \u0026amp;write_to_read); } }   每一次计算循环开始，需要切换相应的读写状态、绑定相应的descriptor_set，进行计算着色器的dispatch，最后再进行下一轮的状态切换准备，直到填满Hi-Z Buffer的所有Mipmap层级为止。\n屏幕空间包围结构的计算\n有了Hi-Z Buffer，现在我们需要得到物体包围结构屏幕空间的投影，为了计算方便，只考虑包围球形式，使用的计算方法参考文献[3]，该算法将世界空间的包围球变换为屏幕空间AABB包围盒。\n首先我们回顾一下图形学基础中视图矩阵和投影矩阵的相关概念，视图矩阵$M_{view}$主要作用是将场景变换到相机空间中，所谓的相机空间，就是以相机为原点所定义的空间，视图矩阵可以由相机的模型矩阵求逆得到：$M_{view}=M_{camera\\_position}^{-1}$，当然一般很少通过这种方法来求取视图矩阵，因为不够直观，而是通过摄像机的朝向和摄像机的位置来进行求取：\n$$\nM_{view}=\\begin{bmatrix}\n\\pmb R_x\u0026amp;\\pmb R_y\u0026amp;\\pmb R_z\u0026amp;0\\\\\n\\pmb U_x\u0026amp;\\pmb U_y\u0026amp;\\pmb U_z\u0026amp;0\\\\\n\\pmb D_x\u0026amp;\\pmb D_y\u0026amp;\\pmb D_z\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;0\u0026amp;1\n\\end{bmatrix}\n\\ast\n\\begin{bmatrix}\n1\u0026amp;0\u0026amp;0\u0026amp;-\\pmb P_x\\\\\n0\u0026amp;1\u0026amp;0\u0026amp;-\\pmb P_y\\\\\n0\u0026amp;0\u0026amp;1\u0026amp;-\\pmb P_z\\\\\n0\u0026amp;0\u0026amp;0\u0026amp;1\n\\end{bmatrix}\n$$\n其中，$\\pmb R$为右向量，$\\pmb U$为上向量，$\\pmb D$为方向向量，$\\pmb P$为摄像机的位置向量。\n而投影矩阵则是实现将三维空间的物体投影到二维屏幕上，投影矩阵将相机空间中的顶点数据变换到裁剪空间中，最后通过透视除法变换到标准化设备坐标，这里以透视投影为例：\n从两个方向观察，由三角形近似可得：\n$$\n\\begin{align}\n\\dfrac{x_p}{x_e}\u0026amp;=\\dfrac{-n}{z_e}\\Rightarrow x_p=\\dfrac{-n\\cdot x_e}{z_e}=\\dfrac{n\\cdot x_e}{-z_e}\\\\\n\\dfrac{y_p}{y_e}\u0026amp;=\\dfrac{-n}{z_e}\\Rightarrow y_p=\\dfrac{-n\\cdot y_e}{z_e}=\\dfrac{n\\cdot y_e}{-z_e}\n\\end{align}\n$$\n注意到$x_p$和$y_p$的计算均需要除以一个$-z_e$，这与裁剪空间到NDC正则化的透视除法相对应：\n$$\n\\begin{align}\n\\begin{pmatrix}\nx_{clip}\\\\y_{clip}\\\\z_{clip}\\\\w_{clip}\n\\end{pmatrix}\n\u0026amp;=\\pmb M_{projection}\\cdot\n\\begin{pmatrix}\nx_{eye}\\\\y_{eye}\\\\z_{eye}\\\\w_{eye}\n\\end{pmatrix}\\\\\n\\begin{pmatrix}\nx_{ndc}\\\\y_{ndc}\\\\z_{ndc}\n\\end{pmatrix}\n\u0026amp;=\n\\begin{pmatrix}\nx_{clip}/w_{clip}\\\\\ny_{clip}/w_{clip}\\\\\nz_{clip}/w_{clip}\n\\end{pmatrix}\n\\end{align}\n$$\n这里的$w_{clip}$便是$-z_e$了，因此透视投影矩阵有如下形式：\n$$\n\\begin{align}\n\\begin{pmatrix}\nx_c\\\\\ny_c\\\\\nz_c\\\\\nw_c\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\cdot \u0026amp; \\cdot \u0026amp; \\cdot \u0026amp; \\cdot\\\\\n\\cdot \u0026amp; \\cdot \u0026amp; \\cdot \u0026amp; \\cdot\\\\\n\\cdot \u0026amp; \\cdot \u0026amp; \\cdot \u0026amp; \\cdot\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\nx_e\\\\\ny_e\\\\\nz_e\\\\\nw_e\n\\end{pmatrix}\n\\end{align}\n$$\n下面我们需要把近平面坐标点$x_p$和$y_p$线性映射到NDC坐标$x_n$和$y_n$：$[l,r]\\Rightarrow [-1,1]$以及$[b,t]\\Rightarrow [-1,1]$\n$$\n\\begin{align}\n\\dfrac{x_n-(-1)}{1-(-1)}\u0026amp;=\\dfrac{x_p-l}{r-l}\\Rightarrow x_n=\\dfrac{2x_p}{r-l}-\\dfrac{r+l}{r-l}\\\\\n\\dfrac{y_n-(-1)}{1-(-1)}\u0026amp;=\\dfrac{y_p-b}{t-b}\\Rightarrow y_n=\\dfrac{2y_p}{t-b}-\\dfrac{t+b}{t-b}\n\\end{align}\n$$\n将$x_p$和$y_p$代入得\n$$\n\\begin{align}\nx_n=\\Big(\\dfrac{2n}{r-l}\\cdot x_e+\\dfrac{r+l}{r-l}\\cdot z_e \\Big)\\Big/-z_e\\\\\ny_n=\\Big(\\dfrac{2n}{t-b}\\cdot y_e+\\dfrac{t+b}{t-b}\\cdot z_e \\Big)\\Big/-z_e\n\\end{align}\n$$\n可填入透视投影矩阵：\n$$\n\\begin{align}\n\\begin{pmatrix}\nx_c\\\\\ny_c\\\\\nz_c\\\\\nw_c\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\frac{2n}{r-l}\u0026amp;0\u0026amp;\\frac{r+l}{r-l}\u0026amp;0\\\\\n0\u0026amp;\\frac{2n}{t-b}\u0026amp;\\frac{t+b}{t-b}\u0026amp;0\\\\\n\\cdot \u0026amp; \\cdot \u0026amp; \\cdot \u0026amp; \\cdot\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\nx_e\\\\\ny_e\\\\\nz_e\\\\\nw_e\n\\end{pmatrix}\n\\end{align}\n$$\n由于$z_c$不依赖于$x_e$与$y_e$且与$z_e$和$w_e$成线性关系，设\n$$\n\\begin{align}\n\\begin{pmatrix}\nx_c\\\\\ny_c\\\\\nz_c\\\\\nw_c\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\frac{2n}{r-l}\u0026amp;0\u0026amp;\\frac{r+l}{r-l}\u0026amp;0\\\\\n0\u0026amp;\\frac{2n}{t-b}\u0026amp;\\frac{t+b}{t-b}\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;A\u0026amp;B\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\nx_e\\\\\ny_e\\\\\nz_e\\\\\nw_e\n\\end{pmatrix}\n\\end{align}\n$$\n即\n$$\nz_n=z_c/w_c=\\dfrac{Az_e+Bw_e}{-z_e}\n$$\n在视角空间中，$w_e=1$，因此$z_n=\\frac{Az_e+B}{-z_e}$，利用边界关系：\n$$\n\\begin{cases}\n\\dfrac{-An+B}{n}=-1\\\\\n\\dfrac{-Af+B}{f}=1\n\\end{cases}\n\\Rightarrow\n\\begin{cases}\nA=-\\dfrac{f+n}{f-n}\\\\\nB=-\\dfrac{2fn}{f-n}\n\\end{cases}\n$$\n因此完整的透视投影矩阵表示为：\n$$\n\\begin{pmatrix}\n\\frac{2n}{r-l}\u0026amp;0\u0026amp;\\frac{r+l}{r-l}\u0026amp;0\\\\\n0\u0026amp;\\frac{2n}{t-b}\u0026amp;\\frac{t+b}{t-b}\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;\\frac{-(f+n)}{f-n}\u0026amp;\\frac{-2fn}{f-n}\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n$$\n如果视锥体对称，即$t=-b$和$l=-r$，则可简化为：\n$$\n\\begin{pmatrix}\n\\frac{n}{r}\u0026amp;0\u0026amp;0\u0026amp;0\\\\\n0\u0026amp;\\frac{n}{t}\u0026amp;0\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;\\frac{-(f+n)}{f-n}\u0026amp;\\frac{-2fn}{f-n}\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n$$\n通常情况下我们会用参数$fovy$（$y$轴方向的视域角）、$aspect$（屏幕宽高比）、$near$（近平面）以及$far$（远平面）来构造透视投影矩阵，相关关系如下：\n$$\n\\begin{align}\nr-l\u0026amp;=width=2*near*aspect*tan(fovy/2)\\\\\nt-b\u0026amp;=height=2*near*tan(fovy/2)\n\\end{align}\n$$\n而对于正交投影，只需对各个方向作正则化即可：\n$$\n\\begin{cases}\n\\dfrac{x_n-(-1)}{1-(-1)}=\\dfrac{x_e-l}{r-l}\\\\\n\\dfrac{y_n-(-1)}{1-(-1)}=\\dfrac{y_e-b}{t-b}\\\\\n\\dfrac{z_n-(-1)}{1-(-1)}=\\dfrac{z_e-n}{f-n}\n\\end{cases}\n$$\n得到正交投影矩阵：\n$$\n\\begin{pmatrix}\n\\frac{2}{r-l}\u0026amp;0\u0026amp;0\u0026amp;-\\frac{r+l}{r-l}\\\\\n0\u0026amp;\\frac{2}{t-b}\u0026amp;0\u0026amp;-\\frac{t+b}{t-b}\\\\\n0\u0026amp;0\u0026amp;\\frac{-2}{f-n}\u0026amp;-\\frac{f+n}{f-n}\\\\\n0\u0026amp;0\u0026amp;0\u0026amp;1\n\\end{pmatrix}\n$$\n复习完视图矩阵和投影矩阵的相关概念后，我们正式计算世界空间中的包围球到屏幕空间AABB包围盒的投影。\n首先，需要将包围球投影到相机空间，这一步简单地乘上一个视图矩阵即可。\n求屏幕空间包围盒，即求包围球在投影面上的最大和最小坐标，从单方向看，如上图所示，若$\\hat a$表示$x$轴，欲求取点$T$的坐标，连线$OT$与圆$C$相切，在该二维平面上，有球心坐标$C(C_x,C_z)$，设$\\vec c=(C_x,C_y)$，$c=\\sqrt{C_x^2+C_y^2}$，则从相机到$T$的单位向量可由旋转得到：\n$$\n\\hat\\omega =\\begin{bmatrix}\\cos\\theta\u0026amp;\\sin\\theta\\\\-\\sin\\theta\u0026amp;\\cos\\theta\\end{bmatrix}\\frac{\\vec c}{|\\vec c|}\n$$\n而$T$到相机的距离也很容易求得：$d=\\sqrt{c^2-r^2}$，且$\\cos\\theta = \\frac{d}{c}$，$\\sin\\theta=\\frac{r}{c}$\n解得$T=O+\\hat \\omega d$，同理可求得点$B$的坐标，令$\\tilde \\theta = -\\theta$即可。\n点$B$和$T$即视图空间中，包围球在$x$轴方向上的最左点和最右点，我们还需要将其变换到裁剪空间中，进行归一化处理。\n由前述推导可知，透视投影过程可表示为如下形式：\n$$\n\\begin{pmatrix}\nP_{00}\u0026amp;0\u0026amp;0\u0026amp;0\\\\\n0\u0026amp;P_{11}\u0026amp;0\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;P_{22}\u0026amp;P_{23}\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\nx_e\\\\y_e\\\\z_e\\\\1\n\\end{pmatrix}=\n\\begin{pmatrix}\nP_{00}x_e\\\\P_{11}y_e\\\\P_{22}z_e+P_{23}\\\\-z_e\n\\end{pmatrix}\n$$\n通过透视除法投影到NDC空间中：\n$$\n\\begin{aligned}\nx_n \u0026amp;= \\frac{Ax_e}{-z_e}\\\\\ny_n \u0026amp;= \\frac{By_e}{-z_e}\n\\end{aligned}\n$$\n最后通过简单的线性变换可以从NDC空间$[-1,1]$变换到UV空间$[0,1]$方便后续处理。\nGLSL实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  bool projectSphere(vec3 C, float r, float znear, float P00, float P11, out vec4 aabb) { if (-C.z \u0026lt; r + znear) return false; vec2 cx = C.xz; vec2 vx = vec2(sqrt(dot(cx, cx) - r * r), r); vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx; vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx; vec2 cy = C.yz; vec2 vy = vec2(sqrt(dot(cy, cy) - r * r), r); vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * cy; vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * cy; aabb = vec4(-minx.x / minx.y * P00, -miny.x / miny.y * P11, -maxx.x / maxx.y * P00, -maxy.x / maxy.y * P11); aabb = aabb.xwzy * vec4(0.5f, -0.5f, 0.5f, -0.5f) + vec4(0.5f); return true; }   深度值搜索与比较\n得到Hi-Z Buffer和屏幕空间包围盒后，便可开始最后的计算环节。首先通过屏幕空间包围盒的大小获得需要索引的MipLevel：\n1 2 3  float width = (aabb.z - aabb.x) * cullData.zbuffer_width; float height = (aabb.w - aabb.y) * cullData.zbuffer_height; float mip_level = floor(log2(max(width, height)));   通过包围盒中心位置来确定需要采样的UV坐标，为了保证不会误剔除，在其周围多采样几个像素：\n1 2 3 4 5  vec2 uv = (aabb.xy + aabb.zw) * 0.5; vec2 uv0 = aabb.xy; vec2 uv1 = aabb.zw; vec2 uv2 = aabb.xw; vec2 uv3 = aabb.zy;   选择深度最大的那个深度值，保守剔除策略：\n1 2 3 4 5  float depth = textureLod(hiz_buffer, uv, mip_level).r; depth = max(depth, textureLod(hiz_buffer, uv0, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv1, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv2, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv3, mip_level).r);   还需要将深度值通过逆透视除法还原到裁剪空间中，以避免浮点精度误差带来的剔除准确性降低，设采样得到的深度值为$z_n$，其裁剪空间对应的深度值为：\n$$\nz_c=\\frac{2f\\cdot n}{(f-n)\\cdot z_n-(f+n)}\n$$\n其中，$f$为远裁剪面距离，$n$为近裁剪面距离，注意这里得到的$z_c$为负，需要取反。\n在实际实验中，在摄像机远离物体的过程中可能会出现误剔除的情况，这是由于我们利用了上一帧的深度信息，而这一帧由于远离物体，深度变大，会导致自遮挡的现象出现，解决办法也很简单，我们需要保留上一帧的相机视图-投影矩阵，在计算用于比较的实际深度值时，应使用上一帧的相机参数，以解决自遮挡问题。\n完整的遮挡剔除代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  float LinearizeDepth(float depth) { return -(2.0 * cullData.zfar * cullData.znear) / (cullData.zfar + cullData.znear - depth * (cullData.zfar - cullData.znear));\t} bool checkOcclusion(vec3 center, float radius) { vec3 dir = normalize(camera.position - center); vec4 sceen_space_center_last = camera.last_view_projection * vec4(center + dir*radius, 1.0); vec3 C = ((cullData.view) * vec4(center,1.0)).xyz; vec4 aabb; if(!projectSphere(C, radius, cullData.znear, cullData.P00, cullData.P11, aabb)) { return true; } float width = (aabb.z - aabb.x) * cullData.zbuffer_width; float height = (aabb.w - aabb.y) * cullData.zbuffer_height; float mip_level = floor(log2(max(width, height))); vec2 uv = (aabb.xy + aabb.zw) * 0.5; vec2 uv0 = aabb.xy; vec2 uv1 = aabb.zw; vec2 uv2 = aabb.xw; vec2 uv3 = aabb.zy; float depth = textureLod(hiz_buffer, uv, mip_level).r; depth = max(depth, textureLod(hiz_buffer, uv0, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv1, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv2, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv3, mip_level).r); float depthSphere = abs(sceen_space_center_last.z); return LinearizeDepth(depth) \u0026gt;= depthSphere; }   3.4. 基于Meshlet的渲染优化 前文中我们已经实现了基本的基于GPU的剔除优化技术，在多数场景下都能带来一定的性能增益，但目前我们还只是以子网格为单位进行的剔除与提交，当子网格较大时仍存在不少计算资源的浪费，由于我们已经使用了GPGPU技术来帮助我们完成剔除与绘制的操作，模型的数量和Drawcall已不再是我们的性能瓶颈，一个很自然的想法便是能否将一个大的网格切分为诸多一定规则的小网格，从而提高剔除的粒度，同时由于我们使用了GPU强大的并行处理能力进行剔除，对它们进行处理也不将成为问题，因此，我们引入了Mesh Shader中Meshlet的概念，只是我们为了平台灵活性，不打算用Mesh Shader进行处理，而是使用计算着色器来帮助我们完成相同的功能。\nMeshlet是网格划分为小块的单位，是Mesh Shader处理的基本单元，传统的顶点着色器是逐顶点处理模型的，而Mesh Shader则支持逐Meshlet处理模型。通常来讲，每个Meshlet具有相同的顶点数以及支持的最大三角形数，NVIDIA建议选取顶点数为64，三角形数为124的Meshlet进行处理，Meshlet的生成需要通过离线工具构建，IlumEngine中使用了开源库meshoptimizer进行处理，meshoptimizer使用非常方便，文档齐全，这里不多讲其使用。如下封面图所示，我们已经成功将整个场景分成了大量小网格块：\n加入了Meshlet支持的模型存储方式与之前也基本一致，区别在于每个Model对象需要维护其所有的Meshlet，每个子网格需要存储其拥有的Meshlet的偏移和数量，Meshlet结构体定义如下：\n1 2 3 4 5 6 7  struct Meshlet { meshopt_Bounds bounds; uint32_t indices_offset; uint32_t indices_count; uint32_t vertices_offset; };   meshopt_Bounds为meshoptimizer的包围体结构，使用的是包围球结构以及用于锥体背面剔除的相关参数。\n现在的Model和Submesh结构体定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  struct Model { public: std::vector\u0026lt;SubMesh\u0026gt; submeshes; uint32_t vertices_count = 0; uint32_t indices_count = 0; uint32_t vertices_offset = 0; uint32_t indices_offset = 0; // Raw geometry, original data  std::vector\u0026lt;Vertex\u0026gt; vertices; std::vector\u0026lt;uint32_t\u0026gt; indices; // Meshlet, for mesh shading \u0026amp; cluster culling  std::vector\u0026lt;Meshlet\u0026gt; meshlets; geometry::BoundingBox bounding_box; } struct SubMesh { public: uint32_t index = 0; glm::mat4 pre_transform = glm::mat4(1.f); uint32_t vertices_count = 0; uint32_t indices_count = 0; uint32_t vertices_offset = 0; uint32_t indices_offset = 0; uint32_t meshlet_offset = 0; uint32_t meshlet_count = 0; material::DisneyPBR material; geometry::BoundingBox bounding_box; }   现在我们已经将最小渲染单位从子网格换成了Meshlet，原先的间接绘制、GPU剔除等操作照样进行。\n3.4.1. Meshlet渲染性能调优1：压缩合批 由于我们将每个网格都分成了众多Meshlet，在提高剔除粒度的同时也增加了渲染物的数量，同时用于间接绘制所需要的Draw_Buffer也会相应的变大，在之前的实现中，我们通过设置VkDrawIndexedIndirectCommand中的instanceCount参数来决定是否进行绘制，设为0时则表示被剔除。但在直接从子网格处理转换到Meshlet处理时，却发现当场景规模很大时，渲染效率反而没有原来的高，经过Profile发现瓶颈出在了几何阶段的GPU开销上，尽管有了一系列CPU优化和GPU剔除，CPU已经基本不需要花什么时间了，但绘制过程中的GPU用时居高不下，经分析是由于Draw_Buffer过大造成，光是遍历里头每一条渲染指令就已经花了GPU很多时间了。这个问题的解决方法也很简单：只提交需要进行绘制的指令。\n在之前的实现中，我们是在CPU端事先设置好所有的VkDrawIndexedIndirectCommand数组，传到GPU中，通过GPU可见性判断来设置instanceCount参数决定是否绘制该物体，这种方法造成了最后进行提交的绘制缓冲中有效指令和无效指令相互混叠，容易产生流水线气泡，如果能够对绘制缓冲中的指令进行排序，将有效指令移至渲染队列的头部，将绘制指令数量设置为有效指令的数量，则可以大幅提升性能。但在着色器中实现排序操作似乎不是一件简单的操作，因此我们另辟蹊径，在剔除管线中不仅设置可见性，我们直接在里头设置整个渲染指令。\n为方便渲染队列的构建和有效指令数量的跟踪，我们使用了一个Count_Buffer来记录有效绘制指令的数量，在计算着色器中，通过原子加法操作，实现类似push_back的功能：\n1 2 3 4 5 6 7 8 9 10  if (visible) { uint dci = atomicAdd(visible_count, 1); indirectDraws[dci].indexCount = meshlet.index_count; indirectDraws[dci].instanceCount = 1; indirectDraws[dci].firstIndex = meshlet.index_offset; indirectDraws[dci].vertexOffset = int(meshlet.vertex_offset); indirectDraws[dci].firstInstance = 0; draw_data[dci] = meshlet.instance_id; }   然而，在开发过程中，又遇到一个问题，如何获取Count_Buffer中的计数数据？使用GPU-CPU回读？那样在 一个渲染循环中只能获取到上一帧的计数结果。通过查阅文档发现，Vulkan开发者已经考虑过这个问题了，提供了vkCmdDrawIndexedIndirectCount函数，让我们能够直接使用Count_Buffer作为参数向GPU指定渲染指令数量。\n至此，Meshlet渲染带来的合批过大问题已被完美解决。\n3.4.2. Meshlet渲染性能调优2：层次剔除 简单使用Meshlet进行渲染，除了有合批过大的问题外，还有剔除开销的问题，当场景面数一多，Meshlet数量一大，剔除阶段的计算量也是不可忽视的。这里IlumEngine采用的解决方案是分层次进行剔除，其实也就是先对实例（子网格）进行剔除，再进行Meshlet进行剔除。已经在实例剔除阶段剔除的实例，其包含的Meshlet也就不用再进行剔除了，减少了剔除用时。事实上，层次剔除还可以更进一步的，通过构建不同层级的Meshlet BVH，进行高效地索引需要剔除的层级，能够实现更加高效的剔除策略，和LOD方法相结合，也就是虚幻引擎5中Nanite虚拟几何体的处理方法了。\n4. 结果 场景总览\n渲染管线\n无优化\n仅视锥剔除\n仅背面剔除\n仅遮挡剔除\n使用所有剔除\n演示Demo\n\n可以看到由于使用了帧间连续性的原因，在某些地方仍会有部分闪烁，后续引入TAA等帧间累积方法可以一定程度上解决这个问题，但在帧率上确实有了实质性的提升。\n参考链接 [1] Haar U, Aaltonen S. Gpu-driven rendering pipelines. Ubisoft, Siggraph 2015: Advances in Real-Time Rendering in Games course, 2015\n[2] Gribb G, Hartmann K. Fast extraction of viewing frustum planes from the worldview-projection matrix. Online document, 2001. \n[3] Mara, Michael, and Morgan McGuire. \u0026ldquo;2D polyhedral bounds of a clipped, perspective-projected 3D sphere.\u0026rdquo; JCGT. in submission 5 (2012).\n","description":"IlumEngine的第一次渲染性能优化","id":10,"section":"posts","tags":["Real-time Rendering"],"title":"实时渲染优化技术(1)","uri":"https://chaphlagical.github.io/zh/posts/rendering/optimization1/"},{"content":"Lazy Snapping是一种基于图的图像分割方法[1]，能够将图像分割为前景和背景，通过用户交互挑选前景和背景种子，利用最大流最小分割的方法对图像进行分割。\n1. 基本方法 文献中利用分水岭算法对图像进行预处理，这里我们直接将图像下采样到原分辨率的八分之一进行处理，然后求解以下优化问题：\n$$\nE(X)=\\sum_{i\\in\\mathcal{V}}E_1(x_i)+\\lambda\\sum_{(i,j)\\in\\mathcal\\varepsilon}E_2(x_i, x_j)\n$$\n其中，$E_1(x_i)$为似然能量，编码结点$x_i$的代价，$E_2(x_i,x_j)$为先验能量，代表邻接结点$x_i$和$x_j$的代价。\n似然能量$E_1(x_i)$定义为：\n$$\n\\begin{cases}\n\\begin{matrix}\nE_1(x_i=1)=0\u0026amp;E_1(x_i=0)=\\infty\u0026amp;\\forall i\\in\\mathcal{F}\n\\end{matrix}\\\\\\\\\n\\begin{matrix}\nE_1(x_i=1)=\\infty\u0026amp;E_1(x_i=0)=0\u0026amp;\\forall i\\in\\mathcal{B}\n\\end{matrix}\\\\\\\\\n\\begin{matrix}\nE_1(x_i=1)=\\frac{d_i^\\mathcal{F}}{d_i^\\mathcal{F}+d_i^\\mathcal{B}}\u0026amp;E_1(x_i=0)=\\frac{d_i^\\mathcal{B}}{d_i^\\mathcal{F}+d_i^\\mathcal{B}}\u0026amp;\\forall i\\in\\mathcal{U}\n\\end{matrix}\n\\end{cases}\n$$\n其中，$\\mathcal{F}$表示前景种子集合，$\\mathcal{B}$为背景种子集合，均由用户输入，而$\\mathcal{U}$为补集。$d_i^\\mathcal{F}$和$d_i^\\mathcal{B}$分别表示当前颜色与前景种子平均值和背景种子平均值的距离平方\n先验能量$E_2(x_i,x_j)$定义为：\n$$\nE_2(x_i,x_j)=\\frac{1}{|C(i)-C(j)|^2+\\varepsilon}\n$$\n实验中，取$\\lambda=100$，$\\epsilon=0.01$。\n然后构建无向图，通过最大流最小割方法分离出前景和背景，提取轮廓得到结果\n实验结果    原图像 交互图像 轮廓                     参考文献 [1] Y. Li, J. Sun, C.-K. Tang, and H.-Y. Shum. Lazy snapping. ACM Transactions on Graphics (ToG), 23(3):303–308, 2004.\n","description":"复现Siggraph2004论文《Lazy snapping》","id":11,"section":"posts","tags":["Digital Image Process"],"title":"Lazy Snapping","uri":"https://chaphlagical.github.io/zh/posts/image_process/lazy_snapping/"},{"content":"Seam Carving算法是一种基于内容的图像缩放方法，在保证图像中“重要区域”不发生形变的前提下，对图像进行缩放。\n一种直观的想法便是找出图像中的“不重要区域”，并将其删除。文献[1]中便是采用这种思想，\n通过定义像素的能量函数，通过动态规划方法对某一方向的像素进行能量累积，最后回溯求出能量最低的一条路径，该路径便是我们要删除的“最不重要”路径。\n1. 基本方法 图像的能量简单地由图像梯度描述：\n$$\ne_1(\\pmb I)=\\left|\\frac{\\partial}{\\partial x}\\pmb I\\right|+\\left|\\frac{\\partial}{\\partial y}\\pmb I\\right|\n$$\n论文中也给出另外一种能量的变体实现：\n$$\ne_{HoG}(\\pmb I)=\\frac{\\left|\\frac{\\partial}{\\partial x}\\pmb I\\right|+\\left|\\frac{\\partial}{\\partial y}\\pmb I\\right|}{\\max(HoG(\\pmb I(x,y)))}\n$$\n实现中，采用Sobel算子提取图像梯度作为能量图：\n1 2 3 4 5 6 7 8 9 10 11  void SeamCarving::genEnergyMap(const cv::Mat\u0026amp; img, cv::Mat\u0026amp; energy) { cv::Mat sobel_x, sobel_y, gray_energy; cv::cvtColor(img, gray_energy, cv::COLOR_BGR2GRAY); cv::Sobel(gray_energy, sobel_x, CV_32F, 1, 0, 3); cv::convertScaleAbs(sobel_x, sobel_x); cv::Sobel(gray_energy, sobel_y, CV_32F, 0, 1, 3); cv::convertScaleAbs(sobel_y, sobel_y); cv::addWeighted(sobel_x, 0.5, sobel_y, 0.5, 0, energy); energy.convertTo(energy, CV_32FC1); }   对于$n\\times m$的图像$\\pmb I$，用于删除的接缝由如下定义：\n水平接缝：\n$$\n\\pmb{s^x}=\\{s_i^x\\}_{i=1}^n=\\{(x(i),i)\\}_{i=1}^n,\\ \\\ns.t.\\ \\ \\forall i,\\ \\ |x(i)-x(i-1)|\\leq 1\n$$\n竖直接缝：\n$$\n\\pmb{s^y}=\\{s_i^y\\}_{j=1}^m=\\{(j, y(j))\\}_{j=1}^m,\\ \\\ns.t.\\ \\ \\forall j,\\ \\ |y(j)-y(j-1)|\\leq 1\n$$\n其中，$x:[1,\\cdots,n]\\rightarrow[1,\\cdots,m]$，$y:[1,\\cdots,m]\\rightarrow[1,\\cdots,n]$\n而我们要寻找最低能量路径即求解最小优化问题：\n$$\ns^\\ast=\\min_{\\pmb s}E(\\pmb s)=\\min_{\\pmb s}\\sum_{i=1}^ne(\\pmb I(s_i))\n$$\n利用动态规划的思想可以很方便地求出上述优化问题，利用能量累积矩阵$M$，转移方程：\n$$\nM(i,j)=e(i,j)+\\min(M(i-1,j-1), M(i-1,j), M(i-1,j+1))\n$$\n从边缘出发按转移方程填充能量累积矩阵，最后寻找能量最低的终点$M(n,x)$（竖直搜索）或$M(x,m)$（水平搜索），回溯即可得到完整的最优路径。\n1.1. 图像缩小任务 对于单方向缩小任务，只需重复上述接缝搜索流程，每次删除一条接缝即可。\n对于多方向缩小任务，文献中也将横向竖向接缝的选择顺序其视为一个优化问题，假设现有$m\\times n$的图像$\\pmb I$欲缩小至$m'\\times n'$，其中$m\u0026gt;m',n\u0026gt;n'$，接缝顺序的选择等价于优化以下能量函数：\n$$\n\\min_{\\pmb{s^x},\\pmb{s^y},\\alpha}\\sum_{i=1}^kE(\\alpha_i\\pmb {s_i^x}+(1-\\alpha_i)\\pmb{s_i^y})\n$$\n其中，$r=m-m'$，$c=n-n'$， $\\alpha_i\\in{0,1}$描述了接缝选择的方向，因此有$\\sum_{i=1}^k\\alpha_i=r$，$\\sum_{i=1}^k(1-\\alpha_i)=c$成立。该问题同样可以利用动态规划的想法进行求解，取能量累积矩阵$\\pmb T$，满足$\\pmb T(0,0)=0$，转移方程：\n$$\n\\pmb T(r,c)=\\min(\\pmb T(r-1,c),E(\\pmb s^x(\\pmb {I_{n-r-1\\times m-c}})),\\pmb T(r,c-1),E(\\pmb s^y(\\pmb {I_{n-r\\times m-c-1}})))\n$$\n$\\pmb {I_{n-r-1\\times m-c}}$表示大小为$n-r-1\\times m-c$的图像（中间量），$E(\\pmb{s^x}(\\pmb I))$和$E(\\pmb{s^y}(\\pmb I))$为相应的方向接缝删除后的能量。\n但上述方法实测速度很慢，因此在实现中选择简单的贪婪策略选择带来当前最低能量的方法。\n1.2. 图像拉伸任务 对于图像拉伸任务，同样可以采用缩小任务相似的处理方法，只是将最优接缝的删除修改为最优接缝邻域的插值，但和缩小任务不同的是，每次对单条最优接缝进行插值，容易导致后续的最优接缝\n搜索会集中在同一区域，因此在图像拉伸任务中，建议一次性选择多条低能量接缝进行插值。\n2. 实验结果 2.1. 图像缩小    原图像 图像能量 结果图像                     2.2. 图像拉伸    原图像 图像能量 最优接缝 结果图像                        3. 总结 从上图中可以看出 Seam Carving 的一些局限性：\n 进行图像拉伸任务时容易造成图像区块重复，可以考虑手动排除部分区域进行优化 在梯度变化不明显的“重要区域”容易造成误处理，比如：《蒙娜丽莎》大片的头发。可以考虑手动划分“重要区域”进行处理  参考文献 [1] S. Avidan and A. Shamir. Seam carving for content-aware image resizing. In ACM SIGGRAPH 2007 papers, pages 10–es. 2007\n","description":"复现Siggraph2007论文《Seam Carving for Content-Aware Image Resizing》","id":12,"section":"posts","tags":["Digital Image Process"],"title":"Seam Carving","uri":"https://chaphlagical.github.io/zh/posts/image_process/seam_carving/"},{"content":"1. 问题描述 给定以下两幅图：\n现我们需要将第一幅图中的女孩搬到第二幅图的海水中，为使得复制粘贴更加逼真自然，我们需要设计算法来满足我们两幅图像融合的需要\n2. 算法描述 Poisson Image Editing算法[1]的基本思想是在尽可能保持原图像内部梯度的前提下，让粘贴后图像的边界值与新的背景图相同，以实现无缝粘贴的效果。从数学上讲，对于原图像$f(x,y)$，新背景$f^(x,y)$和嵌入新背景后的新图像$v(x,y)$，等价于解最优化问题：\n$$\n\\min\\limits_f \\iint \\Omega |\\nabla f-\\boldsymbol v |^2 \\ \\ \\mathrm{with}\\ f|{\\partial \\Omega}=f^|_{\\partial \\Omega}\n$$\n利用变分法，令$F=|\\nabla f-\\boldsymbol v |^2=(\\nabla f_x-\\boldsymbol v_x)^2+(\\nabla f_y-\\boldsymbol v_y)^2$\n代入欧拉-拉格朗日方程：\n$$\nF_f-\\frac{\\mathrm d}{\\mathrm d x}F_{f_x}-\\frac{\\mathrm d}{\\mathrm d y}F_{f_y}=0\n$$\n由于$F$是关于$\\nabla f$的函数，因此$F_f=0$\n所以有：\n$$\n\\begin{align}\n\u0026amp;\\frac{\\partial F}{\\partial f}=\\frac{\\mathrm d}{\\mathrm dx}\\left[\\frac{\\partial F}{\\partial(\\nabla f_x-\\pmb v_x)^2}\\right]+\\frac{\\mathrm d}{\\mathrm dy}\\left[\\frac{\\partial F}{\\partial(\\nabla f_y-\\pmb v_y)^2}\\right]\\\\\\\\\n\u0026amp;\\Rightarrow 0=\\frac{\\mathrm d}{\\mathrm dx}[2(\\nabla f_x-\\pmb v_x)]+\n\\frac{\\mathrm d}{\\mathrm dy}[2(\\nabla f_y-\\pmb v_y)]\\\\\\\\\n\u0026amp;\\Rightarrow 0=\\left(\\frac{\\partial ^2f}{\\partial x^2}-\\frac{\\partial \\pmb v}{\\partial x}\\right)+\\left(\\frac{\\partial ^2f}{\\partial y^2}-\\frac{\\partial \\pmb v}{\\partial y}\\right)\\\\\\\\\n\u0026amp;\\Rightarrow \\Delta f=\\mathrm{div}\\pmb v\n\\end{align}\n$$\n可转化为具有Dirichlet边界条件的Poisson方程：\n$$\n\\Delta f= \\mathrm{div} \\boldsymbol v\\ \\ \\mathrm{over}\\ \\Omega\\ \\ \\mathrm{with} \\ \\ f|_{\\partial \\Omega}=f^\\ast|_{\\partial\\Omega}\n$$\n以第一幅图和第二幅图为例，将图1中需要复制的区域设为$S$，定义$N_p$为$S$中的每一个像素$p$四个方向连接邻域，令$\u0026lt;p,q\u0026gt;$为满足$q\\in N_p$的像素对。边界$\\Omega$定义为$\\partial \\Omega ={p\\in S\\setminus \\Omega: N_p \\cap \\Omega \\neq \\emptyset }$，设$f_p$为$p$处的像素值$f$，目标即求解像素值集$f|_\\Omega ={f_p,p\\in \\Omega}$\n利用Poisson Image Editing算法的基本原理，上述问题转化为求解最优化问题：\n$$\n\\min\\limits_{f|_\\Omega}\\sum\\limits_{\u0026lt;p,q\u0026gt;\\cap \\Omega\\neq \\emptyset}(f_p-f_q-v_{pq})^2,\\mathrm{with}\\ f_p=f_p^*,\\forall\\ p\\in \\partial\\Omega\r$$\n化为求解线性方程组：\n$$\n\\forall\\ p\\in \\Omega,\\ |N_p|f_p-\\sum\\limits_{q\\in N_p\\cap \\Omega} f_q=\\sum\\limits_{q\\in N_p\\cap \\partial \\Omega}f_p^*+\\sum\\limits_{q\\in N_p}v_{pq}\n$$\n对于梯度场$\\boldsymbol{v}(\\boldsymbol{x})$的选择，文献[1]给出两种方法，一种是完全使用前景图像的内部梯度，即：\n$$\n\\forall\\ \u0026lt;p,q\u0026gt;,v_{pq}=g_p-g_q\n$$\n另一种是使用混合梯度：\n$$\n\\forall\\ \\boldsymbol{x}\\in \\Omega,\\ \\boldsymbol{v}(\\boldsymbol{x})=\\begin{cases}\n\\nabla f^*(\\boldsymbol{x})\u0026amp;\\mathrm{if}\\ |\\nabla f^*(\\boldsymbol{x})\u0026gt;|\\nabla g(\\boldsymbol{x})|,\\\\\\\\\n\\nabla g(\\boldsymbol{x})\u0026amp;\\mathrm{otherwise}\n\\end{cases} $$\n**扫描线算法**\n为实现多边形和自由绘制闭合图形区域的Poisson Image Editing算法，需通过扫描线算法获取多边形内部掩膜。这里从网上资料了解到一种有序边表法，其基本思想是定义边表ET和活动边表AET，ET记录当前扫描线与边的交点坐标、从当前扫描线到下一条扫描线间x的增量、该边所交的最高扫描线，AET记录只与当前扫描线相交的边的链表，通过迭代得到当前扫描线与待求多边形各边的交点，再利用奇偶检测法判断该点是否在多边形内部进行填充。\n3. 实验结果 3.1. 标准图像测试 原图像：\n新背景图像：\n   边界形式 图1选择区域 图2选择区域 结果图像     矩形边界      多边形边界      自由绘制边界       3.2. Poisson vs. Mix Poisson 背景图像：\n前景图像：\n混合结果：\n如图，左上为直接复制粘贴，保留前景全部颜色梯度信息；左下为普通Poisson编辑，保留前景全部梯度信息，前景像素颜色与背景作融合；右上为应用混合梯度的Poisson编辑，前景梯度部分保留，效果上比普通Poisson编辑更加“透明”，适合用在水印等场景。\n3.3. 其他应用 3.3.1. 遮盖不必要的信息（如去皱纹） 原图像：\n处理效果：\n3.3.2. 恐怖片特效 原图：\n掩盖镜子中人物：\n使用电影《修女》中的角色：\n处理效果：\n3.3.3. 生成表情包 原图：\n处理效果：\n参考文献 [1] Patrick Pérez, Michel Gangnet, Andrew Blake. Poisson image editing. Siggraph 2003.\n","description":"复现Siggraph2003论文《Poisson Image Editing》","id":13,"section":"posts","tags":["Digital Image Process"],"title":"Poisson Image Editing","uri":"https://chaphlagical.github.io/zh/posts/image_process/possion/"},{"content":"1. 算法原理 1.1. 基本原理  输入：$n$对控制点对$(\\pmb p_i,\\pmb q_i)$，$i=1,2,\\cdots,n$，其中$\\pmb p_i\\in\\mathbb R^2$为控制起始点，$\\pmb q_i\\in\\mathbb{R}^2$为控制目标点 目标：找到一个映射$f:\\mathbb R^2\\rightarrow \\mathbb{R}^2$，满足$f(\\pmb p_i)=\\pmb q_i$，$i=1,2,\\cdots,n$  1.2. Inverse distance-weighted interpolation methods(IDW)[1] IDW 算法基本原理是根据给定的控制点对和控制点对的位移矢量，计算控制点对周围像素的反距离加权权重影响，实现图像每一个像素点的位移。\n选择$n$对控制点对$(\\pmb p_i,\\pmb q_i)$，$i=1,2,\\cdots,n$，目标映射$f:\\mathbb R^2\\rightarrow \\mathbb{R}^2$可表示成\n以下形式：\n$$\nf(\\pmb p)=\\sum_{i=1}^n\\omega_i(\\pmb p)f_i(\\pmb p)\n$$\n其中，权重$\\omega_i(\\pmb p)$满足：\n$$\nw_i(\\pmb p)=\\frac{\\sigma_i(\\pmb p)}{\\sum_{j=1}^n\\sigma_j(\\pmb p)}\n$$\n$\\sigma_i(\\pmb p)$反映第$i$对控制点对像素$\\pmb p$得反距离加权权重影响程度，可以直接取：\n$$\n\\sigma_i(\\pmb p)=\\frac{1}{|\\pmb p-\\pmb p_i|^\\mu}\n$$\n其中$\\mu\u0026gt;1$，也可以取locally bounded weight：\n$$\n\\sigma_i(\\pmb p)=\\left[\\frac{R_i-d(\\pmb p,\\pmb p_i)}{R_id(\\pmb p,\\pmb p_i)}\\right]^\\mu\n$$\n$f_i$为线性函数，满足：\n$$\nf_i(\\pmb p)=\\pmb q_i+\\pmb T_i(\\pmb p-\\pmb p_i)\n$$\n其中$\\pmb T_i$为二阶矩阵：\n$$\n\\pmb T_i=\\begin{bmatrix}\nt_{11}^{(i)}\u0026amp;t_{12}^{(i)}\\\\\nt_{21}^{(i)}\u0026amp;t_{22}^{(i)}\n\\end{bmatrix}\n$$\n矩阵$\\pmb T$得确定，可以通过求解如下最优化问题：\n$$\n\\arg\\min_{\\pmb T_i} E(\\pmb T_i)=\\sum_{j=1,j\\neq i}^n\\sigma_i(\\pmb p_j)|\\pmb q_j-f_i(\\pmb p_j)|^2\n$$\n上式对$\\pmb T_i$求导，令方程为0得：\n$$\n\\pmb T_i\\sum_{j=1,j\\neq i}\\sigma_i(\\pmb p_j)\\pmb p\\pmb p^T=\\sum_{j=1,j\\neq i}\\sigma_i(\\pmb p_j)\\pmb q\\pmb p^T\n$$\n其中$\\pmb p=\\pmb p_j-\\pmb p_i$，$\\pmb q=\\pmb q_j-\\pmb q_i$\n又$\\sigma_i(\\pmb p_j)\\pmb p\\pmb p^T$非奇异，因此可以直接解出$\\pmb T_i$的值：\n$$\n\\pmb T_i=\\left(\\sum_{j=1,j\\neq i}\\sigma_i(\\pmb p_j)\\pmb q\\pmb p^T\\right)\\left(\\sum_{j=1,j\\neq i}\\sigma_i(\\pmb p_j)\\pmb p\\pmb p^T\\right)^{-1}\n$$\n求出$\\pmb T_i(i=1,\\cdots,n)$后，映射$f$也就相应确定\n1.3. Radial basis functions interpolation method(RBF)[2] 选择$n$对控制点对$(\\pmb p_i,\\pmb q_i)$，$i=1,2,\\cdots,n$，目标映射$f:\\mathbb R^2\\rightarrow \\mathbb{R}^2$可表示为以下形式：\n$$\nf(\\pmb p)=\\sum_{i=1}^n\\alpha_ig_i(|\\pmb p-\\pmb p_i|)+\\pmb{Ap}+\\pmb B\n$$\n其中，$g_i$为径向基函数，通常可以取Hardy multiquadrics：$g(t)=(t^2+c^2)^{\\pm \\frac{1}{2}}$或高斯函数$g_\\sigma(t)=e^{-t^2/\\sigma^2}$，\n为了计算方便，这里取Hardy multiquadrics：\n$$\n\\begin{aligned}\ng_i(d)\u0026amp;=(d+r_i)^{\\pm\\frac{1}{2}}\\\nr_i\u0026amp;=\\min_{j\\neq i}d(\\pmb p_i,\\pmb p_j)\n\\end{aligned}\n$$\n对于线性部分分量$\\pmb {Ap}+\\pmb B$，本例简单地取$\\pmb A=\\pmb I$和$\\pmb B=\\pmb 0$\n2. 实验结果 2.1. 标准图像测试 如下图所示，固定四角，蓝色为控制起始点，绿色为控制终止。\n2.2. IDW算法    $\\mu$取值 修复前 修复后     $\\mu=-1$     $\\mu=-2$      2.3. RBF算法    $\\mu$取值 修复前 修复后     $\\mu=-0.5$     $\\mu=0.5$      2.4. 相关应用 2.4.1. 柴犬表情包 原图像：\n开心：\nEmmm……：\n2.4.2. 藏狐的笑容 原图像：\n处理后：\n参考文献 [1] D. Ruprecht and H. Muller. Image warping with scattered data interpolation. IEEE Computer Graphics and Applications, 15(2):37–43, 1995. 10\n[2] N. Arad and D. Reisfeld. Image warping using few anchor points and radial functions. In Computer graphics forum, volume 14, pages 35–46. Wiley Online Library, 1995.\n","description":"基于IDW与RBF方法的图像扭曲算法实现","id":14,"section":"posts","tags":["Digital Image Process"],"title":"Image Warping","uri":"https://chaphlagical.github.io/zh/posts/image_process/image_warping/"},{"content":"1. 问题描述 给定一张原图像：\n和一张参考图像：\n我们希望通过设计一个颜色转换算法，使得源图像具有目标图像的颜色风格，如下图：\n2. 算法描述 衡量一幅图像的颜色分布最基础的统计特征就是均值和标准差，文献[1]中便通过这两个特征对图像进行简单的变换并取得不错的效果。\n首先，需要将图像的颜色空间从$RGB$空间变换到$l\\alpha\\beta$空间：\n  $RGB$空间$\\rightarrow$ $XYZ$空间\n$$\n\\begin{pmatrix}\nX\\\\Y\\\\Z\n\\end{pmatrix}=\n\\begin{pmatrix}\n0.5141\u0026amp;0.3239\u0026amp;0.1604\\\\\n0.2651\u0026amp;0.6702\u0026amp;0.0641\\\\\n0.0241\u0026amp;0.1228\u0026amp;0.8444\n\\end{pmatrix}\n\\begin{pmatrix}\nR\\\\G\\\\B\n\\end{pmatrix}\n$$\n  $XYZ$空间$\\rightarrow$ $LMS$空间\n$$\n\\begin{pmatrix}\nL\\\\M\\\\S\n\\end{pmatrix}=\n\\begin{pmatrix}\n0.3897\u0026amp;0.6890\u0026amp;-0.0787\\\\\n-0.2298\u0026amp;1.1834\u0026amp;0.0464\\\\\n0.0000\u0026amp;0.0000\u0026amp;1.0000\n\\end{pmatrix}\n\\begin{pmatrix}\nX\\\\Y\\\\Z\n\\end{pmatrix}\n$$\n  变换到对数空间\n$$\n\\begin{aligned}\n\\pmb L\u0026amp;=\\lg L\\\\\n\\pmb M\u0026amp;=\\lg M\\\\\n\\pmb S\u0026amp;=\\lg S\n\\end{aligned}\n$$\n  $\\pmb{LMS}$空间$\\rightarrow$ $l\\alpha\\beta$空间\n$$\n\\begin{pmatrix}\nl\\\\\\alpha\\\\\\beta\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\frac{1}{\\sqrt{3}}\u0026amp;0\u0026amp;0\\\\\n0\u0026amp;\\frac{1}{\\sqrt{6}}\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;\\frac{1}{\\sqrt{2}}\n\\end{pmatrix}\n\\begin{pmatrix}\n1\u0026amp;1\u0026amp;1\\\\\n1\u0026amp;1\u0026amp;-2\\\\\n1\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\pmb L\\\\\\pmb M\\\\\\pmb S\n\\end{pmatrix}\n$$\n  同理，将图像的颜色空间从 lαβ 空间变换到 RGB 空间只需将相应的变换矩阵依次求逆即可。\n设变换到$l\\alpha\\beta$颜色空间的源图像的均值和标准差分别为$\\mu_s$、$\\sigma_s$，目标图像的均值和标准差分别为$\\mu_t$、$\\sigma_t$，只需通过如下简单处理，即可将源图像的颜色分布变换到接近与目标图像\n$$\n\\begin{aligned}\nl'\u0026amp;=\\frac{\\sigma_t^l}{\\sigma_s^l}(l-\\mu^l_s)+\\mu^l_t\\\\\n\\alpha'\u0026amp;=\\frac{\\sigma_t^\\alpha}{\\sigma_s^\\alpha}(\\alpha-mu^\\alpha_s)+\\mu^\\alpha_t\\\\\n\\beta'\u0026amp;=\\frac{\\sigma_t^\\beta}{\\sigma_s^\\beta}(\\beta-\\mu^\\beta_s)+\\mu^\\beta_t\\\n\\end{aligned}\n$$\n并将图像$(l',\\alpha',\\beta')$变换回$RGB$空间即可得到处理后的结果。\n3. 实验结果    原图像 参考图像 结果图像                               参考文献 [1] E. Reinhard, M. Adhikhmin, B. Gooch, and P. Shirley. Color transfer between images. IEEE Computer graphics and applications, 21(5):34–41, 2001.10\n","description":"复现论文《Color Transfer between Images》","id":15,"section":"posts","tags":["Digital Image Process"],"title":"Color Transfer","uri":"https://chaphlagical.github.io/zh/posts/image_process/color_transfer/"},{"content":"1. 问题描述 给定一张原图像：\n我们希望通过设计一个灰度图着色算法，使得下述灰度目标图像能够利用彩色原图像的颜色信息进行合理的上色：\n以得到类似下图的效果：\n2. 算法描述 实验参考了论文[1]，并使用全局匹配的方法进行求解。我们在图像的$l\\alpha\\beta$颜色空间上进行求解，这是由于$l\\alpha\\beta$颜色空间的$l$即代表着亮度，通过查找灰度源图像上的像素与彩色目标图像的$l$分量最佳匹配像素，再将目标图像对应匹配像素的$\\alpha$和$\\beta$分量赋予源图像即可\n进行灰度图像上色。算法流程如下：\n  将源图像$img_{src}$变换到$l\\alpha\\beta$颜色空间得到$img_{src}^{(l\\alpha\\beta)}$，同时将源图像$img_{src}$转换为灰度图$img_{src}^{(grey)}$\n  利用如下均值标准差变换，将$img_{src}^{(l\\alpha\\beta)}$的$l$通道和$img_{src}^{(grey)}$映射到具有灰度目标图像$img_{tar}$的像素值分布，得到$luminance_{src}$和$luminance_{src}^{grey}$\n$$\n\\begin{aligned}\nl'\u0026amp;=\\frac{\\sigma_t^l}{\\sigma_s^l}(l-\\mu^l_s)+\\mu^l_t\\\\\n\\alpha'\u0026amp;=\\frac{\\sigma_t^\\alpha}{\\sigma_s^\\alpha}(\\alpha-\\mu^\\alpha_s)+\\mu^\\alpha_t\\\\\n\\beta'\u0026amp;=\\frac{\\sigma_t^\\beta}{\\sigma_s^\\beta}(\\beta-\\mu^\\beta_s)+\\mu^\\beta_t\\\\\n\\end{aligned}\n$$\n  近邻域标准差计算。利用一个$n\\times n$（本实验中取$n=5)$）滑动窗口遍历图像（类似于卷积操作，边界用0填充），对窗口内的所有像素值计算它们的标准差并赋值到一幅标准差图像上。对$luminance_{src}^{grey}$和$img_{tar}$进行该计算，得到$stddev_{src}^{grey}$和$stddev_{tar}$\n  最佳匹配查找。遍历$img_{tar}$，已知$img_{tar}$上的某一像素值$p_{tar}$和其标准差$stddev_{tar}$对应的值$\\sigma_{tar}$，在源图像上寻找最佳匹配的像素点，这里简单地采用加权的$\\mathcal{L}_2$范数平方去算：\n$$\n\\arg\\min_{x,y} \\Big(w_1\\ast |luminance_{src}(x,y)-p_{tar}|^2+w_2\\ast|stddev_{src}^{grey}(x,y)-\\sigma_{tar}|^2\\Big)\n$$\n其中$w_1$和$w_2$分别表示亮度值和标准差的对匹配结果的贡献，这里简单地取$w_1=w_2=0.5$\n  灰度图上色。将查找到的最佳匹配像素$(\\tilde x. \\tilde y)$在$img_{src}^{(l\\alpha\\beta)}$所在像素值的$\\alpha$和$\\beta$分量赋值给源图像作为其$\\alpha$和$\\beta$通道的值，而原来的灰度值则作为$l$分量继续使用，并将源图像重新变换回$RGB$颜色空间得到最终的结果\n  3. 实验结果    原图像 参考图像 结果图像                               参考文献 [1] Welsh, M. Ashikhmin, and K. Mueller. Transferring color to greyscale im-ages. In Proceedings of the 29th annual conference on Computer graphics and interactive techniques, pages 277–280, 2002.11\n","description":"复现Siggraph2002论文《Transferring Color To Greyscale Image》","id":16,"section":"posts","tags":["Digital Image Process"],"title":"Colorization","uri":"https://chaphlagical.github.io/zh/posts/image_process/colorization/"},{"content":"事实上，从IlumEngine能够显示东西之初，我就已经搭建了一套基于金属工作流的延迟PBR渲染管线，但之前对于PBR材质模型的理解还不够深入，很多情况下都是以抄公式为主，这次借实现Kulla-Conty对微表面模型能量不守恒的修正，从理论上来深入理解实时PBR着色方法。\n1. 渲染着色的物理原理 从物理角度上看，渲染着色即光与物体的材质表面、材质介质的相互作用后，射入摄像机的结果。\n1.1. 光的物理本质 光是具有一定波长的电磁波，限定自由电荷密度$\\rho$和自由电流密度$\\pmb J$，根据欧姆定律有电流密度正比于电场：\n$$\n\\pmb J=\\sigma \\pmb E\n$$\n对于光在线性介质中的传播，满足麦克斯韦方程组：\n$$\n\\begin{aligned}\n\\nabla \\cdot\\pmb E \u0026amp;= \\frac{1}{\\varepsilon}\\pmb \\rho\\\\\\\\\n\\nabla\\cdot\\pmb B\u0026amp;=0\\\\\\\\\n\\nabla\\times \\pmb E\u0026amp;=-\\frac{\\partial \\pmb B}{\\partial t}\\\\\\\\\n\\nabla\\times \\pmb B\u0026amp;=\\mu\\sigma\\pmb E+ \\mu_0\\varepsilon_0\\frac{\\partial \\pmb E}{\\partial t}\n\\end{aligned}\n$$\n由自由电荷的连续性方程：\n$$\n\\nabla\\cdot\\pmb J=-\\frac{\\partial \\rho}{\\partial t}\n$$\n有：\n$$\n\\frac{\\partial \\rho}{\\partial t}=-\\sigma(\\nabla\\cdot\\pmb E)=-\\frac{\\sigma}{\\varepsilon}\\rho\n$$\n可以解出：\n$$\n\\rho(t)=\\rho(0)e^{-(\\sigma/\\varepsilon)t}\n$$\n看到自由电荷密度$\\rho$以特征时间$\\tau\\equiv \\varepsilon/\\sigma$耗散，\n 对于理想导体，$\\sigma =\\infty$，$\\tau=0$ 对于良导体，$\\tau$比电磁波的角周期小得多：$\\tau\\ll1/\\omega$ 对于不良导体，则$\\tau$比电磁波的角周期大得多：$\\tau\\gg 1/\\omega$  对电场与磁场的旋度再取其旋度，有：\n$$\n\\begin{align}\n\\nabla\\times(\\nabla\\times \\pmb E)\u0026amp;=\\nabla(\\nabla\\cdot\\pmb E)-\\nabla^2\\pmb E=\\nabla\\times(-\\frac{\\partial \\pmb B}{\\partial t})\\\\\\\\\n\u0026amp;=-\\frac{\\partial}{\\partial t}(\\nabla\\times\\pmb B)=-\\mu\\sigma\\frac{\\partial \\pmb E}{\\partial t}-\\mu_0\\varepsilon_0\\frac{\\partial^2\\pmb E}{\\partial t^2}\\\\\\\\\n\\nabla\\times(\\nabla\\times \\pmb B)\u0026amp;=\\nabla(\\nabla\\cdot\\pmb B)-\\nabla^2\\pmb B=\\nabla\\times(\\mu\\sigma\\pmb E+\\mu_0\\varepsilon_0\\frac{\\partial \\pmb E}{\\partial t})\\\\\\\\\n\u0026amp;=\\mu\\sigma(\\nabla\\times\\pmb E) +\\mu_0\\varepsilon_0\\frac{\\partial}{\\partial t}(\\nabla\\times\\pmb E)=-\\mu\\sigma\\frac{\\partial B}{\\partial t}-\\mu_0\\varepsilon_0\\frac{\\partial^2\\pmb B}{\\partial t^2}\n\\end{align}\n$$\n忽略电磁波在线性介质中的瞬态效应，即自由电荷消失，$\\rho=0$，则有：\n$$\n\\begin{align}\n\u0026amp;\\begin{matrix}\n\\nabla \\cdot \\pmb E=0\u0026amp;\\nabla\\cdot \\pmb B=0\n\\end{matrix}\\\\\\\\\n\\Rightarrow\\ \\ \\ \u0026amp;\n\\begin{matrix}\n\\nabla^2\\pmb E=\\mu\\sigma\\dfrac{\\partial \\pmb E}{\\partial t}+\\mu_0\\varepsilon_0\\dfrac{\\partial^2\\pmb E}{\\partial t^2}\n\\\\\\\n\\nabla^2\\pmb B=\\mu\\sigma\\dfrac{\\partial B}{\\partial t}+\\mu_0\\varepsilon_0\\dfrac{\\partial^2\\pmb B}{\\partial t^2}\n\\end{matrix}\n\\end{align}\n$$\n可以得到平面波解：\n$$\n\\begin{aligned}\n\\tilde {\\pmb E}(z,t)=\\tilde{\\pmb E}_0e^{i(\\tilde k z-\\omega t)}\\\\\\\\\n\\tilde {\\pmb B}(z,t)=\\tilde{\\pmb B}_0e^{i(\\tilde k z-\\omega t)}\n\\end{aligned}\n$$\n其中，波数$\\tilde k$为复数：\n$$\n\\tilde k^2=\\mu\\varepsilon\\omega^2+i\\mu\\sigma\\omega\n$$\n取平方根得：\n$$\n\\tilde k=k+i\\kappa\n$$\n其中，\n$$\n\\begin{align}\nk\u0026amp;\\equiv \\omega\\sqrt{\\frac{\\mu\\varepsilon}{2}}\\left[\\sqrt{1+\\left(\\frac{\\sigma}{\\varepsilon\\omega}\\right)^2}+1 \\right]^{1/2}\\\\\\\\\n\\kappa\u0026amp;\\equiv \\omega\\sqrt{\\frac{\\mu\\varepsilon}{2}}\\left[\\sqrt{1+\\left(\\frac{\\sigma}{\\varepsilon\\omega}\\right)^2}-1 \\right]^{1/2}\n\\end{align}\n$$\n提取虚部：\n$$\n\\begin{aligned}\n\\tilde {\\pmb E}(z,t)=\\tilde{\\pmb E}_0e^{-\\kappa z} e^{i(k z-\\omega t)}\\\\\\\\\n\\tilde {\\pmb B}(z,t)=\\tilde{\\pmb E}_0e^{-\\kappa z} e^{i(k z-\\omega t)}\n\\end{aligned}\n$$\n可以看到：\n $\\tilde k$的虚部导致波的衰减，振幅随着$z$的增大而减小，度量了波进入导体的深度，也度量了导体阻尼对波能量的吸收（吸收系数$\\alpha\\equiv 2\\kappa$） $\\tilde k$的实部定义了波的属性，如波长$\\lambda = \\frac{2\\pi}{k}$，波速$v=\\frac{\\omega}{k}$，折射率$n=\\frac{ck}{\\omega}$  综合起来，材质通过影响光的$\\tilde k$，对光的传播效应造成影响，从而带来不同的光照效果。\n在成像理论中，光的吸收对视觉效果有直接影响，将降低光的强度，对特定可见波长的吸收将改变光的颜色。\n在渲染中，通常将材质与光的相互作用归结为散射和吸收两类：\n 散射：决定介质的浑浊程度（下图右） 吸收：决定材质的外观颜色（下图左）  每种介质外观均为散射和吸收两种现象的综合结果：\n1.2. 渲染中的光学模型 从电磁波角度出发可以很方便我们理解光、物质和成像之间的相互关系，但在渲染领域尤其是实时渲染领域，我们常常对问题进行简化，现在，我们只考虑物体的表面着色以及几何光学模型。\n1.2.1. 光与物体表面的交互 当一种介质进入到另一种介质，光线将发生反射、折射及其各种衍生现象：\n 镜面反射：光线在两种介质交界处发生直接反射，满足反射定律 折射：从表面进入介质的光由于介质折射率的变化，传播方向发生改变，出现折射现象，介质中的光将发生吸收和散射 吸收：由前推导，当介质中的吸收系数$\\alpha\u0026gt;0$时，在光传播过程中部分能量将会被介质所吸收 散射：光的传播方向由于折射率的剧烈变化发生改变，分裂为多个方向，但光的总能量保持不变  次表面散射：观察像素小于散射距离  透射：入射光进入介质后又穿过该介质出射   漫反射：观察像素大于散射距离    1.2.2. 不同物质与光的交互 不同物质对光的反射、折射效应有所不同，根据光学特性大致分为金属与非金属两大类：\n 金属：金属的外观取决于材质表面的镜面反射，且入射金属的光不存在散射，会被自由粒子完全吸收 非金属：非金属又称电介质，非金属外观取决于吸收和散射特性：  均匀介质：主要为透明介质，无折射率变化，光总以直线传播，不存在散射，但存在吸收 非均匀介质：通常可建模为具有嵌入散射粒子的均匀介质，具有折射率的变化  浑浊介质：具有弱散射 半透明介质：具有强散射 不透明介质：与半透明介质类似，具有强散射      2. 光线传输基础 2.1. 反射方程 所有的渲染方法其实就是在干一件事，求解渲染方程：\n$$\nL_o(\\pmb p,\\pmb \\omega_o)=L_e(\\pmb p,\\pmb \\omega_o)+\\int_\\Omega f_r(\\pmb p,\\pmb \\omega_i\\rightarrow\\pmb \\omega_o)L_i(\\pmb p,\\pmb \\omega_i)\\cdot(\\pmb \\omega_i\\cdot\\pmb n)\\cdot\\mathrm d\\pmb \\omega_i\n$$\n这里我们不考虑物体的自发光，因此$L_e$项恒为0，渲染方程退化为反射方程：\n$$\nL_o(\\pmb p,\\pmb \\omega_o)=\\int_\\Omega f_r(\\pmb p,\\pmb \\omega_i\\rightarrow\\pmb \\omega_o)L_i(\\pmb p,\\pmb \\omega_i)\\cdot(\\pmb \\omega_i\\cdot\\pmb n)\\cdot\\mathrm d\\pmb \\omega_i\n$$\n其中$f_r(\\pmb p,\\pmb \\omega_i\\rightarrow\\pmb \\omega_o)$定义了入射光与出射光的反射比例，称为BxDF，通常为双向反射分布函数BRDF，在离线渲染中我们还常用到BSDF(=BTDF+BRDF)等：\n2.2. BRDF 2.2.1. 辐射度量学的基本概念 BRDF是定义在辐射度量学上的，简单介绍相关概念：\n辐射能\n光的能量可以由光子动能定义：\n$$\nQ=hv\n$$\n其中$h$为普朗克常量，$v$为光子振动频率，由光的波动性，有：\n$$\nc=\\lambda v\n$$\n因此光的能量也可表示为：\n$$\nQ=\\frac{hc}{\\lambda}\n$$\n其中$\\lambda$为光的波长，$c$为光速，能量的量纲为[$J$]，即Joule\n辐射通量\n辐射通量是单位时间内发射、接收或传输的能量，定义为：\n$$\n\\Phi=\\frac{\\mathrm dQ}{\\mathrm dt}\n$$\n功率的量纲为[$lm$]即Lumen，\n辐射强度Radiant Intensity\n定义为单位立体角的光通量：\n$$\nI=\\frac{\\mathrm d\\Phi}{\\mathrm d\\Omega}\n$$\n辐射强度量纲为$[cd]$即candela\n辐照度Irradiance\n辐照度定义为单位面积的辐射通量：\n$$\nE=\\frac{\\mathrm d\\Phi}{\\mathrm d A}\n$$\n辐照度量纲为$[lx]$即lux\n辐射通量为$\\Phi$的点光源在距离$r$处的球面上的辐照度为：\n$$\nE_e=\\frac{\\Phi}{4\\pi r^2}\n$$\n辐亮度Radiance\n辐亮度定义为单位面积和单位立体角的辐射通量\n$$\nL=\\frac{\\mathrm d^2\\Phi}{\\mathrm d\\Omega\\mathrm dA^\\perp}=\\frac{\\mathrm d^2\\Phi}{\\mathrm d\\Omega\\mathrm dA\\cos\\theta}\n$$\n辐亮度的量纲为$[cd/m^2]$或nits\n辐亮度是成像理论中最经常使用的物理量，因为它最符合人和摄像机成像的辐射度量。\n2.2.2. 双向反射分布函数 对于入射光$L_i(\\pmb p,\\pmb \\omega_i)$，计算它在半球上的辐照度$E$：\n$$\nE(\\pmb p)=\\int_\\Omega L_i(\\pmb p,\\pmb \\omega_i)\\cos\\theta_i\\mathrm d\\pmb \\omega_i\n$$\n即：\n$$\n\\mathrm dE(\\pmb p,\\pmb \\omega_i)=L_i(\\pmb p,\\pmb \\omega_i)\\cos\\theta_i\\mathrm d\\pmb \\omega_i\n$$\n而任意方向上，出射光的辐亮度微分应与入射光辐照度成正比，即：\n$$\n\\mathrm dL_o(\\pmb p,\\pmb \\omega_o)\\propto\\mathrm d E(\\pmb p,\\pmb \\omega_i)\n$$\n该比例定义为关于$\\pmb\\omega_i$和$\\pmb \\omega_o$的双向反射分布函数即BRDF：\n$$\nf_r(\\pmb p, \\pmb \\omega_o,\\pmb \\omega_i)=\\frac{\\mathrm dL_o(\\pmb p,\\pmb \\omega_o)}{\\mathrm d E(\\pmb p,\\pmb \\omega_i)}=\\frac{\\mathrm dL_o(\\pmb p,\\pmb \\omega_o)}{L_i(\\pmb p,\\pmb \\omega_i)\\cos\\theta_i\\mathrm d\\pmb \\omega_i}\n$$\n因此在半球上积分有：\n$$\nL_o(\\pmb p,\\pmb \\omega_o,\\pmb \\omega_i)=\\int_\\Omega f_r(\\pmb p, \\pmb \\omega_o,\\pmb \\omega_i)L_i(\\pmb p,\\pmb \\omega_i)\\cos\\theta_i\\mathrm d\\pmb \\omega_i\n$$\nBRDF的性质：\n 交换律：$f_r(\\pmb p,\\pmb \\omega_o,\\pmb \\omega_i)=f_r(\\pmb p,\\pmb \\omega_i,\\pmb \\omega_o)$ 能量守恒：$\\int_\\Omega f_r(\\pmb p,\\pmb \\omega_o,\\pmb \\omega_i)\\cos\\theta\\mathrm d\\omega\\leq 1$  2.2.3. Cook-Torrance BRDF 本文将主要介绍目前主流的Cook-Torrance BRDF模型，Cook-Torrance BRDF由漫反射项和镜面反射项组成：\n$$\nf_r=k_d\\cdot f_{\\mathrm{diffuse}} +k_s\\cdot f_{\\mathrm{specular}}\n$$\n其中漫反射项使用Lambertian光照模型，镜面反射项使用微表面模型进行建模，随后将具体介绍。\n3. Lambertian漫反射材质模型 Lambertian漫反射模型假定出射光线在各个方向上都是均匀的（强度相等），由反射方程：\n$$\n\\begin{aligned}\nL_o(\\pmb\\omega_o)\u0026amp;=\\int_\\Omega f_rL_i(\\pmb\\omega_i)\\cos\\theta_i\\mathrm d\\pmb \\omega_i\\\\\\\\\n\u0026amp;=f_rL_i\\int_\\Omega \\cos\\theta_i\\mathrm d\\pmb \\omega_i\\\\\\\\\n\u0026amp;=\\pi f_rL_i\n\\end{aligned}\n$$\n为了保证能量守恒，BRDF选择：\n$$\nf_r=\\frac{\\rho}{\\pi}\n$$\n其中$\\rho$为材质颜色Albedo参数，通常有RGB三个分量，当$\\rho=(1,1,1)$时，说明材质为白色，没有吸收任何色光，此时$L_o=L_i$。\n4. 镜面反射模型 4.1. 微表面理论 真实世界中不存在绝对光滑的物体表面，即使是看起来很光滑的表面也具有比光的波长大得多的微尺度不规则性。这种微表面现象将导致每个表面点反射和折射不同方向的光，带来不同的材质外观。\n同时，在微表面作用的光还会因为自遮挡带来阴影和遮罩：\n微表面BRDF很大程度由材质的粗糙度所影响，粗糙度度量了微表面材质表面的粗糙程度，如下图从左到右粗糙度依次降低：\n4.2. 法线分布函数（Normal Distribution Function） 法线分布是描述微表面的一个重要几何性质，通常物体表面会有一个法向量$\\pmb n$，可以认为是物体表面绝对光滑时具有的法向量，但由于微表面具有的各种微小几何结构，局部的表面法向量可能与法向量$\\pmb n$不同，这种局部法向量称为微表面法向量$\\pmb m$，而法线分布函数$D(\\pmb m)$则是描述了微表面法线的分布概率密度。\n在渲染中，常用宏观表面的半矢量$\\pmb h$来表示微表面法向，因为只有$\\pmb m=\\pmb h$的表面点能够将入射光反射到视线方向，而其他朝向的表面点对最终的渲染结果没有贡献\n在整个微表面法线上积分$D(\\pmb m)$将得到微表面的面积，不过更常用的是对$D(\\pmb m)(\\pmb n\\cdot\\pmb m)$进行积分，将$D(\\pmb m)$投影到宏观表面平面上，将得到宏观表面的元面积，规定为1，如下图所示：\n又称为投影$D(\\pmb m)(\\pmb n\\cdot\\pmb m)$的归一化：\n$$\n\\int_{\\pmb m\\in\\Theta}D(\\pmb m)(\\pmb n\\cdot\\pmb m)\\mathrm d{\\pmb m}=1\n$$\n上式中的$\\Theta$表示在整个球体上进行积分，虽然在图形学中的微结构模型多为高度场，即在以$\\pmb n$为中心的半球$\\Omega$以外的所有方向有$D(\\pmb m)\\equiv 0$。\n更一般地，微表面和宏观表面在垂直于任何视图方向$\\pmb v$的平面上的投影总是相等的：\n即：\n$$\n\\int_{\\pmb m\\in\\Theta}D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d{\\pmb m}=\\pmb v\\cdot\\pmb n\n$$\n上式定义了一个合理的法线分布函数应当具有的约束性质，一种直观的理解是一片宏观表面的法向等于其微表面所有法向的均值，至于实际法线分布函数应长什么样，那就有特别多的建模手段得到了，例如，对于绝对光滑的表面，显然$\\pmb m$与$\\pmb n$恒相等，法线分布函数则可以由一个冲激函数进行表示：\n$$\nD(\\pmb m)=\\delta(\\pmb m-\\pmb n)\n$$\n注意到式子$\\int_{\\pmb m\\in\\Theta}D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d{\\pmb m}=\\pmb v\\cdot\\pmb n$中，$\\pmb v\\cdot\\pmb m$的正负不受限制，这是由于投影会产生正负造成抵消，如前图所示，但在实际渲染中，我们常常只关注可见的微表面，即离相机最近的那个微表面，可以通过定义几何函数$G_1(\\pmb m,\\pmb v)$来给出沿着视图向量$\\pmb v$可见的具有法向$\\pmb m$的微平面比例，则原式可改写为：\n$$\n\\int_{m\\in\\Theta}G_1(\\pmb m, \\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)^+\\mathrm d\\pmb m=\\pmb v\\cdot \\pmb m\n$$\n如下图所示，而几何遮蔽函数的具体内容待会将作介绍。\n4.2.1. 法线分布函数的基本性质 法线分布函数是一种概率密度函数，很自然地有如下性质：\n  非负性\n$$\n0\\leq D(\\pmb m)\\leq \\infty\n$$\n  法线分布函数的积分表征了微表面的面积，显然微表面面积应大于等于宏观表面面积\n$$\n\\int_{\\pmb m\\in \\Theta}D(\\pmb m)\\mathrm d\\pmb m\\geq 1\n$$\n  微表面和宏观表面在垂直于任何视图方向$\\pmb v$的平面上的投影总是相等的\n$$\n\\int_{\\pmb m\\in\\Theta}D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d{\\pmb m}=\\pmb v\\cdot\\pmb n\n$$\n  特别地，当视图法向沿着宏观法向时，积分归一化\n$$\n\\int_{\\pmb m\\in\\Theta}D(\\pmb m)(\\pmb n\\cdot\\pmb m)\\mathrm d{\\pmb m}=1\n$$\n  4.2.2. 法线分布函数的形状不变性 形状不变性（shape-invariant）是设计合理法线分布函数的一个重要依据，具有形状不变性的法线分布函数，能够推导该函数归一化的各向异性版本，且可以很方便地推导相应的几何函数项$G$\nHeitz定义各向同性的法线分布函数具有形状不变性即材质粗糙度的影响等价于微表面的拉伸，具有形状不变性的微表面法线分布函数可以表示为以下形式：\n$$\nD(\\pmb m)=\\frac{\\chi^+(\\pmb n\\cdot\\pmb m)}{\\alpha^2(\\pmb n\\cdot\\pmb m)^4}g\\left(\\frac{\\sqrt{1-(\\pmb n\\cdot\\pmb m)^2}}{\\alpha(\\pmb n\\cdot\\pmb m)}\\right)\n$$\n其中$g(\\cdot)$代表一个表示法线分布函数形状的一维函数\n4.2.3. 常用的法线分布函数 Blinn-Phong分布\nBlinn-Phong分布函数具有如下形式：\n$$\nD(\\pmb m)=\\frac{\\alpha_p+2}{2\\pi}(\\pmb n\\cdot\\pmb m)^{\\alpha_p}\n$$\n其中，幂$\\alpha_p$为Blinn-Phong法线分布函数的粗糙度参数，$\\alpha_p$越高，表示表面越光滑，$\\alpha_p$的取值可以是$[0,\\infty)$，$\\alpha_p$参数不便于艺术家进行调节，UE4中采用映射$\\alpha_p=2\\alpha^{-2}-2$，使用材质粗糙度$\\alpha$进行控制，得到的Blinn-Phong法线分布函数如下：\n$$\nD(\\pmb m)=\\frac{1}{\\pi\\alpha^2}(\\pmb n\\cdot\\pmb m)^{(\\frac{2}{\\alpha^2}-2)}\n$$\nBlinn-Phong分布函数不具有形状不变性。\nBeckmann分布\nBeckmann分布函数具有如下形式：\n$$\nD(\\pmb m)=\\frac{1}{\\pi\\alpha^2(\\pmb n\\cdot\\pmb m)^4}\\exp(\\frac{(\\pmb n\\cdot\\pmb m)^2-1}{\\alpha^2(\\pmb n\\cdot\\pmb m)^2})\n$$\n Beckmann分布函数呈高斯函数形态，在对称轴$\\pmb n\\cdot\\pmb m$处取得最值，如下图所示呈现一种中间亮两边暗的渲染效果。  Beckmann分布与Blinn-Phong分布可以通过关系式$\\alpha_p=2\\alpha_b^{-2}-2$进行等效，如下图所示，蓝色虚线为Blinn-Phong分布、绿色实线为Beckmann分布：\nBeckmann分布函数具有形状不变性。\nGGX（Trowbridge-Reitz）分布\nGGX分布函数具有如下形式：\n$$\nD(\\pmb m)=\\frac{\\alpha^2}{\\pi((\\pmb n\\cdot \\pmb m)^2(\\alpha^2-1)+1)^2}\n$$\nGGX是目前业界最流行的微表面法线分布函数模型，因为它在主流模型中拥有最长的尾部，如下图所示，Beckmann分布函数会很快地逼近于0，而GGX能维持较长的一段尾部：\nGGX分布函数具有形状不变性。\nGTR（Generalized-Trowbridge-Reitz）分布\n广义的Trowbridge-Reitz分布，具有如下形式：\n$$\nD(\\pmb m)=\\frac{c}{(1+(\\pmb n\\cdot\\pmb m)^2(\\alpha^2-1))^\\gamma}\n$$\n其中，参数$\\gamma$用于控制函数的尾部形状，当$\\gamma=2$时，则退化为GGX分布。各个$\\gamma$取值与GTR分布曲线的关系如下：\nGTR分布函数不具有形状不变性。\n4.2.4. 各项异性的法线分布函数 我们已知对于一个各向同性的具有形状不变性的法线分布函数，可以用下述形式所表示（考虑定义在正半球上）：\n$$\nD(\\pmb m)=\\frac{1}{\\alpha^2(\\pmb n\\cdot\\pmb m)^4}g\\left(\\frac{\\sqrt{1-(\\pmb n\\cdot\\pmb m)^2}}{\\alpha(\\pmb n\\cdot\\pmb m)}\\right)\n$$\n则对应的各项异性法线分布函数则为：\n$$\nD(\\pmb m)=\\frac{1}{\\alpha_x\\alpha_y(\\pmb n\\cdot\\pmb m)^4}g\\left(\\frac{\n\\sqrt{\\frac{(\\pmb t\\cdot\\pmb m)^2}{\\alpha_x^2}+\\frac{(\\pmb b\\cdot\\pmb m)^2}{\\alpha_y^2}}}{\\pmb n\\cdot\\pmb m}\\right)\n$$\n其中，$\\alpha_x$和$\\alpha_y$分别表示沿切线$\\pmb t$方向和副法线$\\pmb b$方向的粗糙度，当$\\alpha_x=\\alpha_y$时，则退化为各向同性的形式。\n各向异性的Beckmann分布\n$$\nD(\\pmb m)=\\frac{1}{\\pi\\alpha_x\\alpha_y(\\pmb n\\cdot\\pmb m)^4}\\exp\\left(\n-\\frac{\\frac{(\\pmb t\\cdot\\pmb m)^2}{\\alpha_x^2}+\\frac{(\\pmb b\\cdot\\pmb m)^2}{\\alpha_y^2}}{(\\pmb n\\cdot\\pmb m)^2}\\right)\n$$\n各项异性的GGX分布\n$$\nD(\\pmb m)=\\frac{1}{\\pi\\alpha_x\\alpha_y}\\frac{1}{\\left(\\frac{(\\pmb t\\cdot\\pmb m)^2}{\\alpha_x^2}+\\frac{(\\pmb b\\cdot\\pmb m)^2}{\\alpha_y^2}+(\\pmb n\\cdot\\pmb m)^2\\right)^2}\n$$\n4.2.5. Beckmann与GGX法线分布函数效果比较 各向同性比较：\n各向异性比较（上一行为Beckmann分布，下一行为GGX分布，$\\alpha_x$从左到右依次递增，$\\alpha_y$保持不变）：\n4.3. 几何函数（Geometry Function） 从法线分布函数一节中我们从微表面模型导出了几何函数的基本概念：\n$$\n\\int_{m\\in\\Theta}G_1(\\pmb m, \\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)^+\\mathrm d\\pmb m=\\pmb v\\cdot \\pmb m\n$$\n几何函数$G$作为一个取值范围为$[0,1]$的标量，描述了微表面的自阴影的属性，表示了具有半矢量的微表面中，同时被入射方向和反射方向可见的比例\n几何函数具有两种主要的形式：\n $G_1$：微表面在单个方向（光照方向或观察方向）上的可见比例，一般表示阴影函数或遮蔽函数 $G_2$：微表面在光照方向和观察方向上均可见的比例，一般表示联合遮蔽阴影函数  一般默认情况下，几何函数指代$G_2$。\n几何函数的设计也有很多，其中基于物理的相对经典的模型为Smith遮蔽函数和V-cavity遮蔽函数\nSmith模型具有不相关的表面，即每个微表面与其邻域不相关，与真实世界的连续微表面对比如下（右图为Smith模型）：\nV-cavity遮蔽函数计算单独微表面上的散射并混合计算结果：\nHeitz证明了Smith遮蔽函数是唯一既遵循公式：\n$$\n\\int_{m\\in\\Theta}G_1(\\pmb m, \\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)^+\\mathrm d\\pmb m=\\pmb v\\cdot \\pmb m\n$$\n又具有法线遮蔽独立性的便利特性的函数，因此业界更青睐于使用Smith模型，Smith模型也比V-cavity模型能够更好地拟合真实世界的反射现象：\n4.3.1. Smith遮蔽函数 下面我们将从各项同性的法线分布函数出发，详细推导Smith几何函数模型。\n在前面的介绍中我们已经得到微表面模型的基本方程：\n$$\n\\int_{m\\in\\Theta}G_1(\\pmb m, \\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)^+\\mathrm d\\pmb m=\\pmb v\\cdot \\pmb m\n$$\n其中的$G_1(\\pmb m,\\pmb v)$项则是我们要求的几何函数项，这里我们仅考虑以高度场建模的微表面，由于几何函数$G_1$将筛选出在单个方向上（即$\\pmb m\\cdot\\pmb v\u0026gt;0$）可见的光，我们可以将$G_1$项分离为：\n$$\nG_1(\\pmb m,\\pmb v)=\\chi^+(\\pmb m,\\pmb v)G_1'(\\pmb v)\n$$\n原方程可化为：\n$$\n\\int_{m\\in\\Theta}\\chi^+(\\pmb m,\\pmb v)G_1'(\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m=\\pmb v\\cdot \\pmb m\n$$\n提取出与$\\pmb m$无关的$G'(\\pmb v)$，有：\n$$\n\\pmb v\\cdot \\pmb m=G_1'(\\pmb v)\\int_{m\\in\\Theta}\\chi^+(\\pmb m,\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m\n$$\n定义与微表面法向$\\pmb m(x_m,y_m,z_m)$相关的微表面坡度：\n$$\n\\tilde m(\\pmb m)=(x_{\\tilde m}, y_{\\tilde m})=(-x_m/z_m,-y_m/z_m)\n$$\n反过来，微表面法向也可表示为：\n$$\n\\pmb m(\\tilde m)=(x_m,y_m,z_m)=\\frac{1}{\\sqrt{x_{\\tilde m}^2+ y_{\\tilde m}^2+1}}(-x_{\\tilde m}, -y_{\\tilde m},1)\n$$\n定义微表面坡度的分布函数$P^{22}$，由$P^{22}$所应满足的归一性：\n$$\n\\int_{-\\infty}^\\infty\\int_{-\\infty}^\\infty P^{22}(\\tilde m)\\mathrm d\\tilde m=1\n$$\n以及法线分布函数的归一性（高度场，仅考虑半球）：\n$$\n\\int_{\\Omega}D(\\pmb m)(\\pmb n\\cdot\\pmb m)\\mathrm d{\\pmb m}=1\n$$\n建立关联：\n$$\nP^{22}(\\tilde m)\\mathrm d\\tilde m=D(\\pmb m)(\\pmb n\\cdot\\pmb m)\\mathrm d{\\pmb m}\n$$\n整理后积分有：\n$$\n\\int_{\\Omega}\\chi^+(\\pmb m,\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m=\\int_{-\\infty}^\\infty\\int_{-\\infty}^\\infty \\chi^+(\\pmb m,\\pmb v)\\frac{\\pmb v\\cdot\\pmb m(\\tilde m)}{\\pmb n\\cdot\\pmb m(\\tilde m)}P^{22}(\\tilde m) \\mathrm d\\tilde m\n$$\n由于$\\pmb n=(0,0,1)$，因此\n$$\n\\pmb n\\cdot\\pmb m(\\tilde m)=\\frac{1}{\\sqrt{x_{\\tilde m}^2+ y_{\\tilde m}^2+1}}\n$$\n与$\\chi^+(\\pmb m,\\pmb v)$项结合起来有：\n$$\n\\chi^+(\\pmb m,\\pmb v)\\pmb v\\cdot\\pmb m(\\tilde m)=\\frac{\\chi^+(-x_0x_{\\tilde m}-y_0y_{\\tilde m}+z_0)(-x_0x_{\\tilde m}-y_0y_{\\tilde m}+z_0)}{\\sqrt{x_{\\tilde m}^2+ y_{\\tilde m}^2+1}}\n$$\n因此积分可以写为：\n$$\n\\int_{\\Omega}\\chi^+(\\pmb m,\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m=\n\\int_{-\\infty}^\\infty\\int_{-\\infty}^\\infty \\chi^+(-x_0x_{\\tilde m}-y_0y_{\\tilde m}+z_0)(-x_0x_{\\tilde m}-y_0y_{\\tilde m}+z_0) P^{22}(x_{\\tilde m},y_{\\tilde m})\\mathrm dx_{\\tilde m}\\mathrm dy_{\\tilde m}\n$$\n不失一般性地，我们可以假设视角方向与$x$轴对齐，即$\\pmb v=(\\sin\\theta_o,0,\\cos\\theta_o)$，则积分表示为：\n$$\n\\begin{align}\n\u0026amp;\\int_{\\Omega}\\chi^+(\\pmb m,\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m\\\\\\\\\n=\u0026amp;\\int_{-\\infty}^\\infty\\int_{-\\infty}^\\infty\\chi^+(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)P^{22}(x_{\\tilde m},y_{\\tilde m})\\mathrm dx_{\\tilde m}\\mathrm dy_{\\tilde m}\\\\\\\\\n=\u0026amp;\\int_{-\\infty}^\\infty\\chi^+(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)\\left(\\int_{-\\infty}^\\infty P^{22}(x_{\\tilde m},y_{\\tilde m})\\mathrm dy_{\\tilde m}\\right)\\mathrm dx_{\\tilde m}\\\\\\\\\n=\u0026amp;\\int_{-\\infty}^\\infty \\chi^+(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n\\end{align}\n$$\n其中，$P^2(x_{\\tilde m})$为沿着视角法向的一维坡度分布函数，定义为：\n$$\nP^2(x_{\\tilde m})=\\int_{-\\infty}^{+\\infty}P^{22}(x_{\\tilde m},y_{\\tilde m})\\mathrm dy_{\\tilde m}\n$$\n又：\n$$\n-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o\u0026gt;0\\Rightarrow x_{\\tilde m}\u0026lt;\\cot\\theta_o\n$$\n因此原积分又可化为：\n$$\n\\int_{-\\infty}^\\infty \\chi^+(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}=\n\\int_{-\\infty}^{\\cot\\theta_o} (-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n代入到方程：\n$$\n\\pmb v\\cdot \\pmb m=G_1'(\\pmb v)\\int_{m\\in\\Theta}\\chi^+(\\pmb m,\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m\n$$\n可以得到：\n$$\n\\cos\\theta_o=G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n两边同除以$\\sin\\theta_o$可得：\n$$\n\\cot\\theta_o=G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-x_{\\tilde m}+\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n由于微表面分布是中心对称的，且任意方向的平均坡度为零（正负抵消，分布的均值为0），即\n$$\n\\int_{-\\infty}^{+\\infty} x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}=0\n$$\n引入该项有：\n$$\n\\cot\\theta_o=G_1'(\\pmb v)\\int_{-\\infty}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}+ G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-x_{\\tilde m}+\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n利用$\\cot\\theta_o=(1-G_1'(\\pmb v))\\cot\\theta_o+G_1'(\\pmb v)\\cot\\theta_o$，代入有：\n$$\n\\begin{align}\n(1-G_1'(\\pmb v))\\cot\\theta_o+G_1'(\\pmb v)\\cot\\theta_o\n=\u0026amp;G_1'(\\pmb v)\\int_{-\\infty}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}+ G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-x_{\\tilde m}+\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\\\\\\\\n(1-G_1'(\\pmb v))\\cot\\theta_o\n=\u0026amp;G_1'(\\pmb v)\\int_{-\\infty}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}+ G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-x_{\\tilde m}+\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\\\\\\\\n\u0026amp;-G_1'(\\pmb v)\\cot\\theta_o\n\\end{align}\n$$\n由于概率密度函数的归一性：\n$$\n\\int_{-\\infty}^{+\\infty} P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}=1\n$$\n因此有\n$$\nG_1'(\\pmb v)\\cot\\theta_o=G_1'(\\pmb v) \\int_{-\\infty}^{+\\infty} \\cot\\theta_oP^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n代入得：\n$$\n\\begin{align}\n(1-G_1'(\\pmb v))\\cot\\theta_o=\u0026amp;G_1'(\\pmb v)\\int_{-\\infty}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}+ G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-x_{\\tilde m}+\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\\\\\\\\n\u0026amp;-G_1'(\\pmb v) \\int_{-\\infty}^{+\\infty} \\cot\\theta_oP^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\\\\\\\\n=\u0026amp;G_1'(\\pmb v)\\left(\\int_{-\\infty}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}-\\int_{-\\infty}^{\\cot\\theta_o} x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\right)\\\\\\\\\n\u0026amp;+G_1'(\\pmb v)\\left(\\int_{-\\infty}^{\\cot\\theta_o}\\cot\\theta_oP^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}-\\int_{-\\infty}^{\\infty}\\cot\\theta_oP^2(x_{\\tilde m})\\mathrm dx_{\\tilde m} \\right)\\\\\\\\\n=\u0026amp;G_1'(\\pmb v)\\int_{\\cot\\theta_o}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}-G_1'(\\pmb v)\\int_{\\cot\\theta_o}^{+\\infty}\\cot\\theta_oP^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\\\\\\\\n=\u0026amp;G_1'(\\pmb v)\\int_{\\cot\\theta_o}^{+\\infty}(x_{\\tilde m}-\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n\\end{align}\n$$\n等式变换一下有：\n$$\n\\frac{1-G'_1(\\pmb v)}{G'_1(\\pmb v)}=\\frac{1}{\\cot\\theta_o}\\int_{\\cot\\theta_o}^{+\\infty}(x_{\\tilde m}-\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n于是得到最终形式：\n$$\nG_1'(\\pmb v)=\\frac{1}{1+\\Lambda(\\pmb v)}\n$$\n其中，$\\Lambda(\\cdot)$定义为：\n$$\n\\Lambda(\\pmb v)=\\frac{1}{\\cot\\theta_o}\\int_{\\cot\\theta_o}^{+\\infty}(x_{\\tilde m}-\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n这是一个与法线分布函数$D(\\pmb m)$相关的函数，每个$D(\\pmb m)$都有唯一的$\\Lambda(\\pmb v)$与之对应。\n综合起来可得Smith几何函数$G_1$的具体形式：\n$$\nG_1(\\pmb m, \\pmb v)=\\frac{\\chi^+(\\pmb m\\cdot\\pmb v)}{1+\\Lambda(\\pmb v)}\n$$\n具有形状不变性的法线分布函数能够得到$\\Lambda(\\pmb v)$的解析解，如：\nBeckmann分布函数\n$$\n\\begin{align}\nP^{22}(x_{\\tilde m},y_{\\tilde m})\u0026amp;=\\frac{1}{\\pi\\alpha^2}\\exp\\left(-\\frac{x^2_{\\tilde m}+y^2_{\\tilde m}}{\\alpha^2}\\right)\\\\\\\\\nD(\\pmb m)\u0026amp;=\\frac{1}{\\pi\\alpha^2(\\pmb n\\cdot\\pmb m)^4}\\exp(\\frac{(\\pmb n\\cdot\\pmb m)^2-1}{\\alpha^2(\\pmb n\\cdot\\pmb m)^2})\\\\\\\\\n\\Lambda(a)\u0026amp;=\\frac{\\mathrm{erf}(a)-1}{2}+\\frac{1}{2a\\sqrt{\\pi}}\\exp(-a^2)\n\\end{align}\n$$\n其中，\n$$\n\\begin{align}\na\u0026amp;=\\frac{\\pmb n\\cdot \\pmb v}{a\\sqrt{1-(\\pmb n\\cdot\\pmb v)^2}}\\\\\\\\\n\\mathrm{erf}(x)\u0026amp;=\\frac{2}{\\sqrt{\\pi}}\\int_0^xe^{-x'^2}\\mathrm dx'^2\n\\end{align}\n$$\n当然上述公式的计算开销很大，Walter等人给出一种近似逼近：\n$$\n\\Lambda(a)=\\begin{cases}\n\\frac{1-1.259a+0.396a^2}{3.535a+2.181a^2},\u0026amp;a\u0026lt;1.6\\\\\\\\\n0,\u0026amp;a\\geq 1.6\n\\end{cases}\n$$\n**GGX分布函数**\n$$\n\\begin{aligned}\nP^{22}(x_{\\tilde m},y_{\\tilde m})\u0026amp;=\\frac{1}{\\pi\\alpha^2\\left(1+\\frac{x^2_{\\tilde m}+y_{\\tilde m}^2}{\\alpha^2}\\right)^2}\\\\\\\\\nD(\\pmb m)\u0026amp;=\\frac{\\alpha^2}{\\pi((\\pmb n\\cdot \\pmb m)^2(\\alpha^2-1)+1)^2}\\\\\\\\\n\\Lambda(a)\u0026amp;=\\frac{-1+\\sqrt{1+\\frac{1}{a^2}}}{2}\n\\end{aligned}\n$$\n其中，\n$$\na=\\frac{\\pmb n\\cdot \\pmb v}{a\\sqrt{1-(\\pmb n\\cdot\\pmb v)^2}}\n$$\n同时，Karis也给出了GGX的Smith $G_1$计算近似公式：\n$$\nG_1(\\pmb v)\\approx \\frac{2(\\pmb n\\cdot\\pmb v)}{(\\pmb n\\cdot\\pmb v)(2-\\alpha)+\\alpha}\n$$\n可以很方便地用在实时渲染中。\n对于各向异性的法线分布函数，可以证明$\\Lambda(\\cdot)$与各向同性版本的一致。\n4.3.2. Smith联合遮蔽函数-阴影函数 分离的遮蔽阴影函数\n最简单和广泛使用的遮蔽阴影函数，认为遮蔽和阴影是独立的，可以分别计算并进行相乘：\n$$\n\\begin{align}\nG_2(\\pmb v,\\pmb l,\\pmb m)\u0026amp;=G_1(\\pmb v,\\pmb m)G_1(\\pmb l,\\pmb m)\\\\\\\\\n\u0026amp;=\\frac{\\chi^+(\\pmb v\\cdot\\pmb m)}{1+\\Lambda(\\pmb v)}\\frac{\\chi^+(\\pmb l\\cdot\\pmb m)}{1+\\Lambda(\\pmb l)}\n\\end{align}\n$$\n这种形式不模拟遮蔽和阴影之间的相关性，因此总会多估算阴影，因为一些相关性总是存在的\n高度相关的遮蔽阴影函数\n这种形式的遮蔽阴影函数更好地模拟了由于微表面高度引起的遮蔽和阴影之间的相关性。直观地说，微平面在微表面升高得越多，对于出射方向未被遮蔽和入射方向未被掩蔽的可见概率会同时增加，形式如下：\n$$\nG_2(\\pmb v,\\pmb l,\\pmb m)=\\frac{\\chi^+(\\pmb v\\cdot\\pmb m)\\chi^+(\\pmb l\\cdot\\pmb m)}{1+\\Lambda(\\pmb v)+\\Lambda(\\pmb l)}\n$$\n方向相关的遮蔽阴影函数\n通过混合可分离的遮蔽阴影函数与两个方向完全相关的情形来表达方向相关：\n$$\nG_2(\\pmb v,\\pmb l,\\pmb m)=\\lambda(\\phi)G_1(\\pmb v,\\pmb m)G_1(\\pmb l,\\pmb m)+(1-\\lambda(\\phi))\\min(G_1(\\pmb v,\\pmb m),G_1(\\pmb l,\\pmb m))\n$$\n其中$\\lambda(\\phi)$是一个经验公式，随着角度$\\phi$的增大，$\\lambda$从0增大到1，Ashikhmin等人建议使用一个高斯函数进行处理：\n$$\n\\lambda(\\phi)=1-e^{-7.3\\phi^2}\n$$\nvan Ginneken则提出另外一种计算方法：\n$$\n\\lambda(\\phi)=\\frac{4.41\\phi}{4.41\\phi+1}\n$$\n高度方向相关的遮蔽阴影函数\n结合高度相关形式和方向相关形式，可以得到：\n$$\nG_2(\\pmb v, \\pmb l,\\pmb m)=\\frac{\\chi^+(\\pmb v\\cdot\\pmb m)\\chi^+(\\pmb l\\cdot\\pmb m)}{1+\\max(\\Lambda(\\pmb v),\\Lambda(\\pmb l))+\\lambda(\\pmb v\\cdot\\pmb l)\\min(\\Lambda(\\pmb v),\\Lambda(\\pmb l))}\n$$\n  当出射方向与入射方向平行且$\\lambda=0$时，遮蔽和阴影完全相关\n  相关性随着方向之间的夹角增加而减小，当$\\lambda=1$时，遮蔽和阴影不再方向相关，而是退化为高度相关的形式\n  $\\lambda$的计算同样可以通过：\n$$\n\\lambda(\\phi)=\\frac{4.41\\phi}{4.41\\phi+1}\n$$\n$\\phi$为$\\pmb v$和$\\pmb l$之间的方位角\n  4.4. 菲涅尔反射 我们已经知道光在两介质的交界表面会发生反射和折射现象，在不考虑次表面散射和透射的情况下我们常常只关注反射光（只有反射光对BRDF有贡献），由费马原理（光路最短原理）我们能够从几何上求出入射角和折射角的关系，但无法确定入射光和折射光、反射光的比例关系。而菲涅尔方程则能够描述了光在介质表面传播的能量关系。\n4.4.1. 菲涅尔方程的推导 要推导出菲涅尔方程，我们需要重新回到麦克斯韦方程组，假设在均匀线性物质中，不存在自由电荷和电流，则麦克斯韦方程组变为：\n$$\n\\begin{aligned}\n\\nabla \\cdot\\pmb E \u0026amp;= 0\\\\\\\\\n\\nabla\\cdot\\pmb B\u0026amp;=0\\\\\\\\\n\\nabla\\times \\pmb E\u0026amp;=-\\frac{\\partial \\pmb B}{\\partial t}\\\\\\\\\n\\nabla\\times \\pmb B\u0026amp;=\\varepsilon\\mu\\frac{\\partial \\pmb E}{\\partial t}\n\\end{aligned}\n$$\n由前述推导中，我们可以很容易求得：\n$$\n\\begin{matrix}\n\\nabla^2\\pmb E=\\mu\\varepsilon\\dfrac{\\partial^2\\pmb E}{\\partial t^2}\u0026amp;\\nabla^2\\pmb B=\\mu\\varepsilon\\dfrac{\\partial^2\\pmb B}{\\partial t^2}\n\\end{matrix}\n$$\n可以看到$\\pmb E$和$\\pmb B$的每个直角坐标分量都满足三维波方程的形式：\n$$\n\\nabla^2f=\\frac{1}{v^2}\\frac{\\partial^2 f}{\\partial t^2}\n$$\n波速：\n$$\nv=\\frac{1}{\\sqrt{\\mu\\varepsilon}}\n$$\n这个波速也为光速，在真空中$v=1/\\sqrt{\\mu_0\\varepsilon_0}=3.00\\times 10^8m/s$\n定义折射率\n$$\nn=\\sqrt{\\frac{\\varepsilon\\mu}{\\varepsilon_0\\mu_0}}\n$$\n则均匀线性物质中的光速为$v=c/n$\n能量密度为：\n$$\nu=\\frac{1}{2}\\left(\\varepsilon E^2+\\frac{1}{\\mu}B^2 \\right)\n$$\n对于单色平面波，波的强度为：\n$$\nI=\\frac{1}{2}\\varepsilon vE_0^2\n$$\n边界条件\n根据麦克斯韦的积分形式，我们可以推导出电磁场在无自由电荷或自由电流的线性介质的边界条件：\n$$\n\\begin{aligned}\n\\varepsilon_1\\pmb E_1^\\perp-\\varepsilon_2\\pmb E_2^\\perp\u0026amp;=0\\\\\\\\\n\\pmb E_1^{\\parallel}-\\pmb E_2^{\\parallel}\u0026amp;=0\\\\\\\\\n\\pmb B_1^\\perp-\\pmb B_2^\\perp\u0026amp;=0\\\\\\\\\n\\frac{1}{\\mu_1}\\pmb B_1^\\parallel-\\frac{1}{\\mu_2}\\pmb B_2^\\parallel\u0026amp;=0\n\\end{aligned}\n$$\n垂直入射的反射与折射\n如上图所示，假设$xy$平面为两线性介质的界面，角频率为$\\omega$，沿$z$方向传播和沿$x$方向偏振的平面波从左边入射到界面：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ I(z,t)\u0026amp;=\\tilde E_{0I}e^{i(k_1z-\\omega t)}\\hat{\\pmb x}\\\\\\\\\n\\tilde{\\pmb B}_ I(z,t)\u0026amp;=\\frac{1}{v_I}\\tilde E_{0I}e^{i(k_1z-\\omega t)}\\hat{\\pmb y}\n\\end{align}\n$$\n它将产生一个反射波：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ R(z,t)\u0026amp;=\\tilde E_{0R}e^{i(-k_1z-\\omega t)}\\hat{\\pmb x}\\\\\\\\\n\\tilde{\\pmb B}_ R(z,t)\u0026amp;=-\\frac{1}{v_1}\\tilde E_{0R}e^{i(-k_1z-\\omega t)}\\hat{\\pmb y}\n\\end{align}\n$$\n和一个透射波：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ T(z,t)\u0026amp;=\\tilde E_{0T}e^{i(k_2z-\\omega t)}\\hat{\\pmb x}\\\\\\\\\n\\tilde{\\pmb B}_ T(z,t)\u0026amp;=\\frac{1}{v_2}\\tilde E_{0T}e^{i(k_2z-\\omega t)}\\hat{\\pmb y}\n\\end{align}\n$$\n由边界条件可以得到：\n$$\n\\begin{align}\n\\tilde E_{0I}+\\tilde E_{0R}\u0026amp;=\\tilde E_{0T}\\\\\\\\\n\\frac{1}{\\mu_1}\\left(\\frac{1}{v_1}\\tilde E_{0I}-\\frac{1}{v_1}\\tilde E_{0R} \\right)\u0026amp;=\\frac{1}{\\mu_2}\\left(\\frac{1}{v_2}\\tilde E_{0T}\\right)\n\\end{align}\n$$\n解得：\n$$\n\\begin{aligned}\n\\tilde E_{0R}=\\left(\\frac{1-\\beta}{1+\\beta}\\right)\\tilde E_{0I}\\\\\\\\\n\\tilde E_{0T}=\\left(\\frac{2}{1+\\beta}\\right)\\tilde E_{0I}\n\\end{aligned}\n$$\n其中，\n$$\n\\beta\\equiv \\frac{\\mu_1v_1}{\\mu_2v_2}=\\frac{\\mu_1n_2}{\\mu_2n_1}\n$$\n若介质的磁导率$\\mu$与真空中的接近（大多数介质是这样），则$\\beta\\approx v_1/v_2$，有：\n$$\n\\begin{aligned}\n\\tilde E_{0R}=\\left(\\frac{v_2-v_1}{v_2+v_1}\\right)\\tilde E_{0I}\\\\\\\\\n\\tilde E_{0T}=\\left(\\frac{2v_2}{v_2+v_1}\\right)\\tilde E_{0I}\n\\end{aligned}\n$$\n实振幅间有以下关系：\n$$\n\\begin{aligned}\nE_{0R}=\\left|\\frac{v_2-v_1}{v_2+v_1}\\right|E_{0I}=\\left|\\frac{n_1-n_2}{n_1+n_2}\\right|E_{0I}\\\\\\\\\nE_{0T}=\\left|\\frac{2v_2}{v_2+v_1}\\right|E_{0I}=\\left|\\frac{2n_1}{n_1+n_2}\\right|E_{0I}\n\\end{aligned}\n$$\n从能量角度看，反射波与入射波强度之比为：\n$$\nR\\equiv\\frac{I_R}{I_I}=\\left(\\frac{E_{0R}}{E_{0I}}\\right)^2=\\left(\\frac{n_1-n_2}{n_1+n_2}\\right)^2\n$$\n透射波与入射波强度之比为：\n$$\nT\\equiv\\frac{I_T}{I_I}=\\frac{\\varepsilon_2v_2}{\\varepsilon_1v_1}\\left(\\frac{E_{0T}}{E_{0I}}\\right)^2=\\frac{4n_1n_2}{(n_1+n_2)^2}\n$$\n其中，$R$称为反射系数，$T$称为透射系数，注意到，$R+T=1$，也是一种能量守恒。\n倾斜入射的反射与折射\n如上图所示，考虑更一般的入射情况，入射角度为$\\theta_I$，假设一个单色平面波：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ I(\\pmb r,t)\u0026amp;=\\tilde E_{0I}e^{i(\\pmb k_I\\cdot\\pmb r-\\omega t)}\\\\\\\\\n\\tilde{\\pmb B}_ I(\\pmb r,t)\u0026amp;=\\frac{1}{v_1}(\\tilde{\\pmb k_I}\\times\\tilde{\\pmb E_I})\n\\end{align}\n$$\n从左边入射，得到一个反射波：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ R(\\pmb r,t)\u0026amp;=\\tilde {\\pmb E}_{0R}e^{i(\\pmb k_R\\cdot\\pmb r-\\omega t)}\\\\\\\\\n\\tilde{\\pmb B}_ R(\\pmb r,t)\u0026amp;=\\frac{1}{v_1}(\\tilde{\\pmb k_R}\\times\\tilde{\\pmb E_R})\n\\end{align}\n$$\n和一个透射波：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ T(\\pmb r,t)\u0026amp;=\\tilde {\\pmb E}_{0T}e^{i(\\pmb k_T\\cdot\\pmb r-\\omega t)}\\\\\\\\\n\\tilde{\\pmb B}_ T(\\pmb r,t)\u0026amp;=\\frac{1}{v_2}(\\tilde{\\pmb k_T}\\times\\tilde{\\pmb E_T})\n\\end{align}\n$$\n所有三个波具有相同的频率$\\omega$，该物理量由光源所决定，因此三个波的波数之间存在关系：\n$$\nk_Iv_1=k_Rv_1=k_Tv_2=\\omega\n$$\n由边界条件，介质(1)中的合场强$\\tilde{\\pmb E}_I+\\tilde{\\pmb E}_R$和$\\tilde{\\pmb B}_I+\\tilde{\\pmb B}_R$必须拟合介质(2)中的合场强$\\tilde{\\pmb E_T}+\\tilde{\\pmb B}_T$，因此当$z=0$时，应有：\n$$\n\\pmb k_I\\cdot \\pmb r=\\pmb k_R\\cdot\\pmb r=\\pmb k_T\\cdot\\pmb r\n$$\n保证指数项相等，因此，对所有的$x$和$y$有：\n$$\nx(k_I)_x+y(k_I)_y=\nx(k_R)_x+y(k_R)_y=\nx(k_T)_x+y(k_T)_y\n$$\n对$x=0$，有\n$$\n(k_I)_y=(k_R)_y=(k_T)_y\n$$\n对$y=0$，有\n$$\n(k_I)_x=(k_R)_x=(k_T)_x\n$$\n因此，通过改变坐标轴的方向，我们可以使得$\\pmb k_I$、$\\pmb k_R$和$\\pmb k_T$均在xz平面内，至此，我们可以得出几何光学的三个基本定律：\n  入射光、反射光和折射光矢量在同一个平面内（称为入射面），入射面法线也在入射面内，同时满足：\n$$\nk_I\\sin\\theta_I=k_R\\sin\\theta_R=k_T\\sin\\theta_T\n$$\n式中，$\\theta_I$为入射角，$\\theta_R$为反射角，$\\theta_T$为折射角，都是相对于法线方向考虑\n  由于$k_1v_1=k_Rv_1=\\omega$，因此$k_I=k_R$，于是有入射角等于反射角：\n$$\n\\theta_I=\\theta_R\n$$\n即反射定律\n  由$k_Iv_1=k_Tv_2=\\omega$，可得\n$$\nk_I=\\frac{n_1}{n_2}k_T\n$$\n因此有\n$$\n\\frac{\\sin\\theta_T}{\\sin\\theta_I}=\\frac{n_1}{n_2}\n$$\n即折射定律，又称斯涅尔定律\n  回到边界条件问题，我们已经可以将指数项进行抵消，则可以得到下述新的边界条件方程：\n$$\n\\begin{aligned}\n\\varepsilon_1(\\tilde {\\pmb E}_ {0I}+\\tilde{\\pmb E}_ {0R})_z\u0026amp;=\\varepsilon_2(\\tilde {\\pmb E}_ {0T})_z\\\\\\\\\n(\\tilde {\\pmb B}_{0I}+\\tilde{\\pmb B}_ {0R})_z\u0026amp;=(\\tilde {\\pmb B}_ {0T})_z\\\\\\\\\n(\\tilde{\\pmb E}_{0T}+\\tilde {\\pmb E}_ {0R})_{x,y}\u0026amp;=(\\tilde {\\pmb E}_ {0T})_{x,y}\\\\\\\\\n\\frac{1}{\\mu_1}(\\tilde{\\pmb B}_ {0T}+\\tilde {\\pmb B}_ {0R})_{x,y}\u0026amp;=\\frac{1}{\\mu_2}(\\tilde {\\pmb B}_ {0T})_{x,y}\n\\end{aligned}\n$$\n其中，$\\tilde{\\pmb B}_0=(1/v)\\hat{\\pmb k}\\times\\tilde{\\pmb E}_0$\n为了简化问题，假设入射波的电场的偏振方向平行于入射面，即图中的$xz$平面，这样一来反射和透射波的电场的偏振方向也在这个面内，则边界条件方程可表示为：\n$$\n\\begin{align}\n\\varepsilon_1(-\\tilde E_{0I}\\sin\\theta_I+\\tilde E_{0R}\\sin\\theta_R)\u0026amp;=\\varepsilon_2(-\\tilde E_{0T}\\sin\\theta_T)\\\\\\\\\n\\tilde E_{0I}\\cos\\theta_I+\\tilde E_{0R}\\cos\\theta_R\u0026amp;=\\tilde{E}_{0T}\\cos\\theta_T\\\\\\\\\n\\frac{1}{\\mu_1v_1}(\\tilde E_{0I}-\\tilde E_{0R})\u0026amp;=\\frac{1}{\\mu_2v_2}\\tilde E_{0T}\n\\end{align}\n$$\n由反射定律和折射定律，上式可简化为：\n$$\n\\begin{aligned}\n\\tilde E_{0I}-\\tilde E_{0R}\u0026amp;=\\beta\\tilde E_{0T}\\\\\\\\\n\\tilde E_{0I}+\\tilde E_{0R}\u0026amp;=\\alpha\\tilde E_{0T}\n\\end{aligned}\n$$\n其中，\n$$\n\\begin{align}\n\\alpha\u0026amp;\\equiv\\frac{\\cos\\theta_T}{\\cos\\theta_I}\\\\\\\\\n\\beta\u0026amp;\\equiv\\frac{\\mu_1v_1}{\\mu_2v_2}=\\frac{\\mu_1n_2}{\\mu_2n_1}\n\\end{align}\n$$\n解得：\n$$\n\\begin{aligned}\n\\tilde E_{0R}\u0026amp;=\\left(\\frac{\\alpha-\\beta}{\\alpha+\\beta}\\right)\\tilde E_{0I}\\\\\\\\\n\\tilde E_{0T}\u0026amp;=\\left(\\frac{2}{\\alpha+\\beta}\\right)\\tilde E_{0I}\n\\end{aligned}\n$$\n上式则是大名鼎鼎的菲涅尔方程了，可以看到透射波和反射波的振幅受入射角度影响，因为$\\alpha$是关于$\\theta_I$的函数：\n$$\n\\alpha=\\frac{\\sqrt{1-\\sin^2\\theta_T}}{\\cos\\theta_I}=\\frac{\\sqrt{1-[(n_1/n_2)\\sin\\theta_I]^2}}{\\cos\\theta_I}\n$$\n反射率和透射率随入射角度的变化如下图所示：\n而且可以看到，当$\\alpha=\\beta$时，即\n$$\n\\sin^2\\theta_B=\\frac{1-\\beta^2}{(n_1/n_2)^2-\\beta^2}\n$$\n反射波完全消失，$\\theta_B$成为布鲁斯特角。而当入射角$\\theta_I=90°$时，$\\tilde E_{0R}=\\tilde E_{0I}$，入射光全部反射，因此当光打在一个球体上，球面掠角方向应会有反光现象：\n再从能量角度看，单位入射面上的功率为$\\pmb S\\cdot\\hat{\\pmb z}$，入射强度为：\n$$\nI_I=\\frac{1}{2}\\varepsilon_1v_1E_{0I}^2\\cos\\theta_I\n$$\n反射和折射强度分别为：\n$$\n\\begin{align}\nI_R\u0026amp;=\\frac{1}{2}\\varepsilon_1v_1E_ {0R}^2\\cos\\theta_R\\\\\\\\\nI_T\u0026amp;=\\frac{1}{2}\\varepsilon_2v_2E_ {0T}^2\\cos\\theta_T\n\\end{align}\n$$\n反射系数和透射系数为：\n$$\n\\begin{aligned}\nR\u0026amp;\\equiv\\frac{I_R}{I_I}=\\left(\\frac{E_{0R}}{E_{0I}}\\right)^2=\\left(\\frac{\\alpha-\\beta}{\\alpha+\\beta}\\right)^2\\\\\\\\\nI_T\u0026amp;\\equiv\\frac{I_T}{I_I}=\\frac{\\varepsilon_2v_2}{\\varepsilon_1v_1}\\left(\\frac{E_{0T}}{E_{0I}}\\right)^2\\frac{\\cos\\theta_T}{\\cos\\theta_I}=\\alpha\\beta\\left(\\frac{2}{\\alpha+\\beta}\\right)^2\n\\end{aligned}\n$$\n4.4.2. Schlick近似 在实际渲染中，对菲涅尔项的处理经常采用Schlick近似方法进行逼近：\n$$\nR(\\theta)=R_0+(1-R_0)(1-\\cos\\theta)^5\n$$\n其中，\n$$\nR_0=\\left(\\frac{n_1-n_2}{n_1+n_2}\\right)^2\n$$\n4.5. 镜面反射项 至此，我们已经详细推导了基于物理的BRDF中镜面反射项的三个重要组成部分：\n 法线分布函数$D(\\pmb m)$ 几何函数$G(\\pmb m,\\pmb v)$ 菲涅尔项$F(\\pmb v,\\pmb m)$  现在来研究如何将这三项整合到我们的PBR着色模型中。\n4.5.1. 半矢量 前面已经简单介绍过半矢量$\\pmb h$的概念，这里再提一下。如上图所示，只有当入射光通过微表面反射后能够沿着视角方向的反射光才能对BRDF有贡献，因此我们定义使得反射光能够沿视角方向的法向量为半矢量：\n$$\n\\pmb h=\\widehat{\\pmb v+\\pmb l}\n$$\n在渲染中，我们常用半矢量$\\pmb h$代替微表面法向$\\pmb m$。\n下面推导中，我们采用的符号意义如上图所示\n4.5.2. Torrance-Sparrow模型 Torrance-Sparrow模型是微表面BRDF的一个经典模型，其镜面反射项与IlumEngine中所用的Cook-Torrance BRDF几乎一致，这里以Torrance-Sparrow模型为例推导从微表面模型到基于物理的BRDF。\n微表面上方向为$\\pmb \\omega_h$的微元面积为：\n$$\n\\mathrm dA(\\pmb \\omega_h)=D(\\pmb \\omega_h)\\mathrm d\\pmb \\omega_h\\mathrm dA\n$$\n因此微元面积上的辐射通量为：\n$$\n\\begin{align}\n\\mathrm d\\Phi_h\u0026amp;=L_i(\\pmb \\omega_i)\\mathrm d\\pmb \\omega_i\\mathrm dA^\\perp(\\pmb \\omega_h)\\\\\\\\\n\u0026amp;=L_i(\\pmb \\omega_i)\\mathrm d\\pmb \\omega_i\\cos\\theta_h\\mathrm dA(\\pmb \\omega_h)\\\\\\\\\n\u0026amp;=L_i(\\pmb \\omega_i)\\mathrm d\\pmb \\omega_i\\cos\\theta_hD(\\pmb \\omega_h)\\mathrm d\\pmb \\omega_h\\mathrm dA\n\\end{align}\n$$\n又由菲涅尔定律，出射辐射通量有：\n$$\n\\mathrm d\\Phi_o=F(\\pmb \\omega_o)\\mathrm d\\Phi_h\n$$\n又根据辐亮度定义：\n$$\nL(\\pmb \\omega_o)=\\frac{\\mathrm d\\Phi_o}{\\mathrm d\\pmb \\omega_o\\cos\\theta_o\\mathrm dA}\n$$\n联立有：\n$$\nL(\\pmb \\omega_o)=\\frac{F(\\pmb \\omega_o)L_i(\\pmb \\omega_i)\\mathrm d\\pmb \\omega_iD(\\pmb \\omega_h)\\mathrm d\\pmb \\omega_h\\mathrm dA\\cos\\theta_h}{\\mathrm d\\pmb \\omega_o\\mathrm dA\\cos\\theta_o}\n$$\n但是对半矢量$\\pmb \\omega_h$是困难的，我们将其转化为简单地对$\\pmb \\omega_o$采样，由立体角公式，我们有：\n$$\n\\frac{\\mathrm d\\pmb \\omega_h}{\\mathrm d\\pmb \\omega_i}=\\frac{\\sin\\theta_h\\mathrm d\\theta_h\\mathrm d\\phi_h}{\\sin\\theta_i\\mathrm d\\theta_i\\mathrm d\\phi_i}\n$$\n如下图所示，\n由反射定律，显然有$\\theta_i=2\\theta_h$，又由反射面性质，有$\\phi_i=\\phi_h$，因此，\n$$\n\\begin{align}\n\\frac{\\mathrm d\\pmb \\omega_h}{\\mathrm d\\pmb \\omega_i}=\\frac{\\mathrm d\\pmb \\omega_h}{\\mathrm d\\pmb \\omega_o}\n\u0026amp;=\\frac{\\sin\\theta_h\\mathrm d\\theta_h\\mathrm d\\phi_h}{\\sin\\theta_i\\mathrm d\\theta_i\\mathrm d\\phi_i}\\\\\\\\\n\u0026amp;=\\frac{\\sin\\theta_h\\mathrm d\\theta_h\\mathrm d\\phi_h}{2\\sin2\\theta_h\\mathrm d\\theta_h\\mathrm d\\phi_h}\\\\\\\\\n\u0026amp;=\\frac{1}{4\\cos\\theta_h}\\\\\\\\\n\u0026amp;=\\frac{1}{4(\\pmb \\omega_i\\cdot\\pmb \\omega_h)}=\\frac{1}{4(\\pmb \\omega_o\\cdot\\pmb \\omega_h)}\n\\end{align}\n$$\n代入到辐亮度求算公式，有：\n$$\nL(\\pmb \\omega_o)=\\frac{F(\\pmb \\omega_o)L_i(\\pmb \\omega_i)D(\\pmb \\omega_h)\\mathrm d\\pmb \\omega_i}{4\\cos\\theta_o}\n$$\n进一步考虑几何函数，则BRDF可以写为：\n$$\nf_r(\\pmb \\omega_o,\\pmb \\omega_i)=\\frac{F(\\pmb \\omega_o)G(\\pmb \\omega_o,\\pmb \\omega_i)D(\\pmb \\omega_h)}{4\\cos\\theta_o\\cos\\theta_i}=\\frac{F(\\pmb \\omega_o)G(\\pmb \\omega_o,\\pmb \\omega_i)D(\\pmb \\omega_h)}{4(\\pmb \\omega_o\\cdot \\pmb n)(\\pmb \\omega_i\\cdot \\pmb n)}\n$$\n至此，我们的基于物理BRDF的镜面反射项推导完成。\n5. PBR着色模型 5.1. Cook-Torrance BRDF 综合前述推导，我们得到Cook-Torrance BRDF的最终形式：\n$$\nf_r(\\pmb \\omega_o,\\pmb \\omega_i)=(1-F(\\pmb\\omega_o))\\frac{\\rho}{\\pi}+\\frac{F(\\pmb \\omega_o)G(\\pmb \\omega_o,\\pmb \\omega_i)D(\\pmb \\omega_h)}{4(\\pmb \\omega_o\\cdot \\pmb n)(\\pmb \\omega_i\\cdot \\pmb n)}\n$$\n其中，\n  $\\rho$为Albedo，材质的颜色\n  $F(\\pmb\\omega_o)$为菲涅尔系数，选用Schlick近似\n$$\n\\begin{align}\nF(\\theta)\u0026amp;=F_0+(1-F_0)(1-\\cos\\theta)^5\\\\\\\\\nF_0\u0026amp;=\\left(\\frac{n_1-n_2}{n_1+n_2}\\right)^2\n\\end{align}\n$$\n  $D(\\pmb \\omega_h)$为法线分布函数，选用GGX分布\n$$\nD(\\pmb \\omega_h)=\\frac{\\alpha^2}{\\pi((\\pmb n\\cdot \\pmb \\omega_h)^2(\\alpha^2-1)+1)^2}\n$$\n  $G(\\pmb\\omega_o,\\pmb\\omega_i)$为几何函数，选用Smith分布的Schlick近似\n$$\nG(\\pmb \\omega_o,\\pmb\\omega_i)=\\frac{\\pmb \\omega_o\\cdot\\pmb\\omega_h}{(\\pmb \\omega_o\\cdot\\pmb\\omega_h)(1-k)+k}\n$$\n其中，$k=\\frac{(\\alpha+1)^2}{8}$\n  5.2. 金属工作流 Cook-Torrance BRDF中的Schlick近似的菲涅尔公式只能用于描述电介质材质（水、玻璃），对于导体（如金属）则需要使用另外一个菲涅尔公式，对材质设计造成不变，金属工作流则使用金属度参数进行插值金属属性，使得菲涅尔公式同时可以用于描述电介质和导体，非金属的$F_0$默认为0.04，而金属的$F_0$则为表面颜色，通过金属度插值$F_0$的GLSL代码如下：\n1 2  vec3 F0 = vec3(0.04); F0 = mix(F0, albedo, metallic);   不同金属度和粗糙度的着色结果：\n    Roughness = 0.1 Roughness = 0.4 Roughness = 0.7 Roughness = 1.0     Metallic = 0.1       Metallic = 0.4       Metallic = 0.7       Metallic = 1.0        5.3. 多次弹射Kulla-Conty能量补偿 前述的微表面模型仅考虑光线与微表面的单次反射，而不考虑光线多次弹射的结果，这将带来能量损失的问题，具体表现为当材质粗糙度越大时，物体的亮度越低，如下图所示：\nHeitz于2016年给出了能量补偿问题的精确解，但由于计算量过大并不适合于实时渲染，Kulla和Conty则给出了一种近似的能量补偿算法。\n首先，定义给定出射方向$\\mu_o$二维BRDF lobe的总能量，这个能量表示了单次弹射的能量占比：\n$$\nE(\\mu_o)=\\int_0^{2\\pi}\\int_0^1f(\\mu_o,\\mu_i,\\phi)\\mu_i\\mathrm d\\mu_i\\mathrm d\\phi\n$$\n在半球上进行积分，其中$\\mu=\\sin\\theta$\nKulla-Conty方法的核心思想是设计另外一个BRDF，满足积分为$1-E(\\mu_0)$，则这个能量将作为能量补偿项。\n通过经验性的拼凑，凑出了一个满足要求的BRDF函数：\n$$\nf_{ms}(\\mu_o,\\mu_i)=\\frac{(1-E(\\mu_o))(1-E(\\mu_i))}{\\pi(1-E_{avg})}\n$$\n其中，\n$$\nE_{\\mathrm{avg}}=2\\int_0^1E(\\mu)\\mu\\mathrm d\\mu\n$$\n验证一下$f_{ms}(\\mu_o,\\mu_i)$是否满足要求：\n$$\n\\begin{align}\nE_{ms}(\\mu_o)\n\u0026amp;=\\int_0^{2\\pi}\\int_0^1f_{ms}(\\mu_o,\\mu_i,\\phi)\\mu_i\\mathrm d\\mu_i\\mathrm d\\phi\\\\\\\\\n\u0026amp;=2\\pi\\int_0^1\\frac{(1-E(\\mu_o))(1-E(\\mu_i))}{\\pi(1-E_{\\mathrm{avg}})}\\mu_i\\mathrm d\\mu_i\\\\\\\\\n\u0026amp;=2\\frac{1-E(\\mu_o)}{1-E_{\\mathrm {avg}}}\\int_0^1(1-E(\\mu_i))\\mu_i\\mathrm d\\mu_i\\\\\\\\\n\u0026amp;=\\frac{1-E(\\mu_o)}{1-E_{\\mathrm {avg}}}(1-E_{\\mathrm {avg}})\\\\\\\\\n\u0026amp;=1-E(\\mu_o)\n\\end{align}\n$$\n确实是可以的。\n然而$E(\\mu)$和$E_{\\mathrm {avg}}$都没有解析表达，因此在实际开发中应使用预计算的方法，用贴图预存积分结果。\n对于$E(\\mu)$，采用一张单通道二维贴图进行存储，从上到下粗糙度依次增加，从左到右$\\mu$依次增加\n对于$E_{\\mathrm{avg}}$，采用一张单通道一维贴图进行存储，为了可视化方便，这里仍采用二维贴图进行展示，从上到下粗糙度依次增加\n从上图中可以看到的能量，在粗糙度低时微表面能量损失少，能量多存储结果较大；在粗糙度高时微表面能量损失多，能量少结果偏黑，与我们的认知是一致的。\n截至目前，我们仅讨论没有颜色的BRDF的能量补偿情况，对于具有颜色的BRDF，意味着会发生能量的吸收，能量将发生损失，因此我们仍需要计算损失的能量。\n定义平均菲涅尔系数（表示了被反射的能量的多少）：\n$$\nE_{\\mathrm{avg}}=\\frac{\\int_0^1F(\\mu)\\mu\\mathrm d\\mu}{\\int_0^1\\mu\\mathrm d\\mu}=2\\int_0^1F(\\mu)\\mu\\mathrm d\\mu\n$$\n因此带有颜色的反射能量为：$F_{\\mathrm{avg}}E_{\\mathrm{avg}}$\n 一次弹射之后：$F_{\\mathrm{avg}}(1-E_{\\mathrm{avg}})\\cdot F_{\\mathrm{avg}}E_{\\mathrm{avg}}$ …… $k$次弹射之后：$F_{\\mathrm{avg}}^k(1-E_{\\mathrm{avg}})^k\\cdot F_{\\mathrm{avg}}E_{\\mathrm{avg}}$  等比数列求和得到颜色项：\n$$\n\\sum_{k=0}^\\infty F_{\\mathrm{avg}}^k(1-E_{\\mathrm{avg}})^k\\cdot F_{\\mathrm{avg}}E_{\\mathrm{avg}}=\\frac{F_{\\mathrm{avg}}E_{\\mathrm{avg}}}{1-F_{\\mathrm{avg}}(1-E_{\\mathrm{avg}})}\n$$\n其中$F_{\\mathrm{avg}}$也没有很好求，不过有一种近似的计算方法：\n$$\n\\begin{aligned}\nF_{\\mathrm{avg}}(r,g)\u0026amp;\\approx 0.087237 + 0.0230685g - 0.0864902g^2 + 0.0774594g^3\\\\\\\\\n\u0026amp;+ 0.782654r - 0.136432r^2 + 0.278708r^3\\\\\\\\\n\u0026amp;+ 0.19744gr + 0.0360605g^2r - 0.2586gr^2;\n\\end{aligned}\n$$\n其中$r$为反射率，$g$为边缘色调，通常取$r$为Albedo颜色，$g=(0.827, 0.792, 0.678)$即可\n下图展示了Kulla-Conty能量补偿的结果，其中上面一行为进行能量补偿的结果，下一行为未进行能量补偿的结果\n6. 参考资料 【基于物理的渲染（PBR）白皮书】（一） 开篇：PBR核心知识体系总结与概览\n【基于物理的渲染（PBR）白皮书】（二） PBR核心理论与渲染光学原理总结\n【基于物理的渲染（PBR）白皮书】（四）法线分布函数相关总结\n【基于物理的渲染（PBR）白皮书】（五）几何函数相关总结\nAkenine-Moller, Tomas, Eric Haines, and Naty Hoffman. Real-time rendering. AK Peters/crc Press, 2019.\nPharr, Matt, Wenzel Jakob, and Greg Humphreys. Physically based rendering: From theory to implementation. Morgan Kaufmann, 2016.\nGAMES202:高质量实时渲染\nGriffiths, David J. \u0026ldquo;Introduction to electrodynamics.\u0026rdquo; (2005): 574-574.\n","description":"PBR着色的相关理论推导与实现","id":17,"section":"posts","tags":["Real-time Rendering"],"title":"基于物理的实时渲染方法","uri":"https://chaphlagical.github.io/zh/posts/rendering/pbr/"},{"content":"我将在这里分享有趣的知识与技术\n","description":"My Blog","id":18,"section":"","tags":null,"title":"简介","uri":"https://chaphlagical.github.io/zh/about/"}]