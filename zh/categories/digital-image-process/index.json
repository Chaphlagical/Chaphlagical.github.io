[{"content":"1. 样条曲面简介 当输入为一维时，将得到曲线，而将输入变为二维时，则可以得到曲面输出\n1.1. 参数样条曲面  两个参数坐标$(u,v)$ 分段双变量多项式 多片合成连续的完整一片 每个片元称为样条块Spline Patch  有两种方法进行建模：\n 张量积曲面Tensor Product Surface 全度曲面Total Degree Surface  1.2. 张量积曲面  构造简单 与曲线的情况类似 四边形块Quad Patch 度数各向异性  1.3. 全度曲面  不够直接，可借助极形式进行理解 度数各向同性 三角形块Triangle Patch 曲线的自然泛化  2. 张量积曲面 2.1. 基本思想 给定一个$n$维基函数空间\n$$\n\\pmb B^{(curv)}:=\\{b_1(t),\\cdots,b_n(t)\\}\n$$\n其中，$b_i(t):t\\in[t_0,t_1]\\rightarrow \\mathbb R^d$\n构建一个双参数基函数空间：\n$$\n\\pmb{B}^{(surf)}=\\{b_i(u)b_j(v)\\}_{i,j=1}^n\n$$\n 示例：\n张量积基函数：\n对于单项式基$b_i(t)=t^{i-1}$，有\n 张量积曲面定义为：\n$$\n\\begin{aligned} \\boldsymbol { f } ( u , v ) \u0026amp; = \\sum _ { i = 1 } ^ { n } \\sum _ { j = 1 } ^ { n } b _ { i } ( u ) b _ { j } ( v ) \\boldsymbol { p } _ { i , j } \\\\\\\\ \u0026amp; = \\sum _ { i = 1 } ^ { n } b _ { i } ( u ) \\sum _ { j = 1 } ^ { n } b _ { j } ( v ) \\boldsymbol { p } _ { i , j } \\\\\\\\ \u0026amp; = \\sum _ { j = 1 } ^ { n } b _ { j } ( v ) \\sum _ { i = 1 } ^ { n } b _ { i } ( u ) \\boldsymbol { p } _ { i , j } \\end{aligned}\n$$\n ”曲线的曲线“ 顺序无关性  基本性质：\n 线性不变性 当$\\sum_{i=1}^n b_i(t)=1$时，具有仿射不变性 当$b_i(t)\\ge 0$时，具有凸包性  偏导：\n$$\n\\begin{aligned} \\frac { \\partial ^ { r + s } } { \\partial u ^ { r } \\partial v ^ { s } } \\sum _ { i = 1 } ^ { n } \\sum _ { j = 1 } ^ { n } b _ { i } ( u ) b _ { j } ( v ) \\boldsymbol { p } _ { i , j } \u0026amp; = \\sum _ { j = 1 } ^ { n } \\left( \\frac { d ^ { s } } { d v ^ { s } } b _ { i } \\right) ( v ) \\sum _ { i = 1 } ^ { n } \\left( \\frac { d ^ { r } } { d u ^ { r } } b _ { i } \\right) ( u ) \\boldsymbol { p } _ { i , j } \\\\\\\\ \u0026amp; = \\sum _ { i = 1 } ^ { n } \\left( \\frac { d ^ { r } } { d u ^ { r } } b _ { i } \\right) ( u ) \\sum _ { j = 1 } ^ { n } \\left( \\frac { d ^ { s } } { d v ^ { s } } b _ { j } \\right) ( v ) \\boldsymbol { p } _ { i , j } \\end{aligned}\n$$\n法向量：\n$$\n\\pmb n(u,v)=\\frac{\\dfrac{\\partial \\pmb f}{\\partial u}\\times\\dfrac{\\partial \\pmb f}{\\partial v}}{\\left\\|\\dfrac{\\partial \\pmb f}{\\partial u}\\times\\dfrac{\\partial \\pmb f}{\\partial v}\\right\\|}\n$$\n2.2. 张量积Bézier曲面 2.2.1. 线性插值曲面 双线性曲面\n$$\n\\begin{aligned}\n\\pmb{h}_ 0 \u0026amp;= (1-u)\\pmb{b}_ {00}+u\\pmb{b}_ {10}\\\\\\\\\n\\pmb{h}_ 1 \u0026amp;= (1-u)\\pmb{b}_ {01}+u\\pmb{b}_ {11}\n\\end{aligned}\n$$\n故有：\n$$\n\\begin{aligned}\n\\pmb{x}(u,v) \u0026amp;= (1-v)\\pmb{h}_0 + v\\pmb{h}_1\\\\\\\\\n\u0026amp;= (1-v)((1-u)\\pmb{b}_ {00}+u\\pmb{b}_ {10}) + v((1-u)\\pmb{b}_ {01}+u\\pmb{b}_ {11})\\\\\\\\\n\u0026amp;= ( 1 - u ) ( 1 - v ) \\boldsymbol { b } _ { 00 } + u ( 1 - v ) \\boldsymbol { b } _ { 10 } + ( 1 - u ) v \\boldsymbol { b } _ { 01 } + u v \\boldsymbol { b } _ { 11 }\n\\end{aligned}\n$$\n双线性曲面的导数：\n$$\n\\begin{array} { l } { x _ { u } ( u , v ) = ( 1 - v ) \\left( \\boldsymbol { b } _ { 10 } - \\boldsymbol { b } _ { 00 } \\right) + v \\left( \\boldsymbol { b } _ { 11 } - \\boldsymbol { b } _ { 01 } \\right) } \\\\\\\\ { x _ { v } ( u , v ) = ( 1 - u ) \\left( \\boldsymbol { b } _ { 01 } - \\boldsymbol { b } _ { 00 } \\right) + u \\left( \\boldsymbol { b } _ { 11 } - \\boldsymbol { b } _ { 10 } \\right) } \\\\\\\\ { x _ { u u } ( u , v ) = x _ { v v } ( u , v ) = 0 } \\\\\\\\ { x _ { u v } ( u , v ) = x _ { v u } ( u , v ) = \\boldsymbol { b } _ { 00 } - \\boldsymbol { b } _ { 10 } - \\boldsymbol { b } _ { 01 } + \\boldsymbol { b } _ { 11 } } \\end{array}\n$$\n**双三次曲面**\n$$\n\\begin{array} { l } { \\boldsymbol { b } _ { 00 } ^ { 1 } = ( 1 - u ) ( 1 - v ) \\boldsymbol { b } _ { 00 } + u ( 1 - v ) \\boldsymbol { b } _ { 10 } + ( 1 - u ) v \\boldsymbol { b } _ { 01 } + u v \\boldsymbol { b } _ { 11 } } \\\\\\\\ { \\boldsymbol { b } _ { 10 } ^ { 1 } = ( 1 - u ) ( 1 - v ) \\boldsymbol { b } _ { 10 } + u ( 1 - v ) \\boldsymbol { b } _ { 20 } + ( 1 - u ) v \\boldsymbol { b } _ { 11 } + u v \\boldsymbol { b } _ { 21 } } \\\\\\\\ { \\boldsymbol { b } _ { 01 } ^ { 1 } = ( 1 - u ) ( 1 - v ) \\boldsymbol { b } _ { 01 } + u ( 1 - v ) \\boldsymbol { b } _ { 11 } + ( 1 - u ) v \\boldsymbol { b } _ { 02 } + u v \\boldsymbol { b } _ { 12 } } \\\\\\\\ { \\boldsymbol { b } _ { 11 } ^ { 1 } = ( 1 - u ) ( 1 - v ) \\boldsymbol { b } _ { 11 } + u ( 1 - v ) \\boldsymbol { b } _ { 21 } + ( 1 - u ) v \\boldsymbol { b } _ { 12 } + u v \\boldsymbol { b } _ { 22 } } \\end{array}\n$$\n又有：\n$$\n\\begin{aligned} { \\pmb{x} ( u , v ) } \u0026amp;{ = ( 1 - u ) ( 1 - v ) \\boldsymbol { b } _ { 00 } ^ { 1 } + u ( 1 - v ) \\boldsymbol { b } _ { 10 } ^ { 1 } + ( 1 - u ) v \\boldsymbol { b } _ { 01 } ^ { 1 } + u v \\boldsymbol { b } _ { 11 } ^ { 1 } } \\\\\\\\ \u0026amp;{ = \\sum _ { i = 0 } ^ { 2 } \\sum _ { j = 0 } ^ { 2 } B _ { i } ^ { 2 } ( u ) B _ { j } ^ { 2 } ( v ) \\boldsymbol { b } _ { i , j } } \\end{aligned}\n$$\n2.2.2. Bézier块 使用Bernstein张量积作为基函数：\n$$\n\\boldsymbol { f } ( u , v ) = \\sum _ { i = 0 } ^ { d } \\sum _ { j = 0 } ^ { d } B _ { i } ^ { ( d ) } ( u ) B _ { j } ^ { ( d ) } ( v ) \\boldsymbol { p } _ { i , j }\n$$\n性质：\n 仿射不变性 凸包性 端点插值 边界曲线为边界控制点生成的Bézier曲线  边界的切向量：\n$$\n\\begin{aligned} \\left. \\frac { \\partial } { \\partial u } f ( u , v ) \\right| _ { u = 0 } \u0026amp; = \\sum _ { i = 0 } ^ { d } \\sum _ { j = 0 } ^ { d } B _ { i } ^ { ( d ) } ( v ) B _ { j } ^ { \\prime } ( 0 ) \\boldsymbol { p } _ { i , j } \\\\\\\\ \u0026amp; = d \\sum _ { j = 0 } ^ { d } B _ { j } ^ { ( d ) } ( v ) \\left( \\boldsymbol { p } _ { 1 , j } - \\boldsymbol { p } _ { 0 , j } \\right) \\\\\\\\ \\left. \\frac { \\partial } { \\partial u } \\boldsymbol { f } ( u , v ) \\right| _ { u = 1 } \u0026amp; = d \\sum _ { j = 0 } ^ { d } B _ { j } ^ { ( d ) } ( v ) \\left( \\boldsymbol { p } _ { d , j } - \\boldsymbol { p } _ { d - 1 , j } \\right) \\end{aligned}\n$$\n2.2.3. 连续性   $C^0$：边界控制点匹配\n  $C^1$：边界差值向量匹配\n  2.2.4. 极形式 曲面函数 $F$ 和极形式 $\\pmb{f}$ 分别为：\n$$\n\\begin{array}{ll}\nF:\\mathbb{R}\\times \\mathbb{R} \\to \\mathbb{R}^n \u0026amp; F(u,v)\\\\\\\\\n\\pmb{f}:\\mathbb{R}^d\\times \\mathbb{R}^d \\to \\mathbb{R}^n\n\\end{array}\n$$\n性质：\n  对角性：$\\pmb{f}(u,\\dots,u;v,\\dots,v)=F(u,v)$\n  对称性：$\\pmb{f}(u_1,\\dots,u_n;v_1,\\dots,v_m)=\\pmb{f}(u_{\\pi(1)},\\dots,u_{\\pi(n)};v_1,\\dots,v_{\\pi(m)})$，其中 $\\pi$ 和 $\\mu$ 为任意置换\n  多重仿射性\n$$\n\\begin{aligned}\n\\pmb{f}(u_1,\\dots,\\sum\\alpha_k u_i^{(k)},\\dots,u_n;v_1,\\dots,v_m)\u0026amp;=\\sum \\alpha_k\\pmb{f}(u_1,\\dots,u_i^{(k)},\\dots,u_n;v_1,\\dots,v_m)\\\\\\\\\n\\pmb{f}(u_1,\\dots,u_n;v_1,\\dots,\\sum\\alpha_k v_i^{(k)},\\dots,v_m)\u0026amp;=\\sum \\alpha_k\\pmb{f}(u_1,\\dots,u_n;v_1,\\dots,v_i^{(k)},\\dots,v_m)\\\n\\end{aligned}\n$$\n其中$\\sum \\alpha_k=1$\n  极形式分离$u$和$v$，能用于推导一些性质和算法，类似于曲线情形\nBézier控制点的极形式表示\nde Casteljau算法的极形式表示\n","description":"张量积曲面与","id":5,"section":"posts","tags":["Geometry"],"title":"几何造型(6)：样条曲面","uri":"https://chaphlagical.github.io/zh/posts/geometry/spline_surface/"},{"content":"Bézier曲线和B样条曲线均不能用于表示圆锥曲线（如圆、椭圆、双曲线），我们需要一种更强大的样条曲线表示方法。\n1. 二次曲面与圆锥曲线 1.1. 定义 圆锥曲线可以表示为二次函数的零集：\n$$\n\\begin{aligned}\nax^2+bxy+cy^2+dx+ey+f\u0026amp;=0\\\\\\\\\n\\pmb{x}^\\top\\left[\\begin{matrix}\na \u0026amp; \\frac{b}{2}\\\\\\\\\n\\frac{b}{2} \u0026amp; c\n\\end{matrix}\\right]\n\\pmb{x}\n+\n\\left[\\begin{matrix}\nd \u0026amp; e\n\\end{matrix}\\right]\n\\pmb{x}\n+f=0\n\\end{aligned}\n$$\n 示例：\n圆锥的隐式表示 $Ax^2+By^2=z^2$\n平面的隐式表示 $z=Dx+Ey+F$\n圆锥曲线 $Ax^2+By^2=(Dx+Ey+F)^2$\n 二次曲线是二次方程（任意维数）的零集：\n$$\n\\{\\pmb{x}\\in \\mathbb{R}^d|\\pmb{x}^\\top M \\pmb{x}+\\pmb{b}^\\top \\pmb{x}+\\pmb{c}=0\\}\n$$\n 圆锥曲线是$d=2$时的二次曲线  1.2. 圆锥曲线的类型 记\n$$\nM:= \\left[\\begin{matrix}\na \u0026amp; \\frac{b}{2} \\\\\\\\\n\\frac{b}{2} \u0026amp; c\n\\end{matrix}\\right]\n$$\n$M$的特征值为：\n$$\n\\lambda_{1,2}=\\frac{a+c \\pm \\sqrt{(a-c)^2+b^2}}{2}\n$$\n则：\n 椭圆：$b^2\u0026lt;4ac$，$\\lambda_2\u0026gt;0$  圆：$b=0$，$a=c$   抛物线：$b^2=4ac$，$\\lambda_2=0$ 双曲线：$b^2\u0026gt;4ac$，$\\lambda\u0026lt;0$  1.3. 二次曲线投影 定义：\n 给定一条三维空间中的二次曲线 将$z$坐标设为齐次项$\\omega$，将曲线投影到平面$\\omega=1$说  齐次空间（Homogeneous）二次曲线为：\n$$\n\\pmb{f} ^ { ( h o m ) } ( t ) = \\pmb{p} _ { 0 } + t \\pmb{p} _ { 1 } + t ^ { 2 } \\pmb{p} _ { 2 } = \\left( \\begin{array} { c } { \\pmb{p} _ { 0 } \\cdot x } \\\\\\ { \\pmb{p} _ { 0 } \\cdot y } \\\\\\ { \\pmb{p} _ { 0 } \\cdot \\omega } \\end{array} \\right) + t \\left( \\begin{array} { c } { \\pmb{p} _ { 1 } \\cdot x } \\\\\\ { \\pmb{p} _ { 1 } \\cdot y } \\\\\\ { \\pmb{p} _ { 1 } \\cdot \\omega } \\end{array} \\right) + t ^ { 2 } \\left( \\begin{array} { c } { \\pmb{p} _ { 2 } \\cdot x } \\\\\\ { \\pmb{p} _ { 2 } \\cdot y } \\\\\\ { \\pmb{p} _ { 2 } \\cdot \\omega } \\end{array} \\right)\n$$\n欧氏空间（Euclidean）投影曲线：\n$$\n\\pmb{f} ^ { ( e u c l ) } ( t ) = \\frac { \\left( \\begin{array} { c } { \\pmb{p} _ { 0 } \\cdot x } \\\\\\\\ { \\pmb{p} _ { 0 } \\cdot y } \\end{array} \\right) + t \\left( \\begin{array} { c } { \\pmb{p} _ { 1 } \\cdot x } \\\\\\\\ { \\pmb{p} _ { 1 } \\cdot y } \\end{array} \\right) + t ^ { 2 } \\left( \\begin{array} { c } { \\pmb{p} _ { 2 } \\cdot x } \\\\\\\\ { \\pmb{p} _ { 2 } \\cdot y } \\end{array} \\right) } { \\pmb{p} _ { 0 } \\cdot \\omega + t \\pmb{p} _ { 1 } \\cdot \\omega + t ^ { 2 } \\pmb{p} _ { 2 } \\cdot \\omega }\n$$\n1.3.1. 抛物线 对于抛物线方程\n$$\ny=ax^2\n$$\n参数化为\n$$\n\\begin{cases}\nx=t\\\\\\\\\ny=at^2\n\\end{cases}\n$$\n则齐次空间方程：\n$$\n\\pmb f^{(hom)}(t)=\n\\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix}+\n\\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix}t+\n\\begin{pmatrix}0\\\\a\\\\0\\end{pmatrix}t^2\n$$\n因此投影曲线为：\n$$\n\\pmb f^{(eucl)}=\\frac{\n\\begin{pmatrix}0\\\\0\\end{pmatrix}+\n\\begin{pmatrix}1\\\\0\\end{pmatrix}t+\n\\begin{pmatrix}0\\\\a\\end{pmatrix}t^2\n}{1+0t+0t^2}\n$$\n1.3.2. 椭圆 对椭圆方程：\n$$\n\\frac{x^2}{a^2}+\\frac{y^2}{b^2}=1\n$$\n参数化为：\n$$\n\\begin{cases}\nx=a\\cos\\theta\\\\\\\\\ny=b\\cos\\theta\n\\end{cases}\n$$\n令$t=\\tan\\frac{\\theta}{2}$，当$t\\in[0,1]$时，$\\theta\\in[0,\\frac{\\pi}{4}]$，为四分之一圆，先考虑这四分之一的部分\n则参数方程可化为：\n$$\n\\begin{cases}\nx=\\dfrac{a(1-t^2)}{1+t^2}\\\\\\\\\ny=\\dfrac{2bt}{1+t^2}\n\\end{cases}\n$$\n则齐次空间方程：\n$$\n\\pmb f^{(hom)}(t)=\n\\begin{pmatrix}a\\\\0\\\\1\\end{pmatrix}+\n\\begin{pmatrix}0\\\\2b\\\\0\\end{pmatrix}t+\n\\begin{pmatrix}-a\\\\0\\\\1\\end{pmatrix}t^2\n$$\n因此投影曲线为：\n$$\n\\pmb f^{(eucl)}=\\frac{\n\\begin{pmatrix}a\\\\0\\end{pmatrix}+\n\\begin{pmatrix}0\\\\2b\\end{pmatrix}t+\n\\begin{pmatrix}-a\\\\0\\end{pmatrix}t^2\n}{1+0t+1t^2}\n$$\n1.3.3. 双曲线 对双曲线方程：\n$$\n\\frac{x^2}{a^2}-\\frac{y^2}{b^2}=1\n$$\n参数化为：\n$$\n\\begin{cases}\nx=\\dfrac{a}{\\cos\\theta}\\\\\\\\\ny=b\\tan\\theta\n\\end{cases}\n$$\n令$t=\\tan\\frac{\\theta}{2}$，当$t\\in[0,1]$时，$\\theta\\in[0,\\frac{\\pi}{4}]$，为四分之一圆，先考虑这四分之一的部分\n则参数方程可化为：\n$$\n\\begin{cases}\nx=\\dfrac{a(1+t^2)}{1-t^2}\\\\\\\\\ny=\\dfrac{2bt}{1-t^2}\n\\end{cases}\n$$\n则齐次空间方程：\n$$\n\\pmb f^{(hom)}(t)=\n\\begin{pmatrix}a\\\\0\\\\1\\end{pmatrix}+\n\\begin{pmatrix}0\\\\2b\\\\0\\end{pmatrix}t+\n\\begin{pmatrix}a\\\\0\\\\-1\\end{pmatrix}t^2\n$$\n因此投影曲线为：\n$$\n\\pmb f^{(eucl)}=\\frac{\n\\begin{pmatrix}a\\\\0\\end{pmatrix}+\n\\begin{pmatrix}0\\\\2b\\end{pmatrix}t+\n\\begin{pmatrix}a\\\\0\\end{pmatrix}t^2\n}{1+0t-1t^2}\n$$\n2. 有理Bézier曲线 2.1. 定义 $\\mathbb R^n$上定义的$d$阶有理Bézier曲线：\n 构成$n+1$维上的$d$阶Bézier曲线 最后一维视为齐次项 欧式坐标由投影变换得到  $$\n\\begin{aligned}\n\\pmb f^{(hom)}(t)\u0026amp;=\\sum_{i=0}^nB_i^{(d)}(t)\\pmb p_i,\\quad \\pmb p_i\\in\\mathbb{R}^{n+1}\\\\\\\\\n\\pmb f^{(eucl)}(t)\u0026amp;=\\dfrac{\\sum_{i=0}^nB_i^{(d)}(t)\\begin{pmatrix}p_i^{(1)}\\\\\\vdots\\\\p_i^{(n)}\\end{pmatrix}}{\\sum_{i=0}^nB_i^{(d)}(t)p_i^{(n+1)}}\n\\end{aligned}\n$$\n等价地可写为权重形式：\n$$\n\\begin{aligned}\n\\pmb f^{(eucl)}(t)\u0026amp;=\\dfrac{\\sum_{i=0}^nB_i^{(d)}(t)\\omega_i\\begin{pmatrix}p_i^{(1)}\\\\\\vdots\\\\p_i^{(n)}\\end{pmatrix}}{\\sum_{i=0}^nB_i^{(d)}(t)\\omega_i}\\\\\\\\\n\u0026amp;=\\sum_{i=0}^nq_i(t)\\pmb p_i\n\\end{aligned}\n$$\n其中，\n$$\nq_i(t)=\\dfrac{B_i^{(d)}(t)\\omega_i}{\\sum_{i=0}^nB_i^{(d)}(t)\\omega_i}\n$$\n满足：$\\sum_{i=0}^nq_i(t)=1$\n 几何解释：\n普通的Bézier曲线通过中心投影变换得到有理Bézier曲线\n 2.2. 有理de Casteljau算法 三种计算方法：\n  在$n+1$维上进行计算，最后再投影：$\\boldsymbol { b } _ { i } ^ { ( r ) } ( t ) = ( 1 - t ) \\boldsymbol { b } _ { i } ^ { ( r - 1 ) } ( t ) + t \\boldsymbol { b } _ { i + 1 } ^ { ( r - 1 ) } ( t )$\n  分别计算分子和分母，最后进行除法，类似于第一种\n  每一步都作投影除法：\n$$\n\\begin{aligned}\n\\pmb b_i^{(r)}(t)=(1-t)\\frac{\\omega_i^{(r-1)}(t)}{\\omega_i^{(r)}(t)}\\pmb b_i^{(r-1)}(t)+t\\frac{\\omega_{i+1}^{(r-1)}(t)}{\\omega_i^{(r)}(t)}\\pmb b_{i+1}^{(r-1)}(t)\n\\end{aligned}\n$$\n其中，\n$$\n\\omega_i^{(r)}(t)=(1-t)\\omega_i^{(r-1)}(t)+t\\omega_{i+1}^{(r-1)}(t)\n$$\n  3. 二次有理Bézier曲线 3.1. 二次有理Bézier曲线的标准型 二次有理曲线能够充要地表达圆锥曲线，二次有理Bézier曲线形式如下：\n$$\n\\begin{aligned}\n\\pmb{f} ^ { ( e u c l ) } ( t )\n\u0026amp;= \\frac { B _ { 0 } ^ { ( 2 ) } ( t ) \\omega _ { 0 } \\boldsymbol { p } _ { 0 } + B _ { 1 } ^ { ( 2 ) } ( t ) \\omega _ { 1 } \\boldsymbol { p } _ { 1 } + B _ { 2 } ^ { ( 2 ) } ( t ) \\omega _ { 2 } \\boldsymbol { p } _ { 2 } } { B _ { 0 } ^ { ( 2 ) } ( t ) \\omega _ { 0 } + B _ { 1 } ^ { ( 2 ) } ( t ) \\omega _ { 1 } + B _ { 2 } ^ { ( 2 ) } ( t ) \\omega _ { 2 } }\\\\\\\\\n\u0026amp;=\\frac { (1-t)^2 \\omega _ { 0 } \\boldsymbol { p } _ { 0 } + 2t(1-t) \\omega _ { 1 } \\boldsymbol { p } _ { 1 } + t^2 \\omega _ { 2 } \\boldsymbol { p } _ { 2 } } { (1-t)^2 \\omega _ { 0 } + 2t(1-t) \\omega _ { 1 } + t^2 \\omega _ { 2 } }\n\\end{aligned}\n$$\n只考虑曲线的形状，进行重参数化：\n$$\nt=\\frac{\\tilde{t}}{\\alpha(1-\\tilde{t})+\\tilde{t}}\n$$\n这样一来形状仅与参数$\\alpha$有关\n代入二次有理Bézier曲线形式：\n$$\n\\begin{aligned} f ^ { ( e u c l ) } ( t )\n=\u0026amp; \\frac {\n\\left( \\frac { \\alpha ( 1 - \\tilde { t } ) } { \\alpha ( 1 - \\tilde { t } ) + \\tilde { t } } \\right) ^ { 2 } \\omega _ { 0 } \\boldsymbol { p } _ { 0 }\n+ 2 \\left( \\frac { \\alpha ( 1 - \\tilde { t } ) } { \\alpha ( 1 - \\tilde { t } ) + \\tilde { t } } \\right) \\left( \\frac { \\tilde { t } } { \\alpha ( 1 - \\tilde { t } ) + \\tilde { t } } \\right) \\omega _ { 1 } \\boldsymbol { p } _ { 1 }\n+ \\left( \\frac { \\tilde { t } } { \\alpha ( 1 - \\tilde { t } ) + \\tilde { t } } \\right) ^ { 2 } \\omega _ { 2 } \\boldsymbol { p } _ { 2 }\n}{\n\\left( \\frac { \\alpha ( 1 - \\tilde { t } )} { \\alpha ( 1 - \\tilde { t } ) + \\tilde { t } } \\right) ^ { 2 } \\omega _ { 0 }\n+ 2 \\left( \\frac { \\alpha ( 1 - \\tilde { t } ) } { \\alpha ( 1 - \\tilde { t } ) + \\tilde { t } } \\right) \\left( \\frac { \\tilde { t } } { \\alpha ( 1 - \\tilde { t } ) + \\tilde { t } } \\right) \\omega _ { 1 }\n+ \\left( \\frac { \\tilde { t } } { \\alpha ( 1 - \\tilde { t } ) + \\tilde { t } } \\right) ^ { 2 } \\omega _ { 2 }\n}\\\\\\\\\n= \u0026amp;\\frac { \\alpha ^ { 2 } ( 1 - \\tilde { t } ) ^ { 2 } \\omega _ { 0 } \\boldsymbol { p } _ { 0 } + 2 \\alpha ( 1 - \\tilde { t } ) \\tilde { t } \\omega _ { 1 } \\boldsymbol { p } _ { 1 } + \\tilde { t } ^ { 2 } \\omega _ { 2 } \\boldsymbol { p } _ { 2 } } { \\alpha ^ { 2 } ( 1 - \\tilde { t } ) ^ { 2 } \\omega _ { 0 } + 2 \\alpha ( 1 - \\tilde { t } ) \\tilde { t } \\omega _ { 1 } + \\tilde { t } ^ { 2 } \\omega _ { 2 } }\\\\\\\\\n= \u0026amp;\\frac { \\alpha ^ { 2 } B_0^{(2)}(\\tilde{t}) \\omega _ { 0 } \\boldsymbol { p } _ { 0 } + \\alpha B_1^{(2)}(\\tilde{t}) \\omega _ { 1 } \\boldsymbol { p } _ { 1 } + B_2^{(2)}(\\tilde{t}) \\omega _ { 2 } \\boldsymbol { p } _ { 2 } } { \\alpha ^ { 2 } B_0^{(2)}(\\tilde{t}) \\omega _ { 0 } + \\alpha B_1^{(2)}(\\tilde{t}) \\omega _ { 1 } + B_2^{(2)}(\\tilde{t}) \\omega _ { 2 } }\\\\\\\\\n\\xlongequal{\\alpha=\\sqrt{\\frac{\\omega_2}{\\omega_0}}}\u0026amp;\\frac { B_0^{(2)}(\\tilde{t}) \\omega _ { 2 } \\boldsymbol { p } _ { 0 } + B_1^{(2)}(\\tilde{t}) \\sqrt{\\frac{\\omega_2}{\\omega_0}} \\omega _ { 1 } \\boldsymbol { p } _ { 1 } + B_2^{(2)}(\\tilde{t}) \\omega _ { 2 } \\boldsymbol { p } _ { 2 } } { B_0^{(2)}(\\tilde{t}) \\omega _ { 2 } + B_1^{(2)}(\\tilde{t}) \\sqrt{\\frac{\\omega_2}{\\omega_0}} \\omega _ { 1 } + B_2^{(2)}(\\tilde{t}) \\omega _ { 2 } }\\\\\\\\\n=\u0026amp;\\frac { B_0^{(2)}(\\tilde{t})\\boldsymbol { p } _ { 0 } + B_1^{(2)}(\\tilde{t}) \\sqrt{\\frac{1}{\\omega_0\\omega_2}} \\omega _ { 1 } \\boldsymbol { p } _ { 1 } + B_2^{(2)}(\\tilde{t}) \\boldsymbol { p } _ { 2 } } { B_0^{(2)}(\\tilde{t}) + B_1^{(2)}(\\tilde{t}) \\sqrt{\\frac{1}{\\omega_0\\omega_2}} \\omega _ { 1 } + B_2^{(2)}(\\tilde{t}) }\\\\\\\\\n\\xlongequal{\\omega=\\sqrt{\\frac{1}{\\omega_0\\omega_2}}\\omega_1}\u0026amp;\\frac { B_0^{(2)}(\\tilde{t})\\boldsymbol { p } _ { 0 } + B_1^{(2)}(\\tilde{t}) \\omega \\boldsymbol { p } _ { 1 } + B_2^{(2)}(\\tilde{t}) \\boldsymbol { p } _ { 2 } } { B_0^{(2)}(\\tilde{t}) + B_1^{(2)}(\\tilde{t}) \\omega + B_2^{(2)}(\\tilde{t}) }\n\\end{aligned}\n$$\n得到二次有理Bézier曲线的标准形式\n3.2. 分类 从标准形式出发，设$\\omega_0=\\omega_2=1$，$\\omega_1=\\omega$\n则有：\n $\\omega\u0026lt;1$：椭圆曲线段 $\\omega=1$：抛物线曲线段 $\\omega\u0026gt;1$：双曲线曲线段   证明：\n将参数形式转化为隐式形式，将曲线表示为重心坐标：\n$$\n\\pmb{f}(t)=\\tau_0(t)\\pmb{p}_0+\\tau_1(t)\\pmb{p}_1+\\tau_2(t)\\pmb{p}_2\n$$\n对比有理二次Bézier曲线的标准形式有：\n$$\n\\begin{array}{lll}\n\\tau_0(t) \u0026amp;= \\frac{(1-t)^2\\omega_0}{\\omega(t)}\n\u0026amp;\\Rightarrow 1-t=\\sqrt{\\frac{\\tau_0(t)\\omega(t)}{\\omega_0}}\\\\\\\\\n\\tau_1(t) \u0026amp;= \\frac{2t(1-t)\\omega_1}{\\omega(t)}\\\\\\\\\n\\tau_2(t) \u0026amp;= \\frac{t^2\\omega_2}{\\omega(t)}\n\u0026amp;\\Rightarrow t=\\sqrt{\\frac{\\tau_2(t)\\omega(t)}{\\omega_2}}\\\n\\end{array}\n$$\n其中，\n$$\n\\omega(t)=(1-t)^2\\omega_0+2t(1-t)\\omega_1+t^2\\omega_2\n$$\n则有：\n$$\n\\tau_1(t)\n=2\\frac{\\omega_1}{\\omega(t)}\\sqrt{\\frac{\\tau_0(t)\\omega(t)}{\\omega_0}\\frac{\\tau_2(t)\\omega(t)}{\\omega_2}}\n=2\\omega_1\\sqrt{\\frac{\\tau_0(t)\\tau_2(t)}{\\omega_0\\omega_2}}\n$$\n利用：\n$$\n\\tau_2(t)=1-\\tau_0(t)-\\tau_1(t)\n$$\n整理得到：\n$$\n4\\omega_1^2\\tau_0^2(t)+4\\omega_1^2\\tau_0(t)\\tau_1(t)+\\omega_0\\omega_2\\tau_1^2(t)-4\\omega_1^2\\tau_0(t)=0\n$$\n对于标准形式 $\\omega_0=\\omega_2=1$，$\\omega_1=\\omega$，则\n$$\n4\\omega^2\\tau_0^2(t)+4\\omega^2\\tau_0(t)\\tau_1(t)+\\tau_1^2(t)-4\\omega^2\\tau_0(t)=0\n$$\n这里$\\tau_0$ 和 $\\tau_1$ 就相当于 $x$ 和 $y$，因此，由圆锥曲线的隐式表达可知：\n$$\n\\lambda_{1,2}=\\frac{4\\omega^2+1\\pm\\sqrt{(4\\omega^2-1)^2+16\\omega^4}}{2}\n$$\n得到：\n $\\omega=1$：抛物线 $\\omega\u0026lt;1$：椭圆 $\\omega\u0026gt;1$：双曲线   3.3. 对偶 对于二次有理曲线的一般形式，$t\\in[0,1]$：\n$$\n\\pmb x(t)=\\frac{(1-t)^2\\pmb b_0+2t(1-t)\\omega\\pmb b_1+t^2\\pmb b_2}{(1-t)^2+2t(1-t)\\omega+t^2}\n$$\n对偶段为$t\\in\\mathbb R\\backslash [0,1]$，则可用参数化\n$$\n\\hat t=\\frac{t}{2t-1}\n$$\n当$t\\in(0,\\frac{1}{2})$时，$\\hat t\\in(0,-\\infty)$；当$t\\in(\\frac{1}{2},1)$时，$\\hat t\\in(+\\infty，1)$\n代入二次有理曲线的一般形式可得：\n$$\n\\begin{aligned}\n\\pmb{x}(\\hat{t})\u0026amp;= \\frac { ( 1 - \\hat { t } ) ^ { 2 } \\pmb{p} _ { 0 } + 2 \\hat { t } ( 1 - \\hat { t } ) \\omega \\pmb{p} _ { 1 } + \\hat { t } ^ { 2 } \\pmb{p} _ { 2 } } { ( 1 - \\hat { t } ) ^ { 2 } + 2 \\hat { t } ( 1 - \\hat { t } ) \\omega + \\hat { t } ^ { 2 } }\\\\\\\\\n\u0026amp;= \\frac { ( 1 - t ) ^ { 2 } \\pmb{p} _ { 0 } - 2 t ( 1 - t ) \\omega \\pmb{p} _ { 1 } + t ^ { 2 } \\pmb{p} _ { 2 } } { ( 1 - t ) ^ { 2 } - 2 t ( 1 - t ) \\omega + t ^ { 2 } }\\end{aligned}\n$$\n区别在于$\\omega$取反\n 示例：\n 考虑分母\n$$\n\\omega(t)=(1-t)^2-2t(1-t)\\omega+t^2\n$$\n为一个图像如下的抛物线：\n可推得：\n $\\omega\u0026lt;1$：没有奇异点，椭圆 $\\omega=1$：有一个奇异点，抛物线 $\\omega\u0026gt;1$：有两个奇异点，双曲线  3.4. 圆锥曲线的绘制   先将圆锥曲线的隐式表示转为参数表示：\n$$\n\\begin{cases}\nx=x(t)\\\\\\\\\ny=y(t)\n\\end{cases}\n$$\n  计算二次有理曲线形式：\n$$\n\\pmb f(t)=\\frac{(1-t)^2\\pmb b_0+2t(1-t)\\omega\\pmb b_1+t^2\\pmb b_2}{(1-t)^2+2t(1-t)\\omega+t^2}\n$$\n  求得控制点$\\pmb b_0$，$\\pmb b_1$，$\\pmb b_2$，构成矩阵$P$：\n$$\nP=(\\pmb b_0,\\pmb b_1,\\pmb b_2)\n$$\n  对于采样点$0=t_0=t_1=\\cdots=t_n=1$，构成矩阵：\n$$\nT=\\begin{pmatrix}\n(1-t_0)^2\u0026amp;(1-t_1)^2\u0026amp;\\cdots\u0026amp;(1-t_n)^2\\\\\n2t_0(1-t_0)\u0026amp;2t_1(1-t_1)\u0026amp;\\cdots\u0026amp;2t_n(1-t_n)\\\\\nt_0^2\u0026amp;t_1^2\u0026amp;\\cdots\u0026amp;t_n^2\n\\end{pmatrix}\n$$\n  曲线点由$X=PT$进行计算\n  对于对偶曲线，控制点矩阵为：\n$$\n\\tilde P=(\\pmb b_0,-\\pmb b_1,\\pmb b_2)\n$$\n  对偶曲线由$X=\\tilde PT$进行计算\n  3.5. Farin点 $$\n\\begin{aligned}\n\\overline{\\pmb{f}_ i}\n\u0026amp;=\\frac{1}{2}(\\overline{\\pmb{b}_ i}+\\overline{\\pmb{b}_ {i+1}})\\\\\\\\\n\\pmb{f}_ i\u0026amp;=\\frac{\\omega_ ib_ i+\\omega_{i+1}b_ {i+1}}{\\omega_ i+\\omega_ {i+1}}\n\\end{aligned}\n$$\n满足关系\n$$\n\\frac { \\omega _ { i + 1 } } { \\omega _ { i } } = \\frac { \\left\\| \\pmb{b} _ { i } - \\pmb{f} _ { i } \\right\\| } { \\left\\| \\pmb{b} _ { i + 1 } - \\pmb{f} _ { i } \\right\\| }\n$$\n对于标准形式，有\n$$\n\\pmb{q} _ { 0 } = \\frac { \\pmb{p} _ { 0 } + \\omega _ { 1 } \\pmb{p} _ { 1 } } { 1 + \\omega _ { 1 } } , \\pmb{q} _ { 1 } = \\frac { \\pmb{p} _ { 1 } + \\omega _ { 1 } \\pmb{p} _ { 2 } } { 1 + \\omega _ { 1 } }\n$$\n3.6. 二次有理Bézier曲线的性质 3.6.1. 端点插值 $$\n\\begin{align}\n\\pmb f(0)\u0026amp;=\\pmb b_0\\\\\\\\\n\\pmb f(1)\u0026amp;=\\pmb b_2\n\\end{align}\n$$\n3.6.2. 凸包性质 曲线位于凸包$(\\pmb{b}_ 0,\\pmb{f}_ 0,\\dots,\\pmb{f}_ {n-1},\\pmb{b}_ n)$内\n3.6.3. 导数性质 令：\n$$\n\\pmb f(t)=\\frac{\\sum_{i=0}^nB_i^{(d)}(t)\\omega_i\\pmb p_i}{\\sum_{i=0}^nB_i^{(d)}(t)\\omega_i}=:\\frac{\\pmb p(t)}{\\omega(t)}\n$$\n因此，有\n$$\n\\begin{aligned}\n\\pmb f(t)=\\frac{\\pmb p(t)}{\\omega(t)}\u0026amp;\\Rightarrow\\pmb p(t)=\\pmb f(t)\\omega(t)\\\\\\\\\n\u0026amp;\\Rightarrow \\pmb p'(t)=\\pmb f'(t)\\omega(t)+\\pmb f(t)\\omega'(t)\\\\\\\\\n\u0026amp;\\Rightarrow \\pmb f'(t)=\\frac{\\pmb p'(t)-\\pmb f(t)\\omega'(t)}{\\omega(t)}\n\\end{aligned}\n$$\n对于边界点，有：\n$$\n\\begin{aligned}\n\\pmb{f}^\\prime(0)\u0026amp;=\\frac{d(\\omega_1\\pmb{p}_1-\\omega_0\\pmb{p}_0)-d(\\omega_1-\\omega_0)\\pmb{p}_0}{\\omega_0}=d\\frac{\\omega_1}{\\omega_0}(\\pmb{p}_1-\\pmb{p}_0)\\\\\\\\\n\\pmb{f}^\\prime(1)\u0026amp;=\\frac{d(\\omega_{d}\\pmb{p}_{d}-\\omega_{d-1}\\pmb{p}_{d-1})-d(\\omega_{d}-\\omega_{d-1})\\pmb{p}_{d}}{\\omega_d}=d\\frac{\\omega_{d-1}}{\\omega_d}(\\pmb{p}_d-\\pmb{p}_{d-1})\n\\end{aligned}\n$$\n","description":"有理样条曲线的原理与实现","id":6,"section":"posts","tags":["Geometry"],"title":"几何造型(5)：有理样条曲线","uri":"https://chaphlagical.github.io/zh/posts/geometry/rational/"},{"content":"1. 基本思想 1.1. 仿射组合(Affine Combinations) $n$点的仿射组合为：\n$$\np_{\\pmb\\alpha}=\\sum_{i=1}^n\\alpha_i\\pmb{p}_i\n$$\n其中，$\\sum_{i=1}^n\\alpha_i=1$\n函数 $f$ 对参数 $x_i$ 是仿射的是指：\n$$\nf \\left( x _ { 1 } , \\ldots , \\sum _ { k = 1 } ^ { n } \\alpha _ { k } x _ { i } ^ { ( k ) } , \\ldots , x _ { m } \\right) = \\sum _ { k = 1 } ^ { n } \\alpha _ { k } f \\left( x _ { 1 } , \\ldots , x _ { i } ^ { ( k ) } , \\ldots , x _ { m } \\right)\n$$\n其中，$\\sum_{i=1}^n\\alpha_i=1$\n示例：\n   两点间的仿射插值为：\n$$\n\\pmb{p}_\\alpha = (1-\\alpha)\\pmb{p}_1+\\alpha\\pmb{p}_2\n$$\n  三点间的仿射组合（亦为重心坐标）为：\n$$\n\\pmb{p}=\\alpha\\pmb{p}_1+\\beta\\pmb{p}_2+\\gamma\\pmb{p}_3\n$$\n其中，$\\alpha+\\beta+\\gamma=1$\n系数可用坐标表示：\n$$\n\\alpha = \\frac { \\operatorname { area } \\left( \\Delta \\left( p _ { 2 } , p _ { 3 } , p \\right) \\right) } { \\operatorname { area } \\left( \\Delta \\left( p _ { 1 } , p _ { 2 } , p _ { 3 } \\right) \\right) } ,\n\\beta = \\frac { \\operatorname { area } \\left( \\Delta \\left( p _ { 1 } , p _ { 3 } , p \\right) \\right) } { \\operatorname { area } \\left( \\Delta \\left( p _ { 1 } , p _ { 2 } , p _ { 3 } \\right) \\right) } ,\n\\gamma = \\frac { \\operatorname { area } \\left( \\Delta \\left( p _ { 1 } , p _ { 2 } , p \\right) \\right) } { \\operatorname { area } \\left( \\Delta \\left( p _ { 1 } , p _ { 2 } , p _ { 3 } \\right) \\right) }\n$$\n   1.2. 动机 我们希望：将（分段）多项式曲线表示为迭代线性（仿射）插值的形式\n例如：\n  对于一个多项式：$p(t)=at^3+bt^2+ct+d$\n  能够写为$p(t)=a\\cdot t\\cdot t\\cdot t+b\\cdot t\\cdot t+c\\cdot t+d$\n  将每个变量t解释为单独的参数：\n$$\n\\pmb p(t_1,t_2,t_3)=\\pmb at_1t_2t_3+\\pmb bt_1t_2+\\pmb ct_1+\\pmb d\n$$\n $t_1$控制$\\pmb a+\\pmb b+\\pmb c$方向上的移动 $t_2$控制$\\pmb a+\\pmb b$方向上的移动 $t_3$控制$\\pmb a$方向上的移动    上述方法存在的问题：固定方向，多种表示形式\n  2. 极形式 2.1. 定义 将（分段）多项式曲线表示为迭代线性（仿射）插值的形式的升级版解决方法：极形式/开花\n$n$次多项式$F:\\mathbb{R}\\to\\mathbb{R}$ 的极形式/开花$f:\\mathbb{R}^n\\to\\mathbb{R}$ 是一个满足以下性质的$ d $维函数：\n 对角性Diagonality：$f(t,\\dots,t)=F(t)$ 对称性Symmetry：对任意置换 $\\pi$，$f(t_1,\\dots,t_d)=f(t_{\\pi(1)},\\dots,t_{\\pi(d)})$ 多仿射Multi-affine：$f(t_1,\\dots,\\sum_\\limits{k=1}^n\\alpha_kt_i^{(k)},\\dots,t_d)=\\sum_{k=1}^n\\alpha_k f(t_1,\\dots,t_i^{(k)},\\dots,t_d)$  2.2. 唯一性 多项式 $F(t)$ 与极形式 $f(t_1,\\dots,t_n)$ 是一一对应的，常用多项式的极形式如下：\n 0 次：$f=c_0$ 1 次：$f(t_1)=c_0+c_1t_1$ 2 次：$f(t_1,t_2)=c_0+c_1\\frac{t_1+t_2}{2} + c_2t_1t_2$ 3 次：$f(t_1,t_2,t_3)=c_0+c_1\\frac{t_1+t_2+t_3}{3}+c_2\\frac{t_1t_2+t_2t_3+t_1t_3}{3}+c_3t_1t_2t_3$  一般形式：\n$$\n\\begin{aligned}\nF(t)\u0026amp;=\\sum_{i=0}^n c_i t^i\\\\\\\\\nf(t_1,\\cdots,t_n)\u0026amp;=\\sum_{i=0}^n c_i \\begin{pmatrix}n\\\\\\\\i\\end{pmatrix}^{-1}\\sum_{S\\subseteq\\{1,\\cdots,n\\},|S|=i}\\prod_{j\\in S}t_i\n\\end{aligned}\n$$\n2.3. 泛化 对于高维情况：\n$$\n\\begin{aligned}\nF\u0026amp;:\\mathbb{R}^m\\to \\mathbb{R}^n\\\nf\u0026amp;:\\mathbb{R}^{d\\times m}\\to \\mathbb{R}^n\n\\end{aligned}\n$$\n满足性质\n 对角性 diagonality：$f(\\pmb{t},\\dots,\\pmb{t})=F(\\pmb{t})$ 对称性 symmetry：对任意置换 $\\pi$，$f(\\pmb t_1,\\cdots \\pmb t_d)=f(\\pmb t_ {\\pi(1)},\\cdots,\\pmb t_ {\\pi(d)})$ 多仿射 multi-affine：$f(\\pmb t_1,\\cdots,\\sum_{k=1}^n\\alpha_k\\pmb t_i^{(k)},\\cdots,\\pmb t_d)=\\sum_{k=1}^n\\alpha_kf(\\pmb t_1,\\cdots,\\pmb t_i^{(k)},\\cdots,\\pmb t_d)$  对于参数向量：\n  需要区分点 point 和向量 vectors（点的差值）\n  使用“帽子”记号 $\\hat{v}=p-q$ 来表示向量\n  1向量：$\\hat{1}=1-0,\\hat{\\pmb{1}}=[1,\\dots,1]^\\top-\\pmb{0}$\n  极形式中向量的递归定义：\n$$\n\\begin{aligned}\nf(\\underbrace{t_1,\\dots,t_{n-k}}_{n-k},\\underbrace{\\hat{v}_1,\\dots,\\hat{v}_k}_k)\u0026amp;:=\\\\\\\\\nf(\\underbrace{t_1,\\dots,t_{n-k}}_{n-k},p_1,\\underbrace{\\hat{v}_2,\\dots,\\hat{v}_{k-1}}_{k-1})\u0026amp;-f(\\underbrace{t_1,\\dots,t_{n-k}}_{n-k},q_1,\\underbrace{\\hat{v}_2,\\dots,\\hat{v}_{k-1}}_{k-1})\n\\end{aligned}\n$$\n其中 $\\hat{v}_i=p_i-q_i(i=1,\\dots,k)$\n  2.4. 导数 $$\nf(t_1,\\cdots,t_n)=\\sum_{i=0}^n c_i \\begin{pmatrix}n\\\\\\\\i\\end{pmatrix}^{-1}\\sum_{S\\subseteq\\{1,\\cdots,n\\},|S|=i}\\prod_{j\\in S}t_i\n$$\n  $c_i$与$t=0$处的导数值相关\n  因此有：\n$$\nc_k=\\frac{1}{k!}\\frac{\\mathrm d^k}{\\mathrm dt^k}F(0)=\\begin{pmatrix}n\\\\\\\\k\\end{pmatrix}^{-1}f(\\underbrace{0,\\dots,0}_{n-k},\\underbrace{\\hat{1},\\dots,\\hat{1}}_k)\n$$\n  一般情况：\n$$\n\\frac{\\mathrm d^k}{\\mathrm dt^k}F(t)=\\frac{n!}{(n-k)!}f(\\underbrace{t,\\dots,t}_{n-k},\\underbrace{\\hat{1},\\dots,\\hat{1}}_k)\n$$\n  示例：\n $$\n\\begin{aligned}\nF(t)\u0026amp;=c_0+c_1t+c_2t^2+c_3t^3\\\\\\\\\nf \\left( t _ { 1 } , t _ { 2 } , t _ { 3 } \\right) \u0026amp;= c _ { 0 } + c _ { 1 } \\frac { t _ { 1 } + t _ { 2 } + t _ { 3 } } { 3 } + c _ { 1 } \\frac { t _ { 1 } t _ { 2 } + t _ { 1 } t _ { 3 } + t _ { 2 } t _ { 3 } } { 3 } + c _ { 3 } t _ { 1 } t _ { 2 } t _ { 3 }\\\\\\\\\nF ^ { \\prime } ( t )\n\u0026amp;= 3f(t,t,\\hat{1})\\\\\\\\\n\u0026amp;= 3 \\left[f(t,t,1)-f(t,t,0)\\right]\\\\\\\\\n\u0026amp;= 3 \\left[ \\left( c _ { 0 } + c_1\\frac { 1 + t + t } { 3 } + c _ { 2 } \\frac { 1 t + t t + 1 t } { 3 } + c _ { 3 } 1 t t \\right) - \\left( c _ { 0 } + c_1\\frac { 0 + t + t } { 3 } + c _ { 2 } \\frac { t t } { 3 } \\right) \\right]\\\\\\\\\n\u0026amp;= 3 \\left( c _ { 1 } \\frac { 1 } { 3 } + c _ { 2 } \\frac { 2 t } { 3 } + c _ { 3 } t t \\right)\\\\\\\\\n\u0026amp;= 3 c _ { 3 } t ^ { 2 } + 2 c _ { 2 } t + c _ { 1 }\n\\end{aligned}\n$$\n 2.5. 连续性条件 下列三个条件分别等价\n $F$ 和 $G$ 在 $t$ 点 $C^k$ 连续 $\\forall t_1,\\dots,t_k, f(t,\\dots,t,t_1,\\dots,t_k)=g(t,\\dots,t,t_1,\\dots,t_k)$ $f ( t , \\ldots , t , \\underbrace{\\hat { 1 } , \\ldots , \\hat { 1 }}_k ) = g ( t , \\ldots , t , \\underbrace{\\hat { 1 } , \\ldots , \\hat { 1 }}_k )$   2$\\Leftrightarrow$3证明：\n$$\n\\begin{aligned}\nf(t,\\cdots,t,t_1)\u0026amp;=f(t,\\cdots,t,(t_1-0))\\\\\\\\\n\u0026amp;=t_1f(t,\\cdots,t,1)-f(t,\\cdots,t,0)\\\\\\\\\n\u0026amp;=t_1f(t,\\cdots,t,\\hat 1)\n\\end{aligned}\n$$\n 举例：\n  $\\forall t_1,t_2,t_3$：$f(t_1,t_2,t_3)=g(t_1,t_2,t_3)\\Rightarrow$同一条曲线 $\\forall t_1,t_2$：$f(t_1,t_2,t)=g(t_1,t_2,t)\\Rightarrow$在$t$处$C^2$连续 $\\forall t_1$：$f(t_1,t,t)=g(t_1,t,t)\\Rightarrow$在$t$处$C^1$连续 $f(t,t,t)=g(t,t,t)\\Rightarrow$在$t$处$C^0$连续   2.6. 升阶 给定$ d $次函数 $f(t_1,\\dots,t_d)$，升阶得：\n$$\nf ^ { ( + 1 ) } \\left( t _ { 1 } , \\ldots , t _ { d + 1 } \\right) = \\frac { 1 } { d + 1 } \\sum _ { i = 1 } ^ { d + 1 } f \\left( t _ { 1 } , \\ldots , t _ { i - 1 } , t _ { i + 1 } , \\ldots , t _ { d + 1 } \\right)\n$$\n 注意：$t_i$没了   证明$F^{(+1)}(t)=F(t)$：\n$$\n\\begin{aligned} \\forall t : f ^ { ( + 1 ) } ( t , \\ldots , t ) \u0026amp; = \\left. \\frac { 1 } { d + 1 } \\sum _ { i = 1 } ^ { d + 1 } f \\left( t _ { 1 } , \\ldots , t _ { i - 1 } , t _ { i + 1 } , \\ldots , t _ { d + 1 } \\right) \\right| _ { t _ { 1 } = \\cdots t _ { d + 1 } = t } \\\\\\\\ \u0026amp; = \\frac { 1 } { d + 1 } \\sum _ { i = 1 } ^ { d + 1 } f ( t , \\ldots , t ) \\\\\\\\ \u0026amp; = f ( t , \\ldots , t ) \\end{aligned}\n$$\n 3. Bézier样条的极形式应用 3.1. 回顾De Casteljau算法 之前我们已经推导过构造Bézier曲线的De Casteljau算法：\n$$\n\\pmb b_i^{(r)}=(1-t)\\pmb b_i^{(r-1)}+t\\pmb b_{i+1}^{(r-1)}\n$$\n三次Bézier曲线的构造过程如下图所示：\n3.2. Bézier样条的极形式 根据极形式的仿射组合性质，导出Bernstein基函数的组合形式：\n$$\n\\begin{aligned}\nf(t,\\cdots,t)\n\u0026amp;=(1-t)f(t,\\cdots,t,0)+tf(t,\\cdots,t,1)\\\\\\\\\n\u0026amp;=(1-t)[(1-t)f(t,\\cdots,t,0,0)+tf(t,\\cdots,t,0,1)]+\nt[(1-t)f(t,\\cdots,t,1,0)+tf(t,\\cdots,t,1,1)]\\\\\\\\\n\u0026amp;=(1-t)^2f(t,\\cdots,t,0,0)+2t(1-t)f(t,\\cdots,0,1)+t^2f(t,\\cdots,t,1,1)\\\\\\\\\n\u0026amp;=\\cdots\\\\\\\\\n\u0026amp;=\\sum_{i=0}^n\\begin{pmatrix}n\\\\\\\\i\\end{pmatrix}t^i(1-t)^{n-i}f(\\underbrace{0,\\dots,0}_{n-i},\\underbrace{1,\\dots,1}_i)\\\\\\\\\n\u0026amp;=\\sum_{i=0}^nB_n^i(t)f(\\underbrace{0,\\dots,0}_{n-i},\\underbrace{1,\\dots,1}_i)\n\\end{aligned}\n$$\n因此，我们可以看到：\n  Bézier点为：$\\pmb b_i^{(0)}(t)=f(\\underbrace{0,\\dots,0}_{n-i},\\underbrace{1,\\dots,1}_i)$\n  中间的生成点为：$\\pmb b_i^{(j)}(t)=f(\\underbrace{0,\\dots,0}_{n-i-j},\\underbrace{1,\\dots,1}_i,\\underbrace{t,\\dots,t}_j)$\n  De Casteljau算法递归计算：\n$$\n\\begin{aligned}\n\\pmb b_i^{(j)}(t)\u0026amp;=f(\\underbrace{0,\\dots,0}_ {n-i-j},\\underbrace{1,\\dots,1}_i,\\underbrace{t,\\dots,t}_j)\\\\\\\\\n\u0026amp;=(1-t)f(\\underbrace{0,\\dots,0}_ {n-i-j+1},\\underbrace{1,\\dots,1}_i,\\underbrace{t,\\dots,t}_ {j-1})+tf(\\underbrace{0,\\dots,0}_ {n-i-j},\\underbrace{1,\\dots,1}_ {i+1},\\underbrace{t,\\dots,t}_ {j-1})\\\\\\\\\n\u0026amp;=(1-t)\\pmb b_i^{(j-1)}+t\\pmb b_ {i+1}^{(j-1)}(t)\n\\end{aligned}\n$$\n  示例：\n 仿射组合：\n$$\n\\begin{align}\nb(0,t,1)\u0026amp;=b(0,0(1-t)+1t,1(1-t)+1t)\\\\\\\\\n\u0026amp;=(1-t)b(0,0,1)+tb(0,1,1)\n\\end{align}\n$$\n 3.3. 泛化情况 $f(t)$是$t\\in [u,v]$的$d$阶 Bezier 曲线，$\\pmb{p}$是$f$的极形式，则Bézier点用极形式表示为：\n$$\n\\pmb b_i=p(u,\\cdots,u,v,\\cdots,v)\n$$\n示例：\n 三次Bézier曲线控制点为：\n$\\pmb{p}(u,u,u),\\pmb{p}(u,u,v),\\pmb{p}(u,v,v),\\pmb{p}(v,v,v)$\n 3.4. 换基 给定$n$次多项式$\\pmb p(t)$，反求Bézier控制点${\\pmb b_i}^n_{i=0}$\n计算方法：\n 求出极形式：$\\pmb p(t)\\Rightarrow\\pmb b(t_1,\\cdots,t_n)$ 求出控制点：$\\pmb{b}_ i=\\pmb{b}(\\underbrace{0,\\dots,0}_ {n-i},\\underbrace{1,\\dots,1}_ i)$，其中$i=0,\\cdots,n$  示例：\n $p(t)=1+2t+3t^2-t^3$\n极形式表示：\n$$\n\\pmb{b} \\left( t _ { 0 } , t _ { 1 } , t _ { 2 } \\right) = 1 + 2 \\frac { t _ { 0 } + t _ { 1 } + t _ { 2 } } { 3 } + 3 \\frac { t _ { 0 } t _ { 1 } + t _ { 1 } t _ { 2 } + t _ { 0 } t _ { 2 } } { 3 } - t _ { 0 } t _ { 1 } t _ { 2 }\n$$\n则有\n$$\n\\begin{aligned}\n\\pmb{b}(0,0,0)\u0026amp;=1\\\n\\pmb{b}(0,0,1)\u0026amp;=\\frac{5}{3}\\\n\\pmb{b}(0,1,1)\u0026amp;=\\frac{10}{3}\\\n\\pmb{b}(1,1,1)\u0026amp;=5\\\n\\end{aligned}\n$$\n 3.5. 分段曲线 两条曲线段\n$$\n\\{ \\boldsymbol { p } ( 0,0,0 ) , \\boldsymbol { p } ( 0,0,1 ) , \\boldsymbol { p } ( 0,1,1 ) , \\boldsymbol { p } ( 1,1,1 ) \\} , \\{ p ( 1,1,1 ) , \\boldsymbol { p } ( 1,1,2 ) , \\boldsymbol { p } ( 1,2,2 ) , \\boldsymbol { p } ( 2,2,2 ) \\}\n$$\n3.6. 导数 $$\n\\frac { \\mathrm{d} } { \\mathrm{d} t } F ( t ) = n f ( t , \\ldots , t , \\hat { 1 } ) = n ( f ( t , \\ldots , t , 1 ) - f ( t , \\ldots , t , 0 ) )\n$$\n3.7. 细分  每一次de Casteljau迭代都会产生两个新的控制多边形，分别描述Bézier曲线$f(t)$的左侧和右侧 利用这两个新的控制多边形，可以将该Bézier曲线分割成两条，实现细分  3.8. 升阶 对Bézier曲线$\\pmb b(t_1,\\cdots,t_n)$进行升阶得到：\n$$\n\\pmb{b} ^ { ( + 1 ) } \\left( t _ { 1 } , \\ldots , t _ { n + 1 } \\right) = \\frac { 1 } { n + 1 } \\sum _ { i = 1 } ^ { n + 1 } \\pmb{b} \\left( t _ { 1 } , \\ldots , t _ { i - 1 } , t _ { i + 1 } , \\ldots , t _ { n + 1 } \\right)\n$$\n升阶后曲线 $\\pmb{b}^{(+1)}$ 的 $n+2$ 个控制点 $\\pmb{b}^{(+1)}_ 0,\\dots,\\pmb{b}^{(+1)}_ {n+1}$ 为：\n$$\n\\begin{aligned}\n\\pmb b_i^{(+1)}\u0026amp;=\\pmb b^{(+1)}(\\underbrace{0,\\dots,0}_{n+1-i},\\underbrace{1,\\dots,1}_i)\\\\\\\\\n\u0026amp;=\\frac{i}{n+i}\\pmb b(\\underbrace{0,\\dots,0}_{d+1-i},\\underbrace{1,\\dots,1}_{i-1})+\\left(1-\\frac{i}{n+1}\\right)\\pmb{b}(\\underbrace{0,\\dots,0}_{n-i},\\underbrace{1,\\dots,1}_i)\\\\\\\\\n\u0026amp;=\\frac{i}{n+1}\\pmb b_{i-1}+\\left(1-\\frac{i}{n+1}\\right)\\pmb b_i\n\\end{aligned}\n$$\n特别地，\n$$\n\\begin{aligned}\n\\pmb{b}_0^{(+1)}\u0026amp;=\\pmb{b}_0\\\\\\\\\n\\pmb{b}_{n+1}^{(+1)}\u0026amp;=\\pmb{b}_n\\\n\\end{aligned}\n$$\n4. B样条的极形式应用 4.1. B样条的极形式 分段线性多项式曲线的极形式是存在且唯一的\n给定$k$阶（$k-1$次）B样条曲线$\\pmb x$\n 结向量：$T=(t_0,\\dots,t_{n+k})$ de Boor 点 $\\pmb{d}_0,\\dots,\\pmb{d}_n$  设$\\underline { \\pmb{x} }(u_1,\\dots,u_{k-1})$是$\\pmb{x}(t)$的极形式，则de Boor点可表示为：\n$$\n\\pmb{d}_i=\\underline{\\pmb{x}}(t_{i+1},\\dots,t_{i+k-1})\n$$\n 示例：\n$k=4,n=5$\n 4.2. de Boor算法的极形式 要确定$t$处B样条曲线的值，确定出$t$前后的$k-1$个结：\n$$\nr_{k-1}\\leq\\cdots\\leq r_1\\leq t\\leq s_1\\leq\\cdots\\leq s_{k-1}\n$$\n其中，$r_1\\leq t\u0026lt;s_1$，则中间结点为：\n$$\n\\pmb d_j^l(t)=\\underline {\\pmb x}(r_1,\\cdots,r_{k-1-l-j},\\underbrace{t,\\cdots,t}_l,s_1,\\cdots,s_j)\n$$\n最终的曲线为：\n$$\n\\pmb x(t)=\\pmb d_0^{(k-1)}(t)=\\underline{\\pmb x}(\\underbrace{t,\\cdots,t}_{k-1})\n$$\n 示例：\n$k=4$\n仿射组合：\n对于$t_2\\leq t\u0026lt;t_4$，进行如下迭代：\n ","description":"多项式曲线的极形式应用","id":7,"section":"posts","tags":["Geometry"],"title":"几何造型(4)：极形式和开花算法","uri":"https://chaphlagical.github.io/zh/posts/geometry/polar_form/"},{"content":"事实上，从IlumEngine能够显示东西之初，我就已经搭建了一套基于金属工作流的延迟PBR渲染管线，但之前对于PBR材质模型的理解还不够深入，很多情况下都是以抄公式为主，这次借实现Kulla-Conty对微表面模型能量不守恒的修正，从理论上来深入理解实时PBR着色方法。\n1. 渲染着色的物理原理 从物理角度上看，渲染着色即光与物体的材质表面、材质介质的相互作用后，射入摄像机的结果。\n1.1. 光的物理本质 光是具有一定波长的电磁波，限定自由电荷密度$\\rho$和自由电流密度$\\pmb J$，根据欧姆定律有电流密度正比于电场：\n$$\n\\pmb J=\\sigma \\pmb E\n$$\n对于光在线性介质中的传播，满足麦克斯韦方程组：\n$$\n\\begin{aligned}\n\\nabla \\cdot\\pmb E \u0026amp;= \\frac{1}{\\varepsilon}\\pmb \\rho\\\\\\\\\n\\nabla\\cdot\\pmb B\u0026amp;=0\\\\\\\\\n\\nabla\\times \\pmb E\u0026amp;=-\\frac{\\partial \\pmb B}{\\partial t}\\\\\\\\\n\\nabla\\times \\pmb B\u0026amp;=\\mu\\sigma\\pmb E+ \\mu_0\\varepsilon_0\\frac{\\partial \\pmb E}{\\partial t}\n\\end{aligned}\n$$\n由自由电荷的连续性方程：\n$$\n\\nabla\\cdot\\pmb J=-\\frac{\\partial \\rho}{\\partial t}\n$$\n有：\n$$\n\\frac{\\partial \\rho}{\\partial t}=-\\sigma(\\nabla\\cdot\\pmb E)=-\\frac{\\sigma}{\\varepsilon}\\rho\n$$\n可以解出：\n$$\n\\rho(t)=\\rho(0)e^{-(\\sigma/\\varepsilon)t}\n$$\n看到自由电荷密度$\\rho$以特征时间$\\tau\\equiv \\varepsilon/\\sigma$耗散，\n 对于理想导体，$\\sigma =\\infty$，$\\tau=0$ 对于良导体，$\\tau$比电磁波的角周期小得多：$\\tau\\ll1/\\omega$ 对于不良导体，则$\\tau$比电磁波的角周期大得多：$\\tau\\gg 1/\\omega$  对电场与磁场的旋度再取其旋度，有：\n$$\n\\begin{align}\n\\nabla\\times(\\nabla\\times \\pmb E)\u0026amp;=\\nabla(\\nabla\\cdot\\pmb E)-\\nabla^2\\pmb E=\\nabla\\times(-\\frac{\\partial \\pmb B}{\\partial t})\\\\\\\\\n\u0026amp;=-\\frac{\\partial}{\\partial t}(\\nabla\\times\\pmb B)=-\\mu\\sigma\\frac{\\partial \\pmb E}{\\partial t}-\\mu_0\\varepsilon_0\\frac{\\partial^2\\pmb E}{\\partial t^2}\\\\\\\\\n\\nabla\\times(\\nabla\\times \\pmb B)\u0026amp;=\\nabla(\\nabla\\cdot\\pmb B)-\\nabla^2\\pmb B=\\nabla\\times(\\mu\\sigma\\pmb E+\\mu_0\\varepsilon_0\\frac{\\partial \\pmb E}{\\partial t})\\\\\\\\\n\u0026amp;=\\mu\\sigma(\\nabla\\times\\pmb E) +\\mu_0\\varepsilon_0\\frac{\\partial}{\\partial t}(\\nabla\\times\\pmb E)=-\\mu\\sigma\\frac{\\partial B}{\\partial t}-\\mu_0\\varepsilon_0\\frac{\\partial^2\\pmb B}{\\partial t^2}\n\\end{align}\n$$\n忽略电磁波在线性介质中的瞬态效应，即自由电荷消失，$\\rho=0$，则有：\n$$\n\\begin{align}\n\u0026amp;\\begin{matrix}\n\\nabla \\cdot \\pmb E=0\u0026amp;\\nabla\\cdot \\pmb B=0\n\\end{matrix}\\\\\\\\\n\\Rightarrow\\ \\ \\ \u0026amp;\n\\begin{matrix}\n\\nabla^2\\pmb E=\\mu\\sigma\\dfrac{\\partial \\pmb E}{\\partial t}+\\mu_0\\varepsilon_0\\dfrac{\\partial^2\\pmb E}{\\partial t^2}\n\\\\\\\n\\nabla^2\\pmb B=\\mu\\sigma\\dfrac{\\partial B}{\\partial t}+\\mu_0\\varepsilon_0\\dfrac{\\partial^2\\pmb B}{\\partial t^2}\n\\end{matrix}\n\\end{align}\n$$\n可以得到平面波解：\n$$\n\\begin{aligned}\n\\tilde {\\pmb E}(z,t)=\\tilde{\\pmb E}_0e^{i(\\tilde k z-\\omega t)}\\\\\\\\\n\\tilde {\\pmb B}(z,t)=\\tilde{\\pmb B}_0e^{i(\\tilde k z-\\omega t)}\n\\end{aligned}\n$$\n其中，波数$\\tilde k$为复数：\n$$\n\\tilde k^2=\\mu\\varepsilon\\omega^2+i\\mu\\sigma\\omega\n$$\n取平方根得：\n$$\n\\tilde k=k+i\\kappa\n$$\n其中，\n$$\n\\begin{align}\nk\u0026amp;\\equiv \\omega\\sqrt{\\frac{\\mu\\varepsilon}{2}}\\left[\\sqrt{1+\\left(\\frac{\\sigma}{\\varepsilon\\omega}\\right)^2}+1 \\right]^{1/2}\\\\\\\\\n\\kappa\u0026amp;\\equiv \\omega\\sqrt{\\frac{\\mu\\varepsilon}{2}}\\left[\\sqrt{1+\\left(\\frac{\\sigma}{\\varepsilon\\omega}\\right)^2}-1 \\right]^{1/2}\n\\end{align}\n$$\n提取虚部：\n$$\n\\begin{aligned}\n\\tilde {\\pmb E}(z,t)=\\tilde{\\pmb E}_0e^{-\\kappa z} e^{i(k z-\\omega t)}\\\\\\\\\n\\tilde {\\pmb B}(z,t)=\\tilde{\\pmb E}_0e^{-\\kappa z} e^{i(k z-\\omega t)}\n\\end{aligned}\n$$\n可以看到：\n $\\tilde k$的虚部导致波的衰减，振幅随着$z$的增大而减小，度量了波进入导体的深度，也度量了导体阻尼对波能量的吸收（吸收系数$\\alpha\\equiv 2\\kappa$） $\\tilde k$的实部定义了波的属性，如波长$\\lambda = \\frac{2\\pi}{k}$，波速$v=\\frac{\\omega}{k}$，折射率$n=\\frac{ck}{\\omega}$  综合起来，材质通过影响光的$\\tilde k$，对光的传播效应造成影响，从而带来不同的光照效果。\n在成像理论中，光的吸收对视觉效果有直接影响，将降低光的强度，对特定可见波长的吸收将改变光的颜色。\n在渲染中，通常将材质与光的相互作用归结为散射和吸收两类：\n 散射：决定介质的浑浊程度（下图右） 吸收：决定材质的外观颜色（下图左）  每种介质外观均为散射和吸收两种现象的综合结果：\n1.2. 渲染中的光学模型 从电磁波角度出发可以很方便我们理解光、物质和成像之间的相互关系，但在渲染领域尤其是实时渲染领域，我们常常对问题进行简化，现在，我们只考虑物体的表面着色以及几何光学模型。\n1.2.1. 光与物体表面的交互 当一种介质进入到另一种介质，光线将发生反射、折射及其各种衍生现象：\n 镜面反射：光线在两种介质交界处发生直接反射，满足反射定律 折射：从表面进入介质的光由于介质折射率的变化，传播方向发生改变，出现折射现象，介质中的光将发生吸收和散射 吸收：由前推导，当介质中的吸收系数$\\alpha\u0026gt;0$时，在光传播过程中部分能量将会被介质所吸收 散射：光的传播方向由于折射率的剧烈变化发生改变，分裂为多个方向，但光的总能量保持不变  次表面散射：观察像素小于散射距离  透射：入射光进入介质后又穿过该介质出射   漫反射：观察像素大于散射距离    1.2.2. 不同物质与光的交互 不同物质对光的反射、折射效应有所不同，根据光学特性大致分为金属与非金属两大类：\n 金属：金属的外观取决于材质表面的镜面反射，且入射金属的光不存在散射，会被自由粒子完全吸收 非金属：非金属又称电介质，非金属外观取决于吸收和散射特性：  均匀介质：主要为透明介质，无折射率变化，光总以直线传播，不存在散射，但存在吸收 非均匀介质：通常可建模为具有嵌入散射粒子的均匀介质，具有折射率的变化  浑浊介质：具有弱散射 半透明介质：具有强散射 不透明介质：与半透明介质类似，具有强散射      2. 光线传输基础 2.1. 反射方程 所有的渲染方法其实就是在干一件事，求解渲染方程：\n$$\nL_o(\\pmb p,\\pmb \\omega_o)=L_e(\\pmb p,\\pmb \\omega_o)+\\int_\\Omega f_r(\\pmb p,\\pmb \\omega_i\\rightarrow\\pmb \\omega_o)L_i(\\pmb p,\\pmb \\omega_i)\\cdot(\\pmb \\omega_i\\cdot\\pmb n)\\cdot\\mathrm d\\pmb \\omega_i\n$$\n这里我们不考虑物体的自发光，因此$L_e$项恒为0，渲染方程退化为反射方程：\n$$\nL_o(\\pmb p,\\pmb \\omega_o)=\\int_\\Omega f_r(\\pmb p,\\pmb \\omega_i\\rightarrow\\pmb \\omega_o)L_i(\\pmb p,\\pmb \\omega_i)\\cdot(\\pmb \\omega_i\\cdot\\pmb n)\\cdot\\mathrm d\\pmb \\omega_i\n$$\n其中$f_r(\\pmb p,\\pmb \\omega_i\\rightarrow\\pmb \\omega_o)$定义了入射光与出射光的反射比例，称为BxDF，通常为双向反射分布函数BRDF，在离线渲染中我们还常用到BSDF(=BTDF+BRDF)等：\n2.2. BRDF 2.2.1. 辐射度量学的基本概念 BRDF是定义在辐射度量学上的，简单介绍相关概念：\n辐射能\n光的能量可以由光子动能定义：\n$$\nQ=hv\n$$\n其中$h$为普朗克常量，$v$为光子振动频率，由光的波动性，有：\n$$\nc=\\lambda v\n$$\n因此光的能量也可表示为：\n$$\nQ=\\frac{hc}{\\lambda}\n$$\n其中$\\lambda$为光的波长，$c$为光速，能量的量纲为[$J$]，即Joule\n辐射通量\n辐射通量是单位时间内发射、接收或传输的能量，定义为：\n$$\n\\Phi=\\frac{\\mathrm dQ}{\\mathrm dt}\n$$\n功率的量纲为[$lm$]即Lumen，\n辐射强度Radiant Intensity\n定义为单位立体角的光通量：\n$$\nI=\\frac{\\mathrm d\\Phi}{\\mathrm d\\Omega}\n$$\n辐射强度量纲为$[cd]$即candela\n辐照度Irradiance\n辐照度定义为单位面积的辐射通量：\n$$\nE=\\frac{\\mathrm d\\Phi}{\\mathrm d A}\n$$\n辐照度量纲为$[lx]$即lux\n辐射通量为$\\Phi$的点光源在距离$r$处的球面上的辐照度为：\n$$\nE_e=\\frac{\\Phi}{4\\pi r^2}\n$$\n辐亮度Radiance\n辐亮度定义为单位面积和单位立体角的辐射通量\n$$\nL=\\frac{\\mathrm d^2\\Phi}{\\mathrm d\\Omega\\mathrm dA^\\perp}=\\frac{\\mathrm d^2\\Phi}{\\mathrm d\\Omega\\mathrm dA\\cos\\theta}\n$$\n辐亮度的量纲为$[cd/m^2]$或nits\n辐亮度是成像理论中最经常使用的物理量，因为它最符合人和摄像机成像的辐射度量。\n2.2.2. 双向反射分布函数 对于入射光$L_i(\\pmb p,\\pmb \\omega_i)$，计算它在半球上的辐照度$E$：\n$$\nE(\\pmb p)=\\int_\\Omega L_i(\\pmb p,\\pmb \\omega_i)\\cos\\theta_i\\mathrm d\\pmb \\omega_i\n$$\n即：\n$$\n\\mathrm dE(\\pmb p,\\pmb \\omega_i)=L_i(\\pmb p,\\pmb \\omega_i)\\cos\\theta_i\\mathrm d\\pmb \\omega_i\n$$\n而任意方向上，出射光的辐亮度微分应与入射光辐照度成正比，即：\n$$\n\\mathrm dL_o(\\pmb p,\\pmb \\omega_o)\\propto\\mathrm d E(\\pmb p,\\pmb \\omega_i)\n$$\n该比例定义为关于$\\pmb\\omega_i$和$\\pmb \\omega_o$的双向反射分布函数即BRDF：\n$$\nf_r(\\pmb p, \\pmb \\omega_o,\\pmb \\omega_i)=\\frac{\\mathrm dL_o(\\pmb p,\\pmb \\omega_o)}{\\mathrm d E(\\pmb p,\\pmb \\omega_i)}=\\frac{\\mathrm dL_o(\\pmb p,\\pmb \\omega_o)}{L_i(\\pmb p,\\pmb \\omega_i)\\cos\\theta_i\\mathrm d\\pmb \\omega_i}\n$$\n因此在半球上积分有：\n$$\nL_o(\\pmb p,\\pmb \\omega_o,\\pmb \\omega_i)=\\int_\\Omega f_r(\\pmb p, \\pmb \\omega_o,\\pmb \\omega_i)L_i(\\pmb p,\\pmb \\omega_i)\\cos\\theta_i\\mathrm d\\pmb \\omega_i\n$$\nBRDF的性质：\n 交换律：$f_r(\\pmb p,\\pmb \\omega_o,\\pmb \\omega_i)=f_r(\\pmb p,\\pmb \\omega_i,\\pmb \\omega_o)$ 能量守恒：$\\int_\\Omega f_r(\\pmb p,\\pmb \\omega_o,\\pmb \\omega_i)\\cos\\theta\\mathrm d\\omega\\leq 1$  2.2.3. Cook-Torrance BRDF 本文将主要介绍目前主流的Cook-Torrance BRDF模型，Cook-Torrance BRDF由漫反射项和镜面反射项组成：\n$$\nf_r=k_d\\cdot f_{\\mathrm{diffuse}} +k_s\\cdot f_{\\mathrm{specular}}\n$$\n其中漫反射项使用Lambertian光照模型，镜面反射项使用微表面模型进行建模，随后将具体介绍。\n3. Lambertian漫反射材质模型 Lambertian漫反射模型假定出射光线在各个方向上都是均匀的（强度相等），由反射方程：\n$$\n\\begin{aligned}\nL_o(\\pmb\\omega_o)\u0026amp;=\\int_\\Omega f_rL_i(\\pmb\\omega_i)\\cos\\theta_i\\mathrm d\\pmb \\omega_i\\\\\\\\\n\u0026amp;=f_rL_i\\int_\\Omega \\cos\\theta_i\\mathrm d\\pmb \\omega_i\\\\\\\\\n\u0026amp;=\\pi f_rL_i\n\\end{aligned}\n$$\n为了保证能量守恒，BRDF选择：\n$$\nf_r=\\frac{\\rho}{\\pi}\n$$\n其中$\\rho$为材质颜色Albedo参数，通常有RGB三个分量，当$\\rho=(1,1,1)$时，说明材质为白色，没有吸收任何色光，此时$L_o=L_i$。\n4. 镜面反射模型 4.1. 微表面理论 真实世界中不存在绝对光滑的物体表面，即使是看起来很光滑的表面也具有比光的波长大得多的微尺度不规则性。这种微表面现象将导致每个表面点反射和折射不同方向的光，带来不同的材质外观。\n同时，在微表面作用的光还会因为自遮挡带来阴影和遮罩：\n微表面BRDF很大程度由材质的粗糙度所影响，粗糙度度量了微表面材质表面的粗糙程度，如下图从左到右粗糙度依次降低：\n4.2. 法线分布函数（Normal Distribution Function） 法线分布是描述微表面的一个重要几何性质，通常物体表面会有一个法向量$\\pmb n$，可以认为是物体表面绝对光滑时具有的法向量，但由于微表面具有的各种微小几何结构，局部的表面法向量可能与法向量$\\pmb n$不同，这种局部法向量称为微表面法向量$\\pmb m$，而法线分布函数$D(\\pmb m)$则是描述了微表面法线的分布概率密度。\n在渲染中，常用宏观表面的半矢量$\\pmb h$来表示微表面法向，因为只有$\\pmb m=\\pmb h$的表面点能够将入射光反射到视线方向，而其他朝向的表面点对最终的渲染结果没有贡献\n在整个微表面法线上积分$D(\\pmb m)$将得到微表面的面积，不过更常用的是对$D(\\pmb m)(\\pmb n\\cdot\\pmb m)$进行积分，将$D(\\pmb m)$投影到宏观表面平面上，将得到宏观表面的元面积，规定为1，如下图所示：\n又称为投影$D(\\pmb m)(\\pmb n\\cdot\\pmb m)$的归一化：\n$$\n\\int_{\\pmb m\\in\\Theta}D(\\pmb m)(\\pmb n\\cdot\\pmb m)\\mathrm d{\\pmb m}=1\n$$\n上式中的$\\Theta$表示在整个球体上进行积分，虽然在图形学中的微结构模型多为高度场，即在以$\\pmb n$为中心的半球$\\Omega$以外的所有方向有$D(\\pmb m)\\equiv 0$。\n更一般地，微表面和宏观表面在垂直于任何视图方向$\\pmb v$的平面上的投影总是相等的：\n即：\n$$\n\\int_{\\pmb m\\in\\Theta}D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d{\\pmb m}=\\pmb v\\cdot\\pmb n\n$$\n上式定义了一个合理的法线分布函数应当具有的约束性质，一种直观的理解是一片宏观表面的法向等于其微表面所有法向的均值，至于实际法线分布函数应长什么样，那就有特别多的建模手段得到了，例如，对于绝对光滑的表面，显然$\\pmb m$与$\\pmb n$恒相等，法线分布函数则可以由一个冲激函数进行表示：\n$$\nD(\\pmb m)=\\delta(\\pmb m-\\pmb n)\n$$\n注意到式子$\\int_{\\pmb m\\in\\Theta}D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d{\\pmb m}=\\pmb v\\cdot\\pmb n$中，$\\pmb v\\cdot\\pmb m$的正负不受限制，这是由于投影会产生正负造成抵消，如前图所示，但在实际渲染中，我们常常只关注可见的微表面，即离相机最近的那个微表面，可以通过定义几何函数$G_1(\\pmb m,\\pmb v)$来给出沿着视图向量$\\pmb v$可见的具有法向$\\pmb m$的微平面比例，则原式可改写为：\n$$\n\\int_{m\\in\\Theta}G_1(\\pmb m, \\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)^+\\mathrm d\\pmb m=\\pmb v\\cdot \\pmb m\n$$\n如下图所示，而几何遮蔽函数的具体内容待会将作介绍。\n4.2.1. 法线分布函数的基本性质 法线分布函数是一种概率密度函数，很自然地有如下性质：\n  非负性\n$$\n0\\leq D(\\pmb m)\\leq \\infty\n$$\n  法线分布函数的积分表征了微表面的面积，显然微表面面积应大于等于宏观表面面积\n$$\n\\int_{\\pmb m\\in \\Theta}D(\\pmb m)\\mathrm d\\pmb m\\geq 1\n$$\n  微表面和宏观表面在垂直于任何视图方向$\\pmb v$的平面上的投影总是相等的\n$$\n\\int_{\\pmb m\\in\\Theta}D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d{\\pmb m}=\\pmb v\\cdot\\pmb n\n$$\n  特别地，当视图法向沿着宏观法向时，积分归一化\n$$\n\\int_{\\pmb m\\in\\Theta}D(\\pmb m)(\\pmb n\\cdot\\pmb m)\\mathrm d{\\pmb m}=1\n$$\n  4.2.2. 法线分布函数的形状不变性 形状不变性（shape-invariant）是设计合理法线分布函数的一个重要依据，具有形状不变性的法线分布函数，能够推导该函数归一化的各向异性版本，且可以很方便地推导相应的几何函数项$G$\nHeitz定义各向同性的法线分布函数具有形状不变性即材质粗糙度的影响等价于微表面的拉伸，具有形状不变性的微表面法线分布函数可以表示为以下形式：\n$$\nD(\\pmb m)=\\frac{\\chi^+(\\pmb n\\cdot\\pmb m)}{\\alpha^2(\\pmb n\\cdot\\pmb m)^4}g\\left(\\frac{\\sqrt{1-(\\pmb n\\cdot\\pmb m)^2}}{\\alpha(\\pmb n\\cdot\\pmb m)}\\right)\n$$\n其中$g(\\cdot)$代表一个表示法线分布函数形状的一维函数\n4.2.3. 常用的法线分布函数 Blinn-Phong分布\nBlinn-Phong分布函数具有如下形式：\n$$\nD(\\pmb m)=\\frac{\\alpha_p+2}{2\\pi}(\\pmb n\\cdot\\pmb m)^{\\alpha_p}\n$$\n其中，幂$\\alpha_p$为Blinn-Phong法线分布函数的粗糙度参数，$\\alpha_p$越高，表示表面越光滑，$\\alpha_p$的取值可以是$[0,\\infty)$，$\\alpha_p$参数不便于艺术家进行调节，UE4中采用映射$\\alpha_p=2\\alpha^{-2}-2$，使用材质粗糙度$\\alpha$进行控制，得到的Blinn-Phong法线分布函数如下：\n$$\nD(\\pmb m)=\\frac{1}{\\pi\\alpha^2}(\\pmb n\\cdot\\pmb m)^{(\\frac{2}{\\alpha^2}-2)}\n$$\nBlinn-Phong分布函数不具有形状不变性。\nBeckmann分布\nBeckmann分布函数具有如下形式：\n$$\nD(\\pmb m)=\\frac{1}{\\pi\\alpha^2(\\pmb n\\cdot\\pmb m)^4}\\exp(\\frac{(\\pmb n\\cdot\\pmb m)^2-1}{\\alpha^2(\\pmb n\\cdot\\pmb m)^2})\n$$\n Beckmann分布函数呈高斯函数形态，在对称轴$\\pmb n\\cdot\\pmb m$处取得最值，如下图所示呈现一种中间亮两边暗的渲染效果。  Beckmann分布与Blinn-Phong分布可以通过关系式$\\alpha_p=2\\alpha_b^{-2}-2$进行等效，如下图所示，蓝色虚线为Blinn-Phong分布、绿色实线为Beckmann分布：\nBeckmann分布函数具有形状不变性。\nGGX（Trowbridge-Reitz）分布\nGGX分布函数具有如下形式：\n$$\nD(\\pmb m)=\\frac{\\alpha^2}{\\pi((\\pmb n\\cdot \\pmb m)^2(\\alpha^2-1)+1)^2}\n$$\nGGX是目前业界最流行的微表面法线分布函数模型，因为它在主流模型中拥有最长的尾部，如下图所示，Beckmann分布函数会很快地逼近于0，而GGX能维持较长的一段尾部：\nGGX分布函数具有形状不变性。\nGTR（Generalized-Trowbridge-Reitz）分布\n广义的Trowbridge-Reitz分布，具有如下形式：\n$$\nD(\\pmb m)=\\frac{c}{(1+(\\pmb n\\cdot\\pmb m)^2(\\alpha^2-1))^\\gamma}\n$$\n其中，参数$\\gamma$用于控制函数的尾部形状，当$\\gamma=2$时，则退化为GGX分布。各个$\\gamma$取值与GTR分布曲线的关系如下：\nGTR分布函数不具有形状不变性。\n4.2.4. 各项异性的法线分布函数 我们已知对于一个各向同性的具有形状不变性的法线分布函数，可以用下述形式所表示（考虑定义在正半球上）：\n$$\nD(\\pmb m)=\\frac{1}{\\alpha^2(\\pmb n\\cdot\\pmb m)^4}g\\left(\\frac{\\sqrt{1-(\\pmb n\\cdot\\pmb m)^2}}{\\alpha(\\pmb n\\cdot\\pmb m)}\\right)\n$$\n则对应的各项异性法线分布函数则为：\n$$\nD(\\pmb m)=\\frac{1}{\\alpha_x\\alpha_y(\\pmb n\\cdot\\pmb m)^4}g\\left(\\frac{\n\\sqrt{\\frac{(\\pmb t\\cdot\\pmb m)^2}{\\alpha_x^2}+\\frac{(\\pmb b\\cdot\\pmb m)^2}{\\alpha_y^2}}}{\\pmb n\\cdot\\pmb m}\\right)\n$$\n其中，$\\alpha_x$和$\\alpha_y$分别表示沿切线$\\pmb t$方向和副法线$\\pmb b$方向的粗糙度，当$\\alpha_x=\\alpha_y$时，则退化为各向同性的形式。\n各向异性的Beckmann分布\n$$\nD(\\pmb m)=\\frac{1}{\\pi\\alpha_x\\alpha_y(\\pmb n\\cdot\\pmb m)^4}\\exp\\left(\n-\\frac{\\frac{(\\pmb t\\cdot\\pmb m)^2}{\\alpha_x^2}+\\frac{(\\pmb b\\cdot\\pmb m)^2}{\\alpha_y^2}}{(\\pmb n\\cdot\\pmb m)^2}\\right)\n$$\n各项异性的GGX分布\n$$\nD(\\pmb m)=\\frac{1}{\\pi\\alpha_x\\alpha_y}\\frac{1}{\\left(\\frac{(\\pmb t\\cdot\\pmb m)^2}{\\alpha_x^2}+\\frac{(\\pmb b\\cdot\\pmb m)^2}{\\alpha_y^2}+(\\pmb n\\cdot\\pmb m)^2\\right)^2}\n$$\n4.2.5. Beckmann与GGX法线分布函数效果比较 各向同性比较：\n各向异性比较（上一行为Beckmann分布，下一行为GGX分布，$\\alpha_x$从左到右依次递增，$\\alpha_y$保持不变）：\n4.3. 几何函数（Geometry Function） 从法线分布函数一节中我们从微表面模型导出了几何函数的基本概念：\n$$\n\\int_{m\\in\\Theta}G_1(\\pmb m, \\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)^+\\mathrm d\\pmb m=\\pmb v\\cdot \\pmb m\n$$\n几何函数$G$作为一个取值范围为$[0,1]$的标量，描述了微表面的自阴影的属性，表示了具有半矢量的微表面中，同时被入射方向和反射方向可见的比例\n几何函数具有两种主要的形式：\n $G_1$：微表面在单个方向（光照方向或观察方向）上的可见比例，一般表示阴影函数或遮蔽函数 $G_2$：微表面在光照方向和观察方向上均可见的比例，一般表示联合遮蔽阴影函数  一般默认情况下，几何函数指代$G_2$。\n几何函数的设计也有很多，其中基于物理的相对经典的模型为Smith遮蔽函数和V-cavity遮蔽函数\nSmith模型具有不相关的表面，即每个微表面与其邻域不相关，与真实世界的连续微表面对比如下（右图为Smith模型）：\nV-cavity遮蔽函数计算单独微表面上的散射并混合计算结果：\nHeitz证明了Smith遮蔽函数是唯一既遵循公式：\n$$\n\\int_{m\\in\\Theta}G_1(\\pmb m, \\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)^+\\mathrm d\\pmb m=\\pmb v\\cdot \\pmb m\n$$\n又具有法线遮蔽独立性的便利特性的函数，因此业界更青睐于使用Smith模型，Smith模型也比V-cavity模型能够更好地拟合真实世界的反射现象：\n4.3.1. Smith遮蔽函数 下面我们将从各项同性的法线分布函数出发，详细推导Smith几何函数模型。\n在前面的介绍中我们已经得到微表面模型的基本方程：\n$$\n\\int_{m\\in\\Theta}G_1(\\pmb m, \\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)^+\\mathrm d\\pmb m=\\pmb v\\cdot \\pmb m\n$$\n其中的$G_1(\\pmb m,\\pmb v)$项则是我们要求的几何函数项，这里我们仅考虑以高度场建模的微表面，由于几何函数$G_1$将筛选出在单个方向上（即$\\pmb m\\cdot\\pmb v\u0026gt;0$）可见的光，我们可以将$G_1$项分离为：\n$$\nG_1(\\pmb m,\\pmb v)=\\chi^+(\\pmb m,\\pmb v)G_1'(\\pmb v)\n$$\n原方程可化为：\n$$\n\\int_{m\\in\\Theta}\\chi^+(\\pmb m,\\pmb v)G_1'(\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m=\\pmb v\\cdot \\pmb m\n$$\n提取出与$\\pmb m$无关的$G'(\\pmb v)$，有：\n$$\n\\pmb v\\cdot \\pmb m=G_1'(\\pmb v)\\int_{m\\in\\Theta}\\chi^+(\\pmb m,\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m\n$$\n定义与微表面法向$\\pmb m(x_m,y_m,z_m)$相关的微表面坡度：\n$$\n\\tilde m(\\pmb m)=(x_{\\tilde m}, y_{\\tilde m})=(-x_m/z_m,-y_m/z_m)\n$$\n反过来，微表面法向也可表示为：\n$$\n\\pmb m(\\tilde m)=(x_m,y_m,z_m)=\\frac{1}{\\sqrt{x_{\\tilde m}^2+ y_{\\tilde m}^2+1}}(-x_{\\tilde m}, -y_{\\tilde m},1)\n$$\n定义微表面坡度的分布函数$P^{22}$，由$P^{22}$所应满足的归一性：\n$$\n\\int_{-\\infty}^\\infty\\int_{-\\infty}^\\infty P^{22}(\\tilde m)\\mathrm d\\tilde m=1\n$$\n以及法线分布函数的归一性（高度场，仅考虑半球）：\n$$\n\\int_{\\Omega}D(\\pmb m)(\\pmb n\\cdot\\pmb m)\\mathrm d{\\pmb m}=1\n$$\n建立关联：\n$$\nP^{22}(\\tilde m)\\mathrm d\\tilde m=D(\\pmb m)(\\pmb n\\cdot\\pmb m)\\mathrm d{\\pmb m}\n$$\n整理后积分有：\n$$\n\\int_{\\Omega}\\chi^+(\\pmb m,\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m=\\int_{-\\infty}^\\infty\\int_{-\\infty}^\\infty \\chi^+(\\pmb m,\\pmb v)\\frac{\\pmb v\\cdot\\pmb m(\\tilde m)}{\\pmb n\\cdot\\pmb m(\\tilde m)}P^{22}(\\tilde m) \\mathrm d\\tilde m\n$$\n由于$\\pmb n=(0,0,1)$，因此\n$$\n\\pmb n\\cdot\\pmb m(\\tilde m)=\\frac{1}{\\sqrt{x_{\\tilde m}^2+ y_{\\tilde m}^2+1}}\n$$\n与$\\chi^+(\\pmb m,\\pmb v)$项结合起来有：\n$$\n\\chi^+(\\pmb m,\\pmb v)\\pmb v\\cdot\\pmb m(\\tilde m)=\\frac{\\chi^+(-x_0x_{\\tilde m}-y_0y_{\\tilde m}+z_0)(-x_0x_{\\tilde m}-y_0y_{\\tilde m}+z_0)}{\\sqrt{x_{\\tilde m}^2+ y_{\\tilde m}^2+1}}\n$$\n因此积分可以写为：\n$$\n\\int_{\\Omega}\\chi^+(\\pmb m,\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m=\n\\int_{-\\infty}^\\infty\\int_{-\\infty}^\\infty \\chi^+(-x_0x_{\\tilde m}-y_0y_{\\tilde m}+z_0)(-x_0x_{\\tilde m}-y_0y_{\\tilde m}+z_0) P^{22}(x_{\\tilde m},y_{\\tilde m})\\mathrm dx_{\\tilde m}\\mathrm dy_{\\tilde m}\n$$\n不失一般性地，我们可以假设视角方向与$x$轴对齐，即$\\pmb v=(\\sin\\theta_o,0,\\cos\\theta_o)$，则积分表示为：\n$$\n\\begin{align}\n\u0026amp;\\int_{\\Omega}\\chi^+(\\pmb m,\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m\\\\\\\\\n=\u0026amp;\\int_{-\\infty}^\\infty\\int_{-\\infty}^\\infty\\chi^+(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)P^{22}(x_{\\tilde m},y_{\\tilde m})\\mathrm dx_{\\tilde m}\\mathrm dy_{\\tilde m}\\\\\\\\\n=\u0026amp;\\int_{-\\infty}^\\infty\\chi^+(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)\\left(\\int_{-\\infty}^\\infty P^{22}(x_{\\tilde m},y_{\\tilde m})\\mathrm dy_{\\tilde m}\\right)\\mathrm dx_{\\tilde m}\\\\\\\\\n=\u0026amp;\\int_{-\\infty}^\\infty \\chi^+(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n\\end{align}\n$$\n其中，$P^2(x_{\\tilde m})$为沿着视角法向的一维坡度分布函数，定义为：\n$$\nP^2(x_{\\tilde m})=\\int_{-\\infty}^{+\\infty}P^{22}(x_{\\tilde m},y_{\\tilde m})\\mathrm dy_{\\tilde m}\n$$\n又：\n$$\n-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o\u0026gt;0\\Rightarrow x_{\\tilde m}\u0026lt;\\cot\\theta_o\n$$\n因此原积分又可化为：\n$$\n\\int_{-\\infty}^\\infty \\chi^+(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)(-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}=\n\\int_{-\\infty}^{\\cot\\theta_o} (-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n代入到方程：\n$$\n\\pmb v\\cdot \\pmb m=G_1'(\\pmb v)\\int_{m\\in\\Theta}\\chi^+(\\pmb m,\\pmb v)D(\\pmb m)(\\pmb v\\cdot\\pmb m)\\mathrm d\\pmb m\n$$\n可以得到：\n$$\n\\cos\\theta_o=G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-\\sin\\theta_ox_{\\tilde m}+\\cos\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n两边同除以$\\sin\\theta_o$可得：\n$$\n\\cot\\theta_o=G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-x_{\\tilde m}+\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n由于微表面分布是中心对称的，且任意方向的平均坡度为零（正负抵消，分布的均值为0），即\n$$\n\\int_{-\\infty}^{+\\infty} x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}=0\n$$\n引入该项有：\n$$\n\\cot\\theta_o=G_1'(\\pmb v)\\int_{-\\infty}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}+ G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-x_{\\tilde m}+\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n利用$\\cot\\theta_o=(1-G_1'(\\pmb v))\\cot\\theta_o+G_1'(\\pmb v)\\cot\\theta_o$，代入有：\n$$\n\\begin{align}\n(1-G_1'(\\pmb v))\\cot\\theta_o+G_1'(\\pmb v)\\cot\\theta_o\n=\u0026amp;G_1'(\\pmb v)\\int_{-\\infty}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}+ G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-x_{\\tilde m}+\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\\\\\\\\n(1-G_1'(\\pmb v))\\cot\\theta_o\n=\u0026amp;G_1'(\\pmb v)\\int_{-\\infty}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}+ G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-x_{\\tilde m}+\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\\\\\\\\n\u0026amp;-G_1'(\\pmb v)\\cot\\theta_o\n\\end{align}\n$$\n由于概率密度函数的归一性：\n$$\n\\int_{-\\infty}^{+\\infty} P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}=1\n$$\n因此有\n$$\nG_1'(\\pmb v)\\cot\\theta_o=G_1'(\\pmb v) \\int_{-\\infty}^{+\\infty} \\cot\\theta_oP^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n代入得：\n$$\n\\begin{align}\n(1-G_1'(\\pmb v))\\cot\\theta_o=\u0026amp;G_1'(\\pmb v)\\int_{-\\infty}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}+ G_1'(\\pmb v)\\int_{-\\infty}^{\\cot\\theta_o} (-x_{\\tilde m}+\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\\\\\\\\n\u0026amp;-G_1'(\\pmb v) \\int_{-\\infty}^{+\\infty} \\cot\\theta_oP^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\\\\\\\\n=\u0026amp;G_1'(\\pmb v)\\left(\\int_{-\\infty}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}-\\int_{-\\infty}^{\\cot\\theta_o} x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\right)\\\\\\\\\n\u0026amp;+G_1'(\\pmb v)\\left(\\int_{-\\infty}^{\\cot\\theta_o}\\cot\\theta_oP^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}-\\int_{-\\infty}^{\\infty}\\cot\\theta_oP^2(x_{\\tilde m})\\mathrm dx_{\\tilde m} \\right)\\\\\\\\\n=\u0026amp;G_1'(\\pmb v)\\int_{\\cot\\theta_o}^{+\\infty}x_{\\tilde m}P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}-G_1'(\\pmb v)\\int_{\\cot\\theta_o}^{+\\infty}\\cot\\theta_oP^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\\\\\\\\\n=\u0026amp;G_1'(\\pmb v)\\int_{\\cot\\theta_o}^{+\\infty}(x_{\\tilde m}-\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n\\end{align}\n$$\n等式变换一下有：\n$$\n\\frac{1-G'_1(\\pmb v)}{G'_1(\\pmb v)}=\\frac{1}{\\cot\\theta_o}\\int_{\\cot\\theta_o}^{+\\infty}(x_{\\tilde m}-\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n于是得到最终形式：\n$$\nG_1'(\\pmb v)=\\frac{1}{1+\\Lambda(\\pmb v)}\n$$\n其中，$\\Lambda(\\cdot)$定义为：\n$$\n\\Lambda(\\pmb v)=\\frac{1}{\\cot\\theta_o}\\int_{\\cot\\theta_o}^{+\\infty}(x_{\\tilde m}-\\cot\\theta_o)P^2(x_{\\tilde m})\\mathrm dx_{\\tilde m}\n$$\n这是一个与法线分布函数$D(\\pmb m)$相关的函数，每个$D(\\pmb m)$都有唯一的$\\Lambda(\\pmb v)$与之对应。\n综合起来可得Smith几何函数$G_1$的具体形式：\n$$\nG_1(\\pmb m, \\pmb v)=\\frac{\\chi^+(\\pmb m\\cdot\\pmb v)}{1+\\Lambda(\\pmb v)}\n$$\n具有形状不变性的法线分布函数能够得到$\\Lambda(\\pmb v)$的解析解，如：\nBeckmann分布函数\n$$\n\\begin{align}\nP^{22}(x_{\\tilde m},y_{\\tilde m})\u0026amp;=\\frac{1}{\\pi\\alpha^2}\\exp\\left(-\\frac{x^2_{\\tilde m}+y^2_{\\tilde m}}{\\alpha^2}\\right)\\\\\\\\\nD(\\pmb m)\u0026amp;=\\frac{1}{\\pi\\alpha^2(\\pmb n\\cdot\\pmb m)^4}\\exp(\\frac{(\\pmb n\\cdot\\pmb m)^2-1}{\\alpha^2(\\pmb n\\cdot\\pmb m)^2})\\\\\\\\\n\\Lambda(a)\u0026amp;=\\frac{\\mathrm{erf}(a)-1}{2}+\\frac{1}{2a\\sqrt{\\pi}}\\exp(-a^2)\n\\end{align}\n$$\n其中，\n$$\n\\begin{align}\na\u0026amp;=\\frac{\\pmb n\\cdot \\pmb v}{a\\sqrt{1-(\\pmb n\\cdot\\pmb v)^2}}\\\\\\\\\n\\mathrm{erf}(x)\u0026amp;=\\frac{2}{\\sqrt{\\pi}}\\int_0^xe^{-x'^2}\\mathrm dx'^2\n\\end{align}\n$$\n当然上述公式的计算开销很大，Walter等人给出一种近似逼近：\n$$\n\\Lambda(a)=\\begin{cases}\n\\frac{1-1.259a+0.396a^2}{3.535a+2.181a^2},\u0026amp;a\u0026lt;1.6\\\\\\\\\n0,\u0026amp;a\\geq 1.6\n\\end{cases}\n$$\n**GGX分布函数**\n$$\n\\begin{aligned}\nP^{22}(x_{\\tilde m},y_{\\tilde m})\u0026amp;=\\frac{1}{\\pi\\alpha^2\\left(1+\\frac{x^2_{\\tilde m}+y_{\\tilde m}^2}{\\alpha^2}\\right)^2}\\\\\\\\\nD(\\pmb m)\u0026amp;=\\frac{\\alpha^2}{\\pi((\\pmb n\\cdot \\pmb m)^2(\\alpha^2-1)+1)^2}\\\\\\\\\n\\Lambda(a)\u0026amp;=\\frac{-1+\\sqrt{1+\\frac{1}{a^2}}}{2}\n\\end{aligned}\n$$\n其中，\n$$\na=\\frac{\\pmb n\\cdot \\pmb v}{a\\sqrt{1-(\\pmb n\\cdot\\pmb v)^2}}\n$$\n同时，Karis也给出了GGX的Smith $G_1$计算近似公式：\n$$\nG_1(\\pmb v)\\approx \\frac{2(\\pmb n\\cdot\\pmb v)}{(\\pmb n\\cdot\\pmb v)(2-\\alpha)+\\alpha}\n$$\n可以很方便地用在实时渲染中。\n对于各向异性的法线分布函数，可以证明$\\Lambda(\\cdot)$与各向同性版本的一致。\n4.3.2. Smith联合遮蔽函数-阴影函数 分离的遮蔽阴影函数\n最简单和广泛使用的遮蔽阴影函数，认为遮蔽和阴影是独立的，可以分别计算并进行相乘：\n$$\n\\begin{align}\nG_2(\\pmb v,\\pmb l,\\pmb m)\u0026amp;=G_1(\\pmb v,\\pmb m)G_1(\\pmb l,\\pmb m)\\\\\\\\\n\u0026amp;=\\frac{\\chi^+(\\pmb v\\cdot\\pmb m)}{1+\\Lambda(\\pmb v)}\\frac{\\chi^+(\\pmb l\\cdot\\pmb m)}{1+\\Lambda(\\pmb l)}\n\\end{align}\n$$\n这种形式不模拟遮蔽和阴影之间的相关性，因此总会多估算阴影，因为一些相关性总是存在的\n高度相关的遮蔽阴影函数\n这种形式的遮蔽阴影函数更好地模拟了由于微表面高度引起的遮蔽和阴影之间的相关性。直观地说，微平面在微表面升高得越多，对于出射方向未被遮蔽和入射方向未被掩蔽的可见概率会同时增加，形式如下：\n$$\nG_2(\\pmb v,\\pmb l,\\pmb m)=\\frac{\\chi^+(\\pmb v\\cdot\\pmb m)\\chi^+(\\pmb l\\cdot\\pmb m)}{1+\\Lambda(\\pmb v)+\\Lambda(\\pmb l)}\n$$\n方向相关的遮蔽阴影函数\n通过混合可分离的遮蔽阴影函数与两个方向完全相关的情形来表达方向相关：\n$$\nG_2(\\pmb v,\\pmb l,\\pmb m)=\\lambda(\\phi)G_1(\\pmb v,\\pmb m)G_1(\\pmb l,\\pmb m)+(1-\\lambda(\\phi))\\min(G_1(\\pmb v,\\pmb m),G_1(\\pmb l,\\pmb m))\n$$\n其中$\\lambda(\\phi)$是一个经验公式，随着角度$\\phi$的增大，$\\lambda$从0增大到1，Ashikhmin等人建议使用一个高斯函数进行处理：\n$$\n\\lambda(\\phi)=1-e^{-7.3\\phi^2}\n$$\nvan Ginneken则提出另外一种计算方法：\n$$\n\\lambda(\\phi)=\\frac{4.41\\phi}{4.41\\phi+1}\n$$\n高度方向相关的遮蔽阴影函数\n结合高度相关形式和方向相关形式，可以得到：\n$$\nG_2(\\pmb v, \\pmb l,\\pmb m)=\\frac{\\chi^+(\\pmb v\\cdot\\pmb m)\\chi^+(\\pmb l\\cdot\\pmb m)}{1+\\max(\\Lambda(\\pmb v),\\Lambda(\\pmb l))+\\lambda(\\pmb v\\cdot\\pmb l)\\min(\\Lambda(\\pmb v),\\Lambda(\\pmb l))}\n$$\n  当出射方向与入射方向平行且$\\lambda=0$时，遮蔽和阴影完全相关\n  相关性随着方向之间的夹角增加而减小，当$\\lambda=1$时，遮蔽和阴影不再方向相关，而是退化为高度相关的形式\n  $\\lambda$的计算同样可以通过：\n$$\n\\lambda(\\phi)=\\frac{4.41\\phi}{4.41\\phi+1}\n$$\n$\\phi$为$\\pmb v$和$\\pmb l$之间的方位角\n  4.4. 菲涅尔反射 我们已经知道光在两介质的交界表面会发生反射和折射现象，在不考虑次表面散射和透射的情况下我们常常只关注反射光（只有反射光对BRDF有贡献），由费马原理（光路最短原理）我们能够从几何上求出入射角和折射角的关系，但无法确定入射光和折射光、反射光的比例关系。而菲涅尔方程则能够描述了光在介质表面传播的能量关系。\n4.4.1. 菲涅尔方程的推导 要推导出菲涅尔方程，我们需要重新回到麦克斯韦方程组，假设在均匀线性物质中，不存在自由电荷和电流，则麦克斯韦方程组变为：\n$$\n\\begin{aligned}\n\\nabla \\cdot\\pmb E \u0026amp;= 0\\\\\\\\\n\\nabla\\cdot\\pmb B\u0026amp;=0\\\\\\\\\n\\nabla\\times \\pmb E\u0026amp;=-\\frac{\\partial \\pmb B}{\\partial t}\\\\\\\\\n\\nabla\\times \\pmb B\u0026amp;=\\varepsilon\\mu\\frac{\\partial \\pmb E}{\\partial t}\n\\end{aligned}\n$$\n由前述推导中，我们可以很容易求得：\n$$\n\\begin{matrix}\n\\nabla^2\\pmb E=\\mu\\varepsilon\\dfrac{\\partial^2\\pmb E}{\\partial t^2}\u0026amp;\\nabla^2\\pmb B=\\mu\\varepsilon\\dfrac{\\partial^2\\pmb B}{\\partial t^2}\n\\end{matrix}\n$$\n可以看到$\\pmb E$和$\\pmb B$的每个直角坐标分量都满足三维波方程的形式：\n$$\n\\nabla^2f=\\frac{1}{v^2}\\frac{\\partial^2 f}{\\partial t^2}\n$$\n波速：\n$$\nv=\\frac{1}{\\sqrt{\\mu\\varepsilon}}\n$$\n这个波速也为光速，在真空中$v=1/\\sqrt{\\mu_0\\varepsilon_0}=3.00\\times 10^8m/s$\n定义折射率\n$$\nn=\\sqrt{\\frac{\\varepsilon\\mu}{\\varepsilon_0\\mu_0}}\n$$\n则均匀线性物质中的光速为$v=c/n$\n能量密度为：\n$$\nu=\\frac{1}{2}\\left(\\varepsilon E^2+\\frac{1}{\\mu}B^2 \\right)\n$$\n对于单色平面波，波的强度为：\n$$\nI=\\frac{1}{2}\\varepsilon vE_0^2\n$$\n边界条件\n根据麦克斯韦的积分形式，我们可以推导出电磁场在无自由电荷或自由电流的线性介质的边界条件：\n$$\n\\begin{aligned}\n\\varepsilon_1\\pmb E_1^\\perp-\\varepsilon_2\\pmb E_2^\\perp\u0026amp;=0\\\\\\\\\n\\pmb E_1^{\\parallel}-\\pmb E_2^{\\parallel}\u0026amp;=0\\\\\\\\\n\\pmb B_1^\\perp-\\pmb B_2^\\perp\u0026amp;=0\\\\\\\\\n\\frac{1}{\\mu_1}\\pmb B_1^\\parallel-\\frac{1}{\\mu_2}\\pmb B_2^\\parallel\u0026amp;=0\n\\end{aligned}\n$$\n垂直入射的反射与折射\n如上图所示，假设$xy$平面为两线性介质的界面，角频率为$\\omega$，沿$z$方向传播和沿$x$方向偏振的平面波从左边入射到界面：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ I(z,t)\u0026amp;=\\tilde E_{0I}e^{i(k_1z-\\omega t)}\\hat{\\pmb x}\\\\\\\\\n\\tilde{\\pmb B}_ I(z,t)\u0026amp;=\\frac{1}{v_I}\\tilde E_{0I}e^{i(k_1z-\\omega t)}\\hat{\\pmb y}\n\\end{align}\n$$\n它将产生一个反射波：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ R(z,t)\u0026amp;=\\tilde E_{0R}e^{i(-k_1z-\\omega t)}\\hat{\\pmb x}\\\\\\\\\n\\tilde{\\pmb B}_ R(z,t)\u0026amp;=-\\frac{1}{v_1}\\tilde E_{0R}e^{i(-k_1z-\\omega t)}\\hat{\\pmb y}\n\\end{align}\n$$\n和一个透射波：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ T(z,t)\u0026amp;=\\tilde E_{0T}e^{i(k_2z-\\omega t)}\\hat{\\pmb x}\\\\\\\\\n\\tilde{\\pmb B}_ T(z,t)\u0026amp;=\\frac{1}{v_2}\\tilde E_{0T}e^{i(k_2z-\\omega t)}\\hat{\\pmb y}\n\\end{align}\n$$\n由边界条件可以得到：\n$$\n\\begin{align}\n\\tilde E_{0I}+\\tilde E_{0R}\u0026amp;=\\tilde E_{0T}\\\\\\\\\n\\frac{1}{\\mu_1}\\left(\\frac{1}{v_1}\\tilde E_{0I}-\\frac{1}{v_1}\\tilde E_{0R} \\right)\u0026amp;=\\frac{1}{\\mu_2}\\left(\\frac{1}{v_2}\\tilde E_{0T}\\right)\n\\end{align}\n$$\n解得：\n$$\n\\begin{aligned}\n\\tilde E_{0R}=\\left(\\frac{1-\\beta}{1+\\beta}\\right)\\tilde E_{0I}\\\\\\\\\n\\tilde E_{0T}=\\left(\\frac{2}{1+\\beta}\\right)\\tilde E_{0I}\n\\end{aligned}\n$$\n其中，\n$$\n\\beta\\equiv \\frac{\\mu_1v_1}{\\mu_2v_2}=\\frac{\\mu_1n_2}{\\mu_2n_1}\n$$\n若介质的磁导率$\\mu$与真空中的接近（大多数介质是这样），则$\\beta\\approx v_1/v_2$，有：\n$$\n\\begin{aligned}\n\\tilde E_{0R}=\\left(\\frac{v_2-v_1}{v_2+v_1}\\right)\\tilde E_{0I}\\\\\\\\\n\\tilde E_{0T}=\\left(\\frac{2v_2}{v_2+v_1}\\right)\\tilde E_{0I}\n\\end{aligned}\n$$\n实振幅间有以下关系：\n$$\n\\begin{aligned}\nE_{0R}=\\left|\\frac{v_2-v_1}{v_2+v_1}\\right|E_{0I}=\\left|\\frac{n_1-n_2}{n_1+n_2}\\right|E_{0I}\\\\\\\\\nE_{0T}=\\left|\\frac{2v_2}{v_2+v_1}\\right|E_{0I}=\\left|\\frac{2n_1}{n_1+n_2}\\right|E_{0I}\n\\end{aligned}\n$$\n从能量角度看，反射波与入射波强度之比为：\n$$\nR\\equiv\\frac{I_R}{I_I}=\\left(\\frac{E_{0R}}{E_{0I}}\\right)^2=\\left(\\frac{n_1-n_2}{n_1+n_2}\\right)^2\n$$\n透射波与入射波强度之比为：\n$$\nT\\equiv\\frac{I_T}{I_I}=\\frac{\\varepsilon_2v_2}{\\varepsilon_1v_1}\\left(\\frac{E_{0T}}{E_{0I}}\\right)^2=\\frac{4n_1n_2}{(n_1+n_2)^2}\n$$\n其中，$R$称为反射系数，$T$称为透射系数，注意到，$R+T=1$，也是一种能量守恒。\n倾斜入射的反射与折射\n如上图所示，考虑更一般的入射情况，入射角度为$\\theta_I$，假设一个单色平面波：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ I(\\pmb r,t)\u0026amp;=\\tilde E_{0I}e^{i(\\pmb k_I\\cdot\\pmb r-\\omega t)}\\\\\\\\\n\\tilde{\\pmb B}_ I(\\pmb r,t)\u0026amp;=\\frac{1}{v_1}(\\tilde{\\pmb k_I}\\times\\tilde{\\pmb E_I})\n\\end{align}\n$$\n从左边入射，得到一个反射波：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ R(\\pmb r,t)\u0026amp;=\\tilde {\\pmb E}_{0R}e^{i(\\pmb k_R\\cdot\\pmb r-\\omega t)}\\\\\\\\\n\\tilde{\\pmb B}_ R(\\pmb r,t)\u0026amp;=\\frac{1}{v_1}(\\tilde{\\pmb k_R}\\times\\tilde{\\pmb E_R})\n\\end{align}\n$$\n和一个透射波：\n$$\n\\begin{align}\n\\tilde{\\pmb E}_ T(\\pmb r,t)\u0026amp;=\\tilde {\\pmb E}_{0T}e^{i(\\pmb k_T\\cdot\\pmb r-\\omega t)}\\\\\\\\\n\\tilde{\\pmb B}_ T(\\pmb r,t)\u0026amp;=\\frac{1}{v_2}(\\tilde{\\pmb k_T}\\times\\tilde{\\pmb E_T})\n\\end{align}\n$$\n所有三个波具有相同的频率$\\omega$，该物理量由光源所决定，因此三个波的波数之间存在关系：\n$$\nk_Iv_1=k_Rv_1=k_Tv_2=\\omega\n$$\n由边界条件，介质(1)中的合场强$\\tilde{\\pmb E}_I+\\tilde{\\pmb E}_R$和$\\tilde{\\pmb B}_I+\\tilde{\\pmb B}_R$必须拟合介质(2)中的合场强$\\tilde{\\pmb E_T}+\\tilde{\\pmb B}_T$，因此当$z=0$时，应有：\n$$\n\\pmb k_I\\cdot \\pmb r=\\pmb k_R\\cdot\\pmb r=\\pmb k_T\\cdot\\pmb r\n$$\n保证指数项相等，因此，对所有的$x$和$y$有：\n$$\nx(k_I)_x+y(k_I)_y=\nx(k_R)_x+y(k_R)_y=\nx(k_T)_x+y(k_T)_y\n$$\n对$x=0$，有\n$$\n(k_I)_y=(k_R)_y=(k_T)_y\n$$\n对$y=0$，有\n$$\n(k_I)_x=(k_R)_x=(k_T)_x\n$$\n因此，通过改变坐标轴的方向，我们可以使得$\\pmb k_I$、$\\pmb k_R$和$\\pmb k_T$均在xz平面内，至此，我们可以得出几何光学的三个基本定律：\n  入射光、反射光和折射光矢量在同一个平面内（称为入射面），入射面法线也在入射面内，同时满足：\n$$\nk_I\\sin\\theta_I=k_R\\sin\\theta_R=k_T\\sin\\theta_T\n$$\n式中，$\\theta_I$为入射角，$\\theta_R$为反射角，$\\theta_T$为折射角，都是相对于法线方向考虑\n  由于$k_1v_1=k_Rv_1=\\omega$，因此$k_I=k_R$，于是有入射角等于反射角：\n$$\n\\theta_I=\\theta_R\n$$\n即反射定律\n  由$k_Iv_1=k_Tv_2=\\omega$，可得\n$$\nk_I=\\frac{n_1}{n_2}k_T\n$$\n因此有\n$$\n\\frac{\\sin\\theta_T}{\\sin\\theta_I}=\\frac{n_1}{n_2}\n$$\n即折射定律，又称斯涅尔定律\n  回到边界条件问题，我们已经可以将指数项进行抵消，则可以得到下述新的边界条件方程：\n$$\n\\begin{aligned}\n\\varepsilon_1(\\tilde {\\pmb E}_ {0I}+\\tilde{\\pmb E}_ {0R})_z\u0026amp;=\\varepsilon_2(\\tilde {\\pmb E}_ {0T})_z\\\\\\\\\n(\\tilde {\\pmb B}_{0I}+\\tilde{\\pmb B}_ {0R})_z\u0026amp;=(\\tilde {\\pmb B}_ {0T})_z\\\\\\\\\n(\\tilde{\\pmb E}_{0T}+\\tilde {\\pmb E}_ {0R})_{x,y}\u0026amp;=(\\tilde {\\pmb E}_ {0T})_{x,y}\\\\\\\\\n\\frac{1}{\\mu_1}(\\tilde{\\pmb B}_ {0T}+\\tilde {\\pmb B}_ {0R})_{x,y}\u0026amp;=\\frac{1}{\\mu_2}(\\tilde {\\pmb B}_ {0T})_{x,y}\n\\end{aligned}\n$$\n其中，$\\tilde{\\pmb B}_0=(1/v)\\hat{\\pmb k}\\times\\tilde{\\pmb E}_0$\n为了简化问题，假设入射波的电场的偏振方向平行于入射面，即图中的$xz$平面，这样一来反射和透射波的电场的偏振方向也在这个面内，则边界条件方程可表示为：\n$$\n\\begin{align}\n\\varepsilon_1(-\\tilde E_{0I}\\sin\\theta_I+\\tilde E_{0R}\\sin\\theta_R)\u0026amp;=\\varepsilon_2(-\\tilde E_{0T}\\sin\\theta_T)\\\\\\\\\n\\tilde E_{0I}\\cos\\theta_I+\\tilde E_{0R}\\cos\\theta_R\u0026amp;=\\tilde{E}_{0T}\\cos\\theta_T\\\\\\\\\n\\frac{1}{\\mu_1v_1}(\\tilde E_{0I}-\\tilde E_{0R})\u0026amp;=\\frac{1}{\\mu_2v_2}\\tilde E_{0T}\n\\end{align}\n$$\n由反射定律和折射定律，上式可简化为：\n$$\n\\begin{aligned}\n\\tilde E_{0I}-\\tilde E_{0R}\u0026amp;=\\beta\\tilde E_{0T}\\\\\\\\\n\\tilde E_{0I}+\\tilde E_{0R}\u0026amp;=\\alpha\\tilde E_{0T}\n\\end{aligned}\n$$\n其中，\n$$\n\\begin{align}\n\\alpha\u0026amp;\\equiv\\frac{\\cos\\theta_T}{\\cos\\theta_I}\\\\\\\\\n\\beta\u0026amp;\\equiv\\frac{\\mu_1v_1}{\\mu_2v_2}=\\frac{\\mu_1n_2}{\\mu_2n_1}\n\\end{align}\n$$\n解得：\n$$\n\\begin{aligned}\n\\tilde E_{0R}\u0026amp;=\\left(\\frac{\\alpha-\\beta}{\\alpha+\\beta}\\right)\\tilde E_{0I}\\\\\\\\\n\\tilde E_{0T}\u0026amp;=\\left(\\frac{2}{\\alpha+\\beta}\\right)\\tilde E_{0I}\n\\end{aligned}\n$$\n上式则是大名鼎鼎的菲涅尔方程了，可以看到透射波和反射波的振幅受入射角度影响，因为$\\alpha$是关于$\\theta_I$的函数：\n$$\n\\alpha=\\frac{\\sqrt{1-\\sin^2\\theta_T}}{\\cos\\theta_I}=\\frac{\\sqrt{1-[(n_1/n_2)\\sin\\theta_I]^2}}{\\cos\\theta_I}\n$$\n反射率和透射率随入射角度的变化如下图所示：\n而且可以看到，当$\\alpha=\\beta$时，即\n$$\n\\sin^2\\theta_B=\\frac{1-\\beta^2}{(n_1/n_2)^2-\\beta^2}\n$$\n反射波完全消失，$\\theta_B$成为布鲁斯特角。而当入射角$\\theta_I=90°$时，$\\tilde E_{0R}=\\tilde E_{0I}$，入射光全部反射，因此当光打在一个球体上，球面掠角方向应会有反光现象：\n再从能量角度看，单位入射面上的功率为$\\pmb S\\cdot\\hat{\\pmb z}$，入射强度为：\n$$\nI_I=\\frac{1}{2}\\varepsilon_1v_1E_{0I}^2\\cos\\theta_I\n$$\n反射和折射强度分别为：\n$$\n\\begin{align}\nI_R\u0026amp;=\\frac{1}{2}\\varepsilon_1v_1E_ {0R}^2\\cos\\theta_R\\\\\\\\\nI_T\u0026amp;=\\frac{1}{2}\\varepsilon_2v_2E_ {0T}^2\\cos\\theta_T\n\\end{align}\n$$\n反射系数和透射系数为：\n$$\n\\begin{aligned}\nR\u0026amp;\\equiv\\frac{I_R}{I_I}=\\left(\\frac{E_{0R}}{E_{0I}}\\right)^2=\\left(\\frac{\\alpha-\\beta}{\\alpha+\\beta}\\right)^2\\\\\\\\\nI_T\u0026amp;\\equiv\\frac{I_T}{I_I}=\\frac{\\varepsilon_2v_2}{\\varepsilon_1v_1}\\left(\\frac{E_{0T}}{E_{0I}}\\right)^2\\frac{\\cos\\theta_T}{\\cos\\theta_I}=\\alpha\\beta\\left(\\frac{2}{\\alpha+\\beta}\\right)^2\n\\end{aligned}\n$$\n4.4.2. Schlick近似 在实际渲染中，对菲涅尔项的处理经常采用Schlick近似方法进行逼近：\n$$\nR(\\theta)=R_0+(1-R_0)(1-\\cos\\theta)^5\n$$\n其中，\n$$\nR_0=\\left(\\frac{n_1-n_2}{n_1+n_2}\\right)^2\n$$\n4.5. 镜面反射项 至此，我们已经详细推导了基于物理的BRDF中镜面反射项的三个重要组成部分：\n 法线分布函数$D(\\pmb m)$ 几何函数$G(\\pmb m,\\pmb v)$ 菲涅尔项$F(\\pmb v,\\pmb m)$  现在来研究如何将这三项整合到我们的PBR着色模型中。\n4.5.1. 半矢量 前面已经简单介绍过半矢量$\\pmb h$的概念，这里再提一下。如上图所示，只有当入射光通过微表面反射后能够沿着视角方向的反射光才能对BRDF有贡献，因此我们定义使得反射光能够沿视角方向的法向量为半矢量：\n$$\n\\pmb h=\\widehat{\\pmb v+\\pmb l}\n$$\n在渲染中，我们常用半矢量$\\pmb h$代替微表面法向$\\pmb m$。\n下面推导中，我们采用的符号意义如上图所示\n4.5.2. Torrance-Sparrow模型 Torrance-Sparrow模型是微表面BRDF的一个经典模型，其镜面反射项与IlumEngine中所用的Cook-Torrance BRDF几乎一致，这里以Torrance-Sparrow模型为例推导从微表面模型到基于物理的BRDF。\n微表面上方向为$\\pmb \\omega_h$的微元面积为：\n$$\n\\mathrm dA(\\pmb \\omega_h)=D(\\pmb \\omega_h)\\mathrm d\\pmb \\omega_h\\mathrm dA\n$$\n因此微元面积上的辐射通量为：\n$$\n\\begin{align}\n\\mathrm d\\Phi_h\u0026amp;=L_i(\\pmb \\omega_i)\\mathrm d\\pmb \\omega_i\\mathrm dA^\\perp(\\pmb \\omega_h)\\\\\\\\\n\u0026amp;=L_i(\\pmb \\omega_i)\\mathrm d\\pmb \\omega_i\\cos\\theta_h\\mathrm dA(\\pmb \\omega_h)\\\\\\\\\n\u0026amp;=L_i(\\pmb \\omega_i)\\mathrm d\\pmb \\omega_i\\cos\\theta_hD(\\pmb \\omega_h)\\mathrm d\\pmb \\omega_h\\mathrm dA\n\\end{align}\n$$\n又由菲涅尔定律，出射辐射通量有：\n$$\n\\mathrm d\\Phi_o=F(\\pmb \\omega_o)\\mathrm d\\Phi_h\n$$\n又根据辐亮度定义：\n$$\nL(\\pmb \\omega_o)=\\frac{\\mathrm d\\Phi_o}{\\mathrm d\\pmb \\omega_o\\cos\\theta_o\\mathrm dA}\n$$\n联立有：\n$$\nL(\\pmb \\omega_o)=\\frac{F(\\pmb \\omega_o)L_i(\\pmb \\omega_i)\\mathrm d\\pmb \\omega_iD(\\pmb \\omega_h)\\mathrm d\\pmb \\omega_h\\mathrm dA\\cos\\theta_h}{\\mathrm d\\pmb \\omega_o\\mathrm dA\\cos\\theta_o}\n$$\n但是对半矢量$\\pmb \\omega_h$是困难的，我们将其转化为简单地对$\\pmb \\omega_o$采样，由立体角公式，我们有：\n$$\n\\frac{\\mathrm d\\pmb \\omega_h}{\\mathrm d\\pmb \\omega_i}=\\frac{\\sin\\theta_h\\mathrm d\\theta_h\\mathrm d\\phi_h}{\\sin\\theta_i\\mathrm d\\theta_i\\mathrm d\\phi_i}\n$$\n如下图所示，\n由反射定律，显然有$\\theta_i=2\\theta_h$，又由反射面性质，有$\\phi_i=\\phi_h$，因此，\n$$\n\\begin{align}\n\\frac{\\mathrm d\\pmb \\omega_h}{\\mathrm d\\pmb \\omega_i}=\\frac{\\mathrm d\\pmb \\omega_h}{\\mathrm d\\pmb \\omega_o}\n\u0026amp;=\\frac{\\sin\\theta_h\\mathrm d\\theta_h\\mathrm d\\phi_h}{\\sin\\theta_i\\mathrm d\\theta_i\\mathrm d\\phi_i}\\\\\\\\\n\u0026amp;=\\frac{\\sin\\theta_h\\mathrm d\\theta_h\\mathrm d\\phi_h}{2\\sin2\\theta_h\\mathrm d\\theta_h\\mathrm d\\phi_h}\\\\\\\\\n\u0026amp;=\\frac{1}{4\\cos\\theta_h}\\\\\\\\\n\u0026amp;=\\frac{1}{4(\\pmb \\omega_i\\cdot\\pmb \\omega_h)}=\\frac{1}{4(\\pmb \\omega_o\\cdot\\pmb \\omega_h)}\n\\end{align}\n$$\n代入到辐亮度求算公式，有：\n$$\nL(\\pmb \\omega_o)=\\frac{F(\\pmb \\omega_o)L_i(\\pmb \\omega_i)D(\\pmb \\omega_h)\\mathrm d\\pmb \\omega_i}{4\\cos\\theta_o}\n$$\n进一步考虑几何函数，则BRDF可以写为：\n$$\nf_r(\\pmb \\omega_o,\\pmb \\omega_i)=\\frac{F(\\pmb \\omega_o)G(\\pmb \\omega_o,\\pmb \\omega_i)D(\\pmb \\omega_h)}{4\\cos\\theta_o\\cos\\theta_i}=\\frac{F(\\pmb \\omega_o)G(\\pmb \\omega_o,\\pmb \\omega_i)D(\\pmb \\omega_h)}{4(\\pmb \\omega_o\\cdot \\pmb n)(\\pmb \\omega_i\\cdot \\pmb n)}\n$$\n至此，我们的基于物理BRDF的镜面反射项推导完成。\n5. PBR着色模型 5.1. Cook-Torrance BRDF 综合前述推导，我们得到Cook-Torrance BRDF的最终形式：\n$$\nf_r(\\pmb \\omega_o,\\pmb \\omega_i)=(1-F(\\pmb\\omega_o))\\frac{\\rho}{\\pi}+\\frac{F(\\pmb \\omega_o)G(\\pmb \\omega_o,\\pmb \\omega_i)D(\\pmb \\omega_h)}{4(\\pmb \\omega_o\\cdot \\pmb n)(\\pmb \\omega_i\\cdot \\pmb n)}\n$$\n其中，\n  $\\rho$为Albedo，材质的颜色\n  $F(\\pmb\\omega_o)$为菲涅尔系数，选用Schlick近似\n$$\n\\begin{align}\nF(\\theta)\u0026amp;=F_0+(1-F_0)(1-\\cos\\theta)^5\\\\\\\\\nF_0\u0026amp;=\\left(\\frac{n_1-n_2}{n_1+n_2}\\right)^2\n\\end{align}\n$$\n  $D(\\pmb \\omega_h)$为法线分布函数，选用GGX分布\n$$\nD(\\pmb \\omega_h)=\\frac{\\alpha^2}{\\pi((\\pmb n\\cdot \\pmb \\omega_h)^2(\\alpha^2-1)+1)^2}\n$$\n  $G(\\pmb\\omega_o,\\pmb\\omega_i)$为几何函数，选用Smith分布的Schlick近似\n$$\nG(\\pmb \\omega_o,\\pmb\\omega_i)=\\frac{\\pmb \\omega_o\\cdot\\pmb\\omega_h}{(\\pmb \\omega_o\\cdot\\pmb\\omega_h)(1-k)+k}\n$$\n其中，$k=\\frac{(\\alpha+1)^2}{8}$\n  5.2. 金属工作流 Cook-Torrance BRDF中的Schlick近似的菲涅尔公式只能用于描述电介质材质（水、玻璃），对于导体（如金属）则需要使用另外一个菲涅尔公式，对材质设计造成不变，金属工作流则使用金属度参数进行插值金属属性，使得菲涅尔公式同时可以用于描述电介质和导体，非金属的$F_0$默认为0.04，而金属的$F_0$则为表面颜色，通过金属度插值$F_0$的GLSL代码如下：\n1 2  vec3 F0 = vec3(0.04); F0 = mix(F0, albedo, metallic);   不同金属度和粗糙度的着色结果：\n    Roughness = 0.1 Roughness = 0.4 Roughness = 0.7 Roughness = 1.0     Metallic = 0.1       Metallic = 0.4       Metallic = 0.7       Metallic = 1.0        5.3. 多次弹射Kulla-Conty能量补偿 前述的微表面模型仅考虑光线与微表面的单次反射，而不考虑光线多次弹射的结果，这将带来能量损失的问题，具体表现为当材质粗糙度越大时，物体的亮度越低，如下图所示：\nHeitz于2016年给出了能量补偿问题的精确解，但由于计算量过大并不适合于实时渲染，Kulla和Conty则给出了一种近似的能量补偿算法。\n首先，定义给定出射方向$\\mu_o$二维BRDF lobe的总能量，这个能量表示了单次弹射的能量占比：\n$$\nE(\\mu_o)=\\int_0^{2\\pi}\\int_0^1f(\\mu_o,\\mu_i,\\phi)\\mu_i\\mathrm d\\mu_i\\mathrm d\\phi\n$$\n在半球上进行积分，其中$\\mu=\\sin\\theta$\nKulla-Conty方法的核心思想是设计另外一个BRDF，满足积分为$1-E(\\mu_0)$，则这个能量将作为能量补偿项。\n通过经验性的拼凑，凑出了一个满足要求的BRDF函数：\n$$\nf_{ms}(\\mu_o,\\mu_i)=\\frac{(1-E(\\mu_o))(1-E(\\mu_i))}{\\pi(1-E_{avg})}\n$$\n其中，\n$$\nE_{\\mathrm{avg}}=2\\int_0^1E(\\mu)\\mu\\mathrm d\\mu\n$$\n验证一下$f_{ms}(\\mu_o,\\mu_i)$是否满足要求：\n$$\n\\begin{align}\nE_{ms}(\\mu_o)\n\u0026amp;=\\int_0^{2\\pi}\\int_0^1f_{ms}(\\mu_o,\\mu_i,\\phi)\\mu_i\\mathrm d\\mu_i\\mathrm d\\phi\\\\\\\\\n\u0026amp;=2\\pi\\int_0^1\\frac{(1-E(\\mu_o))(1-E(\\mu_i))}{\\pi(1-E_{\\mathrm{avg}})}\\mu_i\\mathrm d\\mu_i\\\\\\\\\n\u0026amp;=2\\frac{1-E(\\mu_o)}{1-E_{\\mathrm {avg}}}\\int_0^1(1-E(\\mu_i))\\mu_i\\mathrm d\\mu_i\\\\\\\\\n\u0026amp;=\\frac{1-E(\\mu_o)}{1-E_{\\mathrm {avg}}}(1-E_{\\mathrm {avg}})\\\\\\\\\n\u0026amp;=1-E(\\mu_o)\n\\end{align}\n$$\n确实是可以的。\n然而$E(\\mu)$和$E_{\\mathrm {avg}}$都没有解析表达，因此在实际开发中应使用预计算的方法，用贴图预存积分结果。\n对于$E(\\mu)$，采用一张单通道二维贴图进行存储，从上到下粗糙度依次增加，从左到右$\\mu$依次增加\n对于$E_{\\mathrm{avg}}$，采用一张单通道一维贴图进行存储，为了可视化方便，这里仍采用二维贴图进行展示，从上到下粗糙度依次增加\n从上图中可以看到的能量，在粗糙度低时微表面能量损失少，能量多存储结果较大；在粗糙度高时微表面能量损失多，能量少结果偏黑，与我们的认知是一致的。\n截至目前，我们仅讨论没有颜色的BRDF的能量补偿情况，对于具有颜色的BRDF，意味着会发生能量的吸收，能量将发生损失，因此我们仍需要计算损失的能量。\n定义平均菲涅尔系数（表示了被反射的能量的多少）：\n$$\nE_{\\mathrm{avg}}=\\frac{\\int_0^1F(\\mu)\\mu\\mathrm d\\mu}{\\int_0^1\\mu\\mathrm d\\mu}=2\\int_0^1F(\\mu)\\mu\\mathrm d\\mu\n$$\n因此带有颜色的反射能量为：$F_{\\mathrm{avg}}E_{\\mathrm{avg}}$\n 一次弹射之后：$F_{\\mathrm{avg}}(1-E_{\\mathrm{avg}})\\cdot F_{\\mathrm{avg}}E_{\\mathrm{avg}}$ …… $k$次弹射之后：$F_{\\mathrm{avg}}^k(1-E_{\\mathrm{avg}})^k\\cdot F_{\\mathrm{avg}}E_{\\mathrm{avg}}$  等比数列求和得到颜色项：\n$$\n\\sum_{k=0}^\\infty F_{\\mathrm{avg}}^k(1-E_{\\mathrm{avg}})^k\\cdot F_{\\mathrm{avg}}E_{\\mathrm{avg}}=\\frac{F_{\\mathrm{avg}}E_{\\mathrm{avg}}}{1-F_{\\mathrm{avg}}(1-E_{\\mathrm{avg}})}\n$$\n其中$F_{\\mathrm{avg}}$也没有很好求，不过有一种近似的计算方法：\n$$\n\\begin{aligned}\nF_{\\mathrm{avg}}(r,g)\u0026amp;\\approx 0.087237 + 0.0230685g - 0.0864902g^2 + 0.0774594g^3\\\\\\\\\n\u0026amp;+ 0.782654r - 0.136432r^2 + 0.278708r^3\\\\\\\\\n\u0026amp;+ 0.19744gr + 0.0360605g^2r - 0.2586gr^2;\n\\end{aligned}\n$$\n其中$r$为反射率，$g$为边缘色调，通常取$r$为Albedo颜色，$g=(0.827, 0.792, 0.678)$即可\n下图展示了Kulla-Conty能量补偿的结果，其中上面一行为进行能量补偿的结果，下一行为未进行能量补偿的结果\n6. 参考资料 【基于物理的渲染（PBR）白皮书】（一） 开篇：PBR核心知识体系总结与概览\n【基于物理的渲染（PBR）白皮书】（二） PBR核心理论与渲染光学原理总结\n【基于物理的渲染（PBR）白皮书】（四）法线分布函数相关总结\n【基于物理的渲染（PBR）白皮书】（五）几何函数相关总结\nAkenine-Moller, Tomas, Eric Haines, and Naty Hoffman. Real-time rendering. AK Peters/crc Press, 2019.\nPharr, Matt, Wenzel Jakob, and Greg Humphreys. Physically based rendering: From theory to implementation. Morgan Kaufmann, 2016.\nGAMES202:高质量实时渲染\nGriffiths, David J. \u0026ldquo;Introduction to electrodynamics.\u0026rdquo; (2005): 574-574.\n","description":"PBR着色的相关理论推导与实现","id":8,"section":"posts","tags":["Real-time Rendering"],"title":"基于物理的实时渲染着色方法","uri":"https://chaphlagical.github.io/zh/posts/rendering/pbr/"},{"content":"1. B样条基函数 为解决Bézier曲线的全局性、端点性等问题，我们引入了Bézier样条来实现曲线的局部编辑，但由于Bézier样条曲线本质上是分段Bézier曲线，数学表达不够优美，在构造、求交等计算上较为麻烦，为此我们又引入B样条基函数的工具，能够精确表达分段Bézier曲线。\n1.1. 单位B样条基函数 B样条基函数通过不同连续阶性的简单基函数进行混合得到连续性更强的高阶基函数，例如一阶单位B样条基函数定义为：\n$$\nN_i^1(t)=\\begin{cases}\n1,\u0026amp;\\mathrm {if}\\ i\\leq t\u0026lt; i+1\\\\\\\\\n0,\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n$$\n$N_i^1(t)$为$C^{-1}$连续，函数图像如下：\n通过平移与混合：\n可以得到$C^0$连续的基函数$N_i^2(t)$：\n$$\n\\begin{aligned}\nN_i^2(t)\u0026amp;=(t-i)N_i^1(t)+(i+2-t)N_{i+1}^1(t)\\\\\\\\\n\u0026amp;=\\begin{cases}\nt-i,\u0026amp;\\mathrm{if}\\ i\\leq t\\leq i+1\\\\\\\\\ni+2-t,\u0026amp;\\mathrm{if}\\ i+1\\leq t\\leq i+2\\\\\\\\\n0,\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n\\end{aligned}\n$$\n依次类推，继续混合：\n这样一来，可以定义$k$阶的单位均匀B样条基函数$N_i^k(t)$定义为：\n$$\n\\begin{aligned}\nN_i^1(t)\u0026amp;=\\begin{cases}\n1,\u0026amp;\\mathrm {if}\\ i\\leq t\u0026lt; i+1\\\\\\\\\n0,\u0026amp;\\mathrm{otherwise}\n\\end{cases}\\\\\\\\\nN_i^k(t)\u0026amp;=\\frac{t-i}{(i+k-1)-i}N_i^{k-1}(t)+\\frac{(i+k)-t}{(i+k)-(i+1)}N_{i+1}^{k-1}(t)\\\\\\\\\n\u0026amp;=\\frac{t-i}{k-1}N_i^{k-1}(t)+\\frac{i+k-t}{k-1}N_{i+1}^{k-1}(t)\n\\end{aligned}\n$$\n**$k$阶单位B样条基函数的性质**\n $N_i^k(t)\u0026gt;0$，$i\u0026lt;t\u0026lt;i+k$ $N_i^k(t)=0$，$t\\in(-\\infty,i]\\cup [i+k,+\\infty)$ $N_i^k(t)$为$C^{k-2}$阶连续 $N_i^k(t)$为分段$k-1$次多项式函数组成  1.2. 一般的B样条基函数 给定结序列$t_0\u0026lt;t_1\u0026lt;\\cdots\u0026lt;t_n\u0026lt;\\cdots\u0026lt;t_{n+k}$，$(t_0,t_1,\\cdots,t_{n+k})$称为结向量\n归一化的$k$阶（即$k-1$度）的单位B样条基函数$N_{i,k}(t)$定义为：\n$$\n\\begin{align}\nN_{i,1}(t)\u0026amp;=\\begin{cases}\n1,\u0026amp;t_i\\leq t\u0026lt;t_{i+1}\\\\0,\u0026amp;\\mathrm{otherwise}\n\\end{cases}\\\\\\\\\nN_{i,k}(t)\u0026amp;=\\dfrac{t-t_i}{t_{i+k-1}-t_i}N_{i,k-1}(t)+\\dfrac{t_{i+k}-t}{t_{i+k}-t_{i+1}}N_{i+1,k-1}(t)\n\\end{align}\n$$\n$k$阶B样条基函数的性质\n $i=0,1,\\cdots,n$，$k\\in\\mathbb Z^+$ 对$t\\in(t_i,t_{i+k})$，有$N_{i,k}(t)\u0026gt;0$ 对$t\\in(-\\infty,t_i]\\cup[t_{i+k},+\\infty)$，有$N_{i,k}(t)=0$ 对$t\\in(t_{k-1},t_{n+1})$，有$\\sum_{i=1}^nN_{i,k}(t)=1$ $N_{i,k}(t)$由分段多项式函数组成，次数为$k-1$，在$[t_i,t_{i+k}]$上$C^{k-2}$阶连续 区间$[t_i,t_{i+k}]$称为$N_{i,k}$的支撑区间  2. B样条曲线 2.1. B样条曲线的定义 给定：\n  $n+1$个控制点$\\pmb d_0,\\pmb d_1,\\cdots,\\pmb d_n\\in\\mathbb R^3$\n  结向量$T=(t_0,\\cdots,t_n,\\cdots,t_{n+k})$\n 这是由于$N_{n,k}$定义在区间$[n,n+k]$上\n   则$k$阶的B样条曲线$\\pmb x(t)$定义为：\n$$\n\\pmb x(t)=\\sum\\limits_{i=0}^nN_{i,k}(t)\\cdot\\pmb d_i\n$$\n其中，点$\\pmb d_i$称为de Boor点\n 注意该定义下，B样条曲线不插值de Boor点$\\pmb d_i$\n 示例：\n重复结向量\nB样条曲线允许重复结向量：$T=(t_0,\\cdots,t_n,\\cdots,t_{n+k})$，$t_0\\leq t_1\\leq \\cdots\\leq t_{n+k}$\n当重复$k$次以上时，函数值视为0，没有贡献。\n当$t_0=t_1=\\cdots=t_{k-1}$且$t_{n+1}=t_{n+2}=\\cdots=t_{n+k}$时，将插值$\\pmb d_0$和$\\pmb d_1$\n示例：\n2.2. B样条曲线的计算——de Boor算法 给定：\n de Boor点：$\\pmb d_0,\\pmb d_1,\\cdots,\\pmb d_n$ 结向量：$(t_0,\\cdots,t_{k-1}=t_0,t_k,t_{k+1},\\cdots,t_n,t_{n+1},\\cdots,t_{n+k}=t_{n+1})$  则B样条曲线的计算流程如下：\n中间系数$\\pmb d_i^j(t)$可以表示为一个下三角矩阵——de Boor图：\n$$\n\\begin{matrix}\n\\pmb d_{r-k+1}=\\pmb d^0_{r-k+1}\\\\\\\\\n\\pmb d_{r-k+2}=\\pmb d^0_{r-k+2}\u0026amp;\\pmb d_{r-k+2}^1\\\\\\\\\n\\vdots\\\\\\\\\n\\pmb d_{r-1}=\\pmb d_{r-1}^0\u0026amp;\\pmb d_{r-1}^1\u0026amp;\\cdots\u0026amp;\\pmb d_{r-1}^{k-2}\\\\\\\\\n\\pmb d_r=\\pmb d_r^0\u0026amp;\\pmb d_r^1\u0026amp;\\cdots\u0026amp;\\pmb d_r^{k-2}\u0026amp;\\pmb d_r^{k-1}=\\pmb x(t)\n\\end{matrix}\n$$\n2.3. B样条曲线的性质 2.3.1. B样条基函数 vs. Bernstein多项式 结向量$T=(t_0,t_1,\\cdots,t_{2k-1})=(\\underbrace{0,\\cdots,0}_k,\\underbrace{1,\\cdots,1}_k)$下的$k$阶B样条函数$N_{i,k}(i=0,\\cdots,k-1)$为$k-1$次Bernstein多项式$B_i^{k-1}$\n2.3.2. 基本性质 给定：\n 结向量：$T=(\\underbrace{t_0,\\cdots,t_0}{k\\ \\mathrm{times}},t_k,\\cdots,t_n,\\underbrace{t{n+1},\\cdots,t_{n+1}}_{k\\ \\mathrm{times}})$ de Boor多边形$\\pmb d_0,\\cdots,\\pmb d_n$  相应的B样条曲线$\\pmb x(t)$有如下性质：\n $\\pmb x(t_{n+1})=\\pmb d_n$，$\\pmb x(t_{n+1})=\\pmb d_n$（边界点插值） $\\dot{\\pmb x}(t_0)=\\dfrac{k-1}{t_k-t_0}(\\pmb d_1-\\pmb d_0)$（$\\pmb d_0$处的切线方向与$\\pmb d_n$处相似） $\\pmb x(t)$由$n-k+2$个$k-1$次多项式曲线段构成 多重内部结$\\Rightarrow$减小了$\\pmb x(t)$的连续阶数，$l$重内部结$(1\\leq l\u0026lt;k)$意味着$C^{k-l-1}$阶连续 de Boor点的局部影响：移动$\\pmb d_i$只会改变曲线的$[t_i,t_{i+k}]$区间部分 插入新的de Boor点不会改变曲线段的多项式阶数  2.4. B样条曲线插值 给定：\n 控制点：$\\pmb k_0,\\pmb k_1,\\cdots,\\pmb k_n$ 结序列：$s_0,s_1,\\cdots,s_n$  目标：\n 分段三次插值B样条曲线$\\pmb x(t)$，满足插值条件：\n$$\n\\pmb x(s_i)=\\pmb k_i,\\ \\ \\ \\ i=0,1,\\cdots,n\n$$  方法：\n  分段三次$\\Rightarrow$$k=4$\n  重复首尾结$k-1=3$，结向量共计$n+2k-1=n+7$个结，对应$n+7-k=n+3$个de Boor点，结向量为：\n$$\n\\begin{align}\nT\u0026amp;=(t_0,t_1,t_2,t_3,t_4,\\cdots,t_{n+2},t_{n+3},t_{n+4},t_{n+5},t_{n+6})\\\\\\\\\n\u0026amp;=(s_0,s_0,s_0,s_0,s_1,\\cdots,s_{n-1},s_n,s_n,s_n,s_n)\n\\end{align}\n$$\n  插值条件（$n+1$个条件）\n$$\n\\begin{align}\n\\pmb x(s_0)\u0026amp;=\\pmb k_0=\\pmb d_0\\\\\\\\\n\\pmb x(s_i)\u0026amp;=\\pmb k_i=N_{i,4}(s_i)\\pmb d_i+N_{i+1,4}(s_i)\\pmb d_{i+1}+N_{i+2,4}(s_i)\\pmb d_{i+2}\\\\\\\\\n\u0026amp;\\mathrm{for}\\ i=1,\\cdots,n-1\\\\\\\\\n\\pmb x(s_n)\u0026amp;=\\pmb k_n=\\pmb d_{n+2}\n\\end{align}\n$$\n  终值条件（2个自然终值条件）\n$$\n\\begin{align}\n\\ddot{\\pmb x}(s_0)\u0026amp;=0\\Leftrightarrow \\dfrac{\\pmb d_2-\\pmb d_1}{s_2-s_0}=\\dfrac{\\pmb d_1-\\pmb d_0}{s_1-s_0}\\\\\\\\\n\\ddot{\\pmb x}(s_n)\u0026amp;=0\\Leftrightarrow \\dfrac{\\pmb d_{n+2}-\\pmb d_{n+1}}{s_n-s_{n-1}}=\\dfrac{\\pmb d_{n+1}-\\pmb d_n}{s_n-s_{n-2}}\n\\end{align}\n$$\n  结果可以表示为求解对角系统方程：\n$$\n\\begin{pmatrix}\n1\\\\\\\\\n\\alpha_0\u0026amp;\\beta_0\u0026amp;\\gamma_0\\\\\\\\\n\u0026amp;\\alpha_1\u0026amp;\\beta_1\u0026amp;\\gamma_1\\\\\\\\\n\u0026amp;\u0026amp;\u0026amp;\\ddots\\\\\\\\\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\alpha_{n-1}\u0026amp;\\beta_{n-1}\u0026amp;\\gamma_{n-1}\\\\\\\\\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\alpha_n\u0026amp;\\beta_n\u0026amp;\\gamma_n\\\\\\\\\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;1\n\\end{pmatrix}\n\\begin{pmatrix}\n\\pmb d_0\\\\\\\\\\pmb d_1\\\\\\\\\\pmb d_2\\\\\\\\\\vdots\\\\\\\\\\pmb d_n\\\\\\\\\n\\pmb d_{n+1}\\\\\\\\\\pmb d_{n+2}\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\pmb k_0\\\\\\\\\\pmb 0\\\\\\\\\\pmb k_1\\\\\\\\\\vdots\\\\\\\\\\pmb k_{n-1}\\\\\\\\\n\\pmb 0\\\\\\\\\\pmb k_{n}\n\\end{pmatrix}\n$$\n其中，\n$$\n\\begin{align}\n\\alpha_0\u0026amp;=s_2-s_0\\\\\\\\\n\\beta_0\u0026amp;=-(s_2-s_0)-(s_1-s_0)\\\\\\\\\n\\gamma_0\u0026amp;=s_1-s_0\\\\\\\\\n\\\\\\\\\n\\alpha_n\u0026amp;=s_n-s_{n-1}\\\\\\\\\n\\beta_n\u0026amp;=-(s_n-s_{n-1})-(s_n-s_{n-2})\\\\\\\\\n\\gamma_n\u0026amp;=s_n-s_{n-2}\\\\\\\\\n\\\\\\\\\n\\alpha_i\u0026amp;=N_{i,4}(s_i)\\\\\\\\\n\\beta_i\u0026amp;=N_{i+1,4}(s_i)\\\\\\\\\n\\gamma_i\u0026amp;=N_{i+2,4}(s_i)\\\\\\\\\n\\mathrm{for}\u0026amp;\\ i=1,\\cdots,n-1\n\\end{align}\n$$\n  求解方法\n 使用Thomas算法——解决对角系统矩阵 仅适用于对角占优矩阵 复杂度$O(n)$     前向消除阶段\n  后向替换阶段\n     2.5. Bézier曲线转B样条曲线 给定：\n 控制点：$\\pmb k_0,\\pmb k_1,\\cdots, \\pmb k_n$ 结序列：$t_0,t_1,\\cdots,t_n$ 2个终值条件 $C^2$连续、插值条件 用于$C^2$连续插值的分段三次Bézier样条曲线的Bézier点$\\pmb b_0,\\pmb b_1,\\cdots,\\pmb b_{3n}$  目标：\n 求取相同曲线的B样条形式  结向量：\n$$\nT=(t_0,t_0,t_0,t_0,t_1,\\cdots,t_{n-1},t_n,t_n,t_n,t_n)\n$$\n 共$n+7$个顶点，$n+3$个de Boor点，即$\\pmb d_0,\\pmb d_1,\\cdots,\\pmb d_{n+2}$\n de Boor点满足：\n$$\n\\begin{align}\n\\pmb d_0\u0026amp;=\\pmb b_0\\\\\\\\\n\\pmb d_1\u0026amp;=\\pmb b_1\\\\\\\\\n\\pmb d_i\u0026amp;=\\pmb b_{3i-4}+\\frac{\\Delta_{i-1}}{\\Delta_{i-2}}(\\pmb b_{3i-4}-\\pmb b_{3i-5})\\ \\mathrm{for}\\ i=2,\\cdots,n\\\\\\\\\n\\pmb d_{n+1}\u0026amp;=\\pmb b_{3n-1}\\\\\\\\\n\\pmb d_{n+2}\u0026amp;=\\pmb b_{3n}\n\\end{align}\n$$\n其中，对于$i=0,\\cdots,n-1$，有$\\Delta_i=t_{i+1}-t_i$\n示例：\n逆问题同样可解\n3. 视频演示 IlumEngine中实现了自然边界条件的4阶（3 次）B曲线的$C^2$连续插值绘制，实际造型与Bézier样条曲线等价\n\n","description":"B样条曲线原理与实现","id":9,"section":"posts","tags":["Geometry"],"title":"几何造型(3)：B样条曲线","uri":"https://chaphlagical.github.io/zh/posts/geometry/b_spline/"},{"content":"因为有了《漫威复仇者联盟》的前车之鉴，许多人是不看好今年这款Crystal Dynamics开发的漫威IP新作，但游戏正式发布后评价却意外的好，趁之前七折赶紧入手冲一把。\n和漫威复联的刷刷刷不同，漫威银护选择走单人线性叙事路线，以星爵作为玩家唯一可操作角色，通过小队作战的战斗机制来使用银河护卫队其他成员的技能。但从玩法上确实没有太多新意，后期技能点满后战斗非常无脑与简单，收集要素很少（均为皮肤和可升级零件），解密难度极低，但是剧本非常扎实，对话量很大，演出效果也很好，很多彩蛋也让我这个漫威迷大呼过瘾，十多小时的大片级体验还是相当不错的。\n以下是我在游戏过程中截取的精彩画面：\n进入新手村前夕\n初遇科斯莫\n理查德·赖德彩蛋，萨姆·亚历山大能在下一部出现吗？\n星爵见老妈\n劝说Worldmind失败，Nova总部溜了\n初遇亚当\n光速跳跃\n全副武装\n封面图，全场最佳\n这个星爵和电影版的还是很不一样\n最终一战\n老板火箭\n","description":"通关了《漫威银河护卫队》，剧情还是相当不错的","id":10,"section":"posts","tags":["Gaming"],"title":"游戏通关：《漫威银河护卫队》","uri":"https://chaphlagical.github.io/zh/posts/gaming/marvel_guardians_of_the_galaxy/"},{"content":"1. 简介 之前我们已经介绍过Bézier曲线的原理与实现方法，但由于Bézier曲线的一些问题，例如：\n 高多项式次数  $n+1$个Bézier控制点将生成一条$n$次多项式表达的Bézier曲线   全局，伪局部性  Bézier曲线在始末两控制点进行插值，在中间控制点进行拟合，当控制点增加时，曲线形态难以控制    因此我们引入的Bézier样条曲线来解决上述两个问题。在了解Bézier样条曲线的工作原理之前，需要弄清楚几何设计中连续性的基本概念。\n1.1. 连续性的基本概念 1.1.1. 参数连续性 给定两条曲线：\n$$\n\\begin{align}\n\u0026amp;\\pmb x_1(t)\\ \\mathrm{over}\\ [t_0,t_1]\\\\\\\\\n\u0026amp;\\pmb x_2(t)\\ \\mathrm{over}\\ [t_1,t_2]\n\\end{align}\n$$\n若$\\pmb x_1$和$\\pmb x_2$在$t_1$处的0阶到$r$阶导数向量均重合，则若$\\pmb x_1$和$\\pmb x_2$在$t_1$处$C^r$连续\n常见的参数连续性有：\n $C^0$：位置变化连续 $C^1$：一阶导数在交界处连续（速度向量相同） $C^2$：二阶导数在交界处连续（加速度向量相同）  1.1.2. 几何连续性 给定两条曲线：\n$$\n\\begin{align}\n\u0026amp;\\pmb x_1(t)\\ \\mathrm{over}\\ [t_0,t_1]\\\\\\\\\n\u0026amp;\\pmb x_2(t)\\ \\mathrm{over}\\ [t_1,t_2]\n\\end{align}\n$$\n若$\\pmb x_1$和$\\pmb x_2$能够以某种方式重新参数化使得在$t_1$处$C^r$连续，则$\\pmb x_1$和$\\pmb x_2$在$t_1$处$G^r$连续\n常见的几何连续性有：\n $G^0=C^0$：位置变化连续性（连接性） $G^1$：切线方向变化连续性（相同切线）  正则化切线变化连续 等价于曲线能够重新参数化到$C^1$ 等价于单位速度参数化为$C^1$   $G^2$：曲率变化连续性（相同切线与曲率）  等价于曲线能够重新参数化到$C^2$ 等价于单位速度参数化为$C^2$    1.1.3. 参数连续性 vs. 几何连续性    参数连续性 几何连续性     在该曲线上运动的粒子是否有光滑的轨迹？（位置、速度、加速度） 曲线本身是否光滑   取决于参数化方式 独立于参数化方式   应用：动画（物体移动、摄像头轨迹） 与建模相关（曲线设计）    1.2. Bézier样条曲线的设计思想 既然Bézier曲线全局性太强、阶次太高，那么优化思路就是降低全局性、降低阶次，一个有效的方法就是进行分段，把一条长的曲线分段成若干条低阶的Bézier曲线，在衔接处满足某种连接性，即可使得曲线满足控制点插值、低次性和局部性等优点，这就是Bézier样条曲线的设计思路。\n设计Bézier样条曲线需要考虑的两个问题是：\n 参数化 连续性  2. Bézier样条参数化 在Bézier曲线的构造中，我们选择的参数为$t\\in[0,1]$，贯穿整条曲线，称之为全局参数。在Bézier样条曲线中，我们通过分段，将曲线分为$[t_0,t_1]$，$[t_1,t_2]$，……，$[t_{n-1},t_n]$的曲线段，每一段对应一条低阶Bézier曲线，这条低阶Bézier曲线使用的参数$u\\in[0,1]$则称为局部参数。当局部参数$u$从0变化到1时，全局参数从$t_i$变化到$t_{i+1}$。\n通常情况下，节序列$t_0,t_1,\\cdots,t_n$可以自定义，选取不同的节序列会得到不同的曲线形态，常用的参数化方法有以下几种：\n  Equidistant (Uniform) Parameterization\n $t_{i+1}-t_i=\\mathrm{const}$ 不考虑数据点之间的几何关系    Chordal Parameterization\n $t_{i+1}-t_i=\\Vert \\pmb k_{i+1}-\\pmb k_i\\Vert$ 参数间隔与相邻控制点的距离成正比    Centripetal Parameterization\n $t_{i+1}-t_i=\\sqrt{\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert}$ 参数间隔与相邻控制点的距离的开方成正比    Foley Parameterization\n 涉及控制多边形的角度  $$\nt_{i+1}-t_i=\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert\\cdot\\Big(1+\\dfrac{3}{2}\\dfrac{\\hat\\alpha_i\\Vert\\pmb k_i-\\pmb k_{i-1}\\Vert}{\\Vert\\pmb k_i-\\pmb k_{i-1}\\Vert+\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert}+\\dfrac{3}{2}\\dfrac{\\hat\\alpha_{i+1}\\Vert \\pmb k_{i+1}-\\pmb k_i\\Vert}{\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert+\\Vert\\pmb k_{i+2}-\\pmb k_{i+1}\\Vert} \\Big)\n$$\n 其中，$\\hat\\alpha_i=\\min\\Big(\\pi-\\alpha_i,\\dfrac{\\pi}{2}\\Big)$，且$\\alpha_i=\\mathrm{angle}(\\pmb k_{i-1},\\pmb k_i,\\pmb k_{i+1})$    3. Bézier样条的连续性 给定\n $\\pmb y(u)$：$[0,1]$上的Bézier曲线 $\\pmb x(u)$：$[t_i,t_{i+1}]$上的Bézier曲线  令$u(t)=\\frac{t-t_i}{t_{i+1}-t_i}$，则$\\pmb x(t)=\\pmb y(u(t))$\n对$\\pmb x(t)$进行求导有：\n$$\n\\begin{align}\n\\dot{\\pmb x}(t)\u0026amp;=\\dot{\\pmb y}(u(t))\\cdot\\dot u(t)=\\dfrac{\\dot{\\pmb y}(u(t))}{t_{i+1}-t_i}\\\\\\\\\n\\ddot{\\pmb x}(t)\u0026amp;=\\ddot{\\pmb y}(u(t))\\cdot(\\dot u(t))^2+\\dot{\\pmb y}(u(t))\\cdot\\ddot u(t)=\\dfrac{\\ddot{\\pmb y}(u(t))}{(t_{i+1}-t_i)^2}\\\\\n\\cdots\\\\\\\\\n\\pmb x^{[n]}(t)\u0026amp;=\\dfrac{\\pmb y^{[n]}(u(t))}{(t_{i+1}-t_i)^n}\n\\end{align}\n$$\n由Bézier曲线解析式：\n$$\n\\pmb f(t)=\\sum_{i=0}^nB_i^n(t)\\pmb b_i\n$$\n其端点值：\n$$\n\\begin{align}\n\\pmb f(0)\u0026amp;=\\pmb b_0\\\\\\\\\n\\pmb f(1)\u0026amp;=\\pmb b_1\n\\end{align}\n$$\n端点一阶导数：\n$$\n\\begin{align}\n\\pmb f'(0)\u0026amp;=n[\\pmb b_1-\\pmb b_0]\\\\\\\\\n\\pmb f'(1)\u0026amp;=n[\\pmb b_n-\\pmb b_{n-1}]\n\\end{align}\n$$\n端点二阶导数：\n$$\n\\begin{align}\n\\pmb f''(0)\u0026amp;=n(n-1)[\\pmb b_2-2\\pmb b_1+\\pmb b_0]\\\\\\\\\n\\pmb f''(1)\u0026amp;=n(n-1)[\\pmb b_n-2\\pmb b_{n-1}+\\pmb b_{n-2}]\n\\end{align}\n$$\n代入到$\\pmb x(t)=\\pmb y(u(t))$中，有：\n$$\n\\begin{align}\n\\pmb x(t_i)\u0026amp;=\\pmb b_0\\\\\\\\\n\\pmb x(t_{i+1})\u0026amp;=\\pmb b_1\\\\\\\\\n\\dot{\\pmb x}(t_i)\u0026amp;=\\dfrac{n(\\pmb b_1-\\pmb b_0)}{t_{i+1}-t_i}\\\\\\\\\n\\dot{\\pmb x}(t_{i+1})\u0026amp;=\\dfrac{n(\\pmb b_n-\\pmb b_{n-1})}{t_{i+1}-t_i}\\\\\\\\\n\\ddot{\\pmb x}(t_i)\u0026amp;=\\dfrac{n(n-1)(\\pmb b_2-2\\pmb b_1+\\pmb b_0)}{(t_{i+1}-t_i)^2}\\\\\\\\\n\\ddot{\\pmb x}(t_{i+1})\u0026amp;=\\dfrac{n(n-1)(\\pmb b_n-2\\pmb b_{n-1}+\\pmb b_{n-2})}{(t_{i+1}-t_i)^2}\\\n\\end{align}\n$$\n现有$m+1$段$n$阶Bézier样条$\\pmb x^{(0)},\\pmb x^{(1)},\\cdots,\\pmb x^{(m)}$构成一条完整曲线$\\pmb x$，Bézier样条$\\pmb x^{(i)}$的控制点为：$\\pmb b_0^{(i)},\\pmb b_1^{(i)},\\cdots,\\pmb b_n^{(i)}$，对应全局参数范围$[t_i,t_{i+1}]$\n$C^0$连续性\n每个样条线段插值两端控制点，因此相邻曲线段两端的控制点必须重合以获得$C^0$连续性，即：\n$$\n\\pmb b^{(i-1)}_{n}=\\pmb b^{(i)}_0\n$$\n$C^1$连续性\n$C^1$连续即该参数化下一阶导数相同，即：\n$$\n\\dot{\\pmb x}^{(i)}(t_{i+1})=\\dot{\\pmb x}^{(i+1)}(t_{i+1})\n$$\n代入表达式有：\n$$\n\\frac{\\pmb b^{(i)}_n-\\pmb b_{n-1}^{(i)}}{t_{i+1}-t_i}=\n\\frac{\\pmb b^{(i)}_{1}-\\pmb b_{0}^{(i)}}{t_{i+2}-t_{i+1}}\n$$\n$C^2$连续性\n$C^1$连续即该参数化下二阶导数相同，即：\n$$\n\\ddot{\\pmb x}^{(i)}(t_{i+1})=\\ddot{\\pmb x}^{(i+1)}(t_{i+1})\n$$\n代入表达式有：\n$$\n\\frac{\\pmb b_n^{(i)}-2\\pmb b_{n-1}^{(i)}+\\pmb b_{n-2}^{(i)}}{(t_{i+1}-t_i)^2}=\n\\frac{\\pmb b_2^{(i+1)}-2\\pmb b_1^{(i+1)}+\\pmb b_0^{(i+1)}}{(t_{i+2}-t_{i+1})^2}\n$$\n令\n$$\n\\pmb d^-=\\pmb b_{n-1}^{(i)}+\\frac{\\Delta_{i+1}}{\\Delta_i}(\\pmb b_{n-1}^{(i)}-\\pmb b_{n-2}^{(i)})\n$$\n和\n$$\n\\pmb d^+=\\pmb b_{1}^{(i+1)}-\\frac{\\Delta_{i}}{\\Delta_{i+1}}(\\pmb b_{2}^{(i+1)}-\\pmb b_{1}^{(i+1)})\n$$\n则有$C^2$连续性等价于$C^1$连续性且$\\pmb d^-=\\pmb d^+$\n$G^1$连续性\n满足在$t=t_i$处$G^1$连续的条件是：\n$$\n\\begin{aligned}\n\u0026amp;\\pmb x^{(i)}(t_i)=\\pmb x^{(i+1)}(t_i)\\\\\\\\\n\u0026amp;\\dot{\\pmb x}^{(i)}(t_i)=\\dot{\\pmb x}^{(i+1)}(t_i)\\\\\\\\\n\u0026amp;\\ddot{\\pmb x}^{(i+1)}(t_i)-\\ddot{\\pmb x}^{(i)}(t_i)\\parallel \\dot{\\pmb x}(t_i)\n\\end{aligned}\n$$\n$G^2$连续性\n满足在$t=t_i$处$G^2$连续的条件是：\n  $G^1$连续\n  $\\pmb b_{n-2}^{(i)},\\pmb b_{n-1}^{(i)},\\pmb b_{n}^{(i)}=\\pmb b_{0}^{(i+1)},\\pmb b_{1}^{(i+1)},\\pmb b_{2}^{(i+1)}$五个向量共面\n  且面积满足：\n$$\n\\dfrac{\\mathrm{area}(\\pmb b_{n-2}^{(i)},\\pmb b_{n-1}^{(i)},\\pmb b_{n}^{(i)})}{\\mathrm {area}(\\pmb b_{0}^{(i+1)},\\pmb b_{1}^{(i+1)},\\pmb b_{2}^{(i+1)})}=\\dfrac{a^3}{b^3}\n$$\n  4. 三次Bézier样条曲线 理论上，只要有足够的边界条件约束，我们可以选用任意阶的Bézier样条进行构造我们的曲线，但一般常用的Bézier样条不会超过三次（某些CAD/CAM软件可能会使用）：\n 零次：分段常数，不光滑 一次：分段线性，不够光滑 二次：二阶导数为常数，不够灵活 三次：图形学应用中最为常用  在IlumEngine中，也选用了三次Bézier样条曲线进行实现。\n对于给定的控制点$\\pmb k_0,\\pmb k_1,\\cdots,\\pmb k_n$，以及参数化节序列$t_0,t_1,\\cdots,t_n$，我们需要生成用于构造连续分段三次Bezier样条曲线的Bézier点$\\pmb b_0,\\cdots,\\pmb b_{3n}$\n该问题中，需要求解：\n $3n+1$个未知点 $C^0$连续：$\\pmb b_{3i}=\\pmb k_i$，$i=0,\\cdots,n$，共$n+1$个方程 $C^1$连续：$\\dfrac{\\pmb b_{3i}-\\pmb b_{3i-1}}{t_i-t_{i-1}}=\\dfrac{\\pmb b_{3i+1}-\\pmb b_{3i}}{t_{i+1}-t_{i}}$，$i=0,\\cdots,n$，共$n-1$个方程 $C^2$连续：$\\dfrac{\\pmb b_{3i}-2\\pmb b_{3i-1}+\\pmb b_{3i-2}}{(t_i-t_{i-1})^2}=\\dfrac{\\pmb b_{3i+2}-2\\pmb b_{3i+1}+\\pmb b_{3i}}{(t_{i+1}-t_{i})^2}$，$i=0,\\cdots,n$，共$n-1$个方程 两个端点条件  端点条件的选取，通常有两种：\n  Bessel End Condition\n  $\\pmb k_0$处的切向量等于插值${\\pmb k_0,\\pmb k_1,\\pmb k_2}$的抛物线在$\\pmb k_0$处的切向量\n  插值${\\pmb k_0,\\pmb k_1,\\pmb k_2}$的抛物线方程：\n$$\n\\pmb p(t)=\n\\dfrac{(t_2-t)(t_1-t)}{(t_2-t_0)(t_1-t_0)}\\pmb k_0+\n\\dfrac{(t_2-t)(t-t_0)}{(t_2-t_1)(t_1-t_0)}\\pmb k_1+\n\\dfrac{(t_0-t)(t_1-t)}{(t_2-t_1)(t_2-t_0)}\\pmb k_2\n$$\n  插值抛物线导数：\n$$\n\\dot{\\pmb p}(t_0)=\n-\\dfrac{(t_2-t_0)+(t_1-t_0)}{(t_2-t_0)(t_1-t_0)}\\pmb k_0+\n\\dfrac{(t_2-t_0)}{(t_2-t_1)(t_1-t_0)}\\pmb k_1-\n\\dfrac{(t_1-t_0)}{(t_2-t_1)(t_2-t_0)}\\pmb k_2\n$$\n  $\\pmb b_1$的位置：\n$$\n\\pmb b_1=\\pmb b_0+\\dfrac{t_1-t_0}{3}\\dot{\\pmb p}(t_0)\n$$\n    Natural End Condition\n$$\n\\begin{align}\n\\ddot {\\pmb x}(t_0)\u0026amp;=0\\Leftrightarrow \\pmb b_1=\\dfrac{\\pmb b_2+\\pmb b_0}{2}\\\\\\\\\n\\ddot{\\pmb x}(t_n)\u0026amp;=0\\Leftrightarrow \\pmb b_{3n-1}=\\dfrac{\\pmb b_{3n-2}+\\pmb b_{3n}}{2}\n\\end{align}\n$$\n  事实上，如果曲线闭合（首尾相连），则可以无需计算端点条件，继续在首尾处计算$C^1$、$C^2$条件即可\n5. 视频演示 IlumEngine中实现了三次Bézier样条曲线，使用Uniform参数化以及Natural端点条件\n\n","description":"Bézier样条曲线原理与实现","id":11,"section":"posts","tags":["Geometry"],"title":"几何造型(2)：Bézier样条曲线","uri":"https://chaphlagical.github.io/zh/posts/geometry/bezier_spline/"},{"content":"1. 基本原理 Bézier曲线于1962年，由法国工程师Pierre Bézier所提出，用于汽车的主体的几何造型设计。\n二阶Bézier曲线如下图所示：\n其几何构造流程如下：\n 依次选定控制点$A$、$B$、$C$ 在$AB$上选定一动点$D$，设参数$t=\\frac{AD}{AB}$，则$t\\in[0,1]$ 在$BC$上构造一点$E$，满足$\\frac{AD}{AB}=\\frac{BE}{BC}=t$ 连接$DE$ 在$DE$上构造一点$F$，满足$\\frac{DF}{DE}=\\frac{AD}{AB}=\\frac{BE}{BC}=t$ 当$t$从0到1变化时，点$F$构成的轨迹即为二阶Bézier曲线  从解析几何角度看，设控制点$A$、$B$、$C$坐标依次为$\\pmb p_1$、$\\pmb p_2$和$\\pmb p_3$，则点$D$可表示为$\\pmb p_4 = (1-t)\\pmb p_1+t\\pmb p_2$，点$E$表示为$\\pmb p_5=(1-t)\\pmb p_2+t\\pmb p_3$，点$F$表示为$\\pmb p_6=(1-t)\\pmb p_4+t\\pmb p_5=(1-t)^2\\pmb p_1+2(1-t)t\\pmb p_2+t^2\\pmb p_3$\n同理我们还可以构造三阶Bézier曲线：\n我们可以从中看出规律，给定$N$个控制点，将生成$N-1$阶的Bézier曲线，几何构造方式都是通过在控制点连线上按比例参数选取新的控制点，然后通过新的控制点再往下生成控制点，直到最终只生成一个控制点，该点则对应参数下Bézier曲线的取值。\n2. De Casteljau算法 2.1. 算法原理 De Casteljau算法是计算给定参数$t$下Bézier曲线上点的坐标的迭代求解方法。\n对于给定控制点$\\pmb b_0,\\pmb b_1,\\cdots,\\pmb b_n\\in\\mathbb R^3$，我们希望得到曲线$\\pmb x(t),t\\in[0,1]$，De Casteljau算法的迭代方程如下：\n$$\n\\begin{align}\n\\pmb b_i^0(t)\u0026amp;=\\pmb b_i,\\ \\ \\ \\ i=0,\\cdots,n\\\\\n\\pmb b_i^r(t)\u0026amp;=(1-t)\\pmb b_i^{r-1}(t)+t\\pmb b_{i+1}^{r-1}(t)\\\\\nr=\u0026amp;1,\\cdots,n\\ \\ \\ \\ i=0,\\cdots,n-r\n\\end{align}\n$$\n最后，$\\pmb b_0^n(t)$为所找的曲线点$\\pmb x(t)$在参数值$t$的取值，C++程序如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  glm::vec3 BezierCurve::value(const std::vector\u0026lt;glm::vec3\u0026gt; \u0026amp;control_points, float t) { size_t n = control_points.size(); std::vector\u0026lt;glm::vec3\u0026gt; br(control_points); std::vector\u0026lt;glm::vec3\u0026gt; br_1(control_points); for (size_t r = 1; r \u0026lt; n; r++) { for (size_t i = 0; i \u0026lt; n - r; i++) { br[i] = (1 - t) * br_1[i] + t * br_1[i + 1]; } br_1 = br; } return br_1[0]; }   2.2. 算法性质  控制点$\\pmb b_0,\\pmb b_1,\\cdots,\\pmb b_n\\in\\mathbb R^3$依次构成的多边形称为Bézier多边形 控制点$\\pmb b_i$也称为Bézier点 只使用凸组合，因此算法数值稳定 算法复杂度  时间复杂度$O(n^2)$ 空间复杂度$O(n)$    3. Bézier曲线的解析表达 3.1. Bernstein基描述 De Casteljau算法提供了一种迭代求解Bézier曲线的方法，同时我们也可以解析地写出Bézier曲线的基函数表达：\n$$\n\\pmb x(t)=\\sum_{i=0}^nC_n^it^i(1-t)^{n-i}\\pmb b_i\n$$\n其中$C_n^i$为组合数$C_n^i=\\frac{n!}{i!(n-i)!}$，Bernstein基定义为：\n$$\nB_i^n(t)=\n\\begin{cases}\nC_n^it^i(1-t)^{n-i}\u0026amp;t\\in[0,1],i\\in[0,n],i\\in\\mathbb N\\\\\\\\\n0\u0026amp;i\u0026lt;0\\ or\\ i\u0026gt;n\\\\\\\\\n1\u0026amp;i=0\\ and \\ n=0\n\\end{cases}\n$$\nBernstein基示例：\n3.2. Bernstein基的性质 光滑性\nBernstein基函数为$n$次多项式，显然光滑\n归一性\n$$\n\\sum\\limits_{i=0}^nB_i^{n}(t)=(t+(1-t))^n=1\n$$\n递推\n$$\nB_i^n(t)=(1-t)B_i^{n-1}(t)+tB^{n-1}_{i-1}(t)\n$$\n 证明：\n$$\n\\begin{align}\n(1-t)B_i^{n-1}(t)+tB^{n-1}_{i-1}(t)\u0026amp;=(1-t)C_{n-1}^{i}t^i(1-t)^{n-1-i}+tC_{n-1}^{i-1}t^{i-1}(1-t)^{n-i}\\\\\\\\\n\u0026amp;=(C_{n-1}^{i}+C_{n-1}^{i-1})t^i(1-t)^{n-i}\\\\\\\\\n\u0026amp;=C_n^it^i(1-t)^{n-i}\\\\\\\\\n\u0026amp;=B_i^n(t)\n\\end{align}\n$$\n 导数\n$$\n\\frac{\\mathrm d}{\\mathrm dt}B_i^{n}(t)=n\\left[B^{n-1}_{i-1}(t)-B_i^{n-1}(t)\\right]\n$$\n 证明：\n$$\n\\begin{align}\n\\frac{\\mathrm d}{\\mathrm dt}B^n_i(t)\u0026amp;=\\frac{\\mathrm d}{\\mathrm dt}\\left( C_n^it^i(1-t)^{n-i}\\right)\\\\\\\\\n\u0026amp;=iC_n^it^{i-1}(1-t)^{n-i}-(n-i)C_n^it^i(1-t)^{n-i-1}\\\\\\\\\n\u0026amp;=\\frac{n!}{(n-i)!i!}it^{i-1}(1-t)^{n-i}-\\frac{n!}{(n-i)!i!}(n-i)t^i(1-t)^{n-i-1}\\\\\\\\\n\u0026amp;=n\\left[\\frac{(n-1)!}{(n-i)!(i-1)!}t^{i-1}(1-t)^{n-i}-\\frac{(n-1)!}{(n-i-1)!i!}t^i(1-t)^{n-i-1} \\right]\\\\\\\\\n\u0026amp;=n\\left[C_{n-1}^{i-1}t^{i-1}(1-t)^{n-i}-C_{n-1}^i t^i(1-t)^{n-i-1} \\right]\\\\\\\\\n\u0026amp;=n\\left[B^{n-1}_{i-1}(t)-B_i^{n-1}\\right]\n\\end{align}\n$$\n 最值\n$B^n_i(t)$在$t=\\frac{i}{n}$处取得最大值\n 证明：\n由导数为0\n$$\n\\frac{\\mathrm d}{\\mathrm dt}B_i^{n}(t)=n\\left[B^{n-1}_{i-1}(t)-B_i^{n-1}(t)\\right]=0\n$$\n可得当$t=\\frac{i}{n}$时取得最大值\n 对称性\n$$\nB_i^n(t)=B_{n-i}^n(1-t)\n$$\n 证明：\n$$\n\\begin{align}\nB_i^n(t)\u0026amp;=C_n^it^i(1-t)^{n-i}\\\\\\\\\n\u0026amp;=\\frac{n!}{(n-i)!i!}t^i(1-t)^{n-i}\\\\\\\\\n\u0026amp;=\\frac{n!}{(n-(n-i))!(n-i)!}(1-t)^{n-i}t^{n-(n-i)}\\\\\\\\\n\u0026amp;=B_{n-i}^n(1-t)\n\\end{align}\n$$\n 非负性\n$$\n\\begin{align}\nB_i^n(t)\u0026amp;\\geq 0,t\\in [0,1]\\\\\\\\\nB_0^{(n)}(0)=1,\u0026amp;\\ \\ \\ \\ B_1^{(n)}(0)=\\cdots=B_n^{(n)}(0)=0\\\\\\\\\nB_0^{(n)}(1)=\u0026amp;\\cdots=B_{n-1}^{(n)}=0,\\ \\ \\ \\ B_n^{(n)}(1)=1\n\\end{align}\n$$\n4. Bézier曲线的性质 聊完Bézier曲线的构造方法以及Bernstein基函数的相关内容，我们再来聊聊Bézier曲线本身具有的几何性质。\n4.1. 仿射不变性 仿射变换定义为：\n$$\n\\pmb x\\rightarrow\\pmb A\\pmb x+\\pmb b\n$$\n包含线性部分和平移部分。\n线性不变性\nBézier曲线的线性不变性是显然的，Bézier曲线表示为基函数的线性组合：\n$$\n\\pmb f(t)=\\sum\\limits_{i=1}^nb_i(t)\\pmb p_i=\\sum\\limits_{i=1}^nb_i(t)\\begin{pmatrix}\np_i^{(x)}\\\\p_i^{(y)}\\\\p_i^{(z)}\n\\end{pmatrix}\n$$\n因此\n$$\nA(\\pmb f(t))=A\\Big(\\sum\\limits_{i=1}^nb_i(t)\\pmb p_i \\Big)=\\sum\\limits_{i=1}^nb_i(t)(A\\pmb p_i)\n$$\n平移不变性\n$$\n\\sum\\limits_{i=1}^nb_i(t)(\\pmb p_i+\\pmb b)=\\sum\\limits_{i=1}^nb_i(t)\\pmb p_i+\\sum\\limits_{i=1}^nb_i(t)\\pmb b=\\pmb f(t)+\\Big(\\sum\\limits_{i=1}^nb_i(t)\\Big)\\pmb b\n$$\n其中，由Bernstein基函数的归一性，$\\sum\\limits_{i=1}^nb_i(t)=1$，满足平移不变性。\n4.2. 凸包性质 点集${\\pmb p_1,\\cdots,\\pmb p_n}$的一个凸组合为如下形式：\n$$\n\\sum\\limits_{i=1}^n\\lambda_i\\pmb p_i\\ \\mathrm{with}\\sum\\limits_{i=1}^n\\lambda_i=1\\ \\mathrm{and}\\ \\forall i=1,\\cdots,n:0\\leq\\lambda_i\\leq 1\n$$\n因此Bézier曲线为Bernstein基函数的凸组合，能够避免不良震荡，将构造的曲线限制在控制点的凸包中。\n4.3. 导数性质 对于Bézier曲线\n$$\n\\pmb x(t)=\\sum_{i=0}^nB_i^n(t)\\pmb p_i\n$$\n一阶导数：\n$$\n\\begin{aligned}\n\\frac{\\mathrm d\\pmb x}{\\mathrm dt}\u0026amp;=n\\sum_{i=0}^{n}\\left[B^{n-1}_{i-1}(t)-B_i^{n-1}(t)\\right]\\pmb p_i\\\\\\\\\n\u0026amp;=n\\sum_{i=0}^nB_{i-1}^{n-1}(t)\\pmb p_i-n\\sum_{i=0}^n B_i^{n-1}(t)\\pmb p_i\\\\\\\\\n\u0026amp;=n\\sum_{i=-1}^{n-1}B_i^{n-1}(t)\\pmb p_{i+1}-n\\sum_{i=0}^nB_i^{n-1}(t)\\pmb p_i\\\\\\\\\n\u0026amp;=n\\sum_{i=0}^{n-1}B_i^{n-1}(t)\\pmb p_{i+1}-n\\sum_{i=0}^nB_i^{n-1}(t)\\pmb p_i\\\\\\\\\n\u0026amp;=n\\sum_{i=0}^{n-1}B_i^{n-1}(\\pmb p_{i+1}-\\pmb p_i)\n\\end{aligned}\n$$\n边界条件：\n$$\n\\begin{cases}\n\\pmb x'(0)=n(\\pmb p_1-\\pmb p_0)\\\\\\\\\n\\pmb x'(1)=n(\\pmb p_n-\\pmb p_{n-1})\n\\end{cases}\n$$\n高阶导数：\n$$\n\\frac{\\mathrm d^r}{\\mathrm dt^r}\\pmb x(t)=\\frac{n!}{(n-r)!}\\sum_{i=0}^{n-r}B_i^{n-r}(t)\\cdot\\Delta^r\\pmb p_i\n$$\n其中，\n一阶差分：$\\Delta \\pmb p_i=\\pmb p_{i+1}-\\pmb p_i$\n二阶差分：$\\Delta^2\\pmb p_i=\\Delta\\pmb p_{i+1}-\\Delta \\pmb p_i=\\pmb p_{i+2}-2\\pmb p_{i+1}+\\pmb p_i$\n高阶差分递推式：$\\Delta^r\\pmb p_i=\\Delta^{r-1} \\pmb p_{i+1}-\\Delta^{r-1} \\pmb p_i$\n归纳法有：$\\Delta^r\\pmb p_i=\\sum_{k=0}^r(-1)^kC_r^k\\pmb p_{i+r-k}$\n4.4. 杂项性质结论 一条 Bézier 曲线的弧长不大于其控制多边形的周长\n 证明：\n设Bézier曲线方程为$\\pmb f(t)$，曲线弧长为$L$，多边形周长为$C$，则Bézier曲线弧长为：\n$$\n\\begin{aligned}\nL\u0026amp;=\\int_0^1\\|\\pmb f'(t)\\|\\mathrm dt\\\\\\\\\n\u0026amp;=\\int_0^1\\left\\|n\\sum_{i=0}^{n-1}B_i^{(n-1)}(t)(\\pmb p_{i+1}-\\pmb p_i)\\right\\|\\mathrm dt\\\\\\\\\n\u0026amp;\\leq n\\sum_{i=0}^{n-1}\\|\\pmb p_{i+1}-\\pmb p_i\\|\\cdot \\int_0^1B_i^{(n-1)}(t)\\mathrm dt\n\\end{aligned}\n$$\n由Bernstein基函数的性质，有：\n$$\n\\frac{\\mathrm d}{\\mathrm dt}B_i^{(n)}(t)=n\\left[B_{i-1}^{(n-1)}(t)-B_i^{(n-1)}(t)\\right]\n$$\n从0到1积分得：\n$$\nB_i^{(n)}(1)-B_i^{(n)}(0)=n\\left[\\int_0^1B_{i-1}^{(n-1)}(t)-\\int_0^1B_i^{(n-1)}(t)\\right]=0\n$$\n依此类推有：\n$$\n\\int_0^1 B_0^{(n-1)}(t)\\mathrm dt=\n\\int_0^1 B_1^{(n-1)}(t)\\mathrm dt=\n\\cdots=\n\\int_0^1 B_{n-1}^{(n-1)}(t)\\mathrm dt=\\frac{1}{n}\n$$\n因此，有：\n$$\nL\\leq \\sum_{i=0}^{n-1}|\\pmb p_{i+1}-\\pmb p_i|=C\n$$\n结论得证\n 圆弧不能用Bézier曲线精确表示\n 设有一圆弧圆心为$\\pmb c$，半径为$r$，假设它能够用一Bézier曲线$\\pmb f(t)$进行表示，则有：\n$$\n\\left|\\pmb f(t)-\\pmb c\\right|\\equiv r\n$$\n其中，\n$$\n\\begin{aligned}\n\\pmb f(t)\u0026amp;=\\sum_{i=1}^{n}B_i^{n}(t)\\pmb p_i\\\\\\\\\n\u0026amp;=\\sum_{i=1}^{n}\\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}\\pmb p_i\n\\end{aligned}\n$$\n又\n$$\n\\left\\|\\sum_{i=1}^{n}\\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}\\pmb p_i-\\pmb c\\right\\|\\not\\equiv\\mathrm{const}\n$$\n因此假设不成立，圆弧不能用Bézier曲线精确表示\n 5. Bézier曲线的升阶(Degree Elevation) 给定$n+1$个Bézier控制点$\\pmb b_0,\\pmb b_1,\\cdots,\\pmb b_n$，生成Bézier曲线$\\pmb x(t)$\nBézier曲线的升阶即希望生成$n+2$个Bézier控制点$\\bar{\\pmb b}_0,\\bar{\\pmb b}_1,\\cdots,\\bar{\\pmb b}_n$，从而得到曲线$\\bar{\\pmb x}(t)$，满足$\\bar{\\pmb x}(t)=\\pmb x(t)$\n解决方法：\n$$\n\\begin{aligned}\n\\bar{\\pmb b}_0\u0026amp;=\\pmb b_0\\\\\\\\\n\\bar{\\pmb b}_{n+1}\u0026amp;=\\pmb b_n\\\\\\\\\n\\bar{\\pmb b}_j\u0026amp;=\\dfrac{j}{n+1}\\pmb b_{j-1}+\\Big(1-\\dfrac{j}{n+1}\\Big)\\pmb b_j\\ \\ \\ \\ \\ \\mathrm{for}\\ j=1,\\cdots,n\n\\end{aligned}\n$$\n 证明：\n$$\n\\begin{aligned}\n(1-t)B_i^n(t)\u0026amp;=(1-t)C_n^it^i(1-t)^{n-i}\\\\\\\\\n\u0026amp;=C_n^it^i(1-t)^{n+1-i}\\\\\\\\\n\u0026amp;=\\frac{n+1-i}{n+1}C_{n+1}^it^i(1-t)^{n+1-i}\\\\\\\\\n\u0026amp;=\\frac{n+1-i}{n+1}B_i^{n+1}(t)\n\\end{aligned}\n$$\n类似地，\n$$\ntB_i^n(t)=\\dfrac{i+1}{n+1}B_i^{n+1}(t)\n$$\n从而有：\n$$\n\\begin{align}\n\\pmb f(t)\u0026amp;=[(1-t)+t]\\pmb f(t)\\\\\\\\\n\u0026amp;=[(1-t)+t]\\sum\\limits_{i=0}^nB_i^n(t)\\pmb P_i\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\Big[(1-t)B_i^n(t)+tB_i^n(t)\\Big]\\pmb P_i\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\Bigg[\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)+\\dfrac{i+1}{n+1}B_{i+1}^{n+1}(t) \\Bigg]\\pmb P_i\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)\\pmb P_i+\\sum\\limits_{i=0}^n\\dfrac{i+1}{n+1}B_{i+1}^{n+1}(t) \\pmb P_i\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)\\pmb P_i+\\sum\\limits_{i=1}^n\\dfrac{i}{n+1}B_{i}^{n+1}(t) \\pmb P_{i-1}\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^{n+1}\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)\\pmb P_i+\\sum\\limits_{i=0}^n\\dfrac{i}{n+1}B_{i}^{n+1}(t) \\pmb P_{i-1}\\\\\\\\\n\u0026amp;=\\sum\\limits_{i=0}^{n+1}B_i^{n+1}(t)\\Bigg[\\dfrac{n+1-i}{n+1}\\pmb P_i+\\dfrac{i}{n+1}\\pmb P_{i-1} \\Bigg]\n\\end{align}\n$$\n 示例：\n6. Bézier曲线的划分(Subdivision) 给定$n+1$个Bézier控制点$\\pmb b_0,\\pmb b_1,\\cdots,\\pmb b_n$，生成Bézier曲线$\\pmb x(t)$\nBézier曲线的划分即希望得到两条曲线：\n $\\pmb{b}_0^{[1]},\\dots,\\pmb{b}_n^{[1]}\\to \\pmb{x}^{[1]}(t)$ $\\pmb{b}_0^{[2]},\\dots,\\pmb{b}_n^{[2]}\\to \\pmb{x}^{[2]}(t)$  且两条曲线合并可得$\\pmb{x}=\\pmb{x}^{[1]}\\cup \\pmb{x}^{[2]}$\n解决方法：\n$$\n\\begin{aligned}\n\\pmb b_i^{(1)}\u0026amp;=\\pmb b_0^i\\\\\\\\\n\\pmb b_i^{(2)}\u0026amp;=\\pmb b_0^{n-i}\\\\\\\\\n\\mathrm{for}\\ i\u0026amp;=0,\\cdots,n\n\\end{aligned}\n$$\n该方法的依据如下图所示：\n7. 视频演示 Bézier曲线已在IlumEngine中实现，使用De Casteljau算法进行构造。\n\n","description":"Bézier曲线原理与实现","id":12,"section":"posts","tags":["Geometry"],"title":"几何造型(1)：Bézier曲线","uri":"https://chaphlagical.github.io/zh/posts/geometry/bezier_curve/"},{"content":"鼠标拾取是引擎场景编辑器的一个非常基础的功能，通过点击屏幕像素选择场景中的物体，能够使用户更加方便地选择物体、编辑场景。利用空闲时间我将IlumEngine场景编辑器的鼠标拾取功能做了一个优化，从原来的基于Ray Casting方法到现在所使用的G-Buffer回读的方法，两种方法各有优劣，下面详细介绍这两种鼠标拾取的方法。\n1. 基于Ray Casting的鼠标拾取方法 基于Ray Casting的鼠标拾取是一种几何方法，其基本原理如下：\n 由鼠标点击的屏幕像素坐标，生成一条从摄像机发射的射线 对场景作求交计算（与Ray Tracing中的相交检测相同） 寻找与光线相交的最近包围盒，其对应的物体即为鼠标将选中的物体  已知我们已从窗口/UI系统中得到鼠标点击的像素坐标click_pos，首先将其转化为屏幕空间坐标：\n1 2  float x = (click_pos.x / scene_view_size.x) * 2.f - 1.f; float y = -((click_pos.y / scene_view_size.y) * 2.f - 1.f);   我们希望利用拾取点的屏幕空间坐标从相机发射一条射线，一种思路是计算拾取点的远近平面投影坐标，然后将它们连起来即可：\n1 2 3 4 5 6 7 8 9 10  glm::mat4 inv = glm::inverse(main_camera.view_projection); glm::vec4 near_point = inv * glm::vec4(x, y, 0.f, 1.f); near_point /= near_point.w; glm::vec4 far_point = inv * glm::vec4(x, y, 1.f, 1.f); far_point /= far_point.w; geometry::Ray ray; ray.origin = main_camera.position; ray.direction = glm::normalize(glm::vec3(far_point - near_point));   最后，用射线做与包围盒的求交，求交的计算也可用BVH、KD-Tree等加速结构进行加速，这里为了快速实现只是简单遍历并对每个包围盒进行求交：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  float distance = std::numeric_limits\u0026lt;float\u0026gt;::infinity(); const auto group = Scene::instance()-\u0026gt;getRegistry().group\u0026lt;\u0026gt;(entt::get\u0026lt;cmpt::MeshRenderer, cmpt::Transform\u0026gt;); group.each([\u0026amp;](const entt::entity \u0026amp;entity, const cmpt::MeshRenderer \u0026amp;mesh_renderer, const cmpt::Transform \u0026amp;transform) { if (!Renderer::instance()-\u0026gt;getResourceCache().hasModel(mesh_renderer.model)) { return; } auto \u0026amp;model = Renderer::instance()-getResourceCache().loadModel(mesh_renderer.model); float hit_distance = ray.hit(model.get().bounding_box.transform(transform.world_transform)); if (distance \u0026gt; hit_distance) { distance = hit_distance; Editor::instance()-\u0026gt;select(Entity(entity)); } }); }   具体求交的计算后续光线追踪模块的开发将会提到，这里不作具体阐述。\n2. 基于G-Buffer回读的鼠标拾取方法 基于G-Buffer的鼠标拾取是一种图像方法，在几何阶段生成G-Buffers时我们顺带生成一张带有场景物体实体ID的G-Buffer，格式为VK_FORMAT_R32_UINT。在得到鼠标响应时，将该G-Buffer的数据回读到CPU中，利用像素坐标查找相应的实体ID，得到拾取到的对象。完整过程的源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  ImageReference entity_id_buffer = Renderer::instance()-\u0026gt;getRenderGraph()-\u0026gt;getAttachment(\u0026#34;debug - entity\u0026#34;); CommandBuffer cmd_buffer; cmd_buffer.begin(); Buffer staging_buffer(static_cast\u0026lt;VkDeviceSize\u0026gt;(entity_id_buffer.get().getWidth() * entity_id_buffer.get().getHeight()) * sizeof(uint32_t), VK_BUFFER_USAGE_TRANSFER_DST_BIT, VMA_MEMORY_USAGE_GPU_TO_CPU); cmd_buffer.transferLayout(entity_id_buffer, VK_IMAGE_USAGE_SAMPLED_BIT, VK_IMAGE_USAGE_TRANSFER_SRC_BIT); cmd_buffer.copyImageToBuffer(ImageInfo{entity_id_buffer, VK_IMAGE_USAGE_TRANSFER_SRC_BIT, 0, 0}, BufferInfo{staging_buffer, 0}); cmd_buffer.transferLayout(entity_id_buffer, VK_IMAGE_USAGE_TRANSFER_SRC_BIT, VK_IMAGE_USAGE_SAMPLED_BIT); cmd_buffer.end(); cmd_buffer.submitIdle(); std::vector\u0026lt;uint32_t\u0026gt; image_data(entity_id_buffer.get().getWidth() * entity_id_buffer.get().getHeight()); std::memcpy(image_data.data(), staging_buffer.map(), image_data.size() * sizeof(uint32_t)); click_pos.x = glm::clamp(click_pos.x, 0.f, static_cast\u0026lt;float\u0026gt;(entity_id_buffer.get().getWidth())); click_pos.y = glm::clamp(click_pos.y, 0.f, static_cast\u0026lt;float\u0026gt;(entity_id_buffer.get().getHeight())); auto entity = Entity(static_cast\u0026lt;entt::entity\u0026gt;(image_data[static_cast\u0026lt;uint32_t\u0026gt;(click_pos.y) * entity_id_buffer.get().getWidth() + static_cast\u0026lt;uint32_t\u0026gt;(click_pos.x)])); Editor::instance()-\u0026gt;select(entity); staging_buffer.unmap();   由于G-Buffer的内存访问方式均为GPU_only的，我们需要使用一块GPU_to_CPU的Buffer进行暂存，最后Map到CPU内存中。\n3. 比较与选择  Ray Casting方法  优点  CPU实现，不依赖于渲染管线，能够很方便地集成   缺点  不够精确，由于是射线与包围盒求交，拾取的实际上是物体对应的包围盒而不是物体本身，有时候会带来误差，在场景复杂时效果不好 性能受场景规模影响较大，而使用加速结构进行求交加速实际上也增加了集成复杂度（需要引擎具有光追或物理模块支持）     G-Buffer方法  优点  精准，由于是直接把实体ID贴到纹理上，因此能够做到像素级的拾取   缺点  需要一张G-Buffer，增加了带宽开销 需要回读GPU数据，不过只有在鼠标点击时才会触发，影响并不大 需要渲染管线支持，需要配合整个渲染系统进行设计      在开发前期，Render Graph还不够完善，渲染管线扩展能力一般，为了简便，我先直接用Ray Casting的方法给IlumEngine加上一个基本能用的拾取方法，后来为了拾取精度的需要，将拾取算法改为了基于G-Buffer方法。\n最终实现效果如下：\n\n","description":"IlumEngine编辑器鼠标拾取原理","id":13,"section":"posts","tags":["IlumEngine"],"title":"场景编辑器：鼠标拾取","uri":"https://chaphlagical.github.io/zh/posts/rendering/mouse_picking/"},{"content":"前段时间初步完成了个人图形引擎IlumEngine的第一次性能优化。此次优化主要集中在几何渲染与纹理系统上，主要内容大致有：\n Vertex/Index Buffer Packing GPU Driven Rendering  GPU Based Culling  Frustum Culling Hierarchy Z Buffer Occlusion Culling Cone Back Face Culling   Multi Draw Indirect Bindless Texture System    利用现代API灵活的可操作性，解决了几何阶段大量DrawCalls带来的CPU压力，以及提高顶点、索引数据的利用率，并且该架构也有利于后续集成实时光线追踪等功能\n1. IlumEngine简介 IlumEngine是我目前正在开发的一个玩具图形引擎，名字取自*《星球大战》*中凯伯水晶的产地伊冷（后传中被第一军团改造为弑星者基地），引擎使用Vulkan作为图形API（后续或重构为RHI层以支持DX12甚至向下兼容OpenGL），目的是锻炼软件系统工程能力和作为学习图形学经典技术复现和前沿技术的实验平台，预期功能：\n  Render Graph高灵活度渲染管线架构\n  基于ImGui的交互友好的编辑器\n  异步资源加载系统（或进化至流式加载系统）\n  集成基本几何造型算法\n Bezier曲线 三次样条曲线 B样条曲线 有理样条曲线 有理样条曲面等    集成基本数字几何处理算法\n 网格参数化 网格简化与细分 网格变形等    集成基本物理模拟算法\n 刚体模拟 布料模拟 柔性体模拟 流体模拟    集成基本光栅渲染算法\n Forward/Deferred/Tile Based渲染管线 实时阴影  PCF、PCSS VSM CSM   环境光照：IBL、PRT 全局光照  DDGI VXGI等   屏幕空间后处理  Blooming SSGI SSR等      集成基本离线渲染算法\n PT PM BDPT等    目前已将基础的架构部分搭建完成，能够支持Disney PBR材质的延迟渲染管线：\n接下来几节将从存储优化、CPU负载优化、GPU负载优化方面来介绍此次引擎优化的主要内容。\n2. 几何缓存优化 在介绍引擎的几何缓存优化之前，先介绍一下目前引擎使用的场景图和几何模型存储结构。\n2.1. 场景图 场景图是渲染引擎中重要的一个部分，通常采用树状结构（有向无环图）进行组织，IlumEngine中使用基于entt的实体组件系统ECS来实现场景图：\n 每个实体（Entity）作为场景图中的一个结点 每个实体可以挂上若干个组件（Component） 实体只是拓扑关系的结点，不存储实际数据 组件仅存储数据，而不存储逻辑（函数、方法） 组件中的数据由系统（System）使用，实现场景图的更新  想让一个实体拥有几何数据，则将该实体挂载上MeshRenderer组件，在渲染循环系统中，将从所有实体的MeshRenderer中获取渲染所需的几何数据，以完成几何阶段的渲染。\n2.2. 几何模型存储结构 组件MeshRenderer定义如下：\n1 2 3 4 5 6  struct MeshRenderer { std::string model; std::vector\u0026lt;scope\u0026lt;IMaterial\u0026gt;\u0026gt; materials; inline static bool update = false; };   其中，\n model为模型数据的索引，这里使用模型文件所在位置的相对路径表示 materials为模型的材质，初始化时将拷贝为模型的默认材质，在编辑器中也可对某个实体的材质进行修改 update为全局静态更新变量，表示在某循环中与MeshRenderer相关的更新  为得到实际的几何数据，我们还需要利用索引model在资源管理器ResourceCache中查询几何模型，ResourceCache实现了模型与贴图的多线程异步加载和缓存查询等功能，这里不作展开。通过查询，将得到实际模型对象的引用ModelReference：\n1  using ModelReference = std::reference_wrapper\u0026lt;Model\u0026gt;;   而Model便是我们实际存储几何数据的对象了，Model中又有如下数据：\n1 2 3 4 5 6 7  struct Model { std::vector\u0026lt;SubMesh\u0026gt; submeshes; geometry::BoundingBox bounding_box; VertexInfo vertex_info; IndexInfo index_info; }   其中，Submesh为模型的子网格，为导入方便以及支持单个模型不同部分使用不同材质，IlumEngine采用了子网格的形式来组织大型模型，每个子网格拥有以下信息：\n1 2 3 4 5 6 7 8 9  struct Submesh { uint32_t index = 0; glm::mat4 pre_transform = glm::mat4(1.f); material::DisneyPBR material; geometry::BoundingBox bounding_box; VertexInfo vertex_info; IndexInfo index_info; }   其实和Model是差不多的，Submesh是目前几何数据渲染的最小独立单位。\n2.3. 几何存储方案 上文已介绍了几何模型的一个存储结构，但是并未涉及具体的几何数据存储方案，所谓的几何数据存储方案，一个是CPU端的存储，即顶点和索引数据的存储；一个是GPU端的存储，即Vertex Buffer与Index Buffer的存储。对于静态网格模型而已，完全可以将几何数据送入GPU后删除CPU端的数据，但由于本引擎后续需要加入几何处理的功能，为了方便起见依旧全部保留CPU端的几何信息。\n2.3.1. 极简方案 最简单的一种也是最直观的一种策略，便是每个子网格存一份位置的几何信息，即：\n1 2 3 4 5 6 7 8 9 10 11  struct Submesh { uint32_t index = 0; glm::mat4 pre_transform = glm::mat4(1.f); material::DisneyPBR material; geometry::BoundingBox bounding_box; std::vector\u0026lt;Vertex\u0026gt; vertices; std::vector\u0026lt;uint32_t\u0026gt; indices; Buffer vertex_buffer; Buffer index_buffer; }   这种方法最为简单直观，也方便编程，但在实际渲染过程中会有渲染状态频繁切换的问题。假设有$N$个模型，第$i$个模型具有$M_i$个子网格，那么在一个渲染循环内需要做以下操作：\n  遍历$N$个模型\n  遍历模型$i$中的$M_i$个子网格\n  绑定子网格对应的GPU资源\n1 2  vkCmdBindVertexBuffers(cmd_buffer, 0, 1, \u0026amp;vertex_buffer, 0); vkCmdBindIndexBuffer(cmd_buffer, index_buffer, 0, VK_INDEX_TYPE_UINT32);     执行渲染绘制操作\n1  vkCmdDrawIndexed(cmd_buffer, index_count, 1, 0, 0, 0);     因此在一个渲染循环中需要切换绑定$N*M$次顶点/索引缓冲，当模型数量增加时会明显影响效率，而且多块小存储空间也不是一种好的存储分配策略，容易带来内存碎片等问题，同时，当模型具有多个重复的子网格时，这种存储策略将造成数据冗余，降低存储资源的利用率\n2.3.2. 基于模型的优化方案 既然子网格存储所有的几何数据不太好，那我就每个模型存储一份几何数据，然后子网格只存偏移和长度咯。基于模型的优化方案也确实是这样的设计思路：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  struct Model { std::vector\u0026lt;SubMesh\u0026gt; submeshes; geometry::BoundingBox bounding_box; std::vector\u0026lt;Vertex\u0026gt; vertices; std::vector\u0026lt;uint32_t\u0026gt; indices; Buffer vertex_buffer; Buffer index_buffer; } struct Submesh { uint32_t index = 0; glm::mat4 pre_transform = glm::mat4(1.f); material::DisneyPBR material; geometry::BoundingBox bounding_box; uint32_t indices_offset; uint32_t indices_count; }   模型中存储了所有子网格的几何数据，通过顶点索引的偏移offset和顶点索引数量count即可绘制出相应的子网格。由于目前的索引均从顶点缓冲的开头开始，因此暂不需要vertex_offset的参与。\n假设有$N$个模型，第$i$个模型具有$M_i$个子网格，那么在一个渲染循环内需要做以下操作：\n  遍历$N$个模型\n  绑定模型对应的GPU资源\n1 2  vkCmdBindVertexBuffers(cmd_buffer, 0, 1, \u0026amp;vertex_buffer, 0); vkCmdBindIndexBuffer(cmd_buffer, index_buffer, 0, VK_INDEX_TYPE_UINT32);     遍历模型$i$中的$M_i$个子网格\n  执行渲染绘制操作\n1  vkCmdDrawIndexed(cmd_buffer, index_count, 1, index_offset, 0, 0);     因此在一个渲染循环中需要切换绑定$N$次顶点/索引缓冲，比前述的极简方案要好不少，同时模型存储也避免了多个重复子网格冗余的问题，相同的子网格只要有相同的索引偏移和数量即可。\n2.3.3. 统一存储的优化方案 基于模型的方案在渲染每个模型时依然需要切换绑定顶点索引缓冲，在模型数量很多时同样可能带来瓶颈，同时也不利于我们后面进行GPU Driven Rendering的single drawcall设计。所以这次一劳永逸，分配一个大块的GPU显存资源来存储所有的顶点和索引缓冲，而CPU端的几何数据则仍按基于模型的方案设计。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  struct Model { std::vector\u0026lt;SubMesh\u0026gt; submeshes; geometry::BoundingBox bounding_box; std::vector\u0026lt;Vertex\u0026gt; vertices; std::vector\u0026lt;uint32_t\u0026gt; indices; uint32_t indices_offset; uint32_t vertices_offset; } struct Submesh { uint32_t index = 0; glm::mat4 pre_transform = glm::mat4(1.f); material::DisneyPBR material; geometry::BoundingBox bounding_box; uint32_t vertex_offset; uint32_t indices_offset; uint32_t indices_count; } class Renderer { Buffer vertex_buffer; Buffer index_buffer; ... }   该方案的麻烦之处在于，每当有模型添加、修改或删除时需要对全局缓冲进行更新，同时也需要更新每个模型的偏移。下图为各个存储索引关系示例：\n现在，假设有$N$个模型，第$i$个模型具有$M_i$个子网格，那么在一个渲染循环内需要做以下操作：\n  绑定几何数据对应的GPU资源\n1 2  vkCmdBindVertexBuffers(cmd_buffer, 0, 1, \u0026amp;vertex_buffer, 0); vkCmdBindIndexBuffer(cmd_buffer, index_buffer, 0, VK_INDEX_TYPE_UINT32);     遍历$N$个模型\n  遍历模型$i$中的$M_i$个子网格\n  执行渲染绘制操作\n1  vkCmdDrawIndexed(cmd_buffer, index_count, 1, index_offset, vertex_offset, 0);     现在，我们彻底地将几何资源绑定次数降低至single bind，无论场景多大，模型数量多少我们均只需单次绑定开销，而在后续的GPU Driven Rendering的管线设计中，我们也会看到这种Vertex/Index Buffer packing的方法具有的巨大优势。\n3. GPU驱动渲染管线 GPU Driven Rendering Pipelien的概念最早在Siggraph2015上由育碧Ubisoft提出[1]，其相应技术也已在《刺客信条：大革命》中得以落地，在当时可以说是相当前卫的一种设计，但由于当年硬件条件所限，《刺客信条：大革命》却因为层出不穷的Bug被当时的玩家所诟病，一度将育碧和刺客信条系列推向低谷，不过回过头看，《刺客信条：大革命》确实在大型场景和复杂建筑、海量NPC、真实感渲染等方面都是前作所不能比拟的，可以算是3A大作进入画质内卷的一个分界线。\n在IlumEngine中，我也尝试了使用GPU Driven Rendering Pipeline的思想，来对引擎进行性能调优。\n3.1. 无绑定纹理 Bindless方法指不通过传统方法将资源通过bindTexture/bindBuffer的方式进行绑定，而是直接将Texture/Buffer等GPU资源的虚拟地址直接存储在Bindless Buffer中，在着色器中可以直接使用索引进行访问。Bindless技术最早来源于Nvidia提出的 AZDO（Approaching Zero Driver Overhead）技术框架，2008年Nvidia的Tesla架构就已经实现了Bindless Buffer，而在2012年的Kepler架构正式加入了Bindless Texture特性。\n对于传统的绑定模型，我们往往需要在着色器中声明所需要的纹理/缓冲资源，并且分配相应的槽位（slot）：\n1 2 3  layout (binding = 0) uniform sampler2D tex0; layout (binding = 1) uniform sampler2D tex1; layout (binding = 2) uniform sampler2D tex2;   在CPU端，需要显式绑定所有纹理资源：\n而使用Bindless绑定模型，在着色器中，我们相当于使用了一个无穷大的纹理数组：\n1  layout (binding = 0) uniform sampler2D textureArray[];   所有的纹理数据可以一次性全部灌入其中，需要用到时，我们只需要一个下标索引即可进行访问，而对于材质而言，也不再像下图那样的贴图绑定：\n1 2 3  layout (binding = 0) uniform sampler2D Albedo; layout (binding = 1) uniform sampler2D Metallic; layout (binding = 2) uniform sampler2D Roughness;   而是使用一个结构体，存储所有的材质贴图索引：\n1 2 3 4 5 6  struct Material { uint Albedo; uint Metallic; uint Roughness; }   访问时只需：\n1  vec4 albedo = texture(textureArray[nonuniformEXT(material.Albedo)], inUV);   即可。对于GLSL，记得开启扩展GL_EXT_nonuniform_qualifier\nBindless访问模型如下：\nBindless对GPU Driven Rendering Pipeline有至关重要的作用，它主要解决了传统API下绑定资源到管线的开销问题，同时突破了着色器的硬件访问限制，进一步降低CPU-GPU的交互，我们不需要在CPU端设置Bindless资源的绑定状态，是之后实现single drawcall for everything的基础。\nVulkan中与Bindless相关的技术叫descriptor_indexing，在Vulkan 1.0属于EXT特性，但在Vulkan 1.2中已升为Core特性。在Logical Device的创建时指定：\n1 2 3 4 5 6 7  VkPhysicalDeviceVulkan12Features vulkan12_features = {}; vulkan12_features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES; vulkan12_features.shaderSampledImageArrayNonUniformIndexing = VK_TRUE; vulkan12_features.runtimeDescriptorArray = VK_TRUE; vulkan12_features.descriptorBindingVariableDescriptorCount = VK_TRUE; vulkan12_features.descriptorBindingPartiallyBound = VK_TRUE;   其中，shaderSampledImageArrayNonUniformIndexing、runtimeDescriptorArray、descriptorBindingVariableDescriptorCount指定开启descriptor_indexing特性，descriptorBindingPartiallyBound解决了缺省绑定的问题。\n在创建Bindless Texture过程中，需要指定Bindless Texture的数组支持的最大容量，通常会指定为一个较大的数（如1024）以避免反复扩容，而大部分情况下场景中的纹理都不会填满最大容量，此时需要开启descriptorBindingPartiallyBound支持缺省绑定，以防止出错。\nBindless Texture可视化：\n至此，我们又将一个费时的操作从CPU端移走了。\n3.2. 多重间接绘制 此前的一章一节中，我们将几何数据资源绑定的CPU开销降至最低，将纹理资源绑定的CPU开销给完全移走了，在本节中，我们将要把绘制开销降至最低，实现心心念念的single drawcall for everything。\n在最开始的设计中，我以一种非常低效的方式进行几何阶段的渲染，流程如下：\n 绑定Pipeline、DescriptorSet、Vertex/Index Buffer 遍历模型 遍历子网格 收集材质信息，使用Push Constant操作将材质数据送往着色器 调用绘制命令  可以看到，每一个子网格都将贡献一次Push Constant开销和一次Drawcall的开销，更不用说其他的逻辑判断操作，结果可想而知，场景复杂度一上去，CPU开销裂开，非常不贴合现代图形API的设计初衷，我们需要更多类似Bindless Texture的低CPU开销设计。\n好在现代图形API已经帮我们考虑好了，多重间接绘制Multi Draw Indirect能够完美地满足我们的需求。不同于显式调用绘制命令，Multi Draw Indirect允许我们实现将绘制命令预存在GPU的显存中，在需要绘制时调用：\n1  vkCmdDrawIndexedIndirect(cmd_buffer, draw_buffer, buffer_size, draw_count, sizeof(VkDrawIndexedIndirectCommand));   一个Drawcall即可完成所有的绘制指令提交。\n下面介绍多重间接绘制相关的技术细节：\n3.2.1. 指令缓冲 前述中，Multi Draw Indirect使用我们预存在GPU显存中的绘制命令进行提交，这些绘制命令存储在指令缓冲。在Vulkan中，有结构体VkDrawIndexedIndirectCommand或VkDrawIndirectCommand帮助我们指定指令缓冲中需要存哪些信息，一般来讲我们使用索引进行绘制，因此用的是VkDrawIndexedIndirectCommand，其数据结构定义为：\n1 2 3 4 5 6 7  typedef struct VkDrawIndexedIndirectCommand { uint32_t indexCount; uint32_t instanceCount; uint32_t firstIndex; int32_t vertexOffset; uint32_t firstInstance; } VkDrawIndexedIndirectCommand;   是不是和我们显式绘制指令的参数不能说很像，只能说一模一样？\n1 2 3 4 5 6 7  void vkCmdDrawIndexed( VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance);   当然用法也一样，就是把之前要在渲染循环里指定的参数一一写入一个std::vector\u0026lt;VkDrawIndexedIndirectCommand\u0026gt;容器里，然后在把里面的数据传到GPU显存中，使用其缓冲句柄即可调用vkCmdDrawIndexedIndirect了。\n3.2.2. 材质缓冲 前文提到过，在一开始的实现中，我们将材质信息使用Push Constant的方法在几何遍历时传到着色器中，而使用多重间接绘制时我们不再需要遍历几何体，没办法使用Push Constant方法传送逐子网格数据，因此我们需要一种新的传送材质数据的方法。\n这里我也采用了一种比较暴力的方法，那就是将所有的材质数据都存在一个大的Storage Buffer，鉴于材质数据结构中只需存各个贴图的索引和一些简单的参数，需要的显存并不算多，在每帧循环时，根据需要进行更新。\n由于材质信息是每个子网格拥有一份（不支持多材质、分层材质等），连同如预变换（Pre-Transform，与模型变换矩阵相乘构成世界变换矩阵）、包围盒等信息组成PerInstanceData：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  struct PerInstanceData { mat4 world_transform; mat4 pre_transform; vec4 base_color; vec3 emissive_color; float metallic_factor; float roughness_factor; float emissive_intensity; uint albedo_map; uint normal_map; uint metallic_map; uint roughness_map; uint emissive_map; uint ao_map; vec3 min_; float displacement_height; vec3 max_; uint displacement_map; };   （变量顺序是为了内存对齐需要）\n在着色器中，通过扩展GL_ARB_shader_draw_parameters，能够获得当前绘制物体的索引gl_DrawIDARB，由此来访问相应的PerInstanceData。\n这样一来，我们也顺利地使用一个DrawCall完成了所有的绘制指令提交，实际实验结果也很让人满意，CPU开销有了显著的降低，耗时仅为原来的十分之一不到，CPU也不再成为了渲染的瓶颈。\n3.3. 基于GPU的剔除 在前面几节中，我们已经彻底完成了CPU端的瓶颈解除，但我们也不应止步于此，接下来将进行GPU端的性能优化。要想在不减少场景规模的前提下减少GPU的计算耗时，一个基本的想法就是告诉GPU哪些东西是需要渲染的、哪些东西是不需要渲染的，也就是本节的主角——剔除技术了。\n剔除的本质是一种可见性测试，最常见的剔除有两种：视锥体剔除和遮挡剔除，这两种剔除方法能够排除大量不可见的可渲染物体，当然还有小片元剔除、背面剔除等其他方法。\n在传统管线中，通常采用CPU进行剔除处理，通过SSIM等硬件加速手段提高求交检测来实现各种剔除技术。但在本GPU Driven Rendering Pipeline中，我们已经将所有渲染数据和参数放在显存上了，很自然地，我们将利用现代GPU的通用计算功能（GPGPU），使用计算着色器来帮助我们完成剔除的操作。\n3.3.1. 视锥剔除 在学习计算机图形学基础时，我们都会接触到相机投影等相关知识，简单来讲，相机投影定义了一个裁剪空间，对于正交相机，其平截头体是一个长方体：\n而对于透视相机，其平截头体是一个台体\n在平截头体（或视锥体）之外的顶点将在裁剪阶段被渲染管线丢弃，尽管这些顶点不会参与最后的光栅化阶段，但还是会在顶点着色器中进行计算处理，造成不必要的性能浪费。通过视锥剔除计算，在不可见物体送入渲染管线前就进行排除，能够提高我们的计算效率和计算资源利用率。\n视锥剔除的检测，即包围盒与视锥平面的求交检测，这里涉及两个步骤：视锥平面的求算与包围盒的求交。\n视锥平面的求算\n在IlumEngine中，视锥平面的计算使用了Gribb-Hartmann方法进行求解，其详细数学推导可参考[2]。\n已知当前场景主摄像机的投影矩阵为$M_{P}$，视图矩阵为$M_V$，定义投影视图矩阵：\n$$\nM_{PV}=M_PM_V=\\begin{bmatrix}\nm_{11}\u0026amp;m_{12}\u0026amp;m_{13}\u0026amp;m_{14}\\\\\nm_{21}\u0026amp;m_{22}\u0026amp;m_{23}\u0026amp;m_{24}\\\\\nm_{31}\u0026amp;m_{32}\u0026amp;m_{33}\u0026amp;m_{34}\\\\\nm_{41}\u0026amp;m_{42}\u0026amp;m_{43}\u0026amp;m_{44}\n\\end{bmatrix}\n$$\n则六个视锥面方程如下：\n$$\n\\begin{aligned}\n\\begin{matrix}\n\\mathrm{Left: }\u0026amp;(m_{41}+m_{11})x+(m_{42}+m_{12})y+(m_{43}+m_{13})z+(m_{44}+m_{14})=0\\\\\n\\mathrm{Right: }\u0026amp;(m_{41}-m_{11})x+(m_{42}-m_{12})y+(m_{43}-m_{13})z+(m_{44}-m_{14})=0\\\\\n\\mathrm{Bottom: }\u0026amp;(m_{41}+m_{21})x+(m_{42}+m_{22})y+(m_{43}+m_{23})z+(m_{44}+m_{24})=0\\\\\n\\mathrm{Top: }\u0026amp;(m_{41}-m_{21})x+(m_{42}-m_{22})y+(m_{43}-m_{23})z+(m_{44}-m_{24})=0\\\\\n\\mathrm{Near: }\u0026amp;(m_{41}+m_{31})x+(m_{42}+m_{32})y+(m_{43}+m_{33})z+(m_{44}+m_{34})=0\\\\\n\\mathrm{Far: }\u0026amp;(m_{41}-m_{31})x+(m_{42}-m_{32})y+(m_{43}-m_{33})z+(m_{44}-m_{34})=0\\\\\n\\end{matrix}\n\\end{aligned}\n$$\n包围盒的求交\nIlumEngine中使用了包围球和AABB包围盒两种包围结构，包围球具有旋转不变性、求交方便等优点，AABB包围盒的紧致性比包围球更胜一筹，可以提高更细粒度的剔除。\n对于点$\\pmb p(\\pmb p_x, \\pmb p_y,\\pmb p_z)$，设视锥平面为$a_ix+b_iy+c_iz+d_i=0$，$(i=0,1,\\cdots,6)$，则点$\\pmb p$处于视锥体内，当且仅当：\n$$\na_i\\pmb p_x+b_i\\pmb p_y+c_i\\pmb p_z+d_i\u0026lt;0,\\forall i=0,1,\\cdots,6\n$$\n成立。\n对于球心坐标为点$\\pmb p(\\pmb p_x, \\pmb p_y,\\pmb p_z)$，半径为$r$的包围球，当且仅当：\n$$\na_i\\pmb p_x+b_i\\pmb p_y+c_i\\pmb p_z+d_i+r\u0026lt;0,\\forall i=0,1,\\cdots,6\n$$\n成立时，物体不会被剔除，代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11  bool checkSphere(vec3 pos, float radius) { for (uint i = 0; i \u0026lt; 6; i++) { if (dot(camera.frustum[i], vec4(pos, 1)) + radius \u0026lt; 0.0) { return false; } } return true; }   对于两端点为$\\pmb p_{max}$和$\\pmb p_{min}$的AABB包围盒，我们可以组合出八个包围盒顶点和视锥体的六个平面分别求交，但这样计算量太大，也没必要，对于每个视锥平面，我们只需挑选出其中离它最远的那个顶点进行判断即可，最远顶点可有下述公式决定：\n$$\n\\begin{matrix}\n\\pmb p_x=\\begin{cases}\np_{min_x}\u0026amp;a_i\u0026lt;0\\\\\np_{max_x}\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n\u0026amp;\n\\pmb p_y=\\begin{cases}\np_{min_y}\u0026amp;b_i\u0026lt;0\\\\\np_{max_y}\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n\u0026amp;\n\\pmb p_z=\\begin{cases}\np_{min_z}\u0026amp;c_i\u0026lt;0\\\\\np_{max_z}\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n\\end{matrix}\n$$\n使用该点进行判断即可。代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  bool checkAABB(vec3 min_val, vec3 max_val) { for (uint i=0; i \u0026lt; 6; i++) { vec4 plane = camera.frustum[i]; vec3 plane_normal = { plane.x, plane.y, plane.z }; float plane_constant = plane.w; vec3 axis_vert = { 0.0, 0.0, 0.0 }; axis_vert.x = plane.x \u0026lt; 0.0 ? min_val.x : max_val.x; axis_vert.y = plane.y \u0026lt; 0.0 ? min_val.y : max_val.y; axis_vert.z = plane.z \u0026lt; 0.0 ? min_val.z : max_val.z; if (dot(axis_vert, plane_normal) + plane_constant \u0026gt; 0.0) { return false; } } return true; }   3.3.2. Hierarchy Z-Buffer遮挡剔除 除了视锥剔除，遮挡剔除也是一种重要的剔除技术，当场景中有大量体积较大的遮挡物时有比较好的性能提升效果。遮挡剔除的实现手段有很多种，有使用硬件的遮挡查询策略，不过开销较大一般不建议使用；有手动指定Occlude和Occluder，使用CPU低分辨率软光栅进行剔除（参考Battlefield 3实现）；也有通过离线烘培的方法来实现遮挡剔除。在IlumEngine中则利用帧间信息连续性的原理，使用前一帧的深度缓冲，利用计算着色器生成层级Mipmap，再通过屏幕空间包围结构在计算着色器中实现遮挡剔除。\nHierarchy Z-Buffer的生成\n有了深度缓冲，要计算某物体是否被遮挡，一个直接的想法就是在深度图中采样该物体所在的像素位置，比较深度图采样值和该物体实际的深度值，若采样值小于深度值，则认为物体在该像素下被遮挡，当然物体的实际深度和像素位置在光栅化之前是很难算出来的，我们可以用简单的几何体例如包围结构来代替实际的物体，但即便如此，进行全分辨率的搜索和比较也是一个相当耗时的操作，这也是我们为什么需要层级深度缓冲的原因：通过包围结构在屏幕空间的投影大小，能够计算出相应的MipLevel，使得在该MipLevel下一个像素刚好能够覆盖全分辨率下包围结构的大小，这样一来，搜索和比较操作从原来的需要对包围结构所占像素逐个比对，优化至只需要搜索相应的MipLevel，通过一次采样即可完成比对。当然下采样也会带来一定的信息量损失，带来剔除精度的损失，但在剔除精度与开销之间的权衡，我们更倾向于后者。\n在每一帧的几何阶段中，我们都将使用一个格式为VK_FORMAT_D32_SFLOAT_S8_UINT的纹理来作为我们的Depth Stencil Buffer，由于深度图格式无法直接进行Mipmap操作，我们需要自己手动生成相应的Mipmap。\n出于框架的局限性，需要在每个渲染流程的结尾将Deth Stencil Buffer拷贝到另外一张深度贴图Last_Frame.depth_buffer中，在HizPass中，首先我们需要准备好Last_Frame.hiz_buffer的各个层级的VkImageView，以方便后续数据的写入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  m_views.resize(Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer-\u0026gt;getMipLevelCount()); VkImageViewCreateInfo image_view_create_info = {}; image_view_create_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; image_view_create_info.viewType = VK_IMAGE_VIEW_TYPE_2D; image_view_create_info.format = VK_FORMAT_R32_SFLOAT; image_view_create_info.components = {VK_COMPONENT_SWIZZLE_R}; image_view_create_info.subresourceRange.layerCount = 1; image_view_create_info.image = *Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer; for (uint32_t i = 0; i \u0026lt; m_views.size(); i++) { image_view_create_info.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; image_view_create_info.subresourceRange.baseArrayLayer = 0; image_view_create_info.subresourceRange.layerCount = 1; image_view_create_info.subresourceRange.baseMipLevel = i; image_view_create_info.subresourceRange.levelCount = 1; vkCreateImageView(GraphicsContext::instance()-\u0026gt;getLogicalDevice(), \u0026amp;image_view_create_info, nullptr, \u0026amp;m_views[i]); }   出于保守剔除策略，在下采样过程中，我们不应使用线性过滤等方法进行处理，而是考虑选择一个$4\\times 4$ Texels中最大的值（不使用反向Z缓冲），在Vulkan中，可以使用Reduction Mode在VkSampler创建时指定VK_SAMPLER_REDUCTION_MODE_MAX：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  VkSamplerCreateInfo createInfo = {VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO}; createInfo.magFilter = VK_FILTER_LINEAR; createInfo.minFilter = VK_FILTER_LINEAR; createInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST; createInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE; createInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE; createInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE; createInfo.minLod = 0; createInfo.maxLod = 16.f; VkSamplerReductionModeCreateInfo createInfoReduction = {VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT}; createInfoReduction.reductionMode = VK_SAMPLER_REDUCTION_MODE_MAX; createInfo.pNext = \u0026amp;createInfoReduction; vkCreateSampler(GraphicsContext::instance()-\u0026gt;getLogicalDevice(), \u0026amp;createInfo, 0, \u0026amp;m_hiz_sampler);   接着生成好需要用到的descriptor_sets：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  for (uint32_t level = 0; level \u0026lt; m_views.size(); level++) { VkDescriptorImageInfo dstTarget; dstTarget.sampler = m_hiz_sampler; dstTarget.imageView = m_views[level]; dstTarget.imageLayout = VK_IMAGE_LAYOUT_GENERAL; VkDescriptorImageInfo srcTarget; srcTarget.sampler = m_hiz_sampler; if (level == 0) { srcTarget.imageView = Renderer::instance()-\u0026gt;Last_Frame.depth_buffer-\u0026gt;getView(ImageViewType::Depth_Only); srcTarget.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL; } else { srcTarget.imageView = m_views[level - 1]; srcTarget.imageLayout = VK_IMAGE_LAYOUT_GENERAL; } std::vector\u0026lt;VkWriteDescriptorSet\u0026gt; write_descriptor_sets(2); write_descriptor_sets[0] = {}; write_descriptor_sets[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET; write_descriptor_sets[0].dstSet = m_descriptor_sets[level]; write_descriptor_sets[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER; write_descriptor_sets[0].dstBinding = 0; write_descriptor_sets[0].pImageInfo = \u0026amp;srcTarget; write_descriptor_sets[0].pBufferInfo = nullptr; write_descriptor_sets[0].pTexelBufferView = nullptr; write_descriptor_sets[0].descriptorCount = 1; write_descriptor_sets[0].pNext = nullptr; write_descriptor_sets[1] = {}; write_descriptor_sets[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET; write_descriptor_sets[1].dstSet = m_descriptor_sets[level]; write_descriptor_sets[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE; write_descriptor_sets[1].dstBinding = 1; write_descriptor_sets[1].pImageInfo = \u0026amp;dstTarget; write_descriptor_sets[1].pBufferInfo = nullptr; write_descriptor_sets[1].pTexelBufferView = nullptr; write_descriptor_sets[1].descriptorCount = 1; write_descriptor_sets[1].pNext = nullptr; m_descriptor_sets[level].update(write_descriptor_sets); }   每个descriptor_set规定了需要读取和写入的数据，在第一轮中，读取的应为上一帧的深度图，写入MipLevel为0的Hi-Z Buffer，而之后的每一轮都是读取MipLevel为$i$的Hi-Z Buffer，写入MipLevel为$i+1$的Hi-Z Buffer。\n至此准备阶段已经结束了，在每一轮渲染循环中，需要进行以下更新：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  for (uint32_t level = 0; level \u0026lt; views.size(); level++) { { VkImageMemoryBarrier read_to_write{}; read_to_write.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER; read_to_write.oldLayout = VK_IMAGE_LAYOUT_GENERAL; read_to_write.newLayout = VK_IMAGE_LAYOUT_GENERAL; read_to_write.srcAccessMask = VK_ACCESS_SHADER_READ_BIT; read_to_write.dstAccessMask = VK_ACCESS_SHADER_WRITE_BIT; read_to_write.image = *Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer; read_to_write.subresourceRange = VkImageSubresourceRange{VK_IMAGE_ASPECT_COLOR_BIT, level, 1, 0, 1}; read_to_write.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; read_to_write.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; vkCmdPipelineBarrier( cmd_buffer, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_DEPENDENCY_BY_REGION_BIT, 0, nullptr, 0, nullptr, 1, \u0026amp;read_to_write); } vkCmdBindDescriptorSets(cmd_buffer, state.pass.bind_point, state.pass.pipeline_layout, 0, 1, \u0026amp;m_descriptor_sets[level].getDescriptorSet(), 0, nullptr); uint32_t level_width = std::max(1u, Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer-\u0026gt;getWidth() \u0026gt;\u0026gt; level); uint32_t level_height = std::max(1u, Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer-\u0026gt;getHeight() \u0026gt;\u0026gt; level); VkExtent2D extent = {level_width, level_height}; vkCmdPushConstants(cmd_buffer, state.pass.pipeline_layout, VK_SHADER_STAGE_COMPUTE_BIT, 0, sizeof(VkExtent2D), \u0026amp;extent); uint32_t group_count_x = (Renderer::instance()-\u0026gt;getRenderTargetExtent().width + 32 - 1) / 32; uint32_t group_count_y = (Renderer::instance()-\u0026gt;getRenderTargetExtent().height + 32 - 1) / 32; vkCmdDispatch(cmd_buffer, group_count_x, group_count_y, 1); { VkImageMemoryBarrier write_to_read{}; write_to_read.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER; write_to_read.oldLayout = VK_IMAGE_LAYOUT_GENERAL; write_to_read.newLayout = VK_IMAGE_LAYOUT_GENERAL; write_to_read.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT; write_to_read.dstAccessMask = VK_ACCESS_SHADER_READ_BIT; write_to_read.image = *Renderer::instance()-\u0026gt;Last_Frame.hiz_buffer; write_to_read.subresourceRange = VkImageSubresourceRange{VK_IMAGE_ASPECT_COLOR_BIT, level, 1, 0, 1}; write_to_read.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; write_to_read.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; vkCmdPipelineBarrier( cmd_buffer, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_DEPENDENCY_BY_REGION_BIT, 0, nullptr, 0, nullptr, 1, \u0026amp;write_to_read); } }   每一次计算循环开始，需要切换相应的读写状态、绑定相应的descriptor_set，进行计算着色器的dispatch，最后再进行下一轮的状态切换准备，直到填满Hi-Z Buffer的所有Mipmap层级为止。\n屏幕空间包围结构的计算\n有了Hi-Z Buffer，现在我们需要得到物体包围结构屏幕空间的投影，为了计算方便，只考虑包围球形式，使用的计算方法参考文献[3]，该算法将世界空间的包围球变换为屏幕空间AABB包围盒。\n首先我们回顾一下图形学基础中视图矩阵和投影矩阵的相关概念，视图矩阵$M_{view}$主要作用是将场景变换到相机空间中，所谓的相机空间，就是以相机为原点所定义的空间，视图矩阵可以由相机的模型矩阵求逆得到：$M_{view}=M_{camera\\_position}^{-1}$，当然一般很少通过这种方法来求取视图矩阵，因为不够直观，而是通过摄像机的朝向和摄像机的位置来进行求取：\n$$\nM_{view}=\\begin{bmatrix}\n\\pmb R_x\u0026amp;\\pmb R_y\u0026amp;\\pmb R_z\u0026amp;0\\\\\n\\pmb U_x\u0026amp;\\pmb U_y\u0026amp;\\pmb U_z\u0026amp;0\\\\\n\\pmb D_x\u0026amp;\\pmb D_y\u0026amp;\\pmb D_z\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;0\u0026amp;1\n\\end{bmatrix}\n\\ast\n\\begin{bmatrix}\n1\u0026amp;0\u0026amp;0\u0026amp;-\\pmb P_x\\\\\n0\u0026amp;1\u0026amp;0\u0026amp;-\\pmb P_y\\\\\n0\u0026amp;0\u0026amp;1\u0026amp;-\\pmb P_z\\\\\n0\u0026amp;0\u0026amp;0\u0026amp;1\n\\end{bmatrix}\n$$\n其中，$\\pmb R$为右向量，$\\pmb U$为上向量，$\\pmb D$为方向向量，$\\pmb P$为摄像机的位置向量。\n而投影矩阵则是实现将三维空间的物体投影到二维屏幕上，投影矩阵将相机空间中的顶点数据变换到裁剪空间中，最后通过透视除法变换到标准化设备坐标，这里以透视投影为例：\n从两个方向观察，由三角形近似可得：\n$$\n\\begin{align}\n\\dfrac{x_p}{x_e}\u0026amp;=\\dfrac{-n}{z_e}\\Rightarrow x_p=\\dfrac{-n\\cdot x_e}{z_e}=\\dfrac{n\\cdot x_e}{-z_e}\\\\\n\\dfrac{y_p}{y_e}\u0026amp;=\\dfrac{-n}{z_e}\\Rightarrow y_p=\\dfrac{-n\\cdot y_e}{z_e}=\\dfrac{n\\cdot y_e}{-z_e}\n\\end{align}\n$$\n注意到$x_p$和$y_p$的计算均需要除以一个$-z_e$，这与裁剪空间到NDC正则化的透视除法相对应：\n$$\n\\begin{align}\n\\begin{pmatrix}\nx_{clip}\\\\y_{clip}\\\\z_{clip}\\\\w_{clip}\n\\end{pmatrix}\n\u0026amp;=\\pmb M_{projection}\\cdot\n\\begin{pmatrix}\nx_{eye}\\\\y_{eye}\\\\z_{eye}\\\\w_{eye}\n\\end{pmatrix}\\\\\n\\begin{pmatrix}\nx_{ndc}\\\\y_{ndc}\\\\z_{ndc}\n\\end{pmatrix}\n\u0026amp;=\n\\begin{pmatrix}\nx_{clip}/w_{clip}\\\\\ny_{clip}/w_{clip}\\\\\nz_{clip}/w_{clip}\n\\end{pmatrix}\n\\end{align}\n$$\n这里的$w_{clip}$便是$-z_e$了，因此透视投影矩阵有如下形式：\n$$\n\\begin{align}\n\\begin{pmatrix}\nx_c\\\\\ny_c\\\\\nz_c\\\\\nw_c\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\cdot \u0026amp; \\cdot \u0026amp; \\cdot \u0026amp; \\cdot\\\\\n\\cdot \u0026amp; \\cdot \u0026amp; \\cdot \u0026amp; \\cdot\\\\\n\\cdot \u0026amp; \\cdot \u0026amp; \\cdot \u0026amp; \\cdot\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\nx_e\\\\\ny_e\\\\\nz_e\\\\\nw_e\n\\end{pmatrix}\n\\end{align}\n$$\n下面我们需要把近平面坐标点$x_p$和$y_p$线性映射到NDC坐标$x_n$和$y_n$：$[l,r]\\Rightarrow [-1,1]$以及$[b,t]\\Rightarrow [-1,1]$\n$$\n\\begin{align}\n\\dfrac{x_n-(-1)}{1-(-1)}\u0026amp;=\\dfrac{x_p-l}{r-l}\\Rightarrow x_n=\\dfrac{2x_p}{r-l}-\\dfrac{r+l}{r-l}\\\\\n\\dfrac{y_n-(-1)}{1-(-1)}\u0026amp;=\\dfrac{y_p-b}{t-b}\\Rightarrow y_n=\\dfrac{2y_p}{t-b}-\\dfrac{t+b}{t-b}\n\\end{align}\n$$\n将$x_p$和$y_p$代入得\n$$\n\\begin{align}\nx_n=\\Big(\\dfrac{2n}{r-l}\\cdot x_e+\\dfrac{r+l}{r-l}\\cdot z_e \\Big)\\Big/-z_e\\\\\ny_n=\\Big(\\dfrac{2n}{t-b}\\cdot y_e+\\dfrac{t+b}{t-b}\\cdot z_e \\Big)\\Big/-z_e\n\\end{align}\n$$\n可填入透视投影矩阵：\n$$\n\\begin{align}\n\\begin{pmatrix}\nx_c\\\\\ny_c\\\\\nz_c\\\\\nw_c\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\frac{2n}{r-l}\u0026amp;0\u0026amp;\\frac{r+l}{r-l}\u0026amp;0\\\\\n0\u0026amp;\\frac{2n}{t-b}\u0026amp;\\frac{t+b}{t-b}\u0026amp;0\\\\\n\\cdot \u0026amp; \\cdot \u0026amp; \\cdot \u0026amp; \\cdot\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\nx_e\\\\\ny_e\\\\\nz_e\\\\\nw_e\n\\end{pmatrix}\n\\end{align}\n$$\n由于$z_c$不依赖于$x_e$与$y_e$且与$z_e$和$w_e$成线性关系，设\n$$\n\\begin{align}\n\\begin{pmatrix}\nx_c\\\\\ny_c\\\\\nz_c\\\\\nw_c\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\frac{2n}{r-l}\u0026amp;0\u0026amp;\\frac{r+l}{r-l}\u0026amp;0\\\\\n0\u0026amp;\\frac{2n}{t-b}\u0026amp;\\frac{t+b}{t-b}\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;A\u0026amp;B\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\nx_e\\\\\ny_e\\\\\nz_e\\\\\nw_e\n\\end{pmatrix}\n\\end{align}\n$$\n即\n$$\nz_n=z_c/w_c=\\dfrac{Az_e+Bw_e}{-z_e}\n$$\n在视角空间中，$w_e=1$，因此$z_n=\\frac{Az_e+B}{-z_e}$，利用边界关系：\n$$\n\\begin{cases}\n\\dfrac{-An+B}{n}=-1\\\\\n\\dfrac{-Af+B}{f}=1\n\\end{cases}\n\\Rightarrow\n\\begin{cases}\nA=-\\dfrac{f+n}{f-n}\\\\\nB=-\\dfrac{2fn}{f-n}\n\\end{cases}\n$$\n因此完整的透视投影矩阵表示为：\n$$\n\\begin{pmatrix}\n\\frac{2n}{r-l}\u0026amp;0\u0026amp;\\frac{r+l}{r-l}\u0026amp;0\\\\\n0\u0026amp;\\frac{2n}{t-b}\u0026amp;\\frac{t+b}{t-b}\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;\\frac{-(f+n)}{f-n}\u0026amp;\\frac{-2fn}{f-n}\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n$$\n如果视锥体对称，即$t=-b$和$l=-r$，则可简化为：\n$$\n\\begin{pmatrix}\n\\frac{n}{r}\u0026amp;0\u0026amp;0\u0026amp;0\\\\\n0\u0026amp;\\frac{n}{t}\u0026amp;0\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;\\frac{-(f+n)}{f-n}\u0026amp;\\frac{-2fn}{f-n}\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n$$\n通常情况下我们会用参数$fovy$（$y$轴方向的视域角）、$aspect$（屏幕宽高比）、$near$（近平面）以及$far$（远平面）来构造透视投影矩阵，相关关系如下：\n$$\n\\begin{align}\nr-l\u0026amp;=width=2*near*aspect*tan(fovy/2)\\\\\nt-b\u0026amp;=height=2*near*tan(fovy/2)\n\\end{align}\n$$\n而对于正交投影，只需对各个方向作正则化即可：\n$$\n\\begin{cases}\n\\dfrac{x_n-(-1)}{1-(-1)}=\\dfrac{x_e-l}{r-l}\\\\\n\\dfrac{y_n-(-1)}{1-(-1)}=\\dfrac{y_e-b}{t-b}\\\\\n\\dfrac{z_n-(-1)}{1-(-1)}=\\dfrac{z_e-n}{f-n}\n\\end{cases}\n$$\n得到正交投影矩阵：\n$$\n\\begin{pmatrix}\n\\frac{2}{r-l}\u0026amp;0\u0026amp;0\u0026amp;-\\frac{r+l}{r-l}\\\\\n0\u0026amp;\\frac{2}{t-b}\u0026amp;0\u0026amp;-\\frac{t+b}{t-b}\\\\\n0\u0026amp;0\u0026amp;\\frac{-2}{f-n}\u0026amp;-\\frac{f+n}{f-n}\\\\\n0\u0026amp;0\u0026amp;0\u0026amp;1\n\\end{pmatrix}\n$$\n复习完视图矩阵和投影矩阵的相关概念后，我们正式计算世界空间中的包围球到屏幕空间AABB包围盒的投影。\n首先，需要将包围球投影到相机空间，这一步简单地乘上一个视图矩阵即可。\n求屏幕空间包围盒，即求包围球在投影面上的最大和最小坐标，从单方向看，如上图所示，若$\\hat a$表示$x$轴，欲求取点$T$的坐标，连线$OT$与圆$C$相切，在该二维平面上，有球心坐标$C(C_x,C_z)$，设$\\vec c=(C_x,C_y)$，$c=\\sqrt{C_x^2+C_y^2}$，则从相机到$T$的单位向量可由旋转得到：\n$$\n\\hat\\omega =\\begin{bmatrix}\\cos\\theta\u0026amp;\\sin\\theta\\\\-\\sin\\theta\u0026amp;\\cos\\theta\\end{bmatrix}\\frac{\\vec c}{|\\vec c|}\n$$\n而$T$到相机的距离也很容易求得：$d=\\sqrt{c^2-r^2}$，且$\\cos\\theta = \\frac{d}{c}$，$\\sin\\theta=\\frac{r}{c}$\n解得$T=O+\\hat \\omega d$，同理可求得点$B$的坐标，令$\\tilde \\theta = -\\theta$即可。\n点$B$和$T$即视图空间中，包围球在$x$轴方向上的最左点和最右点，我们还需要将其变换到裁剪空间中，进行归一化处理。\n由前述推导可知，透视投影过程可表示为如下形式：\n$$\n\\begin{pmatrix}\nP_{00}\u0026amp;0\u0026amp;0\u0026amp;0\\\\\n0\u0026amp;P_{11}\u0026amp;0\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;P_{22}\u0026amp;P_{23}\\\\\n0\u0026amp;0\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\nx_e\\\\y_e\\\\z_e\\\\1\n\\end{pmatrix}=\n\\begin{pmatrix}\nP_{00}x_e\\\\P_{11}y_e\\\\P_{22}z_e+P_{23}\\\\-z_e\n\\end{pmatrix}\n$$\n通过透视除法投影到NDC空间中：\n$$\n\\begin{aligned}\nx_n \u0026amp;= \\frac{Ax_e}{-z_e}\\\\\ny_n \u0026amp;= \\frac{By_e}{-z_e}\n\\end{aligned}\n$$\n最后通过简单的线性变换可以从NDC空间$[-1,1]$变换到UV空间$[0,1]$方便后续处理。\nGLSL实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  bool projectSphere(vec3 C, float r, float znear, float P00, float P11, out vec4 aabb) { if (-C.z \u0026lt; r + znear) return false; vec2 cx = C.xz; vec2 vx = vec2(sqrt(dot(cx, cx) - r * r), r); vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx; vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx; vec2 cy = C.yz; vec2 vy = vec2(sqrt(dot(cy, cy) - r * r), r); vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * cy; vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * cy; aabb = vec4(-minx.x / minx.y * P00, -miny.x / miny.y * P11, -maxx.x / maxx.y * P00, -maxy.x / maxy.y * P11); aabb = aabb.xwzy * vec4(0.5f, -0.5f, 0.5f, -0.5f) + vec4(0.5f); return true; }   深度值搜索与比较\n得到Hi-Z Buffer和屏幕空间包围盒后，便可开始最后的计算环节。首先通过屏幕空间包围盒的大小获得需要索引的MipLevel：\n1 2 3  float width = (aabb.z - aabb.x) * cullData.zbuffer_width; float height = (aabb.w - aabb.y) * cullData.zbuffer_height; float mip_level = floor(log2(max(width, height)));   通过包围盒中心位置来确定需要采样的UV坐标，为了保证不会误剔除，在其周围多采样几个像素：\n1 2 3 4 5  vec2 uv = (aabb.xy + aabb.zw) * 0.5; vec2 uv0 = aabb.xy; vec2 uv1 = aabb.zw; vec2 uv2 = aabb.xw; vec2 uv3 = aabb.zy;   选择深度最大的那个深度值，保守剔除策略：\n1 2 3 4 5  float depth = textureLod(hiz_buffer, uv, mip_level).r; depth = max(depth, textureLod(hiz_buffer, uv0, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv1, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv2, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv3, mip_level).r);   还需要将深度值通过逆透视除法还原到裁剪空间中，以避免浮点精度误差带来的剔除准确性降低，设采样得到的深度值为$z_n$，其裁剪空间对应的深度值为：\n$$\nz_c=\\frac{2f\\cdot n}{(f-n)\\cdot z_n-(f+n)}\n$$\n其中，$f$为远裁剪面距离，$n$为近裁剪面距离，注意这里得到的$z_c$为负，需要取反。\n在实际实验中，在摄像机远离物体的过程中可能会出现误剔除的情况，这是由于我们利用了上一帧的深度信息，而这一帧由于远离物体，深度变大，会导致自遮挡的现象出现，解决办法也很简单，我们需要保留上一帧的相机视图-投影矩阵，在计算用于比较的实际深度值时，应使用上一帧的相机参数，以解决自遮挡问题。\n完整的遮挡剔除代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  float LinearizeDepth(float depth) { return -(2.0 * cullData.zfar * cullData.znear) / (cullData.zfar + cullData.znear - depth * (cullData.zfar - cullData.znear));\t} bool checkOcclusion(vec3 center, float radius) { vec3 dir = normalize(camera.position - center); vec4 sceen_space_center_last = camera.last_view_projection * vec4(center + dir*radius, 1.0); vec3 C = ((cullData.view) * vec4(center,1.0)).xyz; vec4 aabb; if(!projectSphere(C, radius, cullData.znear, cullData.P00, cullData.P11, aabb)) { return true; } float width = (aabb.z - aabb.x) * cullData.zbuffer_width; float height = (aabb.w - aabb.y) * cullData.zbuffer_height; float mip_level = floor(log2(max(width, height))); vec2 uv = (aabb.xy + aabb.zw) * 0.5; vec2 uv0 = aabb.xy; vec2 uv1 = aabb.zw; vec2 uv2 = aabb.xw; vec2 uv3 = aabb.zy; float depth = textureLod(hiz_buffer, uv, mip_level).r; depth = max(depth, textureLod(hiz_buffer, uv0, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv1, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv2, mip_level).r); depth = max(depth, textureLod(hiz_buffer, uv3, mip_level).r); float depthSphere = abs(sceen_space_center_last.z); return LinearizeDepth(depth) \u0026gt;= depthSphere; }   3.4. 基于Meshlet的渲染优化 前文中我们已经实现了基本的基于GPU的剔除优化技术，在多数场景下都能带来一定的性能增益，但目前我们还只是以子网格为单位进行的剔除与提交，当子网格较大时仍存在不少计算资源的浪费，由于我们已经使用了GPGPU技术来帮助我们完成剔除与绘制的操作，模型的数量和Drawcall已不再是我们的性能瓶颈，一个很自然的想法便是能否将一个大的网格切分为诸多一定规则的小网格，从而提高剔除的粒度，同时由于我们使用了GPU强大的并行处理能力进行剔除，对它们进行处理也不将成为问题，因此，我们引入了Mesh Shader中Meshlet的概念，只是我们为了平台灵活性，不打算用Mesh Shader进行处理，而是使用计算着色器来帮助我们完成相同的功能。\nMeshlet是网格划分为小块的单位，是Mesh Shader处理的基本单元，传统的顶点着色器是逐顶点处理模型的，而Mesh Shader则支持逐Meshlet处理模型。通常来讲，每个Meshlet具有相同的顶点数以及支持的最大三角形数，NVIDIA建议选取顶点数为64，三角形数为124的Meshlet进行处理，Meshlet的生成需要通过离线工具构建，IlumEngine中使用了开源库meshoptimizer进行处理，meshoptimizer使用非常方便，文档齐全，这里不多讲其使用。如下封面图所示，我们已经成功将整个场景分成了大量小网格块：\n加入了Meshlet支持的模型存储方式与之前也基本一致，区别在于每个Model对象需要维护其所有的Meshlet，每个子网格需要存储其拥有的Meshlet的偏移和数量，Meshlet结构体定义如下：\n1 2 3 4 5 6 7  struct Meshlet { meshopt_Bounds bounds; uint32_t indices_offset; uint32_t indices_count; uint32_t vertices_offset; };   meshopt_Bounds为meshoptimizer的包围体结构，使用的是包围球结构以及用于锥体背面剔除的相关参数。\n现在的Model和Submesh结构体定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  struct Model { public: std::vector\u0026lt;SubMesh\u0026gt; submeshes; uint32_t vertices_count = 0; uint32_t indices_count = 0; uint32_t vertices_offset = 0; uint32_t indices_offset = 0; // Raw geometry, original data  std::vector\u0026lt;Vertex\u0026gt; vertices; std::vector\u0026lt;uint32_t\u0026gt; indices; // Meshlet, for mesh shading \u0026amp; cluster culling  std::vector\u0026lt;Meshlet\u0026gt; meshlets; geometry::BoundingBox bounding_box; } struct SubMesh { public: uint32_t index = 0; glm::mat4 pre_transform = glm::mat4(1.f); uint32_t vertices_count = 0; uint32_t indices_count = 0; uint32_t vertices_offset = 0; uint32_t indices_offset = 0; uint32_t meshlet_offset = 0; uint32_t meshlet_count = 0; material::DisneyPBR material; geometry::BoundingBox bounding_box; }   现在我们已经将最小渲染单位从子网格换成了Meshlet，原先的间接绘制、GPU剔除等操作照样进行。\n3.4.1. Meshlet渲染性能调优1：压缩合批 由于我们将每个网格都分成了众多Meshlet，在提高剔除粒度的同时也增加了渲染物的数量，同时用于间接绘制所需要的Draw_Buffer也会相应的变大，在之前的实现中，我们通过设置VkDrawIndexedIndirectCommand中的instanceCount参数来决定是否进行绘制，设为0时则表示被剔除。但在直接从子网格处理转换到Meshlet处理时，却发现当场景规模很大时，渲染效率反而没有原来的高，经过Profile发现瓶颈出在了几何阶段的GPU开销上，尽管有了一系列CPU优化和GPU剔除，CPU已经基本不需要花什么时间了，但绘制过程中的GPU用时居高不下，经分析是由于Draw_Buffer过大造成，光是遍历里头每一条渲染指令就已经花了GPU很多时间了。这个问题的解决方法也很简单：只提交需要进行绘制的指令。\n在之前的实现中，我们是在CPU端事先设置好所有的VkDrawIndexedIndirectCommand数组，传到GPU中，通过GPU可见性判断来设置instanceCount参数决定是否绘制该物体，这种方法造成了最后进行提交的绘制缓冲中有效指令和无效指令相互混叠，容易产生流水线气泡，如果能够对绘制缓冲中的指令进行排序，将有效指令移至渲染队列的头部，将绘制指令数量设置为有效指令的数量，则可以大幅提升性能。但在着色器中实现排序操作似乎不是一件简单的操作，因此我们另辟蹊径，在剔除管线中不仅设置可见性，我们直接在里头设置整个渲染指令。\n为方便渲染队列的构建和有效指令数量的跟踪，我们使用了一个Count_Buffer来记录有效绘制指令的数量，在计算着色器中，通过原子加法操作，实现类似push_back的功能：\n1 2 3 4 5 6 7 8 9 10  if (visible) { uint dci = atomicAdd(visible_count, 1); indirectDraws[dci].indexCount = meshlet.index_count; indirectDraws[dci].instanceCount = 1; indirectDraws[dci].firstIndex = meshlet.index_offset; indirectDraws[dci].vertexOffset = int(meshlet.vertex_offset); indirectDraws[dci].firstInstance = 0; draw_data[dci] = meshlet.instance_id; }   然而，在开发过程中，又遇到一个问题，如何获取Count_Buffer中的计数数据？使用GPU-CPU回读？那样在 一个渲染循环中只能获取到上一帧的计数结果。通过查阅文档发现，Vulkan开发者已经考虑过这个问题了，提供了vkCmdDrawIndexedIndirectCount函数，让我们能够直接使用Count_Buffer作为参数向GPU指定渲染指令数量。\n至此，Meshlet渲染带来的合批过大问题已被完美解决。\n3.4.2. Meshlet渲染性能调优2：层次剔除 简单使用Meshlet进行渲染，除了有合批过大的问题外，还有剔除开销的问题，当场景面数一多，Meshlet数量一大，剔除阶段的计算量也是不可忽视的。这里IlumEngine采用的解决方案是分层次进行剔除，其实也就是先对实例（子网格）进行剔除，再进行Meshlet进行剔除。已经在实例剔除阶段剔除的实例，其包含的Meshlet也就不用再进行剔除了，减少了剔除用时。事实上，层次剔除还可以更进一步的，通过构建不同层级的Meshlet BVH，进行高效地索引需要剔除的层级，能够实现更加高效的剔除策略，和LOD方法相结合，也就是虚幻引擎5中Nanite虚拟几何体的处理方法了。\n4. 结果 场景总览\n渲染管线\n无优化\n仅视锥剔除\n仅背面剔除\n仅遮挡剔除\n使用所有剔除\n演示Demo\n\n可以看到由于使用了帧间连续性的原因，在某些地方仍会有部分闪烁，后续引入TAA等帧间累积方法可以一定程度上解决这个问题，但在帧率上确实有了实质性的提升。\n参考链接 [1] Haar U, Aaltonen S. Gpu-driven rendering pipelines. Ubisoft, Siggraph 2015: Advances in Real-Time Rendering in Games course, 2015\n[2] Gribb G, Hartmann K. Fast extraction of viewing frustum planes from the worldview-projection matrix. Online document, 2001. \n[3] Mara, Michael, and Morgan McGuire. \u0026ldquo;2D polyhedral bounds of a clipped, perspective-projected 3D sphere.\u0026rdquo; JCGT. in submission 5 (2012).\n","description":"IlumEngine的第一次渲染性能优化","id":14,"section":"posts","tags":["Real-time Rendering"],"title":"实时渲染优化技术(1)","uri":"https://chaphlagical.github.io/zh/posts/rendering/optimization1/"},{"content":"Lazy Snapping是一种基于图的图像分割方法[1]，能够将图像分割为前景和背景，通过用户交互挑选前景和背景种子，利用最大流最小分割的方法对图像进行分割。\n1. 基本方法 文献中利用分水岭算法对图像进行预处理，这里我们直接将图像下采样到原分辨率的八分之一进行处理，然后求解以下优化问题：\n$$\nE(X)=\\sum_{i\\in\\mathcal{V}}E_1(x_i)+\\lambda\\sum_{(i,j)\\in\\mathcal\\varepsilon}E_2(x_i, x_j)\n$$\n其中，$E_1(x_i)$为似然能量，编码结点$x_i$的代价，$E_2(x_i,x_j)$为先验能量，代表邻接结点$x_i$和$x_j$的代价。\n似然能量$E_1(x_i)$定义为：\n$$\n\\begin{cases}\n\\begin{matrix}\nE_1(x_i=1)=0\u0026amp;E_1(x_i=0)=\\infty\u0026amp;\\forall i\\in\\mathcal{F}\n\\end{matrix}\\\\\\\\\n\\begin{matrix}\nE_1(x_i=1)=\\infty\u0026amp;E_1(x_i=0)=0\u0026amp;\\forall i\\in\\mathcal{B}\n\\end{matrix}\\\\\\\\\n\\begin{matrix}\nE_1(x_i=1)=\\frac{d_i^\\mathcal{F}}{d_i^\\mathcal{F}+d_i^\\mathcal{B}}\u0026amp;E_1(x_i=0)=\\frac{d_i^\\mathcal{B}}{d_i^\\mathcal{F}+d_i^\\mathcal{B}}\u0026amp;\\forall i\\in\\mathcal{U}\n\\end{matrix}\n\\end{cases}\n$$\n其中，$\\mathcal{F}$表示前景种子集合，$\\mathcal{B}$为背景种子集合，均由用户输入，而$\\mathcal{U}$为补集。$d_i^\\mathcal{F}$和$d_i^\\mathcal{B}$分别表示当前颜色与前景种子平均值和背景种子平均值的距离平方\n先验能量$E_2(x_i,x_j)$定义为：\n$$\nE_2(x_i,x_j)=\\frac{1}{|C(i)-C(j)|^2+\\varepsilon}\n$$\n实验中，取$\\lambda=100$，$\\epsilon=0.01$。\n然后构建无向图，通过最大流最小割方法分离出前景和背景，提取轮廓得到结果\n实验结果    原图像 交互图像 轮廓                     参考文献 [1] Y. Li, J. Sun, C.-K. Tang, and H.-Y. Shum. Lazy snapping. ACM Transactions on Graphics (ToG), 23(3):303–308, 2004.\n","description":"复现Siggraph2004论文《Lazy snapping》","id":15,"section":"posts","tags":["Digital Image Process"],"title":"Lazy Snapping","uri":"https://chaphlagical.github.io/zh/posts/image_process/lazy_snapping/"},{"content":"Seam Carving算法是一种基于内容的图像缩放方法，在保证图像中“重要区域”不发生形变的前提下，对图像进行缩放。\n一种直观的想法便是找出图像中的“不重要区域”，并将其删除。文献[1]中便是采用这种思想，\n通过定义像素的能量函数，通过动态规划方法对某一方向的像素进行能量累积，最后回溯求出能量最低的一条路径，该路径便是我们要删除的“最不重要”路径。\n1. 基本方法 图像的能量简单地由图像梯度描述：\n$$\ne_1(\\pmb I)=\\left|\\frac{\\partial}{\\partial x}\\pmb I\\right|+\\left|\\frac{\\partial}{\\partial y}\\pmb I\\right|\n$$\n论文中也给出另外一种能量的变体实现：\n$$\ne_{HoG}(\\pmb I)=\\frac{\\left|\\frac{\\partial}{\\partial x}\\pmb I\\right|+\\left|\\frac{\\partial}{\\partial y}\\pmb I\\right|}{\\max(HoG(\\pmb I(x,y)))}\n$$\n实现中，采用Sobel算子提取图像梯度作为能量图：\n1 2 3 4 5 6 7 8 9 10 11  void SeamCarving::genEnergyMap(const cv::Mat\u0026amp; img, cv::Mat\u0026amp; energy) { cv::Mat sobel_x, sobel_y, gray_energy; cv::cvtColor(img, gray_energy, cv::COLOR_BGR2GRAY); cv::Sobel(gray_energy, sobel_x, CV_32F, 1, 0, 3); cv::convertScaleAbs(sobel_x, sobel_x); cv::Sobel(gray_energy, sobel_y, CV_32F, 0, 1, 3); cv::convertScaleAbs(sobel_y, sobel_y); cv::addWeighted(sobel_x, 0.5, sobel_y, 0.5, 0, energy); energy.convertTo(energy, CV_32FC1); }   对于$n\\times m$的图像$\\pmb I$，用于删除的接缝由如下定义：\n水平接缝：\n$$\n\\pmb{s^x}=\\{s_i^x\\}_{i=1}^n=\\{(x(i),i)\\}_{i=1}^n,\\ \\\ns.t.\\ \\ \\forall i,\\ \\ |x(i)-x(i-1)|\\leq 1\n$$\n竖直接缝：\n$$\n\\pmb{s^y}=\\{s_i^y\\}_{j=1}^m=\\{(j, y(j))\\}_{j=1}^m,\\ \\\ns.t.\\ \\ \\forall j,\\ \\ |y(j)-y(j-1)|\\leq 1\n$$\n其中，$x:[1,\\cdots,n]\\rightarrow[1,\\cdots,m]$，$y:[1,\\cdots,m]\\rightarrow[1,\\cdots,n]$\n而我们要寻找最低能量路径即求解最小优化问题：\n$$\ns^\\ast=\\min_{\\pmb s}E(\\pmb s)=\\min_{\\pmb s}\\sum_{i=1}^ne(\\pmb I(s_i))\n$$\n利用动态规划的思想可以很方便地求出上述优化问题，利用能量累积矩阵$M$，转移方程：\n$$\nM(i,j)=e(i,j)+\\min(M(i-1,j-1), M(i-1,j), M(i-1,j+1))\n$$\n从边缘出发按转移方程填充能量累积矩阵，最后寻找能量最低的终点$M(n,x)$（竖直搜索）或$M(x,m)$（水平搜索），回溯即可得到完整的最优路径。\n1.1. 图像缩小任务 对于单方向缩小任务，只需重复上述接缝搜索流程，每次删除一条接缝即可。\n对于多方向缩小任务，文献中也将横向竖向接缝的选择顺序其视为一个优化问题，假设现有$m\\times n$的图像$\\pmb I$欲缩小至$m'\\times n'$，其中$m\u0026gt;m',n\u0026gt;n'$，接缝顺序的选择等价于优化以下能量函数：\n$$\n\\min_{\\pmb{s^x},\\pmb{s^y},\\alpha}\\sum_{i=1}^kE(\\alpha_i\\pmb {s_i^x}+(1-\\alpha_i)\\pmb{s_i^y})\n$$\n其中，$r=m-m'$，$c=n-n'$， $\\alpha_i\\in{0,1}$描述了接缝选择的方向，因此有$\\sum_{i=1}^k\\alpha_i=r$，$\\sum_{i=1}^k(1-\\alpha_i)=c$成立。该问题同样可以利用动态规划的想法进行求解，取能量累积矩阵$\\pmb T$，满足$\\pmb T(0,0)=0$，转移方程：\n$$\n\\pmb T(r,c)=\\min(\\pmb T(r-1,c),E(\\pmb s^x(\\pmb {I_{n-r-1\\times m-c}})),\\pmb T(r,c-1),E(\\pmb s^y(\\pmb {I_{n-r\\times m-c-1}})))\n$$\n$\\pmb {I_{n-r-1\\times m-c}}$表示大小为$n-r-1\\times m-c$的图像（中间量），$E(\\pmb{s^x}(\\pmb I))$和$E(\\pmb{s^y}(\\pmb I))$为相应的方向接缝删除后的能量。\n但上述方法实测速度很慢，因此在实现中选择简单的贪婪策略选择带来当前最低能量的方法。\n1.2. 图像拉伸任务 对于图像拉伸任务，同样可以采用缩小任务相似的处理方法，只是将最优接缝的删除修改为最优接缝邻域的插值，但和缩小任务不同的是，每次对单条最优接缝进行插值，容易导致后续的最优接缝\n搜索会集中在同一区域，因此在图像拉伸任务中，建议一次性选择多条低能量接缝进行插值。\n2. 实验结果 2.1. 图像缩小    原图像 图像能量 结果图像                     2.2. 图像拉伸    原图像 图像能量 最优接缝 结果图像                        3. 总结 从上图中可以看出 Seam Carving 的一些局限性：\n 进行图像拉伸任务时容易造成图像区块重复，可以考虑手动排除部分区域进行优化 在梯度变化不明显的“重要区域”容易造成误处理，比如：《蒙娜丽莎》大片的头发。可以考虑手动划分“重要区域”进行处理  参考文献 [1] S. Avidan and A. Shamir. Seam carving for content-aware image resizing. In ACM SIGGRAPH 2007 papers, pages 10–es. 2007\n","description":"复现Siggraph2007论文《Seam Carving for Content-Aware Image Resizing》","id":16,"section":"posts","tags":["Digital Image Process"],"title":"Seam Carving","uri":"https://chaphlagical.github.io/zh/posts/image_process/seam_carving/"},{"content":"1. 问题描述 给定以下两幅图：\n现我们需要将第一幅图中的女孩搬到第二幅图的海水中，为使得复制粘贴更加逼真自然，我们需要设计算法来满足我们两幅图像融合的需要\n2. 算法描述 Poisson Image Editing算法[1]的基本思想是在尽可能保持原图像内部梯度的前提下，让粘贴后图像的边界值与新的背景图相同，以实现无缝粘贴的效果。从数学上讲，对于原图像$f(x,y)$，新背景$f^(x,y)$和嵌入新背景后的新图像$v(x,y)$，等价于解最优化问题：\n$$\n\\min\\limits_f \\iint \\Omega |\\nabla f-\\boldsymbol v |^2 \\ \\ \\mathrm{with}\\ f|{\\partial \\Omega}=f^|_{\\partial \\Omega}\n$$\n利用变分法，令$F=|\\nabla f-\\boldsymbol v |^2=(\\nabla f_x-\\boldsymbol v_x)^2+(\\nabla f_y-\\boldsymbol v_y)^2$\n代入欧拉-拉格朗日方程：\n$$\nF_f-\\frac{\\mathrm d}{\\mathrm d x}F_{f_x}-\\frac{\\mathrm d}{\\mathrm d y}F_{f_y}=0\n$$\n由于$F$是关于$\\nabla f$的函数，因此$F_f=0$\n所以有：\n$$\n\\begin{align}\n\u0026amp;\\frac{\\partial F}{\\partial f}=\\frac{\\mathrm d}{\\mathrm dx}\\left[\\frac{\\partial F}{\\partial(\\nabla f_x-\\pmb v_x)^2}\\right]+\\frac{\\mathrm d}{\\mathrm dy}\\left[\\frac{\\partial F}{\\partial(\\nabla f_y-\\pmb v_y)^2}\\right]\\\\\\\\\n\u0026amp;\\Rightarrow 0=\\frac{\\mathrm d}{\\mathrm dx}[2(\\nabla f_x-\\pmb v_x)]+\n\\frac{\\mathrm d}{\\mathrm dy}[2(\\nabla f_y-\\pmb v_y)]\\\\\\\\\n\u0026amp;\\Rightarrow 0=\\left(\\frac{\\partial ^2f}{\\partial x^2}-\\frac{\\partial \\pmb v}{\\partial x}\\right)+\\left(\\frac{\\partial ^2f}{\\partial y^2}-\\frac{\\partial \\pmb v}{\\partial y}\\right)\\\\\\\\\n\u0026amp;\\Rightarrow \\Delta f=\\mathrm{div}\\pmb v\n\\end{align}\n$$\n可转化为具有Dirichlet边界条件的Poisson方程：\n$$\n\\Delta f= \\mathrm{div} \\boldsymbol v\\ \\ \\mathrm{over}\\ \\Omega\\ \\ \\mathrm{with} \\ \\ f|_{\\partial \\Omega}=f^\\ast|_{\\partial\\Omega}\n$$\n以第一幅图和第二幅图为例，将图1中需要复制的区域设为$S$，定义$N_p$为$S$中的每一个像素$p$四个方向连接邻域，令$\u0026lt;p,q\u0026gt;$为满足$q\\in N_p$的像素对。边界$\\Omega$定义为$\\partial \\Omega ={p\\in S\\setminus \\Omega: N_p \\cap \\Omega \\neq \\emptyset }$，设$f_p$为$p$处的像素值$f$，目标即求解像素值集$f|_\\Omega ={f_p,p\\in \\Omega}$\n利用Poisson Image Editing算法的基本原理，上述问题转化为求解最优化问题：\n$$\n\\min\\limits_{f|_\\Omega}\\sum\\limits_{\u0026lt;p,q\u0026gt;\\cap \\Omega\\neq \\emptyset}(f_p-f_q-v_{pq})^2,\\mathrm{with}\\ f_p=f_p^*,\\forall\\ p\\in \\partial\\Omega\r$$\n化为求解线性方程组：\n$$\n\\forall\\ p\\in \\Omega,\\ |N_p|f_p-\\sum\\limits_{q\\in N_p\\cap \\Omega} f_q=\\sum\\limits_{q\\in N_p\\cap \\partial \\Omega}f_p^*+\\sum\\limits_{q\\in N_p}v_{pq}\n$$\n对于梯度场$\\boldsymbol{v}(\\boldsymbol{x})$的选择，文献[1]给出两种方法，一种是完全使用前景图像的内部梯度，即：\n$$\n\\forall\\ \u0026lt;p,q\u0026gt;,v_{pq}=g_p-g_q\n$$\n另一种是使用混合梯度：\n$$\n\\forall\\ \\boldsymbol{x}\\in \\Omega,\\ \\boldsymbol{v}(\\boldsymbol{x})=\\begin{cases}\n\\nabla f^*(\\boldsymbol{x})\u0026amp;\\mathrm{if}\\ |\\nabla f^*(\\boldsymbol{x})\u0026gt;|\\nabla g(\\boldsymbol{x})|,\\\\\\\\\n\\nabla g(\\boldsymbol{x})\u0026amp;\\mathrm{otherwise}\n\\end{cases} $$\n**扫描线算法**\n为实现多边形和自由绘制闭合图形区域的Poisson Image Editing算法，需通过扫描线算法获取多边形内部掩膜。这里从网上资料了解到一种有序边表法，其基本思想是定义边表ET和活动边表AET，ET记录当前扫描线与边的交点坐标、从当前扫描线到下一条扫描线间x的增量、该边所交的最高扫描线，AET记录只与当前扫描线相交的边的链表，通过迭代得到当前扫描线与待求多边形各边的交点，再利用奇偶检测法判断该点是否在多边形内部进行填充。\n3. 实验结果 3.1. 标准图像测试 原图像：\n新背景图像：\n   边界形式 图1选择区域 图2选择区域 结果图像     矩形边界      多边形边界      自由绘制边界       3.2. Poisson vs. Mix Poisson 背景图像：\n前景图像：\n混合结果：\n如图，左上为直接复制粘贴，保留前景全部颜色梯度信息；左下为普通Poisson编辑，保留前景全部梯度信息，前景像素颜色与背景作融合；右上为应用混合梯度的Poisson编辑，前景梯度部分保留，效果上比普通Poisson编辑更加“透明”，适合用在水印等场景。\n3.3. 其他应用 3.3.1. 遮盖不必要的信息（如去皱纹） 原图像：\n处理效果：\n3.3.2. 恐怖片特效 原图：\n掩盖镜子中人物：\n使用电影《修女》中的角色：\n处理效果：\n3.3.3. 生成表情包 原图：\n处理效果：\n参考文献 [1] Patrick Pérez, Michel Gangnet, Andrew Blake. Poisson image editing. Siggraph 2003.\n","description":"复现Siggraph2003论文《Poisson Image Editing》","id":17,"section":"posts","tags":["Digital Image Process"],"title":"Poisson Image Editing","uri":"https://chaphlagical.github.io/zh/posts/image_process/possion/"},{"content":"1. 算法原理 1.1. 基本原理  输入：$n$对控制点对$(\\pmb p_i,\\pmb q_i)$，$i=1,2,\\cdots,n$，其中$\\pmb p_i\\in\\mathbb R^2$为控制起始点，$\\pmb q_i\\in\\mathbb{R}^2$为控制目标点 目标：找到一个映射$f:\\mathbb R^2\\rightarrow \\mathbb{R}^2$，满足$f(\\pmb p_i)=\\pmb q_i$，$i=1,2,\\cdots,n$  1.2. Inverse distance-weighted interpolation methods(IDW)[1] IDW 算法基本原理是根据给定的控制点对和控制点对的位移矢量，计算控制点对周围像素的反距离加权权重影响，实现图像每一个像素点的位移。\n选择$n$对控制点对$(\\pmb p_i,\\pmb q_i)$，$i=1,2,\\cdots,n$，目标映射$f:\\mathbb R^2\\rightarrow \\mathbb{R}^2$可表示成\n以下形式：\n$$\nf(\\pmb p)=\\sum_{i=1}^n\\omega_i(\\pmb p)f_i(\\pmb p)\n$$\n其中，权重$\\omega_i(\\pmb p)$满足：\n$$\nw_i(\\pmb p)=\\frac{\\sigma_i(\\pmb p)}{\\sum_{j=1}^n\\sigma_j(\\pmb p)}\n$$\n$\\sigma_i(\\pmb p)$反映第$i$对控制点对像素$\\pmb p$得反距离加权权重影响程度，可以直接取：\n$$\n\\sigma_i(\\pmb p)=\\frac{1}{|\\pmb p-\\pmb p_i|^\\mu}\n$$\n其中$\\mu\u0026gt;1$，也可以取locally bounded weight：\n$$\n\\sigma_i(\\pmb p)=\\left[\\frac{R_i-d(\\pmb p,\\pmb p_i)}{R_id(\\pmb p,\\pmb p_i)}\\right]^\\mu\n$$\n$f_i$为线性函数，满足：\n$$\nf_i(\\pmb p)=\\pmb q_i+\\pmb T_i(\\pmb p-\\pmb p_i)\n$$\n其中$\\pmb T_i$为二阶矩阵：\n$$\n\\pmb T_i=\\begin{bmatrix}\nt_{11}^{(i)}\u0026amp;t_{12}^{(i)}\\\\\nt_{21}^{(i)}\u0026amp;t_{22}^{(i)}\n\\end{bmatrix}\n$$\n矩阵$\\pmb T$得确定，可以通过求解如下最优化问题：\n$$\n\\arg\\min_{\\pmb T_i} E(\\pmb T_i)=\\sum_{j=1,j\\neq i}^n\\sigma_i(\\pmb p_j)|\\pmb q_j-f_i(\\pmb p_j)|^2\n$$\n上式对$\\pmb T_i$求导，令方程为0得：\n$$\n\\pmb T_i\\sum_{j=1,j\\neq i}\\sigma_i(\\pmb p_j)\\pmb p\\pmb p^T=\\sum_{j=1,j\\neq i}\\sigma_i(\\pmb p_j)\\pmb q\\pmb p^T\n$$\n其中$\\pmb p=\\pmb p_j-\\pmb p_i$，$\\pmb q=\\pmb q_j-\\pmb q_i$\n又$\\sigma_i(\\pmb p_j)\\pmb p\\pmb p^T$非奇异，因此可以直接解出$\\pmb T_i$的值：\n$$\n\\pmb T_i=\\left(\\sum_{j=1,j\\neq i}\\sigma_i(\\pmb p_j)\\pmb q\\pmb p^T\\right)\\left(\\sum_{j=1,j\\neq i}\\sigma_i(\\pmb p_j)\\pmb p\\pmb p^T\\right)^{-1}\n$$\n求出$\\pmb T_i(i=1,\\cdots,n)$后，映射$f$也就相应确定\n1.3. Radial basis functions interpolation method(RBF)[2] 选择$n$对控制点对$(\\pmb p_i,\\pmb q_i)$，$i=1,2,\\cdots,n$，目标映射$f:\\mathbb R^2\\rightarrow \\mathbb{R}^2$可表示为以下形式：\n$$\nf(\\pmb p)=\\sum_{i=1}^n\\alpha_ig_i(|\\pmb p-\\pmb p_i|)+\\pmb{Ap}+\\pmb B\n$$\n其中，$g_i$为径向基函数，通常可以取Hardy multiquadrics：$g(t)=(t^2+c^2)^{\\pm \\frac{1}{2}}$或高斯函数$g_\\sigma(t)=e^{-t^2/\\sigma^2}$，\n为了计算方便，这里取Hardy multiquadrics：\n$$\n\\begin{aligned}\ng_i(d)\u0026amp;=(d+r_i)^{\\pm\\frac{1}{2}}\\\nr_i\u0026amp;=\\min_{j\\neq i}d(\\pmb p_i,\\pmb p_j)\n\\end{aligned}\n$$\n对于线性部分分量$\\pmb {Ap}+\\pmb B$，本例简单地取$\\pmb A=\\pmb I$和$\\pmb B=\\pmb 0$\n2. 实验结果 2.1. 标准图像测试 如下图所示，固定四角，蓝色为控制起始点，绿色为控制终止。\n2.2. IDW算法    $\\mu$取值 修复前 修复后     $\\mu=-1$     $\\mu=-2$      2.3. RBF算法    $\\mu$取值 修复前 修复后     $\\mu=-0.5$     $\\mu=0.5$      2.4. 相关应用 2.4.1. 柴犬表情包 原图像：\n开心：\nEmmm……：\n2.4.2. 藏狐的笑容 原图像：\n处理后：\n参考文献 [1] D. Ruprecht and H. Muller. Image warping with scattered data interpolation. IEEE Computer Graphics and Applications, 15(2):37–43, 1995. 10\n[2] N. Arad and D. Reisfeld. Image warping using few anchor points and radial functions. In Computer graphics forum, volume 14, pages 35–46. Wiley Online Library, 1995.\n","description":"基于IDW与RBF方法的图像扭曲算法实现","id":18,"section":"posts","tags":["Digital Image Process"],"title":"Image Warping","uri":"https://chaphlagical.github.io/zh/posts/image_process/image_warping/"},{"content":"1. 问题描述 给定一张原图像：\n和一张参考图像：\n我们希望通过设计一个颜色转换算法，使得源图像具有目标图像的颜色风格，如下图：\n2. 算法描述 衡量一幅图像的颜色分布最基础的统计特征就是均值和标准差，文献[1]中便通过这两个特征对图像进行简单的变换并取得不错的效果。\n首先，需要将图像的颜色空间从$RGB$空间变换到$l\\alpha\\beta$空间：\n  $RGB$空间$\\rightarrow$ $XYZ$空间\n$$\n\\begin{pmatrix}\nX\\\\Y\\\\Z\n\\end{pmatrix}=\n\\begin{pmatrix}\n0.5141\u0026amp;0.3239\u0026amp;0.1604\\\\\n0.2651\u0026amp;0.6702\u0026amp;0.0641\\\\\n0.0241\u0026amp;0.1228\u0026amp;0.8444\n\\end{pmatrix}\n\\begin{pmatrix}\nR\\\\G\\\\B\n\\end{pmatrix}\n$$\n  $XYZ$空间$\\rightarrow$ $LMS$空间\n$$\n\\begin{pmatrix}\nL\\\\M\\\\S\n\\end{pmatrix}=\n\\begin{pmatrix}\n0.3897\u0026amp;0.6890\u0026amp;-0.0787\\\\\n-0.2298\u0026amp;1.1834\u0026amp;0.0464\\\\\n0.0000\u0026amp;0.0000\u0026amp;1.0000\n\\end{pmatrix}\n\\begin{pmatrix}\nX\\\\Y\\\\Z\n\\end{pmatrix}\n$$\n  变换到对数空间\n$$\n\\begin{aligned}\n\\pmb L\u0026amp;=\\lg L\\\\\n\\pmb M\u0026amp;=\\lg M\\\\\n\\pmb S\u0026amp;=\\lg S\n\\end{aligned}\n$$\n  $\\pmb{LMS}$空间$\\rightarrow$ $l\\alpha\\beta$空间\n$$\n\\begin{pmatrix}\nl\\\\\\alpha\\\\\\beta\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\frac{1}{\\sqrt{3}}\u0026amp;0\u0026amp;0\\\\\n0\u0026amp;\\frac{1}{\\sqrt{6}}\u0026amp;0\\\\\n0\u0026amp;0\u0026amp;\\frac{1}{\\sqrt{2}}\n\\end{pmatrix}\n\\begin{pmatrix}\n1\u0026amp;1\u0026amp;1\\\\\n1\u0026amp;1\u0026amp;-2\\\\\n1\u0026amp;-1\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\pmb L\\\\\\pmb M\\\\\\pmb S\n\\end{pmatrix}\n$$\n  同理，将图像的颜色空间从 lαβ 空间变换到 RGB 空间只需将相应的变换矩阵依次求逆即可。\n设变换到$l\\alpha\\beta$颜色空间的源图像的均值和标准差分别为$\\mu_s$、$\\sigma_s$，目标图像的均值和标准差分别为$\\mu_t$、$\\sigma_t$，只需通过如下简单处理，即可将源图像的颜色分布变换到接近与目标图像\n$$\n\\begin{aligned}\nl'\u0026amp;=\\frac{\\sigma_t^l}{\\sigma_s^l}(l-\\mu^l_s)+\\mu^l_t\\\\\n\\alpha'\u0026amp;=\\frac{\\sigma_t^\\alpha}{\\sigma_s^\\alpha}(\\alpha-mu^\\alpha_s)+\\mu^\\alpha_t\\\\\n\\beta'\u0026amp;=\\frac{\\sigma_t^\\beta}{\\sigma_s^\\beta}(\\beta-\\mu^\\beta_s)+\\mu^\\beta_t\\\n\\end{aligned}\n$$\n并将图像$(l',\\alpha',\\beta')$变换回$RGB$空间即可得到处理后的结果。\n3. 实验结果    原图像 参考图像 结果图像                               参考文献 [1] E. Reinhard, M. Adhikhmin, B. Gooch, and P. Shirley. Color transfer between images. IEEE Computer graphics and applications, 21(5):34–41, 2001.10\n","description":"复现论文《Color Transfer between Images》","id":19,"section":"posts","tags":["Digital Image Process"],"title":"Color Transfer","uri":"https://chaphlagical.github.io/zh/posts/image_process/color_transfer/"},{"content":"1. 问题描述 给定一张原图像：\n我们希望通过设计一个灰度图着色算法，使得下述灰度目标图像能够利用彩色原图像的颜色信息进行合理的上色：\n以得到类似下图的效果：\n2. 算法描述 实验参考了论文[1]，并使用全局匹配的方法进行求解。我们在图像的$l\\alpha\\beta$颜色空间上进行求解，这是由于$l\\alpha\\beta$颜色空间的$l$即代表着亮度，通过查找灰度源图像上的像素与彩色目标图像的$l$分量最佳匹配像素，再将目标图像对应匹配像素的$\\alpha$和$\\beta$分量赋予源图像即可\n进行灰度图像上色。算法流程如下：\n  将源图像$img_{src}$变换到$l\\alpha\\beta$颜色空间得到$img_{src}^{(l\\alpha\\beta)}$，同时将源图像$img_{src}$转换为灰度图$img_{src}^{(grey)}$\n  利用如下均值标准差变换，将$img_{src}^{(l\\alpha\\beta)}$的$l$通道和$img_{src}^{(grey)}$映射到具有灰度目标图像$img_{tar}$的像素值分布，得到$luminance_{src}$和$luminance_{src}^{grey}$\n$$\n\\begin{aligned}\nl'\u0026amp;=\\frac{\\sigma_t^l}{\\sigma_s^l}(l-\\mu^l_s)+\\mu^l_t\\\\\n\\alpha'\u0026amp;=\\frac{\\sigma_t^\\alpha}{\\sigma_s^\\alpha}(\\alpha-\\mu^\\alpha_s)+\\mu^\\alpha_t\\\\\n\\beta'\u0026amp;=\\frac{\\sigma_t^\\beta}{\\sigma_s^\\beta}(\\beta-\\mu^\\beta_s)+\\mu^\\beta_t\\\\\n\\end{aligned}\n$$\n  近邻域标准差计算。利用一个$n\\times n$（本实验中取$n=5)$）滑动窗口遍历图像（类似于卷积操作，边界用0填充），对窗口内的所有像素值计算它们的标准差并赋值到一幅标准差图像上。对$luminance_{src}^{grey}$和$img_{tar}$进行该计算，得到$stddev_{src}^{grey}$和$stddev_{tar}$\n  最佳匹配查找。遍历$img_{tar}$，已知$img_{tar}$上的某一像素值$p_{tar}$和其标准差$stddev_{tar}$对应的值$\\sigma_{tar}$，在源图像上寻找最佳匹配的像素点，这里简单地采用加权的$\\mathcal{L}_2$范数平方去算：\n$$\n\\arg\\min_{x,y} \\Big(w_1\\ast |luminance_{src}(x,y)-p_{tar}|^2+w_2\\ast|stddev_{src}^{grey}(x,y)-\\sigma_{tar}|^2\\Big)\n$$\n其中$w_1$和$w_2$分别表示亮度值和标准差的对匹配结果的贡献，这里简单地取$w_1=w_2=0.5$\n  灰度图上色。将查找到的最佳匹配像素$(\\tilde x. \\tilde y)$在$img_{src}^{(l\\alpha\\beta)}$所在像素值的$\\alpha$和$\\beta$分量赋值给源图像作为其$\\alpha$和$\\beta$通道的值，而原来的灰度值则作为$l$分量继续使用，并将源图像重新变换回$RGB$颜色空间得到最终的结果\n  3. 实验结果    原图像 参考图像 结果图像                               参考文献 [1] Welsh, M. Ashikhmin, and K. Mueller. Transferring color to greyscale im-ages. In Proceedings of the 29th annual conference on Computer graphics and interactive techniques, pages 277–280, 2002.11\n","description":"复现Siggraph2002论文《Transferring Color To Greyscale Image》","id":20,"section":"posts","tags":["Digital Image Process"],"title":"Colorization","uri":"https://chaphlagical.github.io/zh/posts/image_process/colorization/"},{"content":"我将在这里分享有趣的知识与技术\n","description":"My Blog","id":21,"section":"","tags":null,"title":"简介","uri":"https://chaphlagical.github.io/zh/about/"},{"content":"第一章 计算机网络与互联网络 一、什么是互联网络 1、从构成角度看  节点：端系统（=主机），网络应用程序+网络交换设备（路由器、交换机等） 边：通信链路（接入网链路：主机-互联网、主干链路：路由器-路由器） 互联网络：网络的网络  2、从服务角度看 互联网络=能够为应用提供通信服务的通信架构（已连接可靠服务和无连接不可靠服务）+使用通信服务相互配合工作的应用\n3、协议 协议：对等层实体在通信过程中所遵循的规则集合，控制发送和接收消息\n协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输和/或接收或其他事件方面所采取的动作\n协议=语法+语义+时序\n二、网络边缘 1、网络结构 网路结构=网络边缘（主机、应用程序）+网络核心（路由器、网络的网络）+接入网与通信链路\n2、 网络边缘：运行应用的端系统（端系统中的应用交互方式）  C/S模式：客户端向服务器请求、接收服务 P2P模式：很少（甚至没有）专门的服务器  3、利用网络的服务  采用网络设施的面向连接服务：TCP  可靠的、按顺序的传输数据 流量控制 拥塞控制 HTTP、FTP、Telnet、SMTP   采用基础设施的无连接服务：UDP  无连接 不可靠数据传输 无流量控制 无拥塞控制 流媒体、远程会议、DNS、网络电话    三、网络核心 1、网络核心  组成：路由器+链路 功能：数据交换  2、数据交换方式及比较   电路交换\n  特点：网络资源（如带宽）被分成片，独享资源，建立呼叫连接\n  分片方式：\n  频分FDM：\n  时分TDM：\n  波分WDM\n    举例：电话网络\n    分组交换\n 特点：以分组为单位存储-转发方式；传输时使用全部带宽；在转发之前，节点必须收到整个分组（延迟、排队）；路由器缓存用完时，分组将被抛弃；统计多路复用（时分复用） 虚电路网络VC：  每个分组带虚电路标识VC ID，标签决定下一跳 在呼叫建立时决定路径，在整个呼叫中路径保持不变 路由器维持每个呼叫的状态信息 X.25和ATM    数据报网络Datagram  分组的目标地址决定下一跳 在不同的阶段，路由可以改变 在通信之前，无须建立起一个连接，有数据就能传输 每一个分组都有独立路由 Internet    举例：IP网络    分组交换vs电路交换\n 分组交换是“突发数据的胜利者” 分组交换  缺点：  不适合实时服务（如电话和视频会议），因为其端到端时延是可变的和不可预测的 分组在目的主机需要重新进行排序 每个分组需要携带额外的首部信息   优点：  提供比电路交换更好的带宽共享 比电路交换更简单、更有效，实现成本更低        四、接入网与物理媒介 将端系统连接到边缘路由器的链路或网路\n1、住宅接入网络：点到点接入  调制解调器 modem  原理：将上网数据调制加载音频信号上，在电话线上传输，在局端将其中的数据解调出来：调频、调幅、调相位、综合解调 不能同时上网和打电话，不能总是在线   接入网 DSL  采用现存的到交换局DSLAM的电话线  DSL线路上的数据被传到互联网 DSL线路上的语音被传到电话网   \u0026lt;2.5Mbps上行传输速率 \u0026lt;24Mbps下行传输速率    线缆网络（混合光纤同轴网络HFC）   有线电视信号电缆双向改造 非对称：最高30Mbps下行传输速率，2Mbps上行传输速率   FTTH（光纤到户）  主动光纤网络AON 被动光纤网络PON   家庭网络      2、机构接入：LAN  以太网络 Ethernet  10Mbps，100Mpbs，1Gbps，10Gbps的传输率 端系统经常直接接到以太网络交换机上    无线接入网络 WLAN  各无线端系统共享无线接入网络     3、物理链路 在每个传输-接收对，跨越一种物理媒体\n 导向型介质：信号沿着固体媒介被导引：同轴电缆、光纤、双绞线 非导引型媒体：信号自由传播（如无线电）  4、常用介质  双绞线（TP）  两根绝缘铜线 5类：100Mbps Ethernet 6类：10Gbps   同轴电缆  两根同心的铜导线 双向 基带电缆：  电缆上一个单个信道 Ethernet   宽带电缆  电缆上有多个信道 HFC     光纤  光脉冲：每个脉冲表示一个比特在玻璃纤维中传输 高速：点到点10Gbps~100Gbps 低误码率：两个中继器之间可以有很长的距离，不受电磁噪声的干扰 安全   无线链路  开放空间传输电磁波，携带需要传输的数据 无需物理线缆 双向 传播环境效应：反射、吸收、干扰    五、互联网结构和ISP 1、近似层次型结构  T-1 ISP  中心 国家/国际覆盖，速率极快 直接与其他第一层ISP相连 与大量的第二层ISP和其他客户网络相连   T-2 ISP  通常是区域性的ISP 与一个或多个第一层ISPs，也可能与其他第二层ISP相连   Local ISP  2、ISP之间的连接   POP：高层ISP面向客户网络的接入点，涉及费用结算\n  对等连接：2个ISP对等互接，不涉及费用结算\n  IXP：多个对等ISP互联互通，通常不涉及费用结算\n  3、内容提供商网络  在全球部署DC 内容提供商网络在多处与各个ISP相联 内容提供商自己部署网络将全球的DC相联  内容提供商DC自己之间的访问，通过自己部署的专网 用户接入后通过用户最近的DC为之服务    六、分组交换网络中的延迟与丢失 1、延迟的原因（4个） （1）处理延迟  检查bit级差错 检查分组首部和决定将分组导向何处  （2）排队延迟  在输出链路上等待传输的时间 依赖于路由器的拥塞程度  （3）传输延时  R=链路带宽（bps） L=分组长度（bits） 将分组发送到链路上的时间=L/R 存储转发延迟  （4）传播延时  d=物理链路的长度 s=在媒体上的传播速度（~$2\\times 10^8m/sec$） 传播延迟=d/s  节点延迟的计算：\n$$\nd_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}\n$$\n $d_{proc}$=处理延时，通常是微秒数量级或更少（固定） $d_{queue}$=排队延时，取决于拥塞程度（变化） $d_{trans}$=传输延时=L/R，对低速率的链路而言很大，通常为微秒级到毫秒级（固定） $d_{prop}$=传播延时，几微秒到几百毫秒（固定）  2、流量强度  假设：  R=链路带宽（bps） L=分组长度（bits） a=分组到达队列的平均速率 流量强度=La/R    有以下规律：  La/R~0：平均排队延时很小 La/R-\u0026gt;1：延时变得很大 La/R\u0026gt;1：bit到达队列速率超过从该队列输出的呃速率，平均排队延时趋于无穷    3、丢失原因  链路的队列缓冲区容量有限 当分组到达一个满的队列时，该分组将会丢失 丢失的分组可能会被钱一个节点或源端系统重传或根本不重传  4、吞吐量 在源端和目标端之间传输的速率（数据量/单位时间）\n 瞬间吞吐量：在一个时间点的速率 平均吞吐量：在一个长时间内的平均值 瓶颈链路决定了主机之间的吞吐量 端到端的平均吞吐=min{$R_1$, $R_2$, \u0026hellip; ,$R_n$}  七、协议层次与服务模型 1、分层的原因 网络比较复杂，分层实现比较容易设计，调试和实现\n2、分层 将复杂网络的功能划分成功能明确的层次，上层利用下层提供的服务来实现本层的协议，从而为上层提供更复杂的功能\n3、相关术语与概念  服务：底层实体向上层实体提供它们之间的通信的能力，通过原语来操作，垂直  服务用户 服务提供者   服务访问原语：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语进行交互 服务访问点SAP：上层使用下层提供的服务通过层间接口（如端口、地址） 面向连接的服务：  连接：两个通信实体为进行通信而建立的一种结合 过程：建立连接，通信，拆除链接 例子：网络层的连接为虚电路 适用范围：对于大的数据块要传输，不适合小的零星报文 特点：报序 服务类型：  可靠的信息流：传送页面 可靠的字节流：远程登陆 不可靠的连接：数字化声音     无连接的服务  无连接服务：两个对等层实体在通信前不需要建立一个连接，不预留资源；不需要通信双方都是活跃 特点：不可靠、可能重复、可能失序 IP分组，数据包 适用范围：适合传送零星的数据 服务类型：  不可靠的数据报：电子方式的函件 有确认的数据报：挂号信 请求回答：信息查询     协议：对等层实体之间在相互通信的过程中，需要遵循的规则的集合，水平 协议数据单元     服务与协议的联系：  本层协议的实现要靠下层提供的服务来实现 本层实体通过协议为上层提供更高级的服务    4、互联网络分层模型及每一层的功能  应用层：网络应用  作用：为用户或其他应用进程提供网络应用服务 举例：FTP，SMTP，HTTP，DNS 数据单元：报文Message   传输层：主机之间的数据传输  作用：在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠的通信变成可靠的通信 举例：TCP，UDP 数据单元：报文段Segment   网络层：为数据报从源到目的选择路由  作用：主机-主机之间的通信，端到端的通信，不可靠 举例：IP，路由协议 数据单元：分组packet（无连接方式：数据报datagram）   链路层：相邻网络节点间的数据传输  作用：2个相邻2点的通信，点到点通信，可靠或不可靠 举例：点对点协议PPP，802.11（wifi），Ethernet 数据单元：帧Frame   物理层：在线路上传送bit  数据单元：位bit    5、封装和解封装 八、历史  ARPANET：美国军方资助的分组交换实验网，由于 TCP/IP 架构的包\n容性、免费使用、架构便于应用创新吸引更多的用户等原因，用户数量、\n节点数量和应用数量越来越多。 NSF 建立 ARPANET 的访问网 民用网络从军用网络脱开，成为现在的互联网。 IETF（ITU， IEEE）：国际互联网工程任务组（研发因特网标准） RFC：Request For Comments（RFC），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件  第二章 应用层 一、网络应用原理 1、应用架构 （1） 客户-服务器（C/S）体系结构  服务器  一直运行 固定的IP和周知的端口号 扩展性：服务器场  数据中心进行扩展 扩展性差     客户端  主动与服务器通信 与互联网有间歇性的连接 可能是动态IP地址 不直接与其他客户端通信    （2）对等体（P2P）体系结构  几乎没有一直运行的服务器 任意端系统之间可以进行通信 每一个节点既是客户端又是服务器  自扩展性   参与的主机间歇性连接且可以改变IP地址 例子：Gnutella，迅雷  （3）C/S和P2P体系结构混合体  Napster  文件搜索：集中  主机在中心服务器上注册其资源 主机向中心服务器查询资源位置   文件传输：P2P  任意peer节点之间     即时通信  在线监测：集中  当用户上线时，向中心服务器注册其IP地址 用户与中心服务器联系，以找到其在线好友的位置   两个用户之间聊天：P2P    2、进程通信   同主机：使用进程间通信机制通信（由操作系统定义）\n  不同主机：通过交换报文来通信\n 使用OS提供的通信服务  按照应用协议交换报文\n  3、SOCKET  一个整数，OS用于标识应用通信关系所采用的本地标示 TCP：连接的本地标示，四元组（源IP，源port，目标IP，目标port），TCP服务器需要两个套接字      UDP：端节点的本地标示，二元组（本IP，本port），UDP服务器需要一个套接字  传输报文时需要提供对方的IP和port 接收报文时，传输层需要上传对方的IP和port     4、进程编址 IP+port\n5、 应用所需要的服务需要考虑的因素  丢失率、可靠性 延迟 带宽 安全性  6、传输层协议  TCP：提供的服务特性，可靠的字节流服务，面向连接，流量控制，拥塞控制 UDP：提供的服务特性，无连接，不可靠的服务  区分不同进程 无需建立连接，节省时间，适合事务性的应用 不做可靠性的工作，适合对实时性要求比较高而对正确性要求不高的应用 无拥塞控制和流量控制，应用能按照设定的速度发送数据   都能提供进程的标示，区分不同的进程  二、WEB和HTTP 1、WEB应用包括  HTTP协议 HTML Client，Server  2、术语  网页：由一些对象组成 对象：HTML文件，JPEG文件，Java小程序，声音视频文件 引用URL：包括访问协议，用户名，口令字，端口等；对每个对象进行引用  3、HTTP协议 （1）作用 定义了client和server之间通信的报文格式，解释和时序 （Port 80）\n（2）HTTP连接   持久HTTP\n 多个对象可以在一个TCP连接上传输（HTTP/1.1默认使用持久连接） 服务器在发送响应后，仍保持TCP连接 在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送 客户端在遇到一个引用对象的时候，就可以尽快发送该对象的请求 分类：  非流水方式的持久HTTP：  客户端只能在收到前一个响应后才能发出新的请求 每个引用对象花费一个RTT   流水方式的持久HTTP：  HTTP/1.1的默认模式 客户端遇到一个引用对象就立即产生一个请求 所有引用对象只花费一个RTT是可能的        非持久HTTP\n  最多只有一个对象在TCP链接上发送\n  下载多个对象需要多个TCP连接\n  HTTP/1.0使用非持久连接\n  缺点：\n 每个对象需要2个RTT OS必须为每个TCP连接分配资源 浏览器通常打开并行TCP连接，以获取引用对象    举例：\n注意： 应对每一个对象重复操作\n    4、往返延迟RTT和对象的抓取时间  往返时间RTT：一个小的分组从客户端到服务器，再回到客户端的时间（传输时间忽略） 响应时间：  一个RTT用于发起TCP连接 一个RTT用于HTTP请求并等待HTTP响应 文件传输时间 总共：2RTT+传输时间    5、报文格式   请求报文\n   ASCII 方法：  GET：输入通过请求行的URL字段上载 POST：提交表单输入，包含在实体主体中的输入被提交到服务器 HEAD：要求服务器在响应报文中不包含请求对象（用于故障跟踪） PUT：将实体主体中的文件上载到URL字段规定的路径 DELETE：删除URL字段规定的文件      响应报文\n  Date：首部行指示服务器产生并发送该响应报文的日期和时间   响应状态码：  200 OK：请求成功，请求对象包含在响应报文的后续部分 301 Moved Permanently：  请求的对象已经被永久转移，新的URL再响应报文的Location：首部行中指定 客户端软件自动用新的URL去获取对象   400 Bad Request：表示该请求不能被服务器解读 404 Not Found：请求的文档再该服务上没有找到 505 HTTP Version Not Supported      6、COOKIES   组成部分：\n 在HTTP响应报文中有一个cookies的首部行 在HTTP请求报文中由一个cookies的首部行 在用户端系统中保留有一个cookies文件，由用户的浏览器管理 在web站点有一个后端数据库    维护状态：  应用：用户验证、购物车、推荐、用户状态\n  7、WEB缓存   目的：不访问原始服务器，就满足客户的请求\n  原理\n 用户设置浏览器：通过缓存访问Web 浏览器将所有的HTTP请求发给缓存  在缓存中的对象：缓存直接返回对象 若对象不在缓存中，缓存请求原始服务器，然后将对象返回给客户端      作用：\n 通过本地命中，减少这些对象的访问延迟 进一步减少接入链路的流量强度，从而降低对延迟，带来的总体平均延迟减少 减轻服务器的负担（能减少对所有对象的时延） 互联网大量使用了缓存，可以使较弱的ICP也能有效提供内容    条件GET方法：如果缓存器中的对象拷贝是最新的，就不要发送对象\n  缓存器：在HTTP请求中指定缓存拷贝的日期\nIf-modified-since:\u0026lt;date\u0026gt;\r\r  服务器：如果缓存拷贝陈旧，则响应报文没包含对象\nHTTP/1.0 304 Not Modified\r\r    三、FTP*（不要求） 四、EMAIL 1、电子邮件应用的构成  用户代理  又名“邮件阅读器” 撰写、编辑和阅读邮件 如Outlook，Foxmail 输入和输出邮件保存在服务器上   邮件服务器  邮箱中管理和维护发送给用户的邮件 输出报文队列保持待发送邮件报文 邮件服务器之间的SMTP协议：发送Email报文   SMTP  使用TCP在客户端和服务器之间传送报文，Port：25 直接传输：从发送方服务器到接收方服务器 传输三个阶段：  握手 传输报文 关闭   命令/响应交互  命令：ASCII文本 响应：状态码和状态信息   报文必须为7位ASCII码 SMTP vs HTTP  HTTP：拉 SMTP：推 二者都是ASCII形式的命令/响应交互、状态码 HTTP：每个对象封装在各自的响应报文中 SMTP：多个对象包含在一个报文中   举例：    2、邮件报文格式解析   报文头\n  To：\n  From：\n  Subject：\n与SMTP命令不同\n    报文体：报文，ASCII码字符\n  MIME：邮件多媒体扩展，可以在邮件中编解码多媒体内容\n  3、邮件存取协议  作用  SMTP：传送到接收方的邮件服务器（推协议） 邮件访问协议：从服务器访问邮件   常用  POP3：邮局访问协议，用户身份确认（代理\u0026lt;\u0026ndash;\u0026gt;服务器）并下载  用户确认阶段  客户端命令：user（申明用户名），pass（口令） 服务器响应：+OK，-ERR   事务处理阶段，客户端：  list：报文号列表 retr：根据报文号检索报文 dele：删除 quit   会话中无状态 本地管理文件夹   IMAP：Internet邮件访问协议  IMAP服务器将每个报文与一个文件夹联系起来 允许用户用目录来组织报文 允许用户读取报文组件 IMAP在会话过程中保留用户状态：目录名、报文ID与目录名之间的映射 远程管理文件夹   HTTP：Yahoo，Hotmail等（方便）    五、DNS 1、DNS的作用  完成域名到IP地址的转换（UDP Port53） 主机别名到规范名字的转换：Host aliasing 邮件服务器别名到邮件服务器的正规名字的转换：Mail server aliasing 负载均衡：load distribution  2、DNS的概念：分布式、层式数据库  命名是分层的 域名信息存储和服务是分布的，每个域名服务器担任一个区域的名字到IP地址的权威转换，也缓存名字-ip信息的转换  3、DNS的构成  解析器：本地应用（UDP） 域名服务器  权威DNS服务器 顶级域（TLD）服务器   DNS协议  报文：查询和响应报文的报文格式相同      资源记录（RR）  作用：维护域名-IP地址（其他）的映射关系 位置：Name Server的分布式数据库 RR的格式：（domain_name，ttl，type，class，value）  Domain_name：域名 Class类别：对于Internet，值为IN Value值：可以是数字，域名或ASCII串 Type类别：资源记录的类型  Type=A  Name为主机、 Value为IP地址   Type=NS  Name为域名 Value为该域名的权威服务器的域名   Type=CNAME  Name为规范名字的别名 value为规范名字   Type=MX  Value为name对应的邮件服务器的名字     TTL：生存时间，决定了资源记录应当从缓存中删除的时间        4、域名解析的过程 解析器-\u0026gt;本地DNS服务器-\u0026gt;上层域名服务器-\u0026gt;\u0026hellip;-\u0026gt;权威域名服务器，返回\n 递归查询   名字解析负担都放在当前联络的名字服务器上 问题：根服务器的负担太重 解决：迭代查询   迭代查询   根（以及各级域名）服务器返回的是下一个NS的地址 最后由权威域名服务器给出解析结果 当前联络的服务器给出可联系的服务器的名字    5、DNS缓存  作用：提高效率，使得根服务器不用经常被访问 问题：若情况变化，缓存结果可能和权威资源记录不一致 解决方法：TTL（默认2天） 本地缓存+服务器缓存  6、新增一个域  在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名 和 域名服务器的地址 在新增子域 的名字服务器上运行名字服务器，负责本域的名字解析： 名字-\u0026gt;IP地址 举例：  7、攻击DNS  DDoS攻击  对根服务器进行流量轰炸攻击：发送大量ping  没有成功 根目录服务器配置了流量过滤器，防火墙 Local DNS服务器缓存了TLD服务器的IP地址，因此无需查询根服务器   向TLD服务器流量轰炸攻击：发送大量查询  可能更危险 效果一般，大部分DNS缓存了TLD     重定向攻击  中间人攻击  截获查询，伪造回答，从而攻击某个站点   DNS中毒  发送伪造的应答给DNS服务器，希望它能缓存该虚假结果   技术上较困难：分布式截获和伪造   利用DNS基础设施进行DDoS  伪造某个IP进行查询，攻击这个目标IP 查询放大，响应报文比查询报文大 效果有限    六、P2P 1、P2P概念：每个对等体既是客户端又是服务器   P2P网络是这些peer构成的应用层面上的逻辑网络\n  P2P网络比C/S分发内容快的原因：这些peer节点参与到内容的上载，流量和服务都是分布的，可扩展性\n  分发时间$D$\n  假设：\n $u_s$表示服务器接入链路的上载速率，$u_i$表示第$i$对等方接入链路的上载速率，$d_i$表示第$i$对等方接入链路的下载速率。$F$表示被分发的文件长度，$N$表示要获得该文件副本的对等方数量    服务器向$N$个对等方传输该文件的一个副本，分发时间$D_{cs}=NF/u_s$。对于P2P架构网络，服务器至少在其接入链路上发送文件一次，故最小分发时间至少为$F/u_s$\n  令$d_{min}$表示具有最小下载速率的对等方的下载速率，则最小分发时间至少为$F/d_{min}$\n  系统整体的总上载能力等于服务器的上载速率加上每个单独的对等方的上载速率，即$u_{total}=u_s+u_1+\u0026hellip;+u_N$，则最小分发时间至少为$NF/(u_s+u_1+\u0026hellip;+u_N)$\n  对于C/S体系网络，$D_{cs}=max{\\frac{NF}{u_s},\\frac{F}{d_{min}}}$\n对于P2P体系网络，$D_{P2P}=max{\\frac{F}{u_s},\\frac{F}{d_{min}},\\frac{NF}{u_s+\\sum\\limits^N_{i=1}u_i}}$\n    应用：文件分发、流媒体、VoIP\n  2、典型P2P应用及其原理  Napster Gnutella KaZaA BT DHT  七、视频流化服务和CDN 1、服务器向客户端进行视频流化的方式  UDP流化 http流化 DASH  2、DASH流化过程  服务器  将视频文件分割成多个块 每个块独立存储，编码于不同码率 告示文件：提供不同块的URL   客户端  先获取告示文件 周期性测量服务器到客户端的带宽 查询告示文件，在一个时刻请求一个块，HTTP头部指定字节范围  若带宽足够，选择最大码率的视频块 会话中的不同时刻，可以切换请求不同的编码块     智能客户端  什么时候去请求块 (不至于缓存挨饿，或者溢出) 请求什么编码速率的视频块 (当带宽够用时，请求高质量的视频块) 哪里去请求块 (可以向离自己近的服务器发送URL，或者向高可用带宽的服务器请求)    3、CDN   单个服务器，或者服务器群向客户端提供海量内容并发服务的问题：扩展性差\n  CDN的原理\n 应用层面的协作服务网络 在全网部署缓存节点，内容预先部署到CDN缓存节点上 用户请求通过域名解析重定向向离自己最近的节点请求内容    缓存节点放置的方式\n Enter Deep Bring Home    举例：\n  八、TCP的SOCKET编程 1、SOCKET的概念 TCP连接的本地标示，向这个SOCKET写就是发送给对方的进程；从SOCKET中读，就是读取对方发送过来的数据\n2、SOCKET API  创建 使用（读和写） 关闭  3、TCP SOCKET数据传输的特点  面向连接 可靠的字节流服务  4、TCP SOCKET编程 服务器首先运行，等待连接建立\n 服务器进程必须先处于运行状态  创建欢迎socket 和本地端口捆绑 在欢迎socket上阻塞式等待接收用户的连接    客户端主动和服务器建立连接\n  创建客户端本地套接字（隐式捆绑到本地port）\n 指定服务器进程的IP地址和端口号，与服务器进程连接    当有与客户端连接的请求到来时\n 服务器接受来自用户端的请求，接触阻塞式等待，返回一个新的socket（与欢迎socket不同），与客户端通信  允许服务器与多个客户端通信 使用源IP和源端口来区分不同的客户端      连接API调用有效时，客户端与服务器建立了TCP连接\n  5、面向连接的套接字通信工作流程  服务器先用socket函数来建立一个套接字，用这个套接字完成通信的监听 用bind函数来绑定一个端口号和IP地址。因为本地计算机可能有多个IP，每一个IP有多个端口号，需要指定一个IP和端口进行监听 服务器调用listen函数，使服务器的这个端口和IP出于监听状态，等待客户机的连接 客户端用socket建立一个套接字 客户端调用connect函数，通过远程IP和端口号连接远程计算机指定的端口 服务器用accept函数来接收远程计算机的连接，建立起与客户端之间的通信 建立连接以后，客户端用write函数向socket中写入数据。也可用read函数读取服务器发送来的数据 服务器用read函数读取客户端发送来的数据，也可用write函数发送数据 完成通信以后，用close函数关闭socket连接  九、UDP SOCKET编程 1、UDP SOCKET数据传输的特点  没有握手 发送端在每一个报文中明确的指定目标的IP地址和端口号 服务器必须从收到的分组中提取出发送端的IP地址和端口号  2、UDP SOCKET 编程   建立SOCKET\n  使用\n  关闭\n  第三章 传输层 一、传输层服务 1、传输服务 为运行在不同主机上的应用进程提供逻辑通信\n2、传输协议 运行于端系统的两个对等传输层实体相互通信应该遵守的规则集合\n 发送方：将应用层的报文分成报文段，然后传递给网络层 接收方：将报文段重组成报文，然后传递给应用层  3、传输服务与网络服务的区别  网络服务：主机-主机之间的逻辑通信 传输服务：进程-进程之间的逻辑通信  依赖于网络层服务（延时，带宽） 对网络层服务进行增强（数据丢失、顺序混乱、加密）    4、互联网络传输层协议  TCP：有连接，可靠保序数传服务  多路复用、解复用 拥塞控制 流量控制 建立连接   UDP：不可靠、不保序的传输  多路复用、解复用 没有为尽力而为的IP服务添加更多的其他额外服务    二、复用与解复用 1、复用 源端多个上层应用收集数据：应用报文，封装报文\n2、解复用 接收端将数据按照端口号（结合IP地址）给相应的SOCKET对应的应用\n3、复用和解复用的工作原理：IP PORT  TCP有连接情况：SOCKETS为4元组（源IP，源port，目的IP，目的port）  两个具有不同源IP地址或源端口号的到达TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带了初始创建连接的请求   UDP无连接情况：SOCKETS为2元组（目的IP，目的port）  两个具有不同源IP或源端口号的到达UDP报文段，但具有相同的目的IP地址和目的端口地址，则两个报文段将通过相同的目的套接字被定向到相同的目的进程    三、无连接传输协议UDP 1、必要性  对实时性比较在乎，对可靠性要求不高 简单：在发送端和接收端没有连接状态 报文段头部开销很小（TCP：20字节；UDP：8字节） 无拥塞控制和流量控制，UDP可以尽可能快的发送报文段  2、UDP报文（数据报）格式  UDP校验和  目的：检测在被传输报文段中的差错 发送方：  将报文段的内容视为16比特的整数 校验和：报文段的加法和（1的补运算） 发送方将校验和放在UDP的校验和字段   接收方：  计算接收到的报文段的校验和 检查计算出的校验和与校验和字段的内容是否相等  不相等——检测到差错 相等——可能有残存错误     Internet校验和的例子：    四、可靠数据传输的原理 1、Rdt服务 （1）Rdt1.0：在可靠信道上的可靠数据传输  下层的信道是完全可靠的  没有比特出错 没有分组丢失   发送方和接收方的FSM  发送方将数据发送到下层信道 接收方从下层信道接收数据     （2） Rdt2.0：具有比特差错的信道  下层信道可能会出错：将分组中的比特翻转  用校验和来检测比特差错   从差错中恢复：  确认（ACK）：接收方显式地告诉发送方分组已经被正确接收 否定确认（NAK）：接收方显式地告诉发送方分组发生了差错，发送方收到NAK后，发送方重传分组   新机制：采用差错控制编码进行差错检测  发送方差错控制编码、缓存 接收方使用编码检错 接收方的反馈：控制报文（ACK,NAK） 发送方收到反馈相应的动作   FSM描述：      （3）Rdt2.1：处理Rdt2.0的缺陷  引入序号 处理重复：  发送方在每个分组中加入序号 若ACK/NAK出错，发送方重传当前分组 接收方丢弃重复分组   发送方处理出错的ACK/NAK     接收方处理出错的ACK/NAK     讨论：  发送方：  在分组中加入序列号（两个（0，1）即可，一次只发送一个未经确认的分组）（区分到达的数据包是重传的还是新数据，也可以用来判断数据包顺序是否正确） 必须检测ACK/NAK是否出错（需要EDC） 状态数变成了两倍   接收方：  必须检测接收到的分组是否是重复的  状态会指示希望接收到的房租的序号为0还是1   接收方不知道它最后发送的ACK/NAK是否被正确地收到  发送方不对收到地ACK/NAK给确认 接收方发送ACK，若接收方收到：  下一个分组——则ACK被正确收到 老分组——则ACK没有被正确地传到发送方         rdt2.1的运行      （4）Rdt2.2：无NAK的协议  特点：  功能同rdt2.1，但只使用ACK 接收方对最后正确接收的分组发ACK,以代替NAK  接收方必须显式地包含被正确接收分组地序号   当收到重复的ACK时，重传当前分组   rdt2.2的运行       FSM描述      （5）rdt3.0：具有比特差错和分组丢失的信道  方法：发送方等待ACK一段合理的时间  发送端超时重传：若时间到未收到ACK—\u0026gt;重传 需要一个倒计时定时器（防止丢包现象）   FSM描述     rdt3.0的运行：      rdt3.0的性能  在链路容量较大情况下性能很差    rdt3.0的停-等操作     流水线：提高链路利用率      2、技术机制  校验和，正向确认，反向确认 序号：检查重复 只有正向确认的机制 检错重发和超时重发：处理丢失  滑动窗口    3、利用率计算 （1）停止等待技术 链路带宽延迟积（容量）效率低\n（2）管道技术 在未经对方确认的情况下，可以连续发送多个PDU\n  通用：滑动窗口（slide window）协议\n  发送缓冲区\n 形式：内存中的一个区域，落入缓冲区的分组可以发送 功能：用于存放已发送，但是没有得到确认的分组 必要性：需要重发时可用    发送窗口的移动——前沿移动\n 发送窗口前沿移动的极限：不能超过发送缓冲区      发送窗口的移动——后沿移动\n 条件：收到老分组的确认 结果：发送缓冲区罩住新的分组，来了分组可以发送 移动的极限：不能够超过前沿      发送窗口\n 前沿移动：有新的分组落入发送缓冲区范围，发送 后沿移动：来了老的低序号分组的确认，后沿向前滑动，新的分组可以落入发送缓冲区的范围     接收窗口\n  接收窗口=接收缓冲区\n 只有收到的分组序号落入接收窗口内才允许接收 若序号在接收窗口之外，则丢弃    接收窗口尺寸Wr=1，只能顺序接收\n接收窗口尺寸Wr\u0026gt;1，则可以乱序接受\n  接收窗口的滑动与发送确认\n 滑动：低序号的分组要来，接收窗口移动；高序号分组乱序到，缓存但不交付（rdt不允许失序），不滑动 发送确认：  接收窗口尺寸=1：发送连续收到的最大的分组确认（累计确认） 接收窗口尺寸\u0026gt;1：收到分组，发送哪个分组的确认（非累计确认）            Go-back-N（GBN）协议\n  特点：发送窗口大于1，接收窗口=1（只能顺序接收；发送方设置一个超时定时器，一旦出错，返回到出错的哪一个PDU重发）\n  发送方：\n 分组头部有k比特的序列号，一次发送多个分组 窗口大小为N，发送缓冲区：允许未确认的连续多个分组 ACK(n)：发送端收到确认n，即序号为n之前的所有分组进行确认（累计确认） 只对后沿分组设定时器 timeout(n)：重传发送窗口中所有序号大于等于n的分组  超时只有可能是最老的分组   扩展的FSM：    接收方：\n 只发送ACK：对顺序接收的最高序号的分组  可能会产生重复的ACK 接收窗口=1   对乱序的分组：  丢弃 对顺序接收的最高序号的分组进行确认（累计确认）      运行实例：    选择重传（SR）\n 特点：发送窗口大于1，接收窗口大于1（能够乱序接收；发送方为每个发送出去的PDU；设置超时定时器，哪个超时重发哪个） 发送方：  从上层接收数据：如果下一个可用与该分组的序号可在发送窗口中，则发送 timeout(n)：重新发送分组n，重新设定定时器 ACK(n) in [sendbase, sendbase+N]：将分组n标记为已接收，如果n为最小为确认分组序号，将base移到下一个未确认序号   接收方：  分组n [rcvbase, rcvbase+N-1]  发送ACK(n) 乱序：缓存 顺序正确：该分组及以前缓存的序号连续的分组交付给上层，然后将窗口移到下一个仍未被接收的分组   分组n [rcvbase-N, rcvbase-1]  ACK(n)   其他：  忽略该分组     SR的运行    窗口的最大尺寸（n为序号空间大小，例如：n=2，序列号：0、1、2、3）\n GBN：$2^n-1$ SR：$2^{n-1}$    五、有连接的传输层协议：TCP 1、TCP服务特性  点对点：一个发送方，一个接收方 可靠的、按顺序的字节流：没有报文边界 管道化（流水线）：TCP拥塞控制和流量控制设置窗口大小 发送和接收缓存 全双工数据  在同一连接中数据流双向流动 MSS：最大报文段大小   面向连接：在数据交换之前，通过握手（交换控制报文）初始化发送方、接收方的状态变量 有流量控制：发送方不会淹没接收方  2、TCP段结构  序号：报文段首字节的在字节流的编号（偏移量）32bits 确认号（对顺序收到的最后一个字节+1）32bits：  期望从另一方收到的下一个字节的序号 累计确认   接收窗口：指示接收方愿意接受的字节数量，用于流量控制 16bits 标志字段：  RST、SYN、FIN用于连接建立和拆除 PSH被置位时，指示接收方立即将数据交给上层 URG比特用于指示报文段里存在着被发送端的上层实体置为“紧急”的数据。紧急数据的最后一个字节由16bits的紧急数据指针字段指出     3、RTT时间估计和重发超时时间估计  设置TCP的超时：  比RTT长 太短：太早超时，造成不必要的重发 太长：对报文段丢失的反应太慢，消极   估计RTT：  SampleRTT：测量从报文段发出到确认的时间（若有重传，忽略此次测量） 移动平均计算：对几个最近测量值求平均值 指数加权移动平均：$EstimatedRTT=(1-\\alpha)EstimatedRTT+\\alphaSampleRTT$  过去样本的影响呈指数衰减 推荐值：$\\alpha=0.125$     设置超时：  EstimatedRTT+安全边界时间 当前SampleRTT与EstimatedRTT的偏差：$DevRTT=(1-\\beta)DevRTT+\\beta|SampleRTT-EstimatedRTT|$（推荐值$\\beta=0.25$） 超时时间间隔：$TimeoutInterval=EstimatedRTT+4*DevRTT$    4、TCP的可靠数据传输原理   TCP在IP不可靠服务的基础上建立了rdt\n 管道化的报文段  GBN or SR   累计确认（像GBN） 单个单传定时器（像GBN） 是否可以接受乱序，没有规范    通过以下时间触发重传\n  超时（只重发最老的一个段：SR）\n  重复的确认\n    快速重传：在没有超时的情况下，收到对方对于某一个段的重复三次（一共4个）ACK\n 超时周期往往太长：在重传丢失报文段之前的延时太长 通过重复的ACK来检测报文段丢失  发送方通常连续发送大量的报文段 如果报文段丢失，通常会引起多个重复的ACK   如果发送方收到同一数据的三个冗余ACK，重传最小序号的段  在定时器过时之前重发报文段 它假设跟在被确认的数据后面的数据丢失了  第一个ACK正常 收到第二个该段的ACK，表示接收端收到一个该段后的乱序段 收到第3、4个该段的ACK，表示接收方收到该段之后的2、3个乱序段，段丢失的可能性非常大          5、流量控制   目的：防止淹没接收方\n  方法：将接收窗口大小捎带方式传递给发送端\n  接收方在其向发送方的TCP段头部的rwnd字段通告其空闲buffer大小\n RcvBuffer大小通过socket选项设置（典型默认大小为4096字节） 很多操作系统自动调整RcvBuffer    发送方限制未确认字节个数$\\leq$接收方发送过来的rwnd值\n  缓存中可用的空间\n=RcvWindow\n=RcvBuffer-[LastByteRcvd-LastByteRead]\n    6、连接管理   连接建立：3次握手技术，对双方选择的初始序号给予确认，准备好缓冲区\n  过程：  第一次握手：SYN=1，ACK=0；发起段序号 第二次握手：SYN=1，ACK=1；被呼叫方序号 第三次握手：SYN=0，ACK=1   三次握手FSM    连接拆除：对称\n 客户端，服务器分别关闭自己一侧的连接  发送FIN bit=1的TCP段   一旦接收到FIN，用ACK回应  接到FIN段，ACK可以和它自己发出的FIN段一起发送   可以处理同时的FIN交换    六、拥塞控制原理 1、拥塞的概念及原因   拥塞：太多的数据需要网络传输，超过了网络的处理能力\n  拥塞的表现：\n 分组丢失（路由器缓冲区溢出） 分组经历比较长的延迟（在路由器的队列中排队）    拥塞的原因：\n  场景1\n 假定：  两个发送端，两个接收端 一个路由器，无限大缓冲 输出链路带宽：R 没有重传       场景2\n 假定：  一个路由器，有限的缓冲 分组丢失时，发送端重传  应用层的输入=应用层的输出：$\\lambda_{in}=\\lambda_{out}$ 传输层的输入包括重传：$\\lambda^*{in}\\geq \\lambda{in}$     理想化：发送端有完美的信息  发送端知道什么时候路由器的缓冲可用  只在缓冲可用时发送 不会丢失：$\\lambda^*{in}=\\lambda{in}$      理想化：掌握丢失信息  分组可以丢失，在路由器由于缓冲器满而被丢弃 若知道分组丢失了，发送方重传分组    现实情况：重复  分组可能丢失，由于缓冲器满而被丢弃 发送端最终超时，发送第2个拷贝，2个分组都被传出   拥塞的代价：  为达到一个有效输出，网络需要做更多的工作（重传） 没有必要的重传，链路中包括多个分组的拷贝      场景3\n  假定：\n 4个发送端 多重路径 超时/重传    拥塞的代价\n  当分组丢失时，任何“关于这个分组的上游传输能力”被浪费\n        2、拥塞控制的手段  端到端的拥塞控制  没有来自网络的显式反馈 端系统根据延迟和丢失事件推断是否有拥塞 TCP采用这种方法   网络辅助的拥塞控制  路由器提供给端系统以反馈信息  单个bit置位，显示有拥塞 显式提供发送端可以采用的速率      七、TCP的拥塞控制原理 1、TCP拥塞控制原理   检测拥塞\n 某个段超时了（事件丢失）：拥塞  原因1：网络拥塞（某个路由器缓冲区没空间了，被丢弃）——概率大 原因2：出错被丢弃（未通过校验，被丢弃）——概率小   有关某个段的3次重复ACK：轻微拥塞    速率控制方法\n  维持一个拥塞窗口的值：CongWin\n  发送端限制已发送但是未确认的数据量（的上限）：\nLastByteSent-LastByteAcked$\\leq$ CongWin\n  粗略控制网络速率：\n$$\nrate\\approx\\frac{CongWin}{RTT}byte/sec\n$$\n  CongWin是动态的，是感知到网络拥塞程度的函数：\n 超时或者3个重复ack，CongWin↓  CongWin降为1MSS，进入SS阶段后再倍增到CongWin/2（每个RTT），从而进入CA阶段 CongWin降为CongWin/2（3个重复ACK），CA阶段   正常收到ACK：  SS阶段：加倍增加 CA阶段：线性增加        拥塞控制机制：\n  慢启动\n 连接刚建立时，CongWin=1MSS 当连接开始时，指数性增加发送速率直到丢失事件发生  每一个RTT，CongWin加倍 每收到一个ACK时，CongWin加一 慢启动阶段：只要不超时或3个重复ACK，一个RTT，CongWin加倍   总结：初始速率很慢，但指数级加速，SS时间很短，长期可以忽略    AIMD\n 乘性减：丢失事件后将CongWin降为1，将CongWin/2作为阈值，进入慢启动阶段（倍增至CongWin/2） 加性增：当CongWin\u0026gt;阈值时，一个RTT如果没有发生丢失事件，将CongWin加1MSS 当收到3个重复的ACKs（丢失）：  CongWin减半 窗口（缓冲区大小）之后线性增长   当超时事件发生时：  CongWIn被设置成1MSS，进入SS阶段 窗口指数增长 增长到一个阈值（上次发生拥塞的窗口的一半）时，再线性增加      总结（Reno方法）：\n  当CongWin\u0026lt;Threshold，发送端处于慢启动阶段（slow-start），窗口指数型增长\n  当CongWIn\u0026gt;Threshold，发送端处于拥塞避免阶段（congestion-avoidance），窗口线性增长\n  当收到三个重复的ACKs，Threshold设置成CongWin/2，CongWin=Threshold\n  当超时事件发生时（timeout），Threshold=CongWin/2，CongWin=1MSS，进入SS阶段\n    举例：\n注意： 重复ACK过程中，CongWin和Threshold不变，收到三个重复ACK后，Threshold=CongWin/2，CongWin=Threshold+3MSS\n    2、TCP拥塞控制算法  Tahoe：超时事件和3个冗余ACK处理一样（无快速恢复）  无条件将CongWin减至1   Reno：超时事件和3个冗余ACK处理不一样  超时事件（丢包）：Threshold=CongWin/2，CongWin=1MSS，进入SS阶段 3个冗余ACK：快速重传，Threshold设置成CongWin/2，CongWin=Threshold    3、TCP的吞吐量   设W为发生丢失事件时的窗口尺寸，则平均吞吐量：\n$$\n一条连接的平均吞吐量=\\frac{0.75W}{RTT}\n$$\n  设L为丢包率，则平均吞吐量：\n$$\n一条连接的平均吞吐量=\\frac{1.22\\times MSS}{RTT\\sqrt{L}}\n$$\n  4、TCP的公平性  公平性目标：如果K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为R/K TCP公平的原因：  对于两个竞争的TCP会话：  加性增加，斜率为1，吞吐量增加 乘性减，吞吐量比例减少      第四章 网络层：数据平面 一、简介 1、网络层的主要服务和功能  网络层服务  在发送主机和接受主机之间传送段 在发送端将段封装到数据报中 在接收端，将段上交给传输层实体 网络层协议存在于每一个主机和路由器 路由器检查每一个经过它的IP数据报的头部   网络层功能  转发：将分组从路由器的输入接口转发到合适的输出接口 路由：使用路由算法来决定分组从发送主机到目标接收主机的路径  路由选择算法 路由选择协议      2、实现网络层功能的方式：  传统方式  控制平面和数据平面的功能垂直集成在每个设备上（路由器） 控制平面功能：路由协议实体分布式地计算路由表  本地，每个路由器的功能 决定从路由器输入端口到达的分组如何转发到输出端口 转发功能   数据平面：IP协议按照路由表进行分组的转发  全网范围内的逻辑 决定数据报如何在路由器之间路由，决定数据报从源到目标主机之间地端到端路径     SDN通用转发方式  控制平面和数据平面分离，在不同设备上实现 SDN控制器集中式计算、下发流表实现控制平面地功能 SDN分组交换机按照流表对到来的分组进行转发，实现数据平面的功能    3、网络层提供服务的一些重要指标  带宽 延迟，延迟差 丢包与否，丢包率  二、路由器结构和工作原理 1、路由器的2大功能  路由协议：运行路由选择算法/协议（RIP，OSPF，BGP）——生成路由表 转发分组：从输入到输出链路交换数据报——根据路由表进行分组的转发  2、构成   输入端口：线路终端实现物理层功能、链路协议实体实现链路层功能，网络层功能实现分布式分组转发\n 基于目标的转发：仅仅依赖于IP数据报的目标IP地址 最长前缀匹配：当给定目标地址查找转发表时，采用最长地址前缀的目标地址表项 对于N个输入端口：交换机构的交换速度是输入线路速度的N倍比较理想，才不会成为瓶颈    交换结构\n  通过内存交换\n 在CPU直接控制下的交换，采用传统的计算机 分组被拷贝到系统内存，CPU从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口 转发速率被内存的带宽限制 一次只能转发一个分组    通过总线交换\n 数据报通过共享总线，从输入端口转发到输出端口 总线竞争：交换速度受限于总线带宽 1次处理一个分组 对于接入或企业级路由器，速度足够，但不适合区域或骨干网络    通过互联网络的交换\n 同时并发转发多个分组，克服总线带宽限制 Banyan（榕树）网络，crossbar和其它的互联网络被开发，将多个处理器连接成多处理器 当分组从端口A到达，转给端口Y；控制器短接相应的两个总线 高级设计：将数据报分片为固定长度的信元，通过交换网络交换 能够并行发送多个分组      输出端口\n  实现分组的调度（选择下一个要通过链路传输的分组）\n  FIFO：按照分组到来的次序发送\n 丢弃策略：如果分组到达一个满的队列，丢弃哪个分组  tail drop：丢弃刚刚到达的分组 priority：根据优先权丢失/移除分组 random：随机地丢弃/移除      优先权：发送最高优先权的分组\n 多类，不同类别有不同的优先权  类别可能依赖于标记或其他的头部字段 先传高优先级的队列中的分组，除非没有 高/低优先权中的分组传输次序：FIFO      Round Robin（RR）scheduling\n 多类 循环扫描不同类型的队列，发送完一类的一个分组，再发送下一个类的一个分组，循环所有类    加权队列Weighted Fair Queuing（WFQ）\n 一般化的Round Robin 在一段时间内，每个队列得到的服务时间是：$W_i/(XIGMA(W_i))*t$，与权重成正比 每个类在每一循环中获得不同权重的服务量      输出端口排队\n 设有N个流，链路容量为C，缓存大小等于\n$$\n\\frac{RTT\\times C}{\\sqrt{N}}\n$$      路由处理器：控制各部分的协调工作\n  三、互联网网络层协议 1、IP网络提供的网络模型：尽力而为  含义：丢包、乱序、不可靠、重复  2、网络层构成   路由协议 路由选择协议 ICMP协议\n  转发表\n 获得IP数据报的目标地址 对于转发表中的每一个表项  若(IP Des addr)\u0026amp;(mask)==destination，则按照表项对应的接口转发该数据报 若都没有找到，则使用默认表项转发数据报      3、IP数据报格式  分片和重组  原因：网络链路有MTU（最大传输单元）——链路层帧所携带的最大数据长度  不同的链路类型 不同的MTU   大的IP数据报在网络上被分片（fragmented）  一个数据报被分割成若干个小的数据报  相同的ID 不同的偏移量 最后一个分片标记为0   重组只在最终得目标主机进行 IP头部信息用于标识，排序相关分片   举例    4、IP编址   IP地址：主机或路由器和网络接口得32位标识\n 接口：主机/路由器与网络链路得连接处  路由器通常有多个接口 主机也有可能有多个接口 IP地址和每一个接口关联      一个IP地址和一个接口相关联  子网\n IP地址：子网部分（高位bits），主机部分（低位bits） 在一个子网内得设备之间通信的特点：  通信无需借助路由器 子网前缀一样   要判断一个子网,将每一个接口从主机或者路由器上分开,构成了一个个网络的孤岛，每一个孤岛（网络）都是一个都可以被称之为子网    IP地址分类\n Class A：126 networks，16 million hosts Class B：16382 networks，64K hosts Class C：2 million networks，254 hosts Class D：multicast Class E：reserved for future    特殊的IP地址\n 子网部分：全为0——本网络 主机部分：全为0——本主机 主机部分：全为1——广播地址，这个网络的所有主机 专用IP地址  永远不会被当做公用地址来分配,不会与公用地址重复 路由器不对目标地址是专用地址的分组进行转发 专用地址范围：  Class A 10.0.0.0-10.255.255.255 MASK 255.0.0.0 Class B 172.16.0.0-172.31.255.255 MASK 255.255.0.0 Class C 192.168.0.0-192.168.255.255 MASK 255.255.255.0        子网掩码和CIDR\n 子网掩码  32bits：  1：bit位置表示子网部分 0：bit位置表示主机部分   A，B，C类网络的子网掩码：  A：255.0.0.0 B：255.255.0.0 C：255.255.255.0   另一种表示方法：  /#（/24：表示前面24个bit为子网部分）     CIDR（Classless InterDomain Routing无类域间路由）  子网部分可以在任意位置 分配IP地址块时应以$2^n$为基准分配 地址格式：a.b.c.d/x，其中x是地址中子网号的长度      5、DHCP协议（Dynamic Host Configuration Protocol ）  目的：允许主机在加入网络的时候，动态地从服务器那里获得IP地址 工作概况  主机广播“DHCP discover”报文 DHCP服务器用“DHCP offer”提供报文响应 主机请求IP地址：发送“DHCP request”报文 DHCP服务器发送地址：“DHCP ack”报文   DHCP返回：  IP地址 第一跳路由器地IP地址（默认网关） DNS服务器的域名和IP地址 子网掩码（指示地址部分的网络号和主机号）   实例  6、路由聚集 连续的子网前缀的子网可达信息可以做聚集，减少向外部传输路由的数量，减少路由计算的负担。7、IPv6   IPv6数据报格式\n 头部：  Priority：标示流中数据报的优先级 Flow Label：标示数据报在一个“flow” Next header：标示上层协议   特点：  固定的40字节头部 数据报传输过程中，不允许分片      IPv6的变化\n Checksum：被移除，降低在每一段中的处理速度 Options：允许，但是在头部之外，被“Next Header”字段标示 ICMPv6：ICMP的新版本  附加了报文类型 多播组管理功能      IPv4到IPv6的迁移\n  隧道：在IPv4路由器之间传输的IPv4数据报中携带IPv6数据报\n    四、通用转发和SDN 1、SDN方式控制平面和数据平面分离的优点  集中在控制器上实现控制逻辑，网络可编程，可以实现各种复杂的网络功能、新功能（一次部署，持续升级）、方便管理 形成开发生态（控制器，分组交换机，网络应用，在一个开放的框架下协作） SDN分组交换机按照计算出的流表进行分组转发、通用、便于升级  2、分组交换机的工作原理  模式匹配+行动（转发，组播，修改字段和阻塞等） 进来分组，按照各级字段匹配流表，按照相应的行动动作分组 按照优先权进行判断；之后，统计计数  3、OpenFlow数据平面抽象  流：由分组（帧）头部字段所定义 通用转发：简单的分组处理规则  模式：将分组头部字段和流表进行匹配 行动：对于匹配上的分组，可以是丢弃、转发、修改、将匹配的分组发送给控制器 优先权：几个模式匹配了，优先采用哪个，消除歧义 计数器：#bytes 以及 #packets    第五章 网络层：控制平面 一、概述 1、实现控制平面的方法  每个路由器控制功能实现（传统方法） 逻辑上集中的控制功能实现（SDN）  2、传统方式 在每个路由器中的单独路由器算法元件，在控制平面进行交互3、SDN方式 一个不同的（通常是远程的）控制器与本地控制代理（CAs）交互二、路由选择算法 1、路由协议的目标 根据收集到的路由信息（拓扑、链路代价等），计算出源到目标较好的路径，代价比较低的路径\n 主机-主机的路径==路由器-路由器的路径 路由的目的实际上是计算出节点的汇集树 路由原则：完整正确，简单，健壮，稳定公平，最优  2、路由分类  静态和动态  静态：路由随时间变化缓慢 动态：路由变化很快（周期性更新、根据链路代价的变化而变化）   全局和局部  全局：所有的路由器拥有完整的拓扑和边的代价信息（link state 算法） 分布式：路由器只知道与它有物理连接关系的邻居路由器，和到相应邻居路由器的代价值，迭代的与邻居交换路由信息、计算路由信息（distance vector 算法）    3、LS算法（全局的路由选择算法）   配置LS路由选择算法的路由工作过程\n 各点通过各种渠道获得整个网络拓扑，网络中所有链路代价等信息 使用LS路由算法，计算本站点到其他站点的最优路径，得到路由表 按照该路由表转发分组    LS路由的基本工作原理\n  发现相邻节点，获知对方网络地址\n 一个路由器上电之后，向所有线路发送HELLO分组 其他路由器收到HELLO分组，回送应答，在应答分组中，告知自己的名字 在LAN中，通过广播HELLO分组，获得其他路由器的信息    测量到相邻节点的代价（延迟、开销）\n 实测法：发送一个分组要求对方立即响应 回送一个ECHO分组 通过测量时间可以估算出延迟情况    组装一个LS分组，描述它到相邻节点的代价情况\n 发送者名称 序号，年龄 列表：给出它相邻的节点，和它到相邻节点的延迟    将分组通过扩散的方法发到所有其他路由器\n 顺序号：用于控制无穷的扩散，每个路由器都记录源路由器和顺序号，发现重复的或老的就不扩散    通过Dijkstra算法找出最短路径（路由算法）\n 初始化  除了源节点，所有节点都为临时节点（未找到从源节点到此节点的最优路径的节点） 节点代价除了与源节点代价相邻的节点外，都为∞   从所有临时节点中找到一个节点代价最小的临时节点，将之变为永久节点（当前节点）W 对此节点的所有在临时节点集合中的邻节点（V）  如D(v)\u0026gt;D(w)+c(w,v)，则重新标注此点，(D(w)+c(w,v),w) 否则，不重新标注   开始一个新的循环      Dijkstra算法举例：\n       Dijkstra算法的讨论\n 算法复杂度：n节点  每一次迭代：需要检查所有不在永久集合N中的节点 n(n+1)/2次比较：O($n^2$) 有效实现：O(nlogn)   可能的震荡    4、DV算法（局部的路由选择算法）   基本思想\n 各路由器维护一张路由表   各路由器与相邻路由器交换路由表 根据获得的路由信息，更新路由表    代价及相邻节点间代价的获得：\n 跳数、延迟、队列长度 相邻节点间代价的获得：实测    路由信息的更新：\n 根据实测得到本节点到相邻站点的代价（如延迟） 根据各相邻站点声称它们到目标站点的代价 计算出本站点经过各相邻站点到目标站点的代价    找到一个最小的代价，和相应的下一个节点\n  水平分裂算法\n  目的：解决无穷计算问题（当源节点作为下一跳到目的节点的中间节点时会出现循环）\n  举例：C知道要经过B才能到达A，所以C向B报告它到A的距离为INF；C告诉D它到A的真实距离\n  特例：\n    距离矢量算法\n  $D_x(y)=节点x到y的代价最小值$\n x节点维护距离矢量$D_x=[D_x(y)|y\\in N]$    节点x：\n 知道到所有邻居v的代价：$c(x,v)$ 维护一个它的邻居的距离矢量集，对于每个邻居，x维护$D_v=[D_v(y)|y\\in N]$    每个节点定时或DV有变化时，将自己的距离矢量估计值传送给邻居，邻居收到DV时更新自己的距离矢量\n  Bellman-Ford方程\n$$\nD_x(y)=min_v{c(x,v)+D_v(y)}对于每个节点y\\in N\n$$\n$D_x(y)$：x往y的代价\n$c(x,v)$：x到邻居v的代价\n$D_v(y)$：v声称到y的代价\n  $D_x(y)$估计值最终收敛于实际的最小代价值$d_x(y)$\n    举例：\n  迭代方式\n 异步式：被以下事件触发  本地链路代价发生变化 从邻居来了DV的更新消息   分布式：  每个节点只是在自己的DV改变后向邻居通告        链路代价变化\n 节点检测到本地链路发生变化 更新路由信息，重新计算DV 若DV发生变化，通告其邻居 毒性逆转：  若Z需要通过Y才能路由到X：Z告诉Y，Z到X的距离无穷大（因此Y不会经过Z路由到X）      4、LS和DV算法的比较  消息复杂度（DV胜出）  LS：有n个节点，E条链路，发送报文O(nE)个  局部的路由信息，全局传播   DV：只和邻居交换信息  全局的路由信息，局部传播     收敛时间（LS胜出）  LS：O($n^2$) DV：收敛较慢  可能存在路由环路 无穷计算问题     健壮性（LS胜出）  LS：  节点会通告不正确的链路代价 每个节点只计算自己的路由表 错误信息影响较小，局部，路由较健壮   DV：  DV节点可能通告对全网所有节点的不正确路径代价 每一个节点的路由表可能被其他节点使用      5、层次路由  一个平面解决路由的问题：计算、运输和存储路由信息的量太大，不具备可扩展性，也不满足不同网络运营方不同的管理需求 分成AS，AS内部之间的节点路由有内部网关协议解决；AS之间的路由，分层解决（路由到网关，由网关路由到目标网关，到了目标AS内部，采用AS内部的路由解决） 优势：分层路由，解决了规模性问题，管理性问题  三、互联网络的路由协议 1、内部网关协议IGP   RIP\n 特点：  DV：在邻居之间每30秒交换通告报文  定期，且在改变路由的时候发送通告报文 在对方请求下可以发送通告报文   每一个通告至多AS内部的25个目标网络的DV（25个子网，最大跳数为16）   链路失效与恢复（若180秒没有收到通告信息——邻居或链路失效）  发现经过这个邻居的路由已失效 新的通告报文会传递给邻居 邻居因此发出新的通告 链路失效在全网中传播 使用毒性逆转阻止ping-pong回路（不可达距离：跳数无限=16段）   进程处理  RIP以应用进程的方式实现 通告报文通过UDP报文传送，周期性重复 网络层的协议使用了传输层的服务，以应用层实体的方式实现      OSPF\n  使用LS算法\n  OSPF通告信息中携带L每一个邻居路由器的一个表项\n  通告信息会传遍AS全部（通过泛洪）\n 在IP数据报上直接传送OSPF报文（而不是通过UDP和TCP）    高级特性：\n 安全 允许有多个代价相同的路径存在（RIP协议中只有一个） 对每一个链路，对于不同的TOS有多重代价矩阵 对单播和多播的集成支持 在大型网络中支持层次性OSPF    层次性的OSPF路由\n  两个级别的层次性：本地，骨干\n 链路状态通告仅仅在本地区域范围内进行 每一个节点拥有本地区域的拓扑信息    区域边界路由器（area border router）：汇总到自己区域内网络的距离，向其他区域边界路由器通告\n  骨干路由器（backbone router）：仅仅在骨干区域内，运行OSPF路由\n  边界路由器（boundary router）：连接其他AS‘s\n      IGRP\n  2、外部网关协议EGP   BGP\n  简介\n 网关路由器参与AS内部路由计算，收集AS内部子网可达信息 网关路由器通过AS间路由向其他AS网关通告子网可达信息 网关路由器可转发“过手”子网可达信息，但AS路径要加上自己AS编号（防止形成回路） 网关路由器通过iBGP向AS内部所有路由通告收集到的子网可达信息 网关路由器通过eBGP从相邻的区域获得子网的可达信息 内部路由器，通过AS内路由和AS间路由共同决定向AS外部子网的下一跳（内部网关协议决定如何往网关，外部网关协议决定通过哪个网关可到达AS外部子网）    eBGP，iBGP连接\n  BGP会话\n  2个BGP路由器在一个半永久的TCP连接上交换BGP报文，通告向不同目标子网前缀的“路径”\n  举例：\n    路径的属性\n AS-PATH：前缀的通告所经过的AS列表  检测环路：多路径选择 在向其他AS转发时，需要将自己的AS号加在路径上   NEXT-HOP：从当前AS到下一跳有多个链路，在NEXT-HOP属性中，告诉对方通过哪个转发 其他属性：路由偏好指标，如何被插入的属性    BGP路由\n 基于策略的路由：  当一个网关路由器接收到了一个路由通告，使用输入策略来接受或过滤 策略决定了是否向它的别的邻居通告收到的这个路由信息      BGP路径通告\n      BGP报文\n 使用TCP协议交换BGP报文 BGP报文：  OPEN：打开TCP连接，认证发送方 UPDATE：通告新路径（或撤销原路径） KEEPALIVE：在没有更新时保持连接，也用于对OPEN请求确认 NOTIFICATION：报告以前消息的错误，也用来关闭连接      BGP路径选择\n 本地偏好值属性：偏好策略决定 最短AS-PATH：AS的跳数 最近的NEXT-HOP路由器：热土豆路由 附加的判据：使用BGP标示      3、内部网关协议和外部网关协议的对比  策略  Inter-AS：管理员需要控制通信路径，谁在使用它的网络进行数据传输 Intra-AS：一个管理者，无需策略  AS内部的各子网的主机尽可能地利用资源进行快速路由     规模  Inter-AS：路由必须考虑规模问题，以便支持全网的数据转发 Intra-AS：路由规模不是一个大的问题  若AS太大，可将AS分成小的AS；规模可控 AS之间只不过多了一个点而已 又或AS内部路由支持层次性，层次性路由节约表空间，降低了更新的数据流量     性能  Intra-AS：关注性能 Inter-AS：策略可能比性能更重要    四、SDN控制平面 1、优势  网络管理更加容易：避免路由器的错误配置，对于通信流的弹性更好 基于流表的转发，集中计算流表然后分发 控制平面的开放实现  2、SDN控制器  维护网络状态信息 通过上面的北向API和网络控制应用交互 通过下面的南向API（openflow）和网络交换机交互（下发流表，上报设备状态） 逻辑上集中，但是在实现上通常由于性能、可扩展性、容错性以及鲁棒性采用分布式方法  3、OpenFlow协议  控制器和SDN交互的协议 采用YCP来交换报文  加密可选   3种OpenFlow报文类型  控制器\u0026gt;交换机  特性：控制器查询交换机特性，交换机应答 配置：交换机查询/设置交换机的配置参数 修改状态:增加删除修改OpenFlow表中的流表 packet-out：控制器可以将分组通过特定的端口发出   异步（交换机\u0026gt;控制器）  分组进入：将分组传给控制器 流移除：在交换机上删除流表项 端口状态:通告控制器端口的变化   对称    五、ICMP协议 1、作用  错误报告：主机不可达、网络、端口、协议 Echo请求和回复（ping）  2、报文类型  ICMP处在网络层，但在IP协议上面  ICMP消息由IP数据报承载   ICMP报文  类型 编码 加上IP数据报的头8B    3、举例：Traceroute and ICMP 第六章 数据链路层与局域网 一、引论 1、链路层提供的服务  成帧，链路存取控制（链路访问控制）  将数据报封装在帧中，加上帧头、帧尾部 若采用共享性介质，信道接入获得信道访问权 在帧头部使用MAC地址来标示源和目的   在相邻节点完成可靠数据传递  在低出错率的链路上（光纤和双绞线电缆）很少使用 在无线链路经常使用：出错率高   流量控制  使得相邻的发送和接收方节点的速度匹配   错误检测  差错由信号衰减和噪声引起 接收方检测出错误：  通知发送端进行重传或丢弃帧     差错纠正  接收端检查和纠正bit错误，不通过重传来纠正错误   全双工和半双工服务  半双工：链路可以双向传输，但一次只有一个方向    2、链路层网络节点的连接方式  点到点方式：适合广域 多点连接的方式：比较适合局域、联网方便，但需要解决MAC问题  3、链路层实现位置  在每一个主机上  路由器 交换机的每一个端口   链路层的功能在适配器上实现  以太网卡 实现链路层和相应的物理层功能   接到主机的系统总线上 硬件、软件和固件的综合体  4、适配器通信  发送方  在帧中封装数据报 加上差错控制编码，实现RDT和流量控制功能   接收方  检查有无出错，执行rdt和流量控制功能等 解封装数据报，将至交给上层    5、数据链路层和局域网  WAN：网络形式采用点到点链路  带宽大、距离远（延迟大） 若采用多点连接方式：  竞争方式：一旦冲突代价大 令牌等协调方式：在其中协调节点的发送代价大     LAN：一般采用多点连接方式  连接节点非常方便 接到共享型介质上（或网络交换机），就可以连接所有其它节点    二、检错与纠错 1、检错原理   奇偶校验（发送方附加一个bit，选择它的值，偶校验：使得所有比特中1的总数为偶数；奇校验：使得所有比特中1的总数为奇数）\n  单bit奇偶校验：检测单个bit级错误\n  2维奇偶校验：检测和纠正单个bit错误\n    循环冗余校验CRC\n 将数据比特D看成二进制的数据 生成多项式G：双方协商的r+1位模式（r次方）  生成和检查所使用的位模式   目标：选择r位CRC附加位R，使得  \u0026lt;D, R\u0026gt;正好被G整除（modulo 2） 接收方知道G，将\u0026lt;D, R\u0026gt;除以G，若非0余数，则检查出错误 能检查出所有少于r+1位的突发错误（适当假设下，长度大于r+1比特的突发差错以概率$1-0.5^r$被检测到）   举例：    三、多路访问协议 1、多路访问协议的必要性  分布式算法决定节点如何使用共享信道 关于共享控制的通信必须用借助信道本身传输  没有带外的信道，各节点使用其协调信道使用 用于传输控制信息    2、媒体访问控制（MAC）协议 （1）信道划分  TDMA  轮流使用信道，信道的时间分为周期 每个站点使用每周期中固定的时隙（长度=帧传输时间）传输帧 若站点无帧传输，时隙空闲——浪费   FDMA  信道的有效频率范围被分成一个个小的频段 每个站点被分配一个固定的频段 分配给站点的频段如果没有被使用，则空闲   CDMA  所有站点在整个频段上同时传输，采用编码原理加以区分 完全无冲突 假定：信号同步好，线性叠加    （2）RAP：随机访问协议   时隙ALOHA 假设  所有帧等长 时间被划分为相等的时隙，每个时隙可以发送一帧 节点只在时隙开始时发送帧 节点在时钟上是同步的 如果两个或多个节点在一个时隙传输，所有的站点都能检测到冲突   运行  当节点获取新的帧，在下一个时隙传输 传输时没有检测到冲突，成功  节点能够在下一时隙发送新帧   检测时如果检测到冲突，失败  节点在每一个随后的时隙以概率p重传帧直到成功     优点  节点可以以信道带宽全速连续传输 高度分布：仅需要节点之间在时隙上的同步 简单   缺点  存在冲突，浪费时隙 即使有帧要发送，仍然也可能存在空闲的时隙 节点检测冲突的时间\u0026lt;帧传输的时间  必须完成   需要时钟上同步   效率  假设有N个节点，每个节点都有很多帧要发送，在每个时隙中传输概率为p 一个节点成功传输概率为$p(1-p)^{N-1}$ 信道上，任何一个节点的成功概率是$Np(1-p)^{N-1}$ N为无穷大时的极限为1/e=0.37  最好情况：信道利用率为37%        纯ALOHA  简单、无须节点之间在时间上同步\n  当有帧需要传输：马上传输\n  冲突的概率增加：\n 帧在$t_0$发送，和其他在$[t_0-1,\\ t_0+1]$区间内开始发送的帧冲突 和当前帧冲突的区间增大了一倍    纯ALOHA的效率：\n    CSMA（载波侦听多路访问）\n 基本思想：在传输前先侦听信道  如果侦听到信道空闲，传送整个帧 如果侦听到信道忙，推迟传送   CSMA冲突原因：传播延迟。两个节点可能侦听不到正在进行的传输    CSMA/CD（冲突检测）\n  CSMA/CD：\n 载波侦听CSMA：和在CSMA中一样发送前侦听信道 没有传完一个帧就可以在短时间内检测到冲突 冲突发生时则传输终止，减少对信道的浪费    冲突检测技术：\n 有线局域网中容易实现：  检测信号强度，比较传输与接收到的信号是否相同 通过周期的过零点检测   无线信道：在传输时接收是关闭的  本站点发送的信号强度远远大于来自其他节点的信号强度 本站点周边信号有冲突，不意味着接收节点处有冲突 无法一边发送一边进行冲突检测      以太网CSMA/CD算法\na. 适配器获取数据报，创建帧\nb. 发送前：侦听信道CS\n 闲：开始传送帧 忙：一直等到闲再发送  c. 发送过程中，冲突检测CD\n 没有冲突：成功 检测到冲突：放弃，之后尝试重发  d. 发送方适配器检测到冲突，除放弃外，发送一个Jam信号，所有听到冲突的适配器也是如此（强化冲突：让所有站点都知道冲突）\ne. 如果放弃，适配器进入指数退避状态：在第m次失败后，适配器随机选择一个${0,1,2,\\ \u0026hellip;\\ ,2^{m-1}}$中K，等待K*512位时（512位时，对于100Mbps来说，即5.12ms），然后转至b\n  CSMA/CD效率\n$t_{prop}$=LAN上2个节点的最大传播延迟\n$t_{trans}$=传输最大帧的时间\n$$\nefficiency=\\frac{1}{1+5t_{prop}/t_{trans}}\n$$\n当效率变为1\n 当$t_{prop}$变成0时 当$t_{trans}$变成无穷大时      CSMA/CA（冲突避免，IEEE802.11 MAC协议）\n 发送方：  若站点侦测到信道空闲持续DIFS长，则传输整个帧 若检测到信道忙碌，则选择一个随机回退值，并在信道空闲时递减该值；若信道忙碌，回退值不会变化 到数到0时，发送整个帧 若没有收到ACK，增加回退值，重复等待   接收方  若帧正确，则在SIFS后发送ACK   冲突原因：  两个站点相互隐藏 选择非常靠近的随机回退值   RTS-CTS交换  思想：允许发送方“预约”信道，而不是随机访问该信道（避免长数据帧的冲突 ） 发送方首先使用CSMA向BS发送一个小的RTS分组  RTS可能会冲突（但是由于比较短，浪费信道比较少）   BS广播 clear-to-send CTS，作为RTS的响应 CTS能够被所有涉及到的节点听到  发送方发送数据帧 其它节点抑制发送         （3）轮流MAC协议   轮询\n 主节点邀请从节点依次传送 缺点：  轮询开销：轮询本身消耗信道带宽 等待时间：每个节点需要等到主节点轮询后开始传输，即使只有一个节点，也需要等到轮询一周后才能发送 单点故障：主节点失效时造成整个系统无法工作      令牌传递\n 控制令牌循环从一个节点到下一个节点传递 令牌报文：特殊的帧 缺点：  令牌开销：本身消耗带宽 延迟：只有等到抓住令牌，才可传输 单点故障：  令牌丢失系统级故障，整个系统无法传输 复杂机制重新生成令牌        四、链路层编地址 1、MAC地址  作用：用于使帧从一个网卡传递到与其物理连接的另一个网卡（同一物理网络中） 格式：48bit（e.g.：1A-2F-BB-76-09-AD ） 分配：链理论上全球任何两个网卡的MAC地址都不相同  2、MAC地址与网络层IP地址的区别  格式  32bit IP地址  网络层地址 用于使数据报到达目的IP子网：前n-1跳 从而到达子网中的目标节点：最后一跳   LAN（MAC/物理/以太网）地址  用于使帧从一个网卡传递到与其物理连接的另一个网卡\n(在同一个物理网络中) 48bit MAC地址固化在适配器的ROM，有时也可以通\n过软件设定 理论上全球任何2个网卡的MAC地址都不相同     作用  IP地址：分层  一个子网的所有站点网络号一致，路由聚集，减少路由表，便于计算路由 网络层地址是配置的：IP地址完成网络到网络的交付   MAC地址：平面  网卡的唯一标示，用于区分一个网络内部不同的网卡即可 可以完成一个物理网络内部的节点到节点的数据交付      3、ARP协议   目的：完成物理网络范围内IP地址到MAC地址的转换\n  ARP表：包括一些LAN节点IP/MAC地址的映射\n  工作原理：\n 广播查询 单播应答    在同一LAN网络内的ARP协议\n A要发送帧给B（B的IP地址已知），但B的MAC地址不在A的ARP表中 A广播包含B的IP地址的ARP查询包（广播查询）  LAN上的所有节点都会收到该查询包   B接收到ARP包，回复A自己的MAC地址  帧发送给A 用A的MAC地址（单播应答）   A在自己的ARP表中，缓存IP-to-MAC地址映射关系，直到信息超时  软状态：靠定期刷新维持的系统状态 定期刷新周期之间维护的状态信息可能和原有系统不一样      路由到其他LAN的ARP协议\n  假定发送数据报：由A通过R到B，假设A知道B的IP地址\n  在R上有两个ARP表，分别对应两个LAN\n在源主机的路由表中，发现到目标主机的下一跳时111.111.111.110\n在源主机的ARP表中，发现其MAC地址是E6-E9-00-17-BB-4B，etc\n  A创建数据报，源IP地址：A；目标IP地址：B\n  A创建一个链路层的帧，目标MAC地址是R，该帧包含A到B的IP数据报\n  帧从A发送到R\n  帧被R接收到，从中提取出IP分组，交给上层IP协议实体\n  R转发数据报，数据报源IP地址为A，目标IP地址为B\n  R创建一个链路层帧，目标MAC地址为B，帧中包含A到B的IP数据报    五、以太网络 1、IEEE802.3标准：链路和物理层  相同的MAC协议（介质访问控制协议）和帧结构 不同的速率：2Mbps、10Mbps、100Mbps、1Gbps、10Gbps 不同的物理层标准 不同的物理层媒介：光纤，同轴电缆和双绞线  2、以太网络的帧结构  前导码（preamble）  7B 10101010 + 1B 10101011 用来同步接收方和发送方的时钟速率  使得接收方将自己的时钟调到发送端的时钟 从而可以按照发送端的时钟来接收所发送的帧     地址（dest/source address）：6字节源MAC地址，目标MAC地址 类型（type）：指出高层协议 CRC：在接收方校验（未通过校验则丢弃错误帧）  3、向上提供服务的特点  无连接：帧传输前，发送方和接收方之间没有握手 不可靠：接收方适配器不发送ACKs或NAKs给发送方  递交给网络层的数据报流可能有gap 如上层使用像运输层TCP协议的rdt，gap会被补上 否则，应用层就会看到gap    4、访问控制技术  CSMA/CD 指数后退  5、编码   Manchester编码\n 在10BaseT中使用 每一个bit的位时中间有一个信号跳变 允许在接收方和发送方节点之间进行时钟同步 10Mbps，使用20M带宽，效率50%    六、HUB和交换机 1、集线器（Hub）  本质上为物理层的中继器：  从一个端口收，转发到所有其他端口 速率一致 没有帧的缓存 在hub端口上没有CSMA/CD机制：适配器检测冲突 提供网络管理功能   所有以hub连在一起的站点处于同一网段（可以允许一个站点发送的网络范围），处在一个碰撞域  骨干hub将所有网段连在一起   通过hub可扩展节点之间的最大距离 通过hub，不能将10BaseT和100BaseT的网络连接在一起  2、交换机  工作原理  选择性转发  对到来的帧，检查帧头，根据目标MAC地址进行选择性转发   自学习  无需配置，即插即用 当接收到帧时，交换机学习到发送站点所在的端口 记录发送方MAC地址/进入端口映射关系，在交换表中   流量隔离  透明，主机对交换机的存在可以不关心 通过交换机相联的各节点就像直接相联一样 有MAC地址，无IP地址   专用接入  当帧需要向某个网段进行转发，需要使用CSMA/CD进行接入控制 通常一个交换机端口一个独立网段      3、路由器和交换机的区别  都是存储转发设备，但层次不同  交换机：链路层设备（检查链路层头部） 路由器：网络层设备（检查网络层头部）   都有转发表  交换机：维护交换表，按MAC地址转发  执行过滤、自学习和生成树算法 即插即用；二层设备，速率高 执行生成树算法，限制广播帧的转发 ARP表项随着站点数量增多而增多   路由器：维护路由表，执行路由算法  路由算法能够避免环路，无需执行生成树算法，可以以各种拓扑构建网络 对广播分组做限制 不是即插即用的，配置网络地址（子网前缀） 三层设备，速率低      第七章 网络安全 一、网络安全的含义 1、网络安全的含义  机密性：只有发送方和预订的接收方能够理解传输的报文内容  发送方加密报文 接收方解密报文   可认证性：发送方和接收方需要确认对方的身份 报文完整性：发送方、接收方需要确认报文在传输的过程中或者时候没有被改变 访问控制和服务可用性：服务可以接入以及对用户而言是可用的  2、网络安全威胁  截获：截获报文 插入：在连接上插入报文 伪装：可以在分组的源地址写上伪装的地址 劫持：将发送方或者接收方踢出，接管连接 拒绝服务（DOS）：阻止服务被其他正常用户使用  二、加密原理 1、加密技术   对称加密：发送方和接收方的密钥相同\n  替换（如单码替换密码：将一个字母替换成另外一个字母）\n  DES\n  US加密标准\n  56-bit对称密钥，64-bit明文输入\n  初始替换\n16轮一样的函数应用，每一轮使用不同的48bit密钥\n最终替换\n    AES\n 数据128bit成组加密 128，192或256 bit keys      公开密钥加密\n  RSA\n  要求：\n 需要$K^+_B(\\cdot)$和$K^-_B(\\cdot)$，满足$K^-_B(K^+_B(m))=m$ 给定一个公钥$K_B^+$推出私钥$K^-_B$计算上不可行    选择密钥\n1）选择2个很大的质数$p$，$q$（e.g., 1024 bits each）\n2）计算$n=pq$，$z=(p-1)(q-1)$\n3）选择一个$e$（要求$e\u0026lt;n$）和$z$没有一个公共因子，互素\n4）选择$d$使得$ed-1$正好能够被$z$整除即$ed\\ mod\\ z=1$\n5）公钥$K^+_B=(n,e)$，私钥$K^-_B=(n,d)$\n  加密\n公钥$K^+_B=(n,e)$，加密一个bit模式，m，如此计算：\n$c=m^e\\ mod\\ n$ （i.e., $m^e$除以$n$的余数）\n  解密\n私钥$K^-_B=(n,d)$，对接收到的密文$c$解密，如此计算：\n$m=c^d\\ mod\\ n$（i.e., $c^e$除以$n$的余数）\n  例子  特点\n $m=(m^e\\ mod\\ n)^d\\ mod\\ n$ 数论定理：若$p$，$q$都是素数，$n=pq$，那么：$x^y\\ mod\\ n=x^{y\\ mod\\ (p-1)(q-1)}\\ mod\\ n$ 公钥私钥可交换：$K^-_B(K^+_B(m))=m=K^+_B(K^-_B(m))$        三、认证原理 1、目的  证明身份  2、使用对称加密技术进行认证的工作原理  传送密码来认证  重放攻击：事先记录发送方的分组，事后向接收方重放   传送加密后的密码来认证  重放依然有效   接收方发送给发送方一个nonce，R，发送方必须返回加密之后的R，使用双方约定好的key（证明发送方的活跃性）  3、使用公开密钥加密体系进行认证的工作原理  使用nonce，公开密钥加密技术，$R=K^+_B(K^-_B(R))$  中间攻击    四、报文完整性 1、目的  可鉴别性 不可伪造性 不可抵赖性  2、手段：数字签名  Bob使用他自己的私钥对$m$进行签署，创建数字签名$K^-_B(m)$ 假设Alice收到报文$m$，以及数字签名$K^-_B(m)$ Alice使用Bob的公钥$K_B^+$对$K_B^-(m)$进行验证，判断$K^+_B(K^-_B(m))=m$是否成立 若$K^+_B(K^-_B(m))=m$成立，则签署该文件的人一定拥有Bob的私钥  3、报文摘要   原理：对$m$使用散列函数$H$，获得固定长度的报文摘要$H(m)$\n 散列函数的特性：  多对1 结果固定长度 给定一个报文摘要$x$，反向计算出原报文在计算上是不可行的$x=H(m)$      散列函数算法\n MD5散列函数  4个步骤计算出128-bit的报文摘要 给定一个任意的128-bit串x，很难构造出一个报文m具有相同的摘要x   SHA-1  US标准 160-bit报文摘要      四、改进 加密报文摘要\n五、密钥分发和证书 1、KDC工作原理  KDC在实体之间扮演可信赖中介的角色 服务器和每一个注册用户都分享一个对称式的密钥 Alice，Bob在和KDC通信的时候，知道他们自己的对称式密钥$K_{A-KDC}$和$K_{B-KDC}$ 通信前使用R1作为对称式的会话密钥  2、CA工作原理   CA将每一个注册实体E和他的公钥捆绑\n  E到CA那里注册他的公钥\n E提供给CA自己的身份证据 CA创建一个证书，捆绑了实体信息和他的公钥 Certificate包括了E的公钥，而且是被CA签署的（被CA用自己的私钥加了密）    当Alice需要拿到Bob的公钥\n 获得Bob的证书certificate（从Bob或其他地方） 对Bob的证书，使用CA的公钥来验证    证书结构：  信任树\n 根证书：根证书是未被签名的公钥证书或自签名的证书  拿到一些CA的公钥 渠道：安装OS自带的数字证书；从网上下载你信任的数字证书   信任树  信任根证书CA颁发的证书，拿到了根CA的公钥 由根CA签署的给一些机构的数字证书，包含了这些机构的数字证书      6、防火墙和IDS  作用  阻止拒绝服务攻击  SYN flooding（泛洪）：攻击者建立很多weizaoTCP链接，对于真正用户而言已经没有资源留下了   阻止非法的修改/对非授权内容的访问  e.g., 攻击者替换掉CIA的主页   只允许认证的用户能否访问内部网络资源（经过认证的用户/主机集合）   类型  网络级别：分组过滤器  内部网络通过配置防火墙的路由器连接到互联网上 路由器对分组逐个过滤，根据以下规则来决定转发还是丢弃：  源IP地址，目标IP地址 TCP/UDP源和目标端口 ICMP报文类别 TCP SYN和ACK bits     应用级别：应用程序网关  根据应用数据的内容来过滤进出的数据报 举例：允许内部用户登录到外部服务器，但不是直接登录  需要所有的telnet用户通过网关来telnet 对于认证用户而言，网关建立和目标主机的telnet connect，网关在2个连接上进行中继 路由器过滤器对所有不是来自网关的telnet的分组全部过滤掉       IDS：入侵检测系统  深入分组的检查：检查分组的内容（特征串、已知攻击数据库的病毒和攻击串等） 检查分组间的相关性，判断是否为有害的分组  端口扫描 网络映射 DoS攻击      7、多层次的安全   安全电子邮件\n1）Alice需要发送机密的报文m给Bob\n Alice：  产生随机的对称密钥，$K_S$ 使用$K_S$对报文加密 对$K_S$使用Bob的公钥进行加密 发送$K_S(m)$和$K_B(K_S)$给Bob   Bob：  使用自己的私钥解密$K_S$ 使用$K_S$解密$K_S(m)$得到报文    2）Alice需要提供源端的可认证性和报文完整性 Alice数字签署文件 发送报文（明文）和数字签名  3）Alice需要提供机密性，源端可认证性和报文的完整性\n Alice使用了3个keys：自己的私钥，Bob的公钥，新产生的对称式密钥    日常应用：连接到互联网 总结附录 一、常用缩写  P2P：Peer to peer点对点协议 TCP：Transmission Control Protocol传输控制协议 UDP：User Datagram Protocol用户数据报协议 FDM：Frequency division multiplexing频分 TDM：Time division multiplexing时分 WDM：Wave division multiplexing波分 VC：virtual circuit虚电路 DSL：digital subscriber line数字用户线路 HFC：Hybird fiber coax混合光纤同轴网络 TP：双绞线 ISP：Internet Sevice Providers网络服务提供商 SAP：Services Access Point服务访问点 HTTP：Hyper Text Transfer Protocol超文本传输协议 RTT：round-trip time往返时间 SMTP：Simple Mail Transfer Protocol简单邮件传输协议 MIME：multimedia mail extension多媒体邮件扩展 POP：Post Office Protocol邮局访问协议 IMAP：Internet Mail Access Protocol 邮件访问协议 DNS：Domain Name System域名系统 TLD：Top Level Domain顶级域 RR：Resource Records资源记录 DASH：Dynamic，Adaptive Streaming over HTTP CDN：Content Distribution Networks内容分发网络 SDN：Software Defined Networking软件定义网络 RDT：Reliable data transfering可靠数据传输 SR：Selective Repeat选择重传 GBN：Go Back N 回退N步 MSS：Maximum Segment Size最大报文段大小 RR：Round Robin轮询 WFQ：Weighted Fair Queuing加权队列 IP：Internet Protocol网络协议 DHCP：Dynamic Host Configuration Protocol动态主机配置协议 NAT：Network Address Translation网络地址转换 LS：Link State链路状态 DV：distance vector距离向量 RIP：Routing Information Protocol路由信息协议 OSPF：Open Shortest Path First开放的最短路径优先 AS：autonomous systems自治系统 BGP：Border Gateway Protocol边界网关协议 eBGP：External Border Gateway Protocol外部边界网关协议 iBGP：internal Border Gateway Protocol内部边界网关协议 ICMP：Internet Control Message Protocol网络控制报文协议 SNMP：Simple Networks Management Protocol简单网络管理协议 CRC：Cyclic Redundancy Check循环冗余校验 MAC：Media Access Control媒体访问控制 TDMA：Time Division Multiple Access时分多路访问 FDMA：Frequency Division Multiple Access频分多路访问 CDMA：Code Division Multiple Access码分多路访问 CSMA：Carrier Sense Multiple Access载波侦听多路访问 CD：Collision Detection冲突检测 CA：Collision Avoidance冲突避免 DOCSIS：Data Over Cable Service Interface Spec有线电缆数据服务接口规范 ARP：Address Resolution Protocol地址解析协议 DES：Data Encryption Standard数据加密规范 AES：Advanced Encryption Standard先进加密规范 KDC：Key Distribution Center密钥分发中心 CA：Certification Authority证书认证 IDS：Intrusion Detection System入侵检测系统 DoS：Denial of Service拒绝服务 CIDR：Classless Inter Domain Routing无类域间路由 AIMD：Additive Increase Multiplicative Decrease和式增乘式减 SYN：Synchronize Sequence Number同步序列编号 FTTH：Fiber to The Home 光纤到户 AON：Active Optical Network 主动光纤网络 PON：Passive Optical Network 被动光纤网络 SSL：Secure Sockets Layer 安全套接层 PDU：Protocol Data Unit 协议数据单元 MTU：Maximum Transmission Unit 最大传输单元  二、易错点总结   常用接入技术：DSL、FTTH、Ethernet 、WiFi、3G、LTE\n  1Byte=8bits\n1MB=1024KB=1024x1024B=1024x1024x8bits\nByte：字节\nbit：位、比特\n  节点延迟的计算：\n$$\nd_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}\n$$\n $d_{proc}$=处理延时，通常是微秒数量级或更少（固定） $d_{queue}$=排队延时，取决于拥塞程度（变化） $d_{trans}$=传输延时=分组长度/链路宽度=L/R，对低速率的链路而言很大，通常为微秒级到毫秒级（固定） $d_{prop}$=传播延时=物理链路长度/在媒体上的传播速度=d/s，几微秒到几百毫秒（固定） 带宽-时延积：$R\\cdot t_{prop}$ 衡量链路上能容纳的最大比特数量    SSL属于应用层服务，若是用 SSL 来强化 TCP，则需要在应用程序中包含 SSL 代码\n  一个机构的 Web 服务器和邮件服务器可以有完全相同的主机名别名\n 为了获取邮件服务器的规范主机名，DNS客户应当请求一条MX记录 为了获得其他服务器的规范主机名，DNS客户应当请求CNAME记录    使用 UDP 服务器时，没有欢迎套接字，来自不同客户端的所有数据都通过这个套接字进入服务器\n使用 TCP 服务器，有一个欢迎套接字，每次客户端启动与服务器的连接时，都会创建一个新套接字\n为了支持 n 个并行连接，TCP服务器需要 n + 1 个套接字\n  HTTP 响应报文的头部代码是： 304 时， 为空的报文体\n  周知端口号：0~1023\n  rwnd=接收缓存-主机 B 中已接收但未读取的数据量\n  主机A发送但未被确认的字节数不会超过接收缓存的大小\n  可靠数据传输协议中，窗口长度n与信道利用率$U_{sender}$的关系：$U_{sender}=\\frac{n\\times \\frac{L}{R}}{RTT+\\frac{L}{R}}$\n  TCP客户端建立连接的socket函数：socket-bind-listen-accept\n  TCP首部20字节，UDP首部8字节，IPv4数据报头部20字节，IPv6数据报头部40字节\n  三、重要例题 第二章 P10 易错点：持续连接每次下载引用对象需要发送请求，即一个$(\\frac{200}{150}+T_p)$\n第三章 P27 易错点：\n 第二组数据先于第一组到达，则快速重传：ACK=127不变 第一组数据的确认丢失，超时重发，ACK=247与第二组相同 第二组无需重传（新的一轮timeout内接收到）  第三章 P40 第四章 P5 a.b.c.d/x形式表示：\n易错点：1100001 1……应分到接口3\n第四章 P14 易错点：\n 片位移=当前分片之前所有分片数据长度（减去TCP首部20字节之后）之和/8 分片标识号相同 最后一块分片标志为0，其余为1  第四章 易错点： 分配地址以$2^n$为基准分配\n第四章 第四章 易错点：\n 子网掩码：1表示子网部分，0表示主机部分（和CIDR地址划分区分） 子网号为主机部分全为0时的地址  第四章 第五章 P3 **易错点：**Dijikstra算法每次选择距离最短点进路径进行迭代\n第五章 P5 **易错点：**DV表的计算\n第五章 P7 易错点： 链路代价变化对DV算法的影响\n第五章 P14 第五章 P15 第六章 P5 **易错点：**CRC的计算\n第六章 P15 第六章 P21 第六章 P17 第六章 P26 第六章 P27 第六章 P37 ","description":"计算机网络学习要点，教材：《计算机网络：自顶向下方法》","id":22,"section":"posts","tags":["Computer Network"],"title":"计算机网络学习要点","uri":"https://chaphlagical.github.io/zh/posts/computer/network/"}]