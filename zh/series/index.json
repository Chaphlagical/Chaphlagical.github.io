[{"content":"Lazy Snapping是一种基于图的图像分割方法\\cite{li2004lazy}，能够将图像分割为前景和背景，通过用户交互挑选前景和背景种子，利用最大流最小分割的方法对图像进行分割。\n1. 基本方法 文献中利用分水岭算法对图像进行预处理，这里我们直接将图像下采样到原分辨率的八分之一进行处理，然后求解以下优化问题：\n$$\nE(X)=\\sum_{i\\in\\mathcal{V}}E_1(x_i)+\\lambda\\sum_{(i,j)\\in\\mathcal\\varepsilon}E_2(x_i, x_j)\n$$\n其中，$E_1(x_i)$为似然能量，编码结点$x_i$的代价，$E_2(x_i,x_j)$为先验能量，代表邻接结点$x_i$和$x_j$的代价。\n似然能量$E_1(x_i)$定义为：\n$$\n\\begin{cases}\n\\begin{matrix}\nE_1(x_i=1)=0\u0026amp;E_1(x_i=0)=\\infty\u0026amp;\\forall i\\in\\mathcal{F}\n\\end{matrix}\\\\\\\\\n\\begin{matrix}\nE_1(x_i=1)=\\infty\u0026amp;E_1(x_i=0)=0\u0026amp;\\forall i\\in\\mathcal{B}\n\\end{matrix}\\\\\\\\\n\\begin{matrix}\nE_1(x_i=1)=\\frac{d_i^\\mathcal{F}}{d_i^\\mathcal{F}+d_i^\\mathcal{B}}\u0026amp;E_1(x_i=0)=\\frac{d_i^\\mathcal{B}}{d_i^\\mathcal{F}+d_i^\\mathcal{B}}\u0026amp;\\forall i\\in\\mathcal{U}\n\\end{matrix}\n\\end{cases}\n$$\n其中，$\\mathcal{F}$表示前景种子集合，$\\mathcal{B}$为背景种子集合，均由用户输入，而$\\mathcal{U}$为补集。$d_i^\\mathcal{F}$和$d_i^\\mathcal{B}$分别表示当前颜色与前景种子平均值和背景种子平均值的距离平方\n先验能量$E_2(x_i,x_j)$定义为：\n$$\nE_2(x_i,x_j)=\\frac{1}{|C(i)-C(j)|^2+\\varepsilon}\n$$\n实验中，取$\\lambda=100$，$\\epsilon=0.01$。\n然后构建无向图，通过最大流最小割方法分离出前景和背景，提取轮廓得到结果\n实验结果    原图像 交互图像 轮廓                     参考文献 [1] Y. Li, J. Sun, C.-K. Tang, and H.-Y. Shum. Lazy snapping. ACM Transactions on Graphics (ToG), 23(3):303–308, 2004.\n","description":"复现Siggraph2004论文《Lazy snapping》","id":5,"section":"posts","tags":["Digital Image Process"],"title":"Lazy Snapping","uri":"https://chaphlagical.github.io/zh/posts/image_process/lazy_snapping/"},{"content":"Seam Carving算法是一种基于内容的图像缩放方法，在保证图像中“重要区域”不发生形变的前提下，对图像进行缩放。\n一种直观的想法便是找出图像中的“不重要区域”，并将其删除。文献[1]中便是采用这种思想，\n通过定义像素的能量函数，通过动态规划方法对某一方向的像素进行能量累积，最后回溯求出能量最低的一条路径，该路径便是我们要删除的“最不重要”路径。\n1. 基本方法 图像的能量简单地由图像梯度描述：\n$$\ne_1(\\pmb I)=\\left|\\frac{\\partial}{\\partial x}\\pmb I\\right|+\\left|\\frac{\\partial}{\\partial y}\\pmb I\\right|\n$$\n论文中也给出另外一种能量的变体实现：\n$$\ne_{HoG}(\\pmb I)=\\frac{\\left|\\frac{\\partial}{\\partial x}\\pmb I\\right|+\\left|\\frac{\\partial}{\\partial y}\\pmb I\\right|}{\\max(HoG(\\pmb I(x,y)))}\n$$\n实现中，采用Sobel算子提取图像梯度作为能量图：\n1 2 3 4 5 6 7 8 9 10 11  void SeamCarving::genEnergyMap(const cv::Mat\u0026amp; img, cv::Mat\u0026amp; energy) { cv::Mat sobel_x, sobel_y, gray_energy; cv::cvtColor(img, gray_energy, cv::COLOR_BGR2GRAY); cv::Sobel(gray_energy, sobel_x, CV_32F, 1, 0, 3); cv::convertScaleAbs(sobel_x, sobel_x); cv::Sobel(gray_energy, sobel_y, CV_32F, 0, 1, 3); cv::convertScaleAbs(sobel_y, sobel_y); cv::addWeighted(sobel_x, 0.5, sobel_y, 0.5, 0, energy); energy.convertTo(energy, CV_32FC1); }   对于$n\\times m$的图像$\\pmb I$，用于删除的接缝由如下定义：\n水平接缝：\n$$\n\\pmb{s^x}=\\{s_i^x\\}_{i=1}^n=\\{(x(i),i)\\}_{i=1}^n,\\ \\\ns.t.\\ \\ \\forall i,\\ \\ |x(i)-x(i-1)|\\leq 1\n$$\n竖直接缝：\n$$\n\\pmb{s^y}=\\{s_i^y\\}_{j=1}^m=\\{(j, y(j))\\}_{j=1}^m,\\ \\\ns.t.\\ \\ \\forall j,\\ \\ |y(j)-y(j-1)|\\leq 1\n$$\n其中，$x:[1,\\cdots,n]\\rightarrow[1,\\cdots,m]$，$y:[1,\\cdots,m]\\rightarrow[1,\\cdots,n]$\n而我们要寻找最低能量路径即求解最小优化问题：\n$$\ns^\\ast=\\min_{\\pmb s}E(\\pmb s)=\\min_{\\pmb s}\\sum_{i=1}^ne(\\pmb I(s_i))\n$$\n利用动态规划的思想可以很方便地求出上述优化问题，利用能量累积矩阵$M$，转移方程：\n$$\nM(i,j)=e(i,j)+\\min(M(i-1,j-1), M(i-1,j), M(i-1,j+1))\n$$\n从边缘出发按转移方程填充能量累积矩阵，最后寻找能量最低的终点$M(n,x)$（竖直搜索）或$M(x,m)$（水平搜索），回溯即可得到完整的最优路径。\n1.1. 图像缩小任务 对于单方向缩小任务，只需重复上述接缝搜索流程，每次删除一条接缝即可。\n对于多方向缩小任务，文献中也将横向竖向接缝的选择顺序其视为一个优化问题，假设现有$m\\times n$的图像$\\pmb I$欲缩小至$m'\\times n'$，其中$m\u0026gt;m',n\u0026gt;n'$，接缝顺序的选择等价于优化以下能量函数：\n$$\n\\min_{\\pmb{s^x},\\pmb{s^y},\\alpha}\\sum_{i=1}^kE(\\alpha_i\\pmb {s_i^x}+(1-\\alpha_i)\\pmb{s_i^y})\n$$\n其中，$r=m-m'$，$c=n-n'$， $\\alpha_i\\in{0,1}$描述了接缝选择的方向，因此有$\\sum_{i=1}^k\\alpha_i=r$，$\\sum_{i=1}^k(1-\\alpha_i)=c$成立。该问题同样可以利用动态规划的想法进行求解，取能量累积矩阵$\\pmb T$，满足$\\pmb T(0,0)=0$，转移方程：\n$$\n\\pmb T(r,c)=\\min(\\pmb T(r-1,c),E(\\pmb s^x(\\pmb {I_{n-r-1\\times m-c}})),\\pmb T(r,c-1),E(\\pmb s^y(\\pmb {I_{n-r\\times m-c-1}})))\n$$\n$\\pmb {I_{n-r-1\\times m-c}}$表示大小为$n-r-1\\times m-c$的图像（中间量），$E(\\pmb{s^x}(\\pmb I))$和$E(\\pmb{s^y}(\\pmb I))$为相应的方向接缝删除后的能量。\n但上述方法实测速度很慢，因此在实现中选择简单的贪婪策略选择带来当前最低能量的方法。\n1.2. 图像拉伸任务 对于图像拉伸任务，同样可以采用缩小任务相似的处理方法，只是将最优接缝的删除修改为最优接缝邻域的插值，但和缩小任务不同的是，每次对单条最优接缝进行插值，容易导致后续的最优接缝\n搜索会集中在同一区域，因此在图像拉伸任务中，建议一次性选择多条低能量接缝进行插值。\n2. 实验结果 2.1. 图像缩小    原图像 图像能量 结果图像                     2.2. 图像拉伸    原图像 图像能量 最优接缝 结果图像                        3. 总结 从上图中可以看出 Seam Carving 的一些局限性：\n 进行图像拉伸任务时容易造成图像区块重复，可以考虑手动排除部分区域进行优化 在梯度变化不明显的“重要区域”容易造成误处理，比如：《蒙娜丽莎》大片的头发。可以考虑手动划分“重要区域”进行处理  参考文献 [1] S. Avidan and A. Shamir. Seam carving for content-aware image resizing. In ACM SIGGRAPH 2007 papers, pages 10–es. 2007\n","description":"复现Siggraph2007论文《Seam Carving for Content-Aware Image Resizing》","id":6,"section":"posts","tags":["Digital Image Process"],"title":"Seam Carving","uri":"https://chaphlagical.github.io/zh/posts/image_process/seam_carving/"},{"content":"1. 问题描述 给定一张原图像：\n我们希望通过设计一个灰度图着色算法，使得下述灰度目标图像能够利用彩色原图像的颜色信息进行合理的上色：\n以得到类似下图的效果：\n2. 算法描述 实验参考了论文[1]，并使用全局匹配的方法进行求解。我们在图像的$l\\alpha\\beta$颜色空间上进行求解，这是由于$l\\alpha\\beta$颜色空间的$l$即代表着亮度，通过查找灰度源图像上的像素与彩色目标图像的$l$分量最佳匹配像素，再将目标图像对应匹配像素的$\\alpha$和$\\beta$分量赋予源图像即可\n进行灰度图像上色。算法流程如下：\n  将源图像$img_{src}$变换到$l\\alpha\\beta$颜色空间得到$img_{src}^{(l\\alpha\\beta)}$，同时将源图像$img_{src}$转换为灰度图$img_{src}^{(grey)}$\n  利用如下均值标准差变换，将$img_{src}^{(l\\alpha\\beta)}$的$l$通道和$img_{src}^{(grey)}$映射到具有灰度目标图像$img_{tar}$的像素值分布，得到$luminance_{src}$和$luminance_{src}^{grey}$\n$$\n\\begin{aligned}\nl'\u0026amp;=\\frac{\\sigma_t^l}{\\sigma_s^l}(l-\\mu^l_s)+\\mu^l_t\\\\\n\\alpha'\u0026amp;=\\frac{\\sigma_t^\\alpha}{\\sigma_s^\\alpha}(\\alpha-\\mu^\\alpha_s)+\\mu^\\alpha_t\\\\\n\\beta'\u0026amp;=\\frac{\\sigma_t^\\beta}{\\sigma_s^\\beta}(\\beta-\\mu^\\beta_s)+\\mu^\\beta_t\\\\\n\\end{aligned}\n$$\n  近邻域标准差计算。利用一个$n\\times n$（本实验中取$n=5)$）滑动窗口遍历图像（类似于卷积操作，边界用0填充），对窗口内的所有像素值计算它们的标准差并赋值到一幅标准差图像上。对$luminance_{src}^{grey}$和$img_{tar}$进行该计算，得到$stddev_{src}^{grey}$和$stddev_{tar}$\n  最佳匹配查找。遍历$img_{tar}$，已知$img_{tar}$上的某一像素值$p_{tar}$和其标准差$stddev_{tar}$对应的值$\\sigma_{tar}$，在源图像上寻找最佳匹配的像素点，这里简单地采用加权的$\\mathcal{L}_2$范数平方去算：\n$$\n\\arg\\min_{x,y} \\Big(w_1\\ast |luminance_{src}(x,y)-p_{tar}|^2+w_2\\ast|stddev_{src}^{grey}(x,y)-\\sigma_{tar}|^2\\Big)\n$$\n其中$w_1$和$w_2$分别表示亮度值和标准差的对匹配结果的贡献，这里简单地取$w_1=w_2=0.5$\n  灰度图上色。将查找到的最佳匹配像素$(\\tilde x. \\tilde y)$在$img_{src}^{(l\\alpha\\beta)}$所在像素值的$\\alpha$和$\\beta$分量赋值给源图像作为其$\\alpha$和$\\beta$通道的值，而原来的灰度值则作为$l$分量继续使用，并将源图像重新变换回$RGB$颜色空间得到最终的结果\n  3. 实验结果    原图像 参考图像 结果图像                               参考文献 [1] Welsh, M. Ashikhmin, and K. Mueller. Transferring color to greyscale im-ages. In Proceedings of the 29th annual conference on Computer graphics and interactive techniques, pages 277–280, 2002.11\n","description":"复现Siggraph2002论文《 Transferring Color To Greyscale Image》","id":8,"section":"posts","tags":["Digital Image Process"],"title":"Colorization","uri":"https://chaphlagical.github.io/zh/posts/image_process/colorization/"},{"content":"我将在这里分享有趣的知识与技术\n","description":"My Blog","id":9,"section":"","tags":null,"title":"简介","uri":"https://chaphlagical.github.io/zh/about/"}]