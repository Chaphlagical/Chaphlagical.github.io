[{"content":"å¼€å§‹æ•²ä»£ç ä¹‹å‰ï¼Œå…ˆæ¥æ„å»ºé¡¹ç›®\næˆ‘ä½¿ç”¨çš„å¼€å‘ç¯å¢ƒæ˜¯VS2019 Community + CMake3.19.0\næ–‡ä»¶ç»“æ„ é¦–å…ˆç¡®å®šå¥½é¡¹ç›®çš„æ–‡ä»¶ç»“æ„ï¼Œæ‰€è°“çš„æ–‡ä»¶ç»“æ„å°±æ˜¯å“ªä¸ªåœ°æ–¹æƒ³æ”¾ä»€ä¹ˆç±»å‹çš„æ–‡ä»¶ï¼Œä¾¿äºé¡¹ç›®ç®¡ç†ã€‚\nä¸‹å›¾æ˜¯å½“å‰ç¬¬ä¸€é˜¶æ®µè§„åˆ’çš„ä¸€ä¸ªæ–‡ä»¶ç»“æ„ï¼š\næ ¹ç›®å½•ä¸‹åˆ†ä¸ºä¸ƒä¸ªæ–‡ä»¶å¤¹ï¼š\n externï¼šå¤–éƒ¨åº“ï¼Œç¬¬ä¸‰æ–¹è½¯ä»¶åŒ…æ”¾è¿™é‡Œ internï¼šå†…éƒ¨åº“ï¼Œè‡ªå·±å†™çš„åº•å±‚åº“å’Œç¬¬ä¸‰æ–¹åº“å°è£…æ”¾è¿™é‡Œ platformï¼šç”¨äºåŒºåˆ†å¹³å°çš„ä¸€äº›ä¸œè¥¿ binï¼šç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶æ”¾è¿™é‡Œ libï¼šç”Ÿæˆçš„é™æ€é“¾æ¥åº“æ”¾è¿™é‡Œ sourceï¼šé¡¹ç›®æºæ–‡ä»¶ testï¼šå•å…ƒæµ‹è¯• assertsï¼šèµ„äº§æ–‡ä»¶ cmakeï¼šCMakeç›¸å…³çš„å·¥å…·å‡½æ•°  åŸºæœ¬çš„è°ƒç”¨å…³ç³»å¦‚ä¸‹ï¼š\ngraph TD\rapp --\u0026gt; core\rapp --\u0026gt; editor\rapp --\u0026gt; manager\rapp --\u0026gt; platform\rcore --\u0026gt; platform\reditor --\u0026gt; platform\rmanager --\u0026gt; platform\rcore --\u0026gt; intern\reditor --\u0026gt; intern\rmanager --\u0026gt; intern\rintern --\u0026gt; extern\rCMake æ–‡ä»¶ç›®å½•ç¡®å®šåï¼Œæˆ‘ä»¬å°±å¯ä»¥æ¥å†™CMakeListsæ„å»ºæˆ‘ä»¬çš„é¡¹ç›®äº†\nç”±äºCMakeå­¦ä¹ è·¯çº¿æ¯”è¾ƒé™¡å³­ï¼Œä¸æ‰“ç®—åœ¨è¿™ä¸ŠèŠ±å¤ªå¤šæ—¶é—´ï¼Œè¿™é‡Œæˆ‘ä½¿ç”¨äº†Ubpaå¤§ç¥å°è£…çš„CMakeåº“çš„ä¸ªäººå®šåˆ¶ç‰ˆæ¥æ–¹ä¾¿æˆ‘æ„å»ºç›¸å…³æ¨¡å—ï¼ˆé™„Ubpa: UCMakeï¼‰ï¼Œç›¸å…³å·¥å…·å‡½æ•°å­˜åœ¨./cmakeæ–‡ä»¶å¤¹ä¸­ï¼Œä¸‹é¢ä¸»è¦ä»‹ç»ä¸‰ä¸ªæ¯”è¾ƒé‡è¦çš„åŠŸèƒ½æ¨¡å—ï¼š\nInit è¿™éƒ¨åˆ†ç”¨äºé¡¹ç›®çš„åˆå§‹åŒ–ï¼Œè®¾ç½®ä¸€äº›åŸºæœ¬çš„å…¨å±€é…ç½®ï¼Œå¦‚ï¼šC++ç‰ˆæœ¬ã€å•å…ƒæµ‹è¯•ã€è¾“å‡ºæ–‡ä»¶å¤¹ç­‰\nBuild å®ç°äº†ä¸€è¡Œä»£ç æ„å»ºå­é¡¹ç›®ï¼Œæ”¯æŒè®¾ç½®å•å…ƒæµ‹è¯•ã€è®¾ç½®ç¼–è¯‘æ–¹å¼ã€è®¾ç½®é“¾æ¥åº“ç­‰ï¼ŒåŠŸèƒ½ååˆ†å¼ºå¤§ï¼Œç›´æ¥ç”¨å°±æ˜¯äº†\nPackage è¿™éƒ¨åˆ†æ˜¯ä¾èµ–ç›¸å…³çš„ï¼ŒUbpaæœ¬äººåçˆ±åœ¨çº¿æ„å»ºï¼ˆæœ¬åœ°åªä¿ç•™æ ¸å¿ƒéƒ¨åˆ†ï¼Œç›¸å…³ä¾èµ–ä»githubä¸Šæ‹‰å–ï¼‰ï¼Œè¿™æ ·çš„å¥½å¤„æ˜¯æ›´æ–°æ–¹ä¾¿ï¼Œä¸è¿‡æ¯æ¬¡æ„å»ºä¹ŸèŠ±äº†ä¸å°‘æ—¶é—´åœ¨æ¨¡å—ä¸‹è½½ä¸Šï¼Œå¯¹äºå·²ä¸‹è½½çš„æ¨¡å—åˆ¤æ–­æœºåˆ¶è¿˜ä¸å¤Ÿå¥½ã€‚æœ¬é¡¹ç›®æˆ‘ä»¬ä¸»è¦è¿˜æ˜¯ä½¿ç”¨gitæœ¬èº«çš„submoduleåŠŸèƒ½æ¥æ·»åŠ ç›¸å…³ä¾èµ–ï¼Œæ‰€ä»¥è¿™éƒ¨åˆ†ç”¨çš„ä¼šç›¸å¯¹æ¯”è¾ƒå°‘\nè®¾ç½®å¥½å°±å¯ä»¥å¯åŠ¨æˆ‘ä»¬çš„ç©ºé¡¹ç›®äº†ï¼š\nHello Worldï¼ ç™¾é‡Œä¹‹è¡Œï¼Œå§‹äºè¶³ä¸‹\næˆ‘ä»¬æ¥å®šä¹‰æˆ‘ä»¬çš„å‡½æ•°å…¥å£ï¼Œå³æ•´ä¸ªé¡¹ç›®çš„mainå‡½æ•°\nåœ¨./source/appä¸­æ·»åŠ æˆ‘ä»¬çš„å…¥å£æ–‡ä»¶app.cppï¼Œé”®å…¥Hello Worldä»£ç ï¼š\n1 2 3 4 5 6 7  #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; }   åŒæ—¶æ·»åŠ CMakeLists.txtæ–‡ä»¶ï¼š\n1 2 3  SetTarget( MODE EXE )  SetTargetæ˜¯æˆ‘ä»¬ç”¨æ¥è®¾ç½®æ–°é¡¹ç›®çš„CMakeå‡½æ•°ï¼Œç›¸å…³å‚æ•°å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13  # parameters  # TEST  # NO_GROUP: default no group  # MDOE: EXE/STATIC/SHARED/INTERFACE  # FEATURE: PUBLIC/INTERFACE/PRIVATE(default)/NONE  # TARGET_NAME: (default)/reset  # [arglist]: public, interface, private  # SOURCE: dir(recursive), files, auto add current dir | target_sources  # INC: dir | target_include_directories  # LIB: \u0026lt;lib-target\u0026gt;, *.lib | target_link_libraries  # DEFINE: #define... | target_compile_definitions  # C_OPTION: compile options | target_compile_options  # L_OPTION: link options | target_link_options   å°†Thoth_appè®¾ä¸ºå¯åŠ¨é¡¹ç›®ï¼Œè¿è¡Œåå¯ä»¥çœ‹åˆ°ï¼š\nè¾“å‡ºçš„Thoth_app.exeæ–‡ä»¶ä¹Ÿä¿å­˜åœ¨./binæ–‡ä»¶å¤¹ä¸‹ï¼š\nè‡³æ­¤æˆ‘ä»¬çš„é¡¹ç›®æ„å»ºæˆåŠŸï¼Œä¸‹ä¸€éƒ¨æˆ‘ä»¬å°†æ­£å¼å®šä¹‰æˆ‘ä»¬çš„å…¥å£å‡½æ•°ï¼Œå¼•æ“å¼€å‘ä¹‹æ—…å°±æ­¤å¯ç¨‹\n","description":"Thothé¡¹ç›®æ„å»º","id":0,"section":"posts","tags":["CG","Thoth"],"title":"Thothå¼•æ“å¼€å‘(1) | é¡¹ç›®æ„å»º","uri":"https://chaphlagical.github.io/zh/posts/2020-11-26-thoth1/"},{"content":"å‰è¨€ ä½œä¸ºä¸€ä¸ªæœªæ¥èµ°å›¾å½¢å­¦æ–¹å‘çš„å¤§å››ä¿ç ”ç”Ÿï¼Œå·²æŒæ¡åŸºç¡€çš„è®¡ç®—æœºå›¾å½¢å­¦åŸç†å’Œæ–¹æ³•ï¼Œæ€ä¹ˆèƒ½ä¸æ‰‹å†™ä¸€ä¸ªå¼•æ“å‘¢?ğŸ¶\né‚£ä¹ˆï¼Œè¿™ä¸ªå¼•æ“ï¼Œå®ƒèƒ½åšä»€ä¹ˆï¼Ÿè¯´åˆ°å›¾å½¢å¼•æ“ï¼Œå¾ˆå®¹æ˜“æƒ³åˆ°çš„ä¸€ä¸ªåº”ç”¨æ˜¯æ¸¸æˆå¼•æ“ï¼Œä¸è¿‡è¿™é‡Œæˆ‘ä¸æ‰“ç®—åšæ¸¸æˆå¼•æ“ï¼Œå› ä¸ºåœ¨æ¸¸æˆå¼•æ“ä¸­ï¼Œå›¾å½¢å­¦çš„çŸ¥è¯†å…¶å®åªæ˜¯å…¶ä¸­çš„ä¸€å°æ–¹é¢ï¼Œä¸€ä¸ªæˆç†Ÿçš„æ¸¸æˆå¼•æ“ä¸ä»…è¦æœ‰çµæ´»å¯å®šåˆ¶çš„æ¸²æŸ“ç®¡çº¿ï¼Œè¿˜éœ€è¦åœ¨å®¢æˆ·ç«¯ã€ç½‘ç»œé€šä¿¡ã€è®¾å¤‡I/Oã€GamePlayç­‰ç­‰è¯¸å¤šå…¶ä»–æ¨¡å—ä¸Šä¸‹åŠŸå¤«ã€‚è¿™é‡Œæˆ‘å¸Œæœ›åšçš„æ˜¯ä¸€ä¸ªç±»ä¼¼Blenderè¿™æ ·çš„é›†å‡ ä½•å»ºæ¨¡ã€ç‰©ç†ä»¿çœŸã€å®æ—¶ã€ç¦»çº¿æ¸²æŸ“äºä¸€ä½“çš„å›¾å½¢å¼•æ“ï¼Œå°†æˆç†Ÿçš„ç®—æ³•åœ¨å®ƒä¸Šé¢å°½å¯èƒ½åœ°å®ç°ï¼ŒåŒæ—¶ä¹Ÿä½œä¸ºç ”ç©¶ç”Ÿé˜¶æ®µçš„ä¸€ä¸ªå®éªŒå¹³å°ã€‚äº‹å®ä¸Šåœ¨æ­¤ä¹‹å‰æˆ‘çœ‹äº†æ²¹ç®¡Upä¸»å‰EAå¼•æ“å·¥ç¨‹å¸ˆChernoçš„Game Engine Seriesç³»åˆ—è§†é¢‘åï¼Œä¹Ÿè·Ÿç€åšäº†ä¸€ä¸ªåŸºäºOpenGLçš„ç®€å•æ¸²æŸ“å™¨ï¼ˆGithubé“¾æ¥ï¼šhttps://github.com/Chaphlagical/Chaf-Engineï¼‰ï¼Œä¸è¿‡è¿™ä¸ªæ¸²æŸ“å™¨ä¹Ÿæœ‰è®¸å¤šé—®é¢˜ï¼š\n å„ä¸ªæ¨¡å—è€¦åˆæ€§è¿‡é«˜ï¼Œéš¾ä»¥åˆ†ç¦»å‡ºå¯é€šç”¨çš„éƒ¨åˆ† å¤§éƒ¨åˆ†åŠŸèƒ½ä¸å¤§å®Œå–„ï¼Œç”±äºè®¾è®¡ä¸Šçš„ç¼ºé™·ï¼Œä»£ç è¶Šå †è¶Šä¹± ç”¨çš„è¿˜æ˜¯Chernoçš„æ¶æ„ï¼Œæˆ‘å¸Œæœ›æœ‰æˆ‘è‡ªå·±çš„è®¾è®¡  æ–°å¼•æ“èµ·åä¸ºThothï¼ŒThothæ˜¯å¤åŸƒåŠç¥è¯é‡Œçš„æ™ºæ…§ä¹‹ç¥ï¼Œä¹Ÿæ˜¯æœˆäº®ä¹‹ç¥å’Œæ•°å­¦ä¹‹ç¥ï¼Œä»£è¡¨æ™ºèƒ½ã€è‰ºæœ¯ã€å»ºè®®å’Œç¥å¥‡ä¹‹äº‹ï¼Œæˆ‘å¸Œæœ›èƒ½å¤Ÿåˆ›é€ èƒ½å¤Ÿåˆ›é€ è‰ºæœ¯çš„å·¥å…·ã€‚\næ¶æ„åˆ†æ æ¶æ„å¯¹æœ‰ä¸€å®šè§„æ¨¡çš„è½¯ä»¶å·¥ç¨‹è®¾è®¡æ¥è¯´æ˜¯æå…¶é‡è¦çš„ï¼Œå¥½çš„æ¶æ„è®¾è®¡ï¼Œä¸ä»…ä»…è¦èƒ½å……åˆ†å‘æŒ¥è½¯ä»¶è¿è¡Œçš„ç¡¬ä»¶èµ„æºï¼Œæé«˜æ€§èƒ½ï¼Œè¿˜èƒ½æ–¹ä¾¿å¼€å‘è€…è¿›è¡Œæ‰©å±•å’Œé‡æ„ã€‚ä¸‹é¢æ˜¯Blenderçš„æ¶æ„ç¤ºæ„å›¾ï¼š\nè¿™æ˜¯ä¸€ä¸ªè‡ªåº•å‘ä¸Šçš„æ¨¡å—æ¶æ„åˆ†å¸ƒï¼Œæœ€åº•å±‚æ˜¯æ“ä½œç³»ç»Ÿå±‚ï¼ŒBlenderæ˜¯ä¸€æ¬¾è·¨å¹³å°è½¯ä»¶ï¼Œéœ€è¦è€ƒè™‘ä¸åŒæ“ä½œç³»ç»Ÿä¸‹çš„å…¼å®¹æ€§ï¼Œè¿™é‡Œå®ƒç”¨äº†OpenGLä½œä¸ºæ¸²æŸ“çš„å›¾å½¢APIï¼Œç”¨æ ‡å‡†Cå’ŒC++æ··ç¼–ã€‚æ¥ç€æ˜¯ä¸€ç³»åˆ—åº•å±‚åº“ï¼Œåˆ†ä¸ºå†…éƒ¨åº“ã€å¤–éƒ¨åº“å’Œé¢„ç¼–è¯‘åº“ï¼šå†…éƒ¨åº“ä¸ºBlenderå¼€å‘è€…è‡ªè¡Œå¼€å‘çš„å†…å®¹ï¼›å¤–éƒ¨åº“æ˜¯æ‰€ä½¿ç”¨çš„ç¬¬ä¸‰æ–¹å¤–éƒ¨å¼€æºåº“ï¼Œé¢„ç¼–è¯‘åº“æ˜¯å­˜åœ¨SVNä¸Šæˆ–è¦æ±‚å®‰è£…çš„ç¼–è¯‘å¥½çš„.libåº“æ–‡ä»¶ã€‚å†å¾€ä¸Šåˆ™æ˜¯Blenderçš„é€šç”¨APIä»¥åŠå„ç§ä¸Šå±‚åº”ç”¨ã€‚æˆ‘ä»¬çš„å¼•æ“ä¹Ÿå°†æŒ‰ç…§ç±»ä¼¼çš„æ¶æ„è¿›è¡Œè®¾è®¡ï¼Œå°½å¯èƒ½åœ°å‡å°‘æ¨¡å—é—´çš„è€¦åˆå…³ç³»ï¼Œä»¥æé«˜å¯æ‰©å±•æ€§å’Œæ˜“ç»´æŠ¤æ€§\nè™½ç„¶ä¸åšæ¸¸æˆå¼•æ“ï¼Œä½†ä¹Ÿå¿…é¡»å¾—ç¥­ä¸Šã€Šæ¸¸æˆå¼•æ“æ¶æ„ã€‹ä¸­çš„ä¸€å¹…åå›¾ï¼š\nå¯ä»¥çœ‹åˆ°æˆ‘ä»¬è¦åšçš„å’Œæ¸¸æˆå¼•æ“å…¶å®æœ‰å¾ˆå¤§ç¨‹åº¦çš„é‡åˆï¼Œåªæ˜¯æˆ‘ä»¬å°†ä¼šæ›´åŠ é‡è§†å‡ ä½•é€ å‹å’Œç‰©ç†æ¨¡æ‹Ÿè¿™å—ï¼Œåœ¨æ¶æ„è®¾è®¡ä¸Šä¹Ÿæœ‰å¾ˆå¤šå¯å€Ÿé‰´ä¹‹å¤„\næ¥ä¸‹æ¥è°ˆè°ˆåŸºæœ¬çš„è®¾è®¡ï¼š\næ“ä½œç³»ç»Ÿ å½“å‰ä¸ªäººçš„ä¸»è¦å¼€å‘ç¯å¢ƒä¸ºWin10+VS2019ï¼Œå› æ­¤å¼•æ“å°†åœ¨å¾ˆé•¿ä¸€æ®µæ—¶é—´å†…åªæ”¯æŒMSVCç¼–è¯‘ï¼ŒåæœŸå¯èƒ½è€ƒè™‘åŠ å…¥å…¶ä»–ç¼–è¯‘å™¨ï¼ˆclangã€g++ç­‰ï¼‰æ”¯æŒï¼Œä»¥åå†çœ‹\nç¬¬ä¸‰æ–¹è½¯ä»¶å¼€å‘åŒ… ç¬¬ä¸‰æ–¹è½¯ä»¶å¼€å‘åŒ…å¯ä»¥æ–¹ä¾¿æˆ‘ä»¬ä¸ç”¨è‡ªå·±åŠ¨æ‰‹é€ è½®å­ï¼Œä¸è¿‡å‡ºäºå¯¹åŸç†å­¦ä¹ çš„è€ƒè™‘ï¼ŒåæœŸå¯èƒ½ä¼šæ›¿æ¢æ‰éƒ¨åˆ†ç¬¬ä¸‰æ–¹åº“ï¼Œè€Œæ¢æˆè‡ªå·±çš„è½®å­ï¼ˆå¦‚æœè‡ªå·±çš„è½®å­æ•ˆç‡èƒ½æ‰“çš„è¯ï¼‰ï¼Œgithubä¸Šå„è·¯äººç¼–å†™çš„å„ç§åº“å¾ˆå¤šï¼Œæˆ‘æ‰€é€‰æ‹©ä½¿ç”¨çš„ç¬¬ä¸‰æ–¹åº“å‡ºäºä»¥ä¸‹å‡ ç‚¹è€ƒé‡ï¼š\n é€šç”¨æ€§ï¼šèƒ½å¤Ÿè§£å†³ä¸€å¤§ç±»é—®é¢˜ï¼ŒåŠŸèƒ½å¼ºå¤§ï¼ŒåƒEigen3åŸºæœ¬å°±èƒ½æ»¡è¶³æˆ‘å¯¹æ•°å€¼çº¿æ€§ä»£æ•°ä¸€å—çš„éœ€æ±‚çš„ æ˜“ç”¨æ€§ï¼šå­¦ä¹ æ–¹ä¾¿ï¼Œèƒ½å¤Ÿå¾ˆå¿«ä¸Šæ‰‹ï¼Œæ–‡æ¡£é½å…¨ï¼Œç¤¾åŒºæ´»è·ƒï¼Œè¿™æ˜¯å‡ºäºå¼€å‘æ•ˆç‡è€ƒè™‘ è½»ä¾¿æ€§ï¼šå°½å¯èƒ½åœ°é€‰è½»é‡çº§çš„åº“ï¼Œåçˆ±éƒ¨åˆ†å°è€Œç²¾çš„head-only librariesï¼Œå¤ªç´¯èµ˜é…ç½®èµ·æ¥ä¹Ÿä¸æ–¹ä¾¿ï¼Œé™¤éæ˜¯OpenCVè¿™ç§åŠŸèƒ½å¾ˆå¼ºå¤§åˆæ²¡æœ‰å¾ˆå¥½æ›¿ä»£å“çš„ ç§»æ¤æ€§ï¼šçº¯Cå†™çš„æ›´å¥½ï¼Œå°½é‡æ”¯æŒå¤šå¹³å°ç¼–è¯‘ï¼ŒåæœŸç»´æŠ¤ä¹Ÿæ–¹ä¾¿  ç›®å‰æ‰“ç®—ä½¿ç”¨ä»¥åŠåç»­å¯èƒ½ä¼šè‡ªå·±ç¼–å†™çš„åº“å¤§æ¦‚å¦‚ä¸‹ï¼š\n å›¾å½¢API  OpenGLï¼Œè¿™ä¸ªæ˜¯æˆ‘å½“å‰ä¼šçš„ DX12ï¼Œç°ä»£å›¾å½¢APIï¼Œåªæ”¯æŒWindowsï¼Œæœ‰å¿…è¦ä¸€å­¦ Vulkanï¼Œè·¨å¹³å°çš„ç°ä»£å›¾å½¢APIï¼Œæ®è¯´å¾ˆéš¾ç”¨ï¼Œå¾…å®š è½¯å…‰æ …ï¼Œå¾…å®š   æ•°å­¦åº“  glmï¼Œæ¸²æŸ“ç”¨çš„åŸºç¡€æ•°å­¦åº“ï¼ŒåæœŸè€ƒè™‘æ›¿æ¢ä¸ºè‡ªç¼–å†™çš„cmlæ•°å­¦åº“ Eigen3ï¼Œæ•°å€¼çŸ©é˜µåº“ï¼Œè¿™ä¸ªè½®å­åº”è¯¥é€ ä¸å¤ªæ¥ï¼Œè¿˜æ˜¯ç›´æ¥ç”¨å§ DirectMathï¼Œè§‚æœ›ä¸­ï¼Œå¾…å®š   æ—¥å¿—ç³»ç»Ÿ  spdlogï¼Œè½»é‡ã€çº¯å¤´æ–‡ä»¶   æ ‡å‡†åº“  STLæ ‡å‡†æ¨¡æ¿åº“æ˜¯æˆ‘ä»¬å°½å¯èƒ½ä½¿ç”¨çš„   ç”¨æˆ·ç•Œé¢  GUIå¯ä»¥ä½¿ç”¨Qtï¼Œä½†ä¸ªäººè§‰å¾—Qtè¿‡äºç´¯èµ˜ï¼Œè¿™é‡Œä½¿ç”¨imguiï¼Œç›´æ¥ä½¿ç”¨åŸç”Ÿå›¾å½¢API   å…¶ä»–  stbï¼Œå•æ–‡ä»¶è€ŒåˆåŠŸèƒ½å¼ºå¤§ï¼Œåƒå›¾ç‰‡è¯»å–å›¾ç‰‡å†™å…¥ä¹‹ç±»çš„åŠŸèƒ½å¯ä»¥ç”¨å®ƒ rapidJsonï¼ŒJsonè§£é‡Šå™¨ï¼Œç”¨äºåºåˆ—åŒ–å’Œååºåˆ—åŒ– æš‚æ—¶æƒ³åˆ°è¿™ä¹ˆå¤š    å¹³å°ç‹¬ç«‹å±‚ è¿™ä¸€éƒ¨åˆ†ä¸»è¦å®ç°ä¸€äº›å¹³å°æ— å…³çš„åŠŸèƒ½ï¼Œè¿™é‡Œå°½å¯èƒ½åœ°ä½¿ç”¨æ ‡å‡†åº“è¿›è¡Œå®ç°ï¼š\n å¹³å°æ£€æµ‹ï¼šä½¿ç”¨ç¼–è¯‘å™¨å†…ç½®å®å®šä¹‰ï¼Œä»¥åè®¨è®º é«˜åˆ†è¾¨ç‡æ—¶é’Ÿï¼šstd::chrono çº¿ç¨‹åº“ï¼šstd::thread åŸå­æ“ä½œï¼šstd::atomic é›†åˆä¸è¿­ä»£å™¨ï¼šSTL æ–‡ä»¶ç³»ç»Ÿï¼šfilesystemï¼ŒC++17æ–°ä¸œè¥¿  æ ¸å¿ƒåº“ å‰é¢è®²çš„éƒ½æ˜¯è¦ç”¨åˆ«äººçš„ä»€ä¹ˆï¼Œç°åœ¨è®²è®²æˆ‘ä»¬è¦å†™çš„æ˜¯ä»€ä¹ˆ\né¦–å…ˆæ˜ç¡®éœ€æ±‚ï¼Œä¸‰ä¸ªæ–¹å‘ï¼šå‡ ä½•ã€ä»¿çœŸå’Œæ¸²æŸ“\nå‡ ä½•åŒ…æ‹¬è®¡ç®—æœºè¾…åŠ©å‡ ä½•è®¾è®¡CAGDå’Œæ•°å­—å‡ ä½•å¤„ç†DGPï¼Œä¸€ä¸ªæ˜¯å…³äºæ›²çº¿å’Œæ›²é¢ï¼Œä¸€ä¸ªæ˜¯å…³äºç¦»æ•£ä¸‰è§’ç½‘æ ¼\nCAGDéƒ¨åˆ†æˆ‘å¸Œæœ›åŒæ—¶èƒ½å¤ŸåŒæ—¶æ»¡è¶³2Då’Œ3Dçš„è®¾è®¡ï¼Œ2Dæ–¹é¢å°†å®ç°ç±»ä¼¼å‡ ä½•ç”»æ¿çš„åŠŸèƒ½ï¼ŒåŒ…æ‹¬åŸºæœ¬çš„ç»˜ç‚¹ã€ç»˜çº¿ã€åŸºæœ¬å‡ ä½•ä½“ï¼ˆåœ†ã€çŸ©å½¢ã€æ¤­åœ†ï¼‰ï¼Œä»¥åŠå„ç§å‡ ä½•ç‰¹å¾ï¼ˆä¸­ç‚¹ã€å‚çº¿ã€è§’å¹³åˆ†çº¿ç­‰ï¼‰çš„æ„é€ ï¼Œä»¥åŠæ›²çº¿ï¼ˆBæ ·æ¡ã€Bezierç­‰ï¼‰é€ å‹ã€‚3Déƒ¨åˆ†ç›®å‰è¿˜ä¸å¤ªç†Ÿæ‚‰ï¼Œå¤§æ¦‚ä¹Ÿæ˜¯NURBSç­‰å„ç§æ›²çº¿æ›²é¢çš„å†…å®¹\nDGPéƒ¨åˆ†å°†PMPä½œä¸ºå‚è€ƒä¹¦ï¼Œå®ç°å°½å¯èƒ½å¤šçš„ç½‘æ ¼å¤„ç†ç®—æ³•ï¼Œå¦‚ï¼šé™å™ªã€å‚æ•°åŒ–ã€å˜å½¢ç­‰\nå‡ ä½•éƒ¨åˆ†çš„è®¾è®¡æ–¹æ³•å‡ä»æ•°æ®ç»“æ„å‡ºå‘ï¼Œåˆ©ç”¨åŸºç¡€æ•°å­¦åº“å»ºç«‹é«˜çº§æ•°æ®ç»“æ„ï¼ˆå¦‚åŠè¾¹ç»“æ„ç­‰ï¼‰ï¼Œå†åˆ©ç”¨è¿™äº›æ•°æ®ç»“æ„å®ç°ç›¸å…³çš„ç®—æ³•\næ¸²æŸ“æ–¹é¢æ˜¯é¦–å…ˆè¦å®Œæˆçš„ï¼Œå› ä¸ºå‡ºå›¾åƒå¾ˆå¿«ä¹ã€‚è¿™é‡Œå®æ—¶æ¸²æŸ“éƒ¨åˆ†è¦åšçš„å’Œæˆ‘ä¹‹å‰åšçš„å°å¼•æ“åŠŸèƒ½ç±»ä¼¼ï¼šå°è£…å›¾å½¢APIï¼Œå®ç°æ¸²æŸ“æµæ°´çº¿ï¼ŒåŒæ—¶å®ç°æè´¨ç¼–è¾‘å’Œç€è‰²å™¨è·¨å¹³å°ç¼–è¯‘ç­‰åŠŸèƒ½ã€‚ç¦»çº¿æ¸²æŸ“æ–¹é¢ä»å…‰çº¿è¿½è¸ªç®¡çº¿å‡ºå‘è¿›è¡Œè®¾è®¡ï¼Œå‰æœŸå­¦ä¹ ã€ŠIn One Weekã€‹å’ŒPBRTç³»åˆ—ï¼ŒåæœŸè€ƒè™‘åŠ å…¥Cudaå’ŒOptixè¿›è¡Œæé€Ÿ\nä»¿çœŸéƒ¨åˆ†åº”è¯¥æ˜¯æœ€åå®ç°ï¼Œäº‰å–å®ç°å°½å¯èƒ½å¤šçš„åˆšä½“ã€è½¯ä½“ã€æµä½“æ–¹é¢çš„å®æ—¶ã€ç¦»çº¿ç®—æ³•ï¼Œç”±äºå­¦ä¹ çš„ä¸å¤šï¼Œæš‚æ—¶ä¸å¤šè®²\nèµ„äº§ç®¡ç† å›¾å½¢å¼•æ“çš„èµ„äº§ä¸»è¦åŒ…æ‹¬æœ‰ï¼šå­—ä½“ã€ä¸‰ç»´æ¨¡å‹ã€éª¨éª¼åŠ¨ç”»ã€åœºæ™¯èµ„æºã€çº¹ç†èµ„æºã€æè´¨èµ„æºç­‰\nå’Œæ–‡ä»¶ç³»ç»Ÿç›¸äº’é…åˆï¼ŒåŒæ—¶å®ç°å„ç§åŠ è½½çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–ï¼Œä½¿å¾—ç¼–è¾‘ã€ä¿å­˜åœºæ™¯æ›´åŠ æ–¹ä¾¿\nä¸Šè¿°æ¶æ„è®¾è®¡åªæ˜¯ä¸€ä¸ªå¤§æ¦‚ï¼Œå…·ä½“æ¯ä¸€ä¸ªæ¨¡å—éƒ½å°†ç›¸å½“å¤æ‚ï¼Œè¿™é‡Œåªæ˜¯ç¬¼ç»Ÿåœ°yyä¸€ä¸‹ï¼Œè¯ä¸å¤šè¯´ï¼ŒLet\u0026rsquo;s do it!\n","description":"æ–°å¼•æ“Thothå¼€å‘æä¸Šæ—¥ç¨‹ï¼Œæµ…è°ˆåŸºç¡€è§„åˆ’ä¸æ¶æ„","id":1,"section":"posts","tags":["CG","Thoth"],"title":"Thothå¼•æ“å¼€å‘(0) | è§„åˆ’","uri":"https://chaphlagical.github.io/zh/posts/2020-11-25-thoth0/"},{"content":"B.1 Traditional Lvalues and Rvalues ä¼ ç»Ÿæ„ä¹‰ä¸Šå€¼åˆ†ä¸ºä¸¤ç§ï¼šå·¦å€¼å’Œå³å€¼\n å·¦å€¼æ˜¯æŒ‡ä»£å­˜å‚¨äºå†…å­˜æˆ–å¯„å­˜å™¨çš„å®é™…çš„å€¼çš„è¡¨è¾¾å¼ï¼Œæ¯”å¦‚å·¦å€¼xçš„xæ˜¯ä¸€ä¸ªå˜é‡çš„åå­—  å·¦å€¼æ˜¯å¯ä¿®æ”¹çš„ï¼Œå…è®¸æ›´æ–°å…¶å­˜å‚¨çš„å€¼ï¼Œä¾‹å¦‚x=7å°†xçš„å€¼ä¿®æ”¹æˆ7     ","description":"ã€ŠC++ Templateså­¦ä¹ ç¬”è®°é™„å½•Bã€‹","id":2,"section":"note","tags":["C++ Templates","C++"],"title":"Appendix B: Value Categories","uri":"https://chaphlagical.github.io/zh/note/cpptemplate/appendixb/"},{"content":"ç§»åŠ¨è¯­ä¹‰æ˜¯C++11æ ‡å‡†ä¸­çš„ä¸€ä¸ªé‡è¦ç‰¹æ€§ï¼Œé€šè¿‡ç§»åŠ¨è¯­ä¹‰èƒ½å¤Ÿä¼˜åŒ–å¤åˆ¶å’Œæ„é€ æ“ä½œï¼Œä½¿å†…å®¹ä»åŸå¯¹è±¡ç§»åŠ¨åˆ°ç›®æ ‡å¯¹è±¡ï¼Œè€Œä¸æ˜¯ç›´æ¥å¤åˆ¶\n6.1 Perfect Forwarding å‡è®¾ç°åœ¨éœ€è¦å†™ä¸€æ®µè½¬å‘ä¼ é€’å‚æ•°çš„åŸºæœ¬å±æ€§çš„æ³›å‹ä»£ç ï¼š\n å¯ä¿®æ”¹å¯¹è±¡è¢«è½¬å‘åä»å¯ä¿®æ”¹ å¸¸é‡å¯¹è±¡å¿…é¡»è½¬å‘ä¸ºåªè¯»å¯¹è±¡ å¯ç§»åŠ¨å¯¹è±¡åº”è½¬å‘ä¸ºå¯ç§»åŠ¨å¯¹è±¡  ç¤ºä¾‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  #include \u0026lt;utility\u0026gt;#include \u0026lt;iostream\u0026gt; class X{ ... }; void g(X\u0026amp;){ std::cout \u0026lt;\u0026lt; \u0026#34;g() for variable\\n\u0026#34;; } void g(X const\u0026amp;){ std::cout \u0026lt;\u0026lt; \u0026#34;g() for constant\\n\u0026#34;; } void g(X\u0026amp;\u0026amp;){ std::cout \u0026lt;\u0026lt; \u0026#34;g() for movable object\\n\u0026#34;; } void f(X\u0026amp; val){ g(val);\t// val is non-const lvalue =\u0026gt; calls g(X\u0026amp;) } void f(X const\u0026amp; val){ g(val);\t// val is const lvalue =\u0026gt; calls g(X const\u0026amp;) } void f(X\u0026amp;\u0026amp; val){ g(std::move(val));\t// val is non-const lvalue =\u0026gt; needs std::move() to call g(X\u0026amp;\u0026amp;) } int main() { X v; X const c; f(v); f(c); f(X()); f(std::move(v)); }   å¯¹äºå¯ç§»åŠ¨å¯¹è±¡å¿…é¡»ä½¿ç”¨std::move\nå¯¹å‰ä¸¤ç§æ–¹å¼ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨å‡½æ•°æ¨¡æ¿ï¼š\n1 2 3 4 5  template\u0026lt;typename T\u0026gt; void f(T\u0026amp; val) { g(val); }   è€Œå¯¹äºå¯ç§»åŠ¨å¯¹è±¡æ— æ³•è°ƒç”¨ä¸Šè¿°å‡½æ•°æ¨¡æ¿ï¼ŒC++11ä¸ºè¿™ç§ç‰¹æ®Šæƒ…å†µæä¾›äº†å®Œç¾è½¬å‘å‚æ•°ï¼š\n1 2 3 4 5  template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; val) { g(std::forward\u0026lt;T\u0026gt;(val));\t// perfect forward val to g() }   æ³¨æ„æ¨¡æ¿T\u0026amp;\u0026amp;çš„è§„åˆ™ä¸å…·ä½“ç±»å‹çš„X\u0026amp;\u0026amp;æœ‰æ‰€ä¸åŒï¼š\n X\u0026amp;\u0026amp;è¡¨ç¤ºä¸€ä¸ªå³å€¼å¼•ç”¨ï¼Œåªèƒ½ä½œä¸ºä¸€ä¸ªå¯ç§»åŠ¨å¯¹è±¡ï¼Œä¾‹å¦‚ä¸´æ—¶å˜é‡å’Œç”¨std::move()å¤„ç†çš„ç±» T\u0026amp;\u0026amp;ä¸ºæ¨¡æ¿å‚æ•°Tå£°æ˜çš„ä¸€ä¸ªè½¬å‘å¼•ç”¨ï¼ˆé€šç”¨å¼•ç”¨ï¼‰ï¼Œå®ƒå¯ä»¥ä½œä¸ºå¯å˜ã€ä¸å¯å˜å’Œå¯ç§»åŠ¨å¯¹è±¡  æ³¨æ„è¿™é‡ŒTå¿…é¡»æ˜¯æ¨¡æ¿å‚æ•°ï¼Œä¾èµ–äºæ¨¡æ¿å‚æ•°çš„å˜é‡æ˜¯ä¸å…è®¸ä½œä¸ºè½¬å‘å¼•ç”¨çš„ï¼Œä¾‹å¦‚T::iterator\u0026amp;\u0026amp;åªèƒ½ä½œä¸ºå³å€¼å¼•ç”¨\nä¹‹å‰ä»£ç ç”¨å®Œç¾è½¬å‘æ”¹å†™åä¸ºï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  #include \u0026lt;utility\u0026gt;#include \u0026lt;iostream\u0026gt; class X{ ... }; void g(X\u0026amp;){ std::cout \u0026lt;\u0026lt; \u0026#34;g() for variable\\n\u0026#34;; } void g(X const\u0026amp;){ std::cout \u0026lt;\u0026lt; \u0026#34;g() for constant\\n\u0026#34;; } void g(X\u0026amp;\u0026amp;){ std::cout \u0026lt;\u0026lt; \u0026#34;g() for movable object\\n\u0026#34;; } template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; val){ g(std::forward\u0026lt;T\u0026gt;(val));\t// val is non-const lvalue =\u0026gt; calls g(X\u0026amp;) } int main() { X v; X const c; f(v); f(c); f(X()); f(std::move(v)); }   6.2 Special Member Function Templates æˆå‘˜å‡½æ•°æ¨¡æ¿ä¹Ÿå¯ç”¨ä½œç‰¹æ®Šæˆå‘˜å‡½æ•°æ¨¡æ¿ï¼ŒåŒ…æ‹¬æ„é€ å‡½æ•°ã€ææ„å‡½æ•°ç­‰ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #include \u0026lt;utility\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;iostream\u0026gt; class Person { private: std::string name; public: explicit Person(std::string const\u0026amp; n): name(n){ std::cout \u0026lt;\u0026lt; \u0026#34;copying string-COUSTR for \u0026#39;\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt;\u0026#34;\u0026#39;\\n\u0026#34;; } explicit Person(std::string\u0026amp;\u0026amp; n): name(std::move(n)){ std::cout \u0026lt;\u0026lt; \u0026#34;moving string-COUSTR for \u0026#39;\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt;\u0026#34;\u0026#39;\\n\u0026#34;; } Person(Person const\u0026amp; p): name(p.name){ std::cout \u0026lt;\u0026lt; \u0026#34;COPY-COUSTR Person \u0026#39;\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt;\u0026#34;\u0026#39;\\n\u0026#34;; } Person(Person const\u0026amp;\u0026amp; p): name(std::move(p.name)){ std::cout \u0026lt;\u0026lt; \u0026#34;MOVE-COUSTR Person \u0026#39;\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt;\u0026#34;\u0026#39;\\n\u0026#34;; } }; int main() { std::string s = \u0026#34;sname\u0026#34;; Person p1(s);\t// init with string object =\u0026gt; calls copying string-CONSTR  Person p2(\u0026#34;tmp\u0026#34;);\t// init with string literal =\u0026gt; cakks copying moving string-CONSTR  Person p3(p1);\t// copy Person =\u0026gt; calls COPY-CONSTR  Person p4(std::move(p1));\t// move Person =\u0026gt; calls MOVE-CONSTR }   ä½¿ç”¨å®Œç¾è½¬å‘æ”¹å†™ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #include \u0026lt;utility\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;iostream\u0026gt; class Person { private: std::string name; public: template\u0026lt;typename STR\u0026gt; explicit Person(STR\u0026amp;\u0026amp; n): name(std::forward\u0026lt;STR\u0026gt;(n)){ std::cout \u0026lt;\u0026lt; \u0026#34;TMPL-CONSTR for \u0026#39;\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } Person(Person const\u0026amp; p): name(p.name){ std::cout \u0026lt;\u0026lt; \u0026#34;COPY-COUSTR Person \u0026#39;\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt;\u0026#34;\u0026#39;\\n\u0026#34;; } Person(Person const\u0026amp;\u0026amp; p): name(std::move(p.name)){ std::cout \u0026lt;\u0026lt; \u0026#34;MOVE-COUSTR Person \u0026#39;\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt;\u0026#34;\u0026#39;\\n\u0026#34;; } };   æ­¤æ—¶ä¼ å…¥å­—ç¬¦ä¸²çš„æ„é€ å‡½æ•°èƒ½å¤Ÿæ­£å¸¸ä½¿ç”¨ï¼š\n1 2 3  std:;string s = \u0026#34;sname\u0026#34;; Person p1(s); Person p2(\u0026#34;tmp\u0026#34;);   è€Œ\n1 2  Person p3(p1);\t// ERROR Person p4(std::move(p1));\t// OK   è¿™æ˜¯ç”±äºC++é‡è½½è§„åˆ™ä¸­ï¼Œå¯¹äºéå¸¸é‡çš„å·¦å€¼å¯¹è±¡Person pï¼Œæˆå‘˜æ¨¡æ¿\n1 2  template\u0026lt;typename STR\u0026gt; Person(STR\u0026amp;\u0026amp; n)   æ¯”å¤åˆ¶æ„é€ å‡½æ•°\n1  Person(Person const\u0026amp; p)   æ›´åŠ åŒ¹é…ï¼Œè¿™é‡Œçš„è§£å†³æ–¹æ³•æ˜¯ä½¿ç”¨enable_if\n6.3 Disable Templates with enable_if C++11èµ·æä¾›äº†std::enable_if\u0026lt;\u0026gt;æ–¹æ³•åœ¨ç‰¹å®šçš„ç¼–è¯‘æœŸæ¡ä»¶ä¸‹å¿½ç•¥æŸäº›å‡½æ•°æ¨¡æ¿ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4 5  template\u0026lt;typename T\u0026gt; typename std::enable_if\u0026lt;(sizof(T) \u0026gt; 4)\u0026gt;::type foo(){ }   å½“sizeof(T)\u0026gt;4ä¸ºfalseæ—¶ï¼Œå°†å¿½ç•¥foo()çš„å£°æ˜å’Œå®šä¹‰\næ¦‚æ‹¬ä¸€ä¸‹ï¼Œstd::enable_if\u0026lt;\u0026gt;æ˜¯ä¸€ä¸ªç±»å‹ç‰¹å¾ï¼ˆtype traitï¼‰ï¼Œè®¡ç®—ç»™å®šæ¨¡æ¿å‚æ•°çš„ç¼–è¯‘æœŸè¡¨è¾¾å¼ï¼Œå¹¶ä½œå¦‚ä¸‹åŠ¨ä½œï¼š\n è‹¥è¡¨è¾¾å¼å¾—åˆ°trueï¼Œåˆ™å…¶ç±»å‹æˆå‘˜typeçš„ç»“æœæ˜¯ä¸€ä¸ªç±»å‹  å¦‚æœæ²¡æœ‰ç¬¬äºŒä¸ªæ¨¡æ¿å‚æ•°ï¼Œåˆ™ç±»å‹ä¸ºvoid å¦åˆ™ï¼Œå…¶ç±»å‹ä¸ºç¬¬äºŒä¸ªæ¨¡æ¿å‚æ•°çš„ç±»å‹   è‹¥è¡¨è¾¾å¼å¾—åˆ°falseï¼Œåˆ™æˆå‘˜typeå°†ä¸è¢«å®šä¹‰ï¼Œç”±äºæ¨¡æ¿çš„SFINAEï¼ˆSubstitution Failure Is Not An Errorï¼Œæ›¿æ¢å¤±è´¥ä¸æ˜¯ä¸€ä¸ªé”™è¯¯ï¼‰åŸåˆ™ï¼Œå°†ä½¿å¾—enable_ifåçš„è¡¨è¾¾å¼è¢«å¿½ç•¥  è‡ªC++14èµ·ï¼Œå¯ä»¥ç”¨std::enable_if_t\u0026lt;\u0026gt;ä»£æ›¿std::enable_if\u0026lt;\u0026gt;::type\nå¦‚æœä¼ å…¥äº†ç¬¬äºŒä¸ªå‚æ•°ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4 5  template\u0026lt;typename T\u0026gt; std::enable_if_t\u0026lt;(sizeof(T) \u0026gt; 4), T\u0026gt; foo(){ return T(); }   åˆ™å½“è¡¨è¾¾å¼ä¸ºtrueæ—¶ï¼Œæ•ˆæœä¸ºMyType foo()\nå¦‚æœè§‰å¾—æŠŠenable_ifæ”¾åœ¨ä¸­é—´ä¸å¥½çœ‹ï¼Œå¯ä»¥ä½œä¸ºä¸€ä¸ªé¢å¤–çš„é»˜è®¤å‡½æ•°æ¨¡æ¿å‚æ•°ï¼š\n1 2 3 4  template\u0026lt;typename T, typename = std::enable_if_t\u0026lt;(sizeof(T) \u0026gt; 4)\u0026gt;\u0026gt; void foo(){ }   å½“sizeof(T) \u0026gt; 4æ—¶ï¼Œå°†å˜ä¸ºï¼š\n1 2 3 4  template\u0026lt;typename T, typename = void\u0026gt; void foo(){ }   å¦‚æœè¿˜æ˜¯è§‰å¾—ä¸å¥½çœ‹ï¼Œæƒ³å°½é‡å°†é™åˆ¶åšå¾—æ›´åŠ éšå¼ï¼Œå¯ä»¥ä½¿ç”¨alias templatesï¼š\n1 2 3 4 5 6 7  template\u0026lt;typename T\u0026gt; using EnableIfSizeGreater4 = std::enable_if_t\u0026lt;(sizeof(T) \u0026gt; 4)\u0026gt;; template\u0026lt;typename T, typename = EnableIfSizeGreater4\u0026lt;T\u0026gt;\u0026gt; void foo(){ }   6.4 Using enable_if\u0026lt;\u0026gt; enable_if\u0026lt;\u0026gt;èƒ½å¤Ÿç”¨æ¥è§£å†³æ„é€ å‡½æ•°æ¨¡æ¿çš„é—®é¢˜ï¼Œæˆ‘ä»¬å¸Œæœ›å½“ä¼ å…¥çš„å®å‚STRæœ‰å³å€¼ç±»å‹æ—¶ï¼Œç¦ç”¨æ¨¡æ¿æ„é€ å‡½æ•°\n1 2  template\u0026lt;typename STR\u0026gt; Person(STR\u0026amp;\u0026amp; n);   è¿™é‡Œä½¿ç”¨å¦å¤–ä¸€ä¸ªç±»å‹ç‰¹å¾std::is_convertible\u0026lt;FROM, TO\u0026gt;ï¼Œåœ¨C++17ä¸­ï¼Œç›¸å…³çš„å£°æ˜ä¸ºï¼š\n1 2  template\u0026lt;typename STR, typename = std::enable_if_t\u0026lt;std::is_convertible_v\u0026lt;STR, std::string\u0026gt;\u0026gt;\u0026gt; Person(STR\u0026amp;\u0026amp; n);   è‹¥STRèƒ½å¤Ÿè½¬ä¸ºstd::stringï¼Œåˆ™å£°æ˜å±•å¼€ä¸ºï¼š\n1 2  template\u0026lt;typename STR, typename = void\u0026gt; Person(STR\u0026amp;\u0026amp; n);   å¦åˆ™å°†å¿½ç•¥è¯¥å‡½æ•°æ¨¡æ¿\nä¼˜åŒ–åçš„ä»£ç å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include \u0026lt;utility\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;type_traits\u0026gt; template\u0026lt;typename T\u0026gt; using EnableIfString = std::enable_if_t\u0026lt;std::is_convertible_v\u0026lt;T, std::string\u0026gt;\u0026gt;; class Person { private: std::string name; public: template\u0026lt;typename STR, typename = EnableIfString\u0026lt;STR\u0026gt;\u0026gt; explicit Person(STR\u0026amp;\u0026amp; n): name(std::forward\u0026lt;STR\u0026gt;(n)){ std::cout \u0026lt;\u0026lt; \u0026#34;TMPL-CONSTR for \u0026#39;\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } Person(Person const\u0026amp; p): name(p.name){ std::cout \u0026lt;\u0026lt; \u0026#34;COPY-COUSTR Person \u0026#39;\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt;\u0026#34;\u0026#39;\\n\u0026#34;; } Person(Person const\u0026amp;\u0026amp; p): name(std::move(p.name)){ std::cout \u0026lt;\u0026lt; \u0026#34;MOVE-COUSTR Person \u0026#39;\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt;\u0026#34;\u0026#39;\\n\u0026#34;; } };   Disable Special Member Functions\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬æ— æ³•ä½¿ç”¨enable_ifæ¥ç¦ç”¨é¢„å®šä¹‰çš„å¤åˆ¶ã€ç§»åŠ¨æ„é€ å‡½æ•°å’Œèµ‹å€¼è¿ç®—ç¬¦ã€‚è¿™æ˜¯ç”±äºæˆå‘˜å‡½æ•°æ¨¡æ¿æ°¸è¿œä¸å±äºç‰¹æ®Šæˆå‘˜å‡½æ•°çš„ä¸€ç§ï¼Œå½“éœ€è¦è°ƒç”¨ä¸€ä¸ªå¤åˆ¶æ„é€ å‡½æ•°æ—¶ï¼Œå³ä½¿æ˜¯æœ‰å¦‚ä¸‹å£°æ˜ï¼š\n1 2 3 4 5 6 7 8  class C{ public: template\u0026lt;typename T\u0026gt; C(T const\u0026amp;){ std::cout \u0026lt;\u0026lt; \u0026#34;tmpl copy constructor\\n\u0026#34;; } ... };   é¢„å®šä¹‰çš„å¤åˆ¶æ„é€ å‡½æ•°ä»ä¼šè¢«è°ƒç”¨\n1 2  C x; C y{x};   å› ä¸ºæ²¡åŠæ³•æ¨æ–­æˆ–æŒ‡å®šæ¨¡æ¿å‚æ•°T\nä¸è¿‡æœ‰ä¸ªæŠ€å·§å¯ä»¥å®ç°å¤åˆ¶æ„é€ å‡½æ•°çš„â€åˆ é™¤â€œï¼Œåªéœ€è¦å£°æ˜ä¸€ä¸ªç”¨äºconst volatileå®å‚çš„å¤åˆ¶æ„é€ å‡½æ•°å¹¶å°†å…¶æ ‡ä¸ºdeleteï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13  class C { public: ... C(C const volatile\u0026amp;) = delete; template\u0026lt;typename T\u0026gt; C(T const\u0026amp;) { std::cout \u0026lt;\u0026lt; \u0026#34;tmpl copy constructor\\n\u0026#34;; } ... };   è¿™æ ·åšèƒ½å¤Ÿé˜²æ­¢å…¶ä»–çš„å¤åˆ¶æ„é€ å‡½æ•°éšå¼å£°æ˜ï¼Œæ­¤æ—¶è°ƒç”¨å¤åˆ¶æ„é€ å‡½æ•°å°†ä¼˜å…ˆä½¿ç”¨å‡½æ•°æ¨¡æ¿ï¼Œç„¶åä¾¿å¯ä¸ºå¤åˆ¶æ„é€ å‡½æ•°å¢åŠ é™åˆ¶ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class C { public: ... C(C const volatile\u0026amp;) = delete; // if U is not integral, provide copy constructor template with better match  template\u0026lt;typename U, typename = std::enable_if\u0026lt;!std::is_integral\u0026lt;U\u0026gt;::value\u0026gt;\u0026gt; C(C\u0026lt;U\u0026gt; const\u0026amp;) { ... } ... };   6.5 Using Concepts to Simplify enable_if\u0026lt;\u0026gt; Expressions å¦‚æœè§‰å¾—ç”¨enable_if\u0026lt;\u0026gt;æ¥é™åˆ¶æ¨¡æ¿å‡½æ•°è¿˜æ˜¯å¤ªä¸‘äº†ï¼Œå¯ä»¥ä½¿ç”¨conceptsæ¥ç®€åŒ–enable_if\u0026lt;\u0026gt;\nä¾‹å¦‚ï¼š\n1 2 3 4 5 6 7  template\u0026lt;typename STR\u0026gt; concept ConvertibleToString = std::is_convertible_v\u0026lt;T, std::string\u0026gt;; template\u0026lt;ConvertibleToString STR\u0026gt; Person(STR\u0026amp;\u0026amp; n): name(std::forward\u0026lt;STR\u0026gt;(n)){ ... }   6.6 Summary  In templates, you can â€œperfectlyâ€ forward parameters by declaring them as forwarding references (declared with a type formed with the name of a template parameter followed by \u0026amp;\u0026amp;) and using std::forward\u0026lt;\u0026gt;() in the forwarded call When using perfect forwarding member function templates, they might match better than the predefined special member function to copy or move objects With std::enable_if\u0026lt;\u0026gt;, you can disable a function template when a compile-time condition is false (the template is then ignored once that condition has been determined) By using std::enable_if\u0026lt;\u0026gt; you can avoid problems when constructor templates or assignment operator templates that can be called for single arguments are a better match than implicitly generated special member functions You can templify (and apply enable_if\u0026lt;\u0026gt;) to special member functions by deleting the predefined special member functions for const volatile Concepts will allow us to use a more intuitive syntax for requirements on function templates.  ","description":"ã€ŠC++ Templateså­¦ä¹ ç¬”è®°ç¬¬å…­ç« ã€‹","id":3,"section":"note","tags":["C++ Templates","C++"],"title":"Chapter 6: Move Semantics and enable_if\u003c\u003e","uri":"https://chaphlagical.github.io/zh/note/cpptemplate/ch6/"},{"content":"5.1 Keyword typename å…³é”®è¯typenameç”¨äºæŒ‡æ˜æ¨¡æ¿ä¸­çš„ä¸€ä¸ªæ ‡è¯†ç¬¦æ˜¯ä¸€ä¸ªç±»å‹ã€‚ä¾‹å¦‚ï¼š\n1 2 3 4 5 6 7 8  template\u0026lt;typename T\u0026gt; class MyClass{ public: ... void foo(){ typename T::SubType* ptr; } }   è¿™é‡ŒSubTypeæ˜¯ç±»Tä¸­å®šä¹‰çš„ä¸€ä¸ªç±»å‹ï¼Œptræ˜¯æŒ‡å‘T::SubTypeç±»å‹çš„ä¸€ä¸ªæŒ‡é’ˆã€‚å¦‚æœæ²¡æœ‰å…³é”®è¯typenameï¼Œåˆ™SubTypeä¼šè¢«å‡å®šä¸ºä¸€ä¸ªéç±»å‹æˆå‘˜å˜é‡\nåº”ç”¨ï¼šSTLè¿­ä»£å™¨\n1 2 3 4 5 6 7 8 9  template\u0026lt;typename T\u0026gt; void printcoll(T const\u0026amp; coll) { typename T::const_iterator pos; typename T::const_iterator end(coll.end()); for(pos = coll.begin(); pos!=end; ++pos) std::cout \u0026lt;\u0026lt; *pos \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   åœ¨STLå®¹å™¨å†…éƒ¨æœ‰å¦‚ä¸‹å£°æ˜ï¼š\n1 2 3 4 5 6  class stlcontainer{ public: using iterator = ...; using const_iterator = ...; ... };   5.2 Zero Initialization å¯¹äºå†…ç½®ç±»å‹å¦‚intã€floatã€æŒ‡é’ˆç­‰ï¼Œç”±äºæ²¡æœ‰é»˜è®¤æ„é€ å‡½æ•°è¿›è¡Œåˆå§‹åŒ–ï¼Œéåˆå§‹åŒ–çš„å±€éƒ¨å˜é‡éƒ½æ˜¯æœªå®šçš„\nåœ¨C++11ä»¥å‰ï¼Œç”¨()è¿›è¡Œé›¶åˆå§‹åŒ–ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  template\u0026lt;typename T\u0026gt; class MyClass{ private: T x; public: MyClass(): x(){} ... } template\u0026lt;typename T\u0026gt; void foo() { T x = T(); } template\u0026lt;typename T\u0026gt; void foo(T p = T()) { ... }   åœ¨C++11ä¹‹åï¼Œç”¨{}è¿›è¡Œé›¶åˆå§‹åŒ–ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  template\u0026lt;typename T\u0026gt; class MyClass{ private: T x; public: MyClass(): x{}{} ... } template\u0026lt;typename T\u0026gt; class MyClass{ private: T x{}; ... } template\u0026lt;typename T\u0026gt; void foo() { T x{}; } template\u0026lt;typename T\u0026gt; void foo(T p = T{}) { ... }   5.3 Using this-\u0026gt; å¯¹äºå¸¦æœ‰ä¾èµ–æ¨¡æ¿å‚æ•°åŸºç±»çš„ç±»æ¨¡æ¿ï¼Œä½¿ç”¨è‡ªå·±çš„xå¾€å¾€ä¸this-\u0026gt;xä¸åŒï¼Œå³ä½¿æˆå‘˜xè¢«ç»§æ‰¿ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13  template\u0026lt;typename T\u0026gt; class Base{ public: void bar(); }; template\u0026lt;typename T\u0026gt; class Derived: Base\u0026lt;T\u0026gt;{ public: void foo(){ bar();\t// calls external bar() or error  } };   è¿™é‡Œå­ç±»è°ƒç”¨baråªä¼šè°ƒç”¨å¤–éƒ¨çš„æˆ–ç›´æ¥å‡ºé”™ï¼Œæ­£ç¡®çš„åšæ³•æ˜¯ä½¿ç”¨this-\u0026gt;æˆ–Base\u0026lt;T\u0026gt;::\n5.4 Templates for Raw Arrays and String Literals å½“ä¼ é€’åŸå§‹æ•°ç»„æˆ–å­—ç¬¦ä¸²ç»™æ¨¡æ¿æ—¶ï¼Œéœ€è¦æ³¨æ„ï¼Œå½“ä¼ å…¥å‚æ•°ä¸ºå¼•ç”¨æ—¶ï¼Œå®å‚ä¸å‘ç”Ÿé€€åŒ–ï¼Œä¹Ÿå°±æ˜¯è¯´\u0026quot;Hello\u0026quot;çš„ç±»å‹å³ä¸ºchar const[6]ã€‚åªæœ‰å½“æŒ‰å€¼ä¼ é€’æ—¶ï¼Œç±»å‹å¯é€€åŒ–ï¼Œå­—ç¬¦ä¸²å¯ä»¥è½¬æ¢ä¸ºchar const*sh\nç¤ºä¾‹ï¼š\n1 2 3 4 5 6 7 8 9 10  template\u0026lt;typename T, int N, int M\u0026gt; bool less(T(\u0026amp;a)[N], T(\u0026amp;b)[M]) { for(int i = 0; i \u0026lt; N \u0026amp;\u0026amp; i \u0026lt; M; ++i) { if(a[i]\u0026lt;b[i])return true; if(b[i]\u0026lt;a[i])return false; } return N \u0026lt; M; }   5.5 Member Templates ç±»æˆå‘˜ä¹Ÿå¯ä»¥æ˜¯æ¨¡æ¿ï¼Œä¸»è¦æ˜¯å¯¹äºæˆå‘˜å‡½æ•°å’ŒåµŒå¥—ç±»ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  template\u0026lt;typename T\u0026gt; class Stack{ private: std::deque\u0026lt;T\u0026gt; elems; public: void push(T const\u0026amp;); void pop(); T const\u0026amp; top() const; bool empty() const{ return elems.empty(); } template\u0026lt;typename T2\u0026gt; Stack\u0026amp; operator=(Stack\u0026lt;T2\u0026gt; const\u0026amp;); template\u0026lt;typename\u0026gt; friend class Stack; };   ä¸Šè¿°ä»£ç å…è®¸æˆ‘ä»¬å¯¹ä¸åŒç±»å‹çš„Stackè¿›è¡Œèµ‹å€¼ï¼Œä¾‹å¦‚ï¼š\n1 2 3  Stack\u0026lt;int\u0026gt; intStack; Stack\u0026lt;float\u0026gt; floatStack; floatStack = intStack;   ç±»æˆå‘˜æ¨¡æ¿çš„å®šä¹‰ä¸å¤šå‚æ•°æ¨¡æ¿çš„å®šä¹‰æœ‰æ‰€ä¸åŒï¼š\n1 2 3 4 5 6 7 8 9 10 11 12  template\u0026lt;typename T\u0026gt; template\u0026lt;typename T2\u0026gt; Stack\u0026lt;T\u0026gt;\u0026amp; Stack\u0026lt;T\u0026gt;::operator= (Stack\u0026lt;T2\u0026gt; const\u0026amp; op2) { Stack\u0026lt;T2\u0026gt; tmp(op2); elems.clear(); elems.insert(elems.begin(), op2.elems.begin(), op2.elems.end()); return *this; }   å½“ç„¶ä¸Šè¿°å®éªŒæœ‰ä¸€å®šçš„å±€é™æ€§ï¼Œæ¯”å¦‚ä¸èƒ½æ”¯æŒstd::stringå‹å’Œintå‹è¿™ç§ä¸å¯è½¬æ¢ç±»å‹çš„ç±»çš„èµ‹å€¼\nSpecialization of Member Function Templates\næˆå‘˜å‡½æ•°æ¨¡æ¿å¯è¢«åç‰¹åŒ–æˆ–å…¨ç‰¹åŒ–ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4 5 6 7 8 9 10 11  class BoolString{ private: std::string value; public: BoolString(std::string const\u0026amp; s) :value(s){} template\u0026lt;typename T = std::string\u0026gt; T get() const{ return value; } };   å…¨ç‰¹åŒ–ï¼š\n1 2 3 4  template\u0026lt;\u0026gt; inline bool BoolString::get\u0026lt;bool\u0026gt;() const{ return value == \u0026#34;true\u0026#34; || value == \u0026#34;1\u0026#34; || value == \u0026#34;on\u0026#34;; }   Special Member Function Templates\nåªè¦ç‰¹æ®Šå‡½æ•°å…è®¸ï¼Œå°±å¯ä»¥ä½¿ç”¨æ¨¡æ¿æˆå‘˜å‡½æ•°è¿›è¡Œå¯¹è±¡çš„å¤åˆ¶æˆ–ç§»åŠ¨ã€‚åŒæ ·çš„ï¼Œæ„é€ å‡½æ•°ä¹Ÿå¯ä¸ºæ¨¡æ¿å‡½æ•°ã€‚ä½†æ˜¯æ³¨æ„æ¨¡æ¿æ„é€ å‡½æ•°å’Œæ¨¡æ¿èµ‹å€¼å‡½æ•°ä¸èƒ½æ›¿æ¢é¢„å®šä¹‰çš„æ„é€ å‡½æ•°æˆ–èµ‹å€¼è¿ç®—ç¬¦\nä¼˜ç‚¹ï¼šæ¨¡æ¿æ„é€ å‡½æ•°æˆ–èµ‹å€¼å‡½æ•°å¯èƒ½æ¯”é¢„å®šä¹‰çš„å¤åˆ¶ã€ç§»åŠ¨æ„é€ å‡½æ•°æˆ–èµ‹å€¼è¿ç®—ç¬¦æ›´åŒ¹é…\nç¼ºç‚¹ï¼šä¸å®¹æ˜“æ¨¡æ¿åŒ–å¤åˆ¶/ç§»åŠ¨æ„é€ å‡½æ•°\n5.5.1 The .template Construct æœ‰æ—¶å€™åœ¨è°ƒç”¨æˆå‘˜æ¨¡æ¿æ—¶å¯èƒ½éœ€è¦æ˜¾å¼è°ƒç”¨æ¨¡æ¿å‚æ•°ï¼Œè¿™æ—¶éœ€è¦ç”¨templateå…³é”®å­—æ¥ç¡®ä¿\u0026lt;ç¬¦å·ä¸ºæ¨¡æ¿å‚æ•°åˆ—è¡¨çš„å¼€å§‹ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4 5  template\u0026lt;unsigned long N\u0026gt; void printBitset(std::bitset\u0026lt;N\u0026gt; const\u0026amp; bs) { std::cout \u0026lt;\u0026lt; bs.template to_string\u0026lt;char, std::char_traits\u0026lt;char\u0026gt;, std::allocator\u0026lt;char\u0026gt;\u0026gt;(); }   5.5.2 Generic Lambdas and Member Templates C++14ä¹‹åæ¨å‡ºGeneric Lambdaçš„æ¦‚å¿µï¼Œå®ƒæ˜¯ç›¸åº”æˆå‘˜æ¨¡æ¿çš„ç®€å†™ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4  [](auto x, auto y) { return x + y; }   ä¸ä¸‹è¿°ä»£ç ä½œç”¨ç­‰åŒï¼š\n1 2 3 4 5 6  struct unnamed_lambda { template\u0026lt;typename T, typename U\u0026gt; auto operator()(T x, U y) const {return x + y;} }; auto lambda = unnamed_lambda();   5.6 Variable Templates è‡ªC++14èµ·ï¼Œå˜é‡ä¹Ÿå¯è¢«æ¨¡æ¿åŒ–ï¼Œç§°ä¸ºå˜é‡æ¨¡æ¿ï¼Œä¾‹å¦‚ï¼š\n1 2  template\u0026lt;typename T\u0026gt; constexpr T pi{3.1415926535};   ç”¨æ³•ï¼š\n1 2  std::cout \u0026lt;\u0026lt; pi\u0026lt;double\u0026gt; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; pi\u0026lt;float\u0026gt; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;   ä¹Ÿå¯ä»¥æœ‰é»˜è®¤æ¨¡æ¿å‚æ•°ï¼š\n1 2  template\u0026lt;typename T = long double\u0026gt; constexpr T pi{3.1415926535};   ä½†æ˜¯è°ƒç”¨æ—¶å¿…é¡»å¸¦æœ‰å°–æ‹¬å·ï¼š\n1 2 3  std::cout \u0026lt;\u0026lt; pi\u0026lt;\u0026gt; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\t// OK std::cout \u0026lt;\u0026lt; pi\u0026lt;float\u0026gt; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\t// OK std::cout \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\t// ERROR   å˜é‡æ¨¡æ¿å‚æ•°ä¹Ÿå¯ä»¥ä¸ºéç±»å‹å‚æ•°ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4 5  template\u0026lt;size_t N\u0026gt; std::array\u0026lt;int, N\u0026gt; arr{}; template\u0026lt;auto N\u0026gt; constexpr decltype(N) dval = N;\t//dvalçš„ç±»å‹å–å†³äºä¼ å…¥çš„å‚æ•°   Variable Templates for Data Members\nå˜é‡æ¨¡æ¿å¯ä»¥ç”¨äºè¡¨ç¤ºæ¨¡æ¿ç±»æˆå‘˜å˜é‡ï¼Œä¾‹å¦‚æœ‰æ¨¡æ¿ç±»ï¼š\n1 2 3 4 5  template\u0026lt;typename T\u0026gt; class MyClass{ public: static constexpr int max = 1000; };   ä½¿ç”¨usingï¼š\n1 2  template\u0026lt;typename T\u0026gt; int myMax = MyClass\u0026lt;T\u0026gt;::max;   ä½¿ç”¨æ—¶ï¼Œåˆ™å¯ä»¥ç”¨ï¼š\n1  auto i = myMax\u0026lt;std::string\u0026gt;;   æ•ˆæœç­‰åŒäºï¼š\n1  auto i = MyClass\u0026lt;std::string\u0026gt;::max;   Type Traits Suffix_v\nè‡ªC++17èµ·ï¼Œå¯ä»¥ä½¿ç”¨_våç¼€çš„ç®€å†™\n1 2  std::is_const_v\u0026lt;T\u0026gt;;\t// C++17 std::is_const\u0026lt;T\u0026gt;::value;// C++11   æ ‡å‡†åº“ä¸­å®šä¹‰äº†ï¼š\n1 2 3  namespace std{ template\u0026lt;typename T\u0026gt; constexpr bool is_const_v = is_const\u0026lt;T\u0026gt;::value; }   5.7 Template Template Parameters æ­¤å‰è®¨è®ºçš„Stackç±»å¦‚è¦æŒ‡æ˜å­˜å‚¨çš„å®¹å™¨ç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨\n1  StacK\u0026lt;int, std::vector\u0026lt;int\u0026gt;\u0026gt; vStack;   è‹¥ä½¿ç”¨æ¨¡æ¿çš„æ¨¡æ¿å‚æ•°ï¼Œå…è®¸å¦‚ä¸‹å®šä¹‰ï¼š\n1  StacK\u0026lt;int, std::vector\u0026gt; vStack;   æ¨¡æ¿çš„æ¨¡æ¿å‚æ•°å£°æ˜ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  template\u0026lt;typename T, template\u0026lt;typename Elem\u0026gt; class Cont = std::deque\u0026gt; class Stack{ private: Cont\u0026lt;T\u0026gt; elems; public: void push(T const\u0026amp;); void pop(); T const\u0026amp; top() const; bool empty() const{ return elems.empty(); } ... };   C++11ä¹‹å‰ï¼Œå£°æ˜åªèƒ½ä½¿ç”¨classå…³é”®å­—ï¼š\n1 2 3 4  template\u0026lt;typename T, template\u0026lt;class Elem\u0026gt; class Cont = std::deque\u0026gt; class Stack{ ... };   åˆ°C++17ä¹‹åæ‰æ”¯æŒtypenameå…³é”®å­—\n1 2 3 4  template\u0026lt;typename T, template\u0026lt;typename Elem\u0026gt; class Cont = std::deque\u0026gt; class Stack{ ... };   åŒæ—¶ä¹Ÿå¯ä»¥çœç•¥åœ°å†™ä¸ºï¼š\n1 2 3 4  template\u0026lt;typename T, template\u0026lt;typename\u0026gt; class Cont = std::deque\u0026gt; class Stack{ ... };   åŒæ ·åœ°ï¼Œåœ¨å®ç°ä¸Šä¹Ÿåº”æ ‡æ˜æ˜¯æ¨¡æ¿çš„æ¨¡æ¿å‚æ•°ï¼š\n1 2 3 4 5  template\u0026lt;typename T, template\u0026lt;typename\u0026gt; class Cont\u0026gt; void Stack\u0026lt;T, Cont\u0026gt;::push(T const\u0026amp; elem) { elems.push_back(elem); }   Template Template Argument Matching\nä½†æ˜¯äº‹å®ä¸Šï¼Œä¸Šè¿°çš„ä»£ç ä¼šæŠ¥ä¸€ä¸ªæ¨¡æ¿åˆ—è¡¨ä¸åŒ¹é…çš„é”™è¯¯ï¼Œè¿™æ˜¯ç”±äºåœ¨å£°æ˜æ¨¡æ¿çš„æ¨¡æ¿å‚æ•°æ—¶ï¼Œæ¨¡æ¿å‚æ•°åˆ—è¡¨å¿…é¡»ä¸é»˜è®¤çš„æ¨¡æ¿å‡½æ•°çš„å‚æ•°åˆ—è¡¨ä¸€æ¨¡ä¸€æ ·ï¼Œæ ‡å‡†åº“ä¸­dequeçš„å£°æ˜åº”ä¸ºï¼š\n1 2 3 4  template \u0026lt;class _Ty, class _Alloc = allocator\u0026lt;_Ty\u0026gt;\u0026gt; class deque { ... }   å› æ­¤åŸç±»æ¨¡æ¿åº”æ”¹å†™ä¸ºï¼š\n1 2 3 4 5 6 7 8  template\u0026lt;typename T, template\u0026lt;typename Elem, typename Alloc = std::allocator\u0026lt;Elem\u0026gt; class Cont = std::deque\u0026gt; class Stack{ private: Cont\u0026lt;T\u0026gt; elems; ... };   å®Œæ•´çš„æ¨¡æ¿ç±»Stackå£°æ˜ä¸å®šä¹‰å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  template\u0026lt;typename T, template\u0026lt;typename Elem, typename Alloc = std::allocator\u0026lt;Elem\u0026gt; class Cont = std::deque\u0026gt; class Stack{ private: Cont\u0026lt;T\u0026gt; elems; public: void push(T const\u0026amp;); void pop(); T const\u0026amp; top() const; bool empty() const{ return elems.empty(); } template\u0026lt;typename T2, template\u0026lt;typename Elem2, typename = std::allocator\u0026lt;Elem2\u0026gt; class Cont2\u0026gt; Stack\u0026lt;T, Cont\u0026gt;\u0026amp; operator= (Stack\u0026lt;T2, Cont2\u0026gt; const\u0026amp;); template\u0026lt;typename,template\u0026lt;typename, typename\u0026gt;class\u0026gt; friend class Stack; }; template\u0026lt;typename T, template\u0026lt;typename, typename\u0026gt; class Cont\u0026gt; void Stack\u0026lt;T, Cont\u0026gt;::push(T const\u0026amp; elem) { elems.push_back(elem); } template\u0026lt;typename T, template\u0026lt;typename, typename\u0026gt; class Cont\u0026gt; void Stack\u0026lt;T, Cont\u0026gt;::pop() { assert(!elems.empty()); elems.pop_back(); } template\u0026lt;typename T, template\u0026lt;typename, typename\u0026gt; class Cont\u0026gt; T const\u0026amp; Stack\u0026lt;T, Cont\u0026gt;::top() const { assert(!elems.empty()); return elems.back(); } template\u0026lt;typename T, template\u0026lt;typename, typename\u0026gt; class Cont\u0026gt; template\u0026lt;typename T2, template\u0026lt;typename, typename\u0026gt; class Cont2\u0026gt; Stack\u0026lt;T, Cont\u0026gt;\u0026amp; Stack\u0026lt;T, Cont\u0026gt;::operator=(Stack\u0026lt;T2,Cont2\u0026gt; const\u0026amp; op2) { elems.clear(); elems.insert(elems.begin(), op2.elems.begin(), op2.elems.end()); return *this; }   5.8 Summary  To access a type name that depends on a template parameter, you have to qualify the name with a leading typename To access members of bases classes that depend on template parameters, you have to qualify the access by this-\u0026gt; or their class name Nested classes and member functions can also be templates. One application is the ability to implement generic operations with internal type conversions Template versions of constructors or assignment operators donâ€™t replace predefined constructors or assignment operators By using braced initialization or explicitly calling a default constructor, you can ensure that variables and members of templates are initialized with a default value even if they are instantiated with a built-in type You can provide specific templates for raw arrays, which can also be applicable to string literals When passing raw arrays or string literals, arguments decay (perform an array-to-pointer conversion) during argument deduction if and only if the parameter is not a reference You can define variable templates (since C++14) You can also use class templates as template parameters, as template template parameters Template template arguments must usually match their parameters exactly.  ","description":"ã€ŠC++ Templateså­¦ä¹ ç¬”è®°ç¬¬äº”ç« ã€‹","id":4,"section":"note","tags":["C++ Templates","C++"],"title":"Chapter 5: Tricky Basics","uri":"https://chaphlagical.github.io/zh/note/cpptemplate/ch5/"},{"content":"E.1 Using Concepts E.1.1 Dealing with Requirements ä¸ºæ¨¡æ¿å‡½æ•°æ·»åŠ çº¦æŸï¼š\n1 2 3 4 5  template\u0026lt;typename T\u0026gt; requires LessThanComparable\u0026lt;T\u0026gt; T max(T a, T b) { return b \u0026lt; a? a: b; }    conceptæ˜¯ä¸€ä¸ªå¸¸é‡è¡¨è¾¾å¼çš„å¸ƒå°”æ–­è¨€ï¼Œåœ¨ç¼–è¯‘æœŸè¿è¡Œ æ¨¡æ¿åªæœ‰åœ¨æ»¡è¶³è¦æ±‚çš„æ—¶å€™æ‰ä¼šè¢«å®ä¾‹åŒ–  E.1.2 Dealing with Multiple Requirements å¤šæ¦‚å¿µè¦æ±‚ï¼š\n1 2 3 4 5 6  template\u0026lt;typename Seq\u0026gt; requires Sequence\u0026lt;Seq\u0026gt;\u0026amp;\u0026amp;EqualityComparable\u0026lt;typename Seq::value_type\u0026gt; typename Seq::iterator find(Seq const\u0026amp; seq, typename Seq::value_type const\u0026amp; val) { return std::find(seq.begin(),seq.end(),val); }   é™¤äº†\u0026amp;\u0026amp;è¿˜æ”¯æŒ||ï¼Œä¾‹å¦‚ï¼š\n1 2 3  template\u0026lt;typename T\u0026gt; requires Integral\u0026lt;T\u0026gt; || FloatingPoint\u0026lt;T\u0026gt; T power(T b,T p);   åŒæ—¶å•è¦æ±‚ä¹Ÿæ”¯æŒå¤šæ¨¡æ¿å‚æ•°ï¼Œä¾‹å¦‚ï¼š\n1 2 3  template\u0026lt;typename T, typename U\u0026gt; requires SomeConcept\u0026lt;T, U\u0026gt; auto f(T x, U y) -\u0026gt; decltype(x+y)   E.1.3 Shorthand Notation for Single Requirements å•è¦æ±‚æ—¶å¯ä»¥æŠŠæ¦‚å¿µå¡åœ¨æ¨¡æ¿å‚æ•°å£°æ˜ä¸­è¿›è¡Œç®€å†™\n1 2 3 4  template\u0026lt;LessThanComparable T\u0026gt; T max(T a, T b){ return b \u0026lt; a ? a : b; }   å¤šäºå¤šè¦æ±‚ï¼Œä¹Ÿæ˜¯å¯ä»¥çš„ï¼š\n1 2 3 4 5 6  template\u0026lt;Sequence Seq\u0026gt; requires EqualityComparable\u0026lt;typename Seq::value_type\u0026gt; typename Seq::iterator find(Seq const\u0026amp; seq, typename Seq::value_type const\u0026amp; val) { return std::find(seq.begin(),seq.end(),val); }   E.2 Defining Concepts å‰é¢æåˆ°çš„LessThanComparableå¯ä»¥æœ‰å¦‚ä¸‹å®ç°ï¼š\n1 2 3 4  template\u0026lt;typename T\u0026gt; concept LessThanComparable = requires(T x, T y){ { x \u0026lt; y } -\u0026gt; bool; };   è¿™é‡Œï¼Œx\u0026lt;yï¼š\n å¿…é¡»æ˜¯SFINAEæ„ä¹‰ä¸‹æ˜¯æœ‰æ•ˆ ä¸”ç»“æœå¯ä»¥è½¬åŒ–ä¸ºboolå‹  è¿™ç§è¡¨è¾¾ä¸‹å¯ä»¥åœ¨-\u0026gt;å‰æ’å…¥å…³é”®å­—noexceptè¡¨ç¤ºèŠ±æ‹¬å·å†…çš„è¡¨è¾¾å¼ä¸åº”æŠ›å‡ºå¼‚å¸¸ï¼Œä¸”è¡¨è¾¾å¼åº”ä¸ºtrue\nå¦‚æœæ²¡æœ‰è¿™ç§é™åˆ¶ï¼Œåªæ£€æŸ¥è¡¨è¾¾å¼çš„æœ‰æ•ˆæ€§ï¼Œå¯ä»¥å»æ‰å¤§æ‹¬å·ï¼Œç®€åŒ–ä¸ºä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå¦‚ï¼š\n1 2 3 4  template\u0026lt;typename T\u0026gt; concept Swappable = requires(T x, T y){ swap(x,y); };   Requiresè¡¨è¾¾å¼è¿˜å¯ä»¥è¡¨è¾¾å…³è”ç±»å‹çš„éœ€æ±‚ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4 5 6 7  template\u0026lt;typename Seq\u0026gt; concept Sequence = requires(Seq seq){ typename Seq::iterator; requires Iterator\u0026lt;typename Seq::iterator\u0026gt;; {seq.begin()} -\u0026gt; Seq::iterator; ... };   è¿™é‡Œï¼Œæ–¹æ³•seq.begin()çš„å­˜åœ¨è¿˜éœ€è¦Seq::iteratorçš„å­˜åœ¨ï¼Œè¿™ç§æ–¹æ³•ç§°ä¸ºnested requirement\nE.3 Overloading on Constraints åˆ©ç”¨çº¦æŸè¿›è¡Œé‡è½½ï¼Œä¾‹å¦‚ï¼š\n1 2  template\u0026lt;IntegerLike T\u0026gt; void print(T val); template\u0026lt;StringLike T\u0026gt; void print(T val);   å¦‚æœæ²¡æœ‰çº¦æŸIntegerLikeå’ŒStringLikeï¼Œä¸Šè¿°å£°æ˜å°†è¡¨è¾¾åŒä¸€ä¸ªæ¨¡æ¿å‡½æ•°\nE.3.1 Constraint Subsumption æœ‰çš„æ—¶å€™é™åˆ¶æ˜¯ä¸æ˜¯äº’æ–¥çš„è€Œæ˜¯ç›¸äº’åŒ…å«çš„ï¼Œæ¯”å¦‚C++æ ‡å‡†åº“ä¸­çš„è¿­ä»£å™¨åˆ†ç±»ï¼šinput iteratorï¼Œforward iteratorï¼Œbidirectional iteratorï¼Œrandom access iteratorï¼Œåœ¨C++17ä¸­è¿˜æœ‰contiguous iterator\nå‡è®¾æˆ‘ä»¬å·²ç»å®šä¹‰äº†ä¸€ä¸ªForwardIterator\n1 2  template\u0026lt;typename T\u0026gt; concept ForwardIterator = ...;   ç°åœ¨æœ‰BidirectionalIteratorå®šä¹‰ä¸ºï¼š\n1 2 3 4 5 6  template\u0026lt;typename T\u0026gt; concept BidirectionalIterator = ForwardIterator\u0026lt;T\u0026gt; \u0026amp;\u0026amp; requires(T it){ {--it} -\u0026gt; T\u0026amp; };   è¿™æ ·æˆ‘ä»¬åœ¨ForwardIteratoråŸºç¡€ä¸Šæ·»åŠ äº†å‰ç¼€æ“ä½œç¬¦--çš„é™åˆ¶\nç°åœ¨è€ƒè™‘ä¸€ä¸ªç”¨ForwardIteratorå’ŒBidirectionalIteratoré‡è½½çš„advanceIteræ–¹æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  template\u0026lt;ForwardIterator T, typename D\u0026gt; void advanceIter(T\u0026amp; it, D n) { assert(n\u0026gt;=0); for(; n!=0; --n){ ++it; } } template\u0026lt;BidirectionalIterator T, typename D\u0026gt; void advanceIter(T\u0026amp; it, D n) { if(n \u0026gt; 0){ for(; n != 0; --n){ ++it; } }else if(n \u0026lt; 0){ for(; n != 0; ++n){ --it; } } }    å½“ä½¿ç”¨ä¸€ä¸ªæ™®é€šçš„forward iteratorè°ƒç”¨advanceIteræ—¶ï¼Œç›´æ¥é€‰æ‹©ç¬¬ä¸€ä¸ªæ¨¡æ¿ è€Œå½“ä½¿ç”¨ä¸€ä¸ªbidirectional iteratorè¿›è¡Œè°ƒç”¨æ—¶ï¼Œå°†åŒæ—¶æ»¡è¶³ä¸¤ä¸ªæ¨¡æ¿ï¼Œæ­¤æ—¶æ›´å€¾å‘äºé€‰æ‹©é‚£ä¸ªæœ‰åŒ…å«å…³ç³»çš„æ¨¡æ¿ï¼Œå› æ­¤é¦–é€‰ç¬¬äºŒä¸ªæ¨¡æ¿  E.3.2 Constraints and Tag Dispatching ç¤ºä¾‹ï¼š\n1 2 3 4 5  template\u0026lt;typename T\u0026gt; concept ForwardIterator = InputIterator{ typename std::iterator_traits\u0026lt;T\u0026gt;::iterator_category; is_convertible_v\u0026lt;std::iterator_traits\u0026lt;T\u0026gt;::iterator_category, std::forward_iterator_tag\u0026gt;; };   E.4 Concept Tips E.4.1 Testing Concepts å¯¹äºç»™å®šçš„æ¦‚å¿µCå’Œä¸€äº›ç±»å‹T1ï¼ŒT2ç­‰ï¼Œå¯ä»¥ä½¿ç”¨é™æ€æ–­è¨€è¿›è¡Œæµ‹è¯•\n1  static_assert(C\u0026lt;T1, T2, ...\u0026gt;, \u0026#34;Model Failure\u0026#34;);   æµ‹è¯•æ¦‚å¿µæ—¶éœ€è¦æ³¨æ„çš„é—®é¢˜ï¼š\n Do interfaces and/or algorithms need to copy and/or move objects of the types being modeled? What conversions are acceptable? Which ones are needed? Is the basic set of operations assumed by the template unique? For example, can it operate using either *= or * and =?  E.4.2 Concept Granularity ç¤ºä¾‹ï¼š\n1 2 3 4  template\u0026lt;typename T, typename U\u0026gt; concept Addable = requires(T x, U y){ x + y; }   E.4.3 Binary Compatibility 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #include \u0026lt;iostream\u0026gt; template\u0026lt;typename T\u0026gt; concept HasPlus = requires(T x, T y){ x+y; }; template\u0026lt;typename T\u0026gt; int f(T p) requires HasPlus\u0026lt;T\u0026gt;{ std::cout\u0026lt;\u0026lt;\u0026#34;TU1\\n\u0026#34;; } void g(); int main() { f(1); g(0); }   å’Œ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;iostream\u0026gt; template\u0026lt;typename T\u0026gt; concept HasMult = requires(T x, T y){ x*y; }; template\u0026lt;typename T\u0026gt; int f(T p) requires HasMult\u0026lt;T\u0026gt;{ std::cout\u0026lt;\u0026lt;\u0026#34;TU2\\n\u0026#34;; } template int f(int); void g(){ f(2); }   è¾“å‡ºç»“æœï¼š\nTU1\rTu2\r","description":"ã€ŠC++ Templateså­¦ä¹ ç¬”è®°é™„å½•Eã€‹","id":5,"section":"note","tags":["C++ Templates","C++"],"title":"Appendix E: Concepts","uri":"https://chaphlagical.github.io/zh/note/cpptemplate/appendixe/"},{"content":"3.1 Nontype Class Template Parameters è®¾è®¡ä¸€ä¸ªæŒ‡å®šå­˜å‚¨å¤§å°çš„æ ˆï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #include \u0026lt;array\u0026gt;#include \u0026lt;cassert\u0026gt; template\u0026lt;typename T, std::size_t Maxsize\u0026gt; class Stack{ private: std::array\u0026lt;T, maxSize\u0026gt; elems; std::size_t numElems; public: Stack(); void push(T const\u0026amp; elem); void pop(); T const\u0026amp; top() const; bool empty() const{ return numElems == 0; } std::size_t size() const{ return numElems; } }; // Implementation...   ä½¿ç”¨æ—¶éœ€æŒ‡å®šå­˜å‚¨ç©ºé—´çš„å¤§å°ï¼š\n1 2  Stack\u0026lt;int, 20\u0026gt; int20Stack; Stack\u0026lt;std::string, 40\u0026gt; string40Stack;   è®¾ç½®é»˜è®¤æ¨¡æ¿å½¢å‚ï¼š\n1 2 3 4  template\u0026lt;typename T, std::size_t Maxsize = 100\u0026gt; class Stack{ ... }   3.2 Nontype Function Template Parameters ç¤ºä¾‹ï¼š\n1 2 3 4 5  template\u0026lt;int Val, typename T\u0026gt; T addValue(T x) { return x + Val; }   è¿˜å¯ä»¥ç”¨äºç±»å‹æ¨æ–­ï¼š\n1 2  template\u0026lt;auto Val, typename T = decltype(Val)\u0026gt; T foo();   ç”¨äºç¡®ä¿ä¼ å…¥çš„å€¼æœ‰ç›¸åŒçš„ç±»å‹ï¼š\n1 2  template\u0026lt;typename T, T Val = T{}\u0026gt; T bar();   3.3 Restrictions for Nontype Template Parameters é€šå¸¸æƒ…å†µä¸‹ï¼Œéç±»å‹çš„æ¨¡æ¿å‚æ•°åªèƒ½æœ‰ä»¥ä¸‹å‡ ç§ï¼š\n constant integral values(including enumerations) pointers to objects/functions/members left value references to objects or functions std_nullptr_t  åƒtemplate\u0026lt;double VAT\u0026gt;å’Œtemplate\u0026lt;std::string name\u0026gt;ç­‰æ˜¯ä¸è¢«å…è®¸çš„\nå½“ä¼ é€’çš„æ¨¡æ¿å‚æ•°æ˜¯æŒ‡é’ˆæˆ–å¼•ç”¨æ—¶ï¼Œå¯¹è±¡ä¸åº”ä¸ºstring literalsï¼Œä¸´æ—¶å˜é‡æˆ–æ•°æ®æˆå‘˜æˆ–å…¶ä»–å­å¯¹è±¡ï¼Œå¯¹å…·ä½“çš„C++æ ‡å‡†ï¼Œæœ‰ï¼š\n åœ¨C++11ä¸­ï¼Œå¯¹è±¡å¿…é¡»æ˜¯external linkageçš„ åœ¨C++14ä¸­ï¼Œå¯¹è±¡å¿…é¡»æ˜¯externalæˆ–internal linkageçš„  ä¾‹å¦‚ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  template\u0026lt;char const* name\u0026gt; class MessageP ... }; extern char const s03[] = \u0026#34;hi\u0026#34;; char const s11[] = \u0026#34;hi\u0026#34;; int main() { Message\u0026lt;\u0026#34;Hello\u0026#34;\u0026gt; x;\t// Error  Message\u0026lt;s03\u0026gt; m03;\t// OK for all version  Message\u0026lt;s11\u0026gt; m11;\t// OK since C++11  static char const s17[] = \u0026#34;hi\u0026#34;; Message\u0026lt;s17\u0026gt; m17;\t// OK since C++17 }   3.3.1 Avoiding Invalid Expressions å¯¹äºéç±»å‹æ¨¡æ¿å‚æ•°å¯ä»¥è¿›è¡Œç¼–è¯‘æœŸçš„è¡¨è¾¾å¼è®¡ç®—ï¼Œå¦‚ï¼š\n1 2 3 4  template\u0026lt;int I, bool B\u0026gt; class C; ... C\u0026lt;sizeof(int) + 4, sizeof(int) == 4\u0026gt; c;   ä½†æ˜¯è¦æ³¨æ„å°–æ‹¬å·çš„ä½¿ç”¨ï¼š\n1 2  c\u0026lt;42, sizeof(int) \u0026gt; 4\u0026gt; c;\t// error: first \u0026gt; ends the template argument list c\u0026lt;42, (sizeof(int)\u0026gt;4)\u0026gt;c;\t// OK   3.4 Template Parameter Type auto è‡ªC++17èµ·ï¼Œæ”¯æŒå®šä¹‰æ¥æ”¶ä»»ä½•ç±»å‹çš„éç±»å‹æ¨¡æ¿å®å‚ï¼Œåˆ©ç”¨è¯¥ç‰¹æ€§å¯å®šä¹‰æ›´å…·ä¸€èˆ¬æ€§çš„å…·æœ‰å›ºå®šå¤§å°çš„æ ˆï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  template\u0026lt;typename T, auto Maxsize\u0026gt; class Stack{ public: using size_type = decltype(Maxsize); private: std::array\u0026lt;T, Maxsize\u0026gt; elems; size_type numElems; public: Stack(); void push(T const\u0026amp; elem); void pop(); T const\u0026amp; top() const; bool empty() const{ return numElems == 0; } auto size() const{\t// since C++14  return numElems; } };   3.5 Summary  Templates can have template parameters that are values rather than types You cannot use floating-point numbers or class-type objects as arguments for nontype template parameters. For pointers/references to string literals, temporaries, and subobjects, restrictions apply Using auto enables templates to have nontype template parameters that are values of generic types.  ","description":"ã€ŠC++ Templateså­¦ä¹ ç¬”è®°ç¬¬ä¸‰ç« ã€‹","id":6,"section":"note","tags":["C++ Templates","C++"],"title":"Chapter 3: Nontype Template Parameters","uri":"https://chaphlagical.github.io/zh/note/cpptemplate/ch3/"},{"content":"4.1 Variadic Templates ç±»æ¨¡æ¿å½¢å‚èƒ½å¤Ÿè¢«å®šä¹‰ä¸ºå¯ä»¥æ¥å—ä¸€ä¸²æ¨¡æ¿å®å‚ï¼Œç§°ä¸ºå¯å˜å‚æ•°æ¨¡æ¿\n4.1.1 Variadic Templates by Example ä¸¾ä¾‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11  void print() { } template\u0026lt;typename T, typename... Types\u0026gt; void print(T firstArg, Types... args) { std::cout \u0026lt;\u0026lt; firstArg \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; print(args...); }   è¯¥å‡½æ•°å°†é€’å½’åœ°æ‰“å°æ‰€æœ‰è¾“å…¥çš„å‚æ•°ï¼Œè°ƒç”¨æ—¶ï¼Œ\n1 2  std::string s(\u0026#34;Hello\u0026#34;); print(7.5, \u0026#34;Hello\u0026#34;, s);   å°†è¢«å±•å¼€ä¸ºï¼š\n1  print\u0026lt;double, char const*, std::string\u0026gt;(7.5, \u0026#34;Hello\u0026#34;, s)   è§ç¤ºä¾‹\n4.1.2 Overloading Variadic and Nonvariadic Templates ç¤ºä¾‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12  template\u0026lt;typename T\u0026gt; void print(T arg) { std::cout \u0026lt;\u0026lt; arg \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } template\u0026lt;typename T, typename... Types\u0026gt; void print(T firstArg, Types... args) { print(firstArg); print(args...); }   4.1.3 Operator sizeof... C++11ä¹‹åæå‡ºé’ˆå¯¹å¯å˜å‚æ•°æ¨¡æ¿çš„sizeofï¼Œè¡¨ç¤ºäº†å‚æ•°å—ä¸­çš„å…ƒç´ ä¸ªæ•°ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4 5 6 7  template\u0026lt;typename T, typename... Types\u0026gt; void print(T firstArg, Types... args) { std::cout \u0026lt;\u0026lt; sizeof...(Types) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\t// print number of remaining types  std::cout \u0026lt;\u0026lt; sizeof...(args) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\t// print number of remaining args  ... }   æˆ–è®¸ä½ ä¼šæƒ³åˆ©ç”¨è¿™ä¸ªæ–¹æ³•ä½œä¸ºé€’å½’è°ƒç”¨çš„ç»“æŸæ¡ä»¶ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4 5 6 7 8 9  template\u0026lt;typename T, typename... Types\u0026gt; void print(T firstArg, Types... args) { std::cout \u0026lt;\u0026lt; firstArg \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; if(sizeof...(args) \u0026gt; 0) { print(args...); } }   é—æ†¾çš„æ˜¯ä¸Šè¿°ä»£ç å¹¶æ— æ³•æ­£ç¡®é€šè¿‡ç¼–è¯‘ï¼Œè¿™æ˜¯ç”±äºç¼–è¯‘æœŸè®¡ç®—æ‰€å¯¼è‡´çš„\n4.2 Fold Expressions C++17ä¹‹åï¼Œæ”¯æŒæŠ˜å è¡¨è¾¾å¼\nç¤ºä¾‹ï¼š\n1 2 3 4 5  template\u0026lt;typename... T\u0026gt; auto foldSum(T... s) { return (... + s);\t// ((s1+s2)+s3)+... }   ä¸Šè¿°ä»£ç è®¡ç®—æ‰€æœ‰è¾“å…¥å‚æ•°ä¹‹å’Œ\næŠ˜å è¡¨è¾¾å¼çš„å±•å¼€æ–¹å¼ï¼š\n   Fold Expression Evaluation     (... op pack) ( \u0026hellip; ((pack1 op pack2) op pack3) \u0026hellip; op packN)   (pack op ...) (pack1 op ( \u0026hellip; (packN-1 op packN) \u0026hellip; ))   (init op ... op pack) ( \u0026hellip; (((init op pack1) op pack2) op pack3) \u0026hellip; op packN)   (pack op ... op init) (pack1 op ( \u0026hellip; (packN-1 op (packN op init)) \u0026hellip; ))    ç¤ºä¾‹ï¼šäºŒå‰æ ‘çš„éå†\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  struct Node{ int value; Node* left; Node* right; Node(int i = 0) : value(i), left(nullptr), right(nullptr){} ... }; auto left = \u0026amp;Node::left; auto right = \u0026amp;Node::right; template\u0026lt;typename T, typename... TP\u0026gt; Node* traverse(T np, TP... paths){ return (np -\u0026gt;* ... -\u0026gt;* paths);\t// np -\u0026gt;* paths1 -\u0026gt;* paths2 ... } int main() { Node* root = new Node{0}; root-\u0026gt;left = new Node{1}; root-\u0026gt;left-\u0026gt;right = new Node{2}; ... // traverse  Node* node = traverse(root, left, right); ... }   åˆ©ç”¨æŠ˜å è¡¨è¾¾å¼è¿›è¡Œæ‰“å°ï¼š\n1 2 3 4 5  template\u0026lt;typename.. Types\u0026gt; void print(Types const\u0026amp;... args) { (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt;\u0026lt; args) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   4.3 Application of Variadic Templates  Passing arguments to the constructor of a new heap object owned by a shared pointer:  1  auto sp = std::make_shared\u0026lt;std::complex\u0026lt;float\u0026gt;\u0026gt;(4.2, 7.7);    Passing arguments to a thread, which is started by the library:  1  std::thread t (foo, 42, \u0026#34;hello\u0026#34;);\t// call foo(42, \u0026#34;hello\u0026#34;) in a separate thread    Passing arguments to the constructor of a new element pushed into a vector:  1 2 3  std::vector\u0026lt;Customer\u0026gt; v; ... v.emplace_back(\u0026#34;Tim\u0026#34;, \u0026#34;Jovi\u0026#34;, 1962);   é€šå¸¸æƒ…å†µä¸‹ï¼Œå®å‚ä¸ºå®Œç¾è½¬å‘çš„ç§»åŠ¨è¯­ä¹‰ï¼ˆperfect forwarded with move semanticsï¼‰ï¼Œç›¸åº”çš„å£°æ˜å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  namespace std { template\u0026lt;typename T, typename... Args\u0026gt; shared_ptr\u0026lt;T\u0026gt; make_shared(Args\u0026amp;\u0026amp;... args); class thread{ public: template\u0026lt;typename F, typename... Args\u0026gt; explicit thread(F\u0026amp;\u0026amp; f, Args\u0026amp;\u0026amp;... args); ... }; template\u0026lt;typename T, typename Allocator = allocator\u0026lt;T\u0026gt;\u0026gt; class vector{ public: template\u0026lt;typename... Args\u0026gt; reference emplace_back(Args\u0026amp;\u0026amp;... args); ... }; }   æ³¨æ„ï¼šå¯å˜å‚æ•°æ¨¡æ¿çš„ä¼ å‚è§„åˆ™ä¸æ™®é€šæ¨¡æ¿çš„ä¼ å‚è§„åˆ™ç±»ä¼¼ï¼Œå¦‚æœæ˜¯æŒ‰å€¼ä¼ å‚ï¼Œåˆ™å®å‚ä¸ºå¤åˆ¶å’Œé€€åŒ–çš„ï¼›è‹¥æŒ‰å¼•ç”¨ä¼ å‚ï¼Œåˆ™ä¸ºåŸå‚æ•°çš„å¼•ç”¨ä¸”éé€€åŒ–\n1 2 3 4  // args are copies with decayed types: template\u0026lt;typename... Args\u0026gt; void foo(Args... args); // args are nondecayed references to passed aobjects: template\u0026lt;typename... Args\u0026gt; void bar(Args const\u0026amp;... args);   4.4 Variadic Class Templates and Variadic Expressions 4.4.1 Variadic Expression å¯å˜æ¨¡æ¿å‚æ•°ä¸ç¦å¯ä»¥è½¬å‘å…¨éƒ¨ï¼Œè¿˜å¯è¿›è¡Œè®¡ç®—ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4 5  template\u0026lt;typename... T\u0026gt; void printDoubled(T const\u0026amp;... args) { print(args + args...); }   ä¸Šè¿°ä»£ç å°†è¾“å‡ºæ¯ä¸ªå‚æ•°çš„ç¿»å€\nä¾‹å¦‚è°ƒç”¨ï¼š\n1  printDoubled(7.5,std::complex\u0026lt;float\u0026gt;(4,2),std::string(\u0026#34;hello\u0026#34;));   å°†ç­‰åŒäºè°ƒç”¨ï¼š\n1  print(7.5 + 7.5, std::complex\u0026lt;float\u0026gt;(4,2) + std::complex\u0026lt;float\u0026gt;(4,2), std::string(\u0026#34;hello\u0026#34;) + std::string(\u0026#34;hello\u0026#34;));   å¯¹æ¯ä¸ªå‚æ•°åŠ 1ï¼š\n1 2 3 4 5 6 7  template\u0026lt;typename... T\u0026gt; void addOne(T const\u0026amp;... args) { print(arg + 1 ...); // or  print((arg + 1)...); }   ç¼–è¯‘æœŸæ£€æŸ¥æ‰€æœ‰ç±»å‹æ˜¯å¦ä¸€è‡´ï¼š\n1 2 3 4 5  template\u0026lt;typename T1, typename... TN\u0026gt; constexpr bool isHomogenous(T1, TN...) { return (std::is_same\u0026lt;T1,TN\u0026gt;::value \u0026amp;\u0026amp; ...); }   4.4.2 Variadic Indices å¯ä»¥åˆ©ç”¨å¯å˜ç´¢å¼•åˆ—è¡¨æ¥è®¿é—®ç›¸åº”çš„å…ƒç´ ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4 5  template\u0026lt;typename C, typename... Idx\u0026gt; void printElems(C const\u0026amp; coll, Idx... idx) { print(coll[idx]...); }   å½“è°ƒç”¨\n1 2  std::vector\u0026lt;std::string\u0026gt; coll = {\u0026#34;good\u0026#34;, \u0026#34;times\u0026#34;, \u0026#34;say\u0026#34;, \u0026#34;bye\u0026#34;}; printElems(coll, 2, 0, 3);   å…¶æ•ˆæœç­‰åŒäºï¼š\n1  print(coll[2], coll[0], coll[3]);   4.4.3 Variadic Class Templates å¯å˜æ¨¡æ¿ä¹Ÿå¯ä»¥ä¸ºç±»æ¨¡æ¿\nç±»ä¸­ä»»æ„æ•°é‡çš„æ¨¡æ¿å‚æ•°æŒ‡å®šäº†ç›¸åº”æˆå‘˜çš„ç±»å‹ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4  template\u0026lt;typename... Elements\u0026gt; class Tuple; Tuple\u0026lt;int, std::string, char\u0026gt; t;\t// t can hold integer, string and character   æŒ‡å®šå¯èƒ½çš„æˆå‘˜ç±»å‹ï¼Œå¦‚ï¼š\n1 2 3 4  template\u0026lt;typename... Types\u0026gt; class Variant; Variant\u0026lt;int, std::string, char\u0026gt; v;\t// v can hold integer, string or character   åŒæ—¶ä¹Ÿå¯ä»¥å®šä¹‰å¯å˜éç±»å‹æ¨¡æ¿å‚æ•°ï¼Œä¾‹å¦‚\n1 2 3  template\u0026lt;std::size_t...\u0026gt; struct Indices{ };   è¿™ç§æ–¹æ³•å¯ç”¨äºæ‰“å°æ•°ç»„ç»™å®šç´¢å¼•çš„å…ƒç´ ï¼š\n1 2 3 4 5  template\u0026lt;typename T, std::size_t... Idx\u0026gt; void printByIdx(T t, Indices\u0026lt;Idx...\u0026gt;) { print(std::get\u0026lt;Idx\u0026gt;(t)...); }   ä½¿ç”¨æ–¹æ³•ï¼š\n1 2  std::array\u0026lt;std::string, 5\u0026gt; arr = {\u0026#34;Hello\u0026#34;, \u0026#34;my\u0026#34;, \u0026#34;new\u0026#34;, \u0026#34;!\u0026#34;, \u0026#34;World\u0026#34;}; printByIdx(arr, Indices\u0026lt;0, 4, 3\u0026gt;());   4.4.4 Variadic Deduction Guide æ¨å¯¼å¼•å¯¼ä¹Ÿå¯ä¸ºå¯å˜æ¨¡æ¿ï¼Œä¾‹å¦‚C++æ ‡å‡†åº“ä¸­çš„std::arrayåˆå§‹åŒ–ï¼š\n1 2 3 4  namespace std{ template\u0026lt;typename T, typename... U\u0026gt; array(T, U...) -\u0026gt; array\u0026lt;enable_if_t\u0026lt;(is_same_v\u0026lt;T, U\u0026gt; \u0026amp;\u0026amp; ...), T\u0026gt;, (1 + sizeof...(U))\u0026gt;; }   åˆå§‹åŒ–ï¼š\n1  std::array a{42, 45, 77};   4.4.5 Variadic Base Classes and using ä¸€æ®µä¾‹ç¨‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  #include \u0026lt;string\u0026gt;#include \u0026lt;unordered_set\u0026gt; class Customer { private: std::string name; public: Customer(std::string const\u0026amp; n): name(n){ } std::string getName() const { return name; } }; struct CustomerEq{ bool operator() (Customer const\u0026amp; c1, Customer const\u0026amp; c2) const{ return c1.getName() == c2.getName(); } }; struct CustomerHash{ std::size_t operator() (Customer const\u0026amp; c) const{ return std::hash\u0026lt;std::string\u0026gt;()(c.getName()); } }; template\u0026lt;typename... Bases\u0026gt; struct Overloader: Bases... { using Bases::operator()...; }; int main() { using CustomerOP = Overloader\u0026lt;CustomerEq, CustomerHash\u0026gt;; std::unordered_set\u0026lt;Customer, CustomerHash, CustomerEq\u0026gt; coll1; std::unordered_set\u0026lt;Customer, CustomerOP, CustomerOP\u0026gt; coll2; ... }   åœ¨æ´¾ç”Ÿç±»CustomerOPä¸­ï¼Œæ‹¥æœ‰ä¸¤ç§è¿ç®—ç¬¦()çš„é‡è½½æ–¹å¼\n4.5 Summary  By using parameter packs, templates can be defined for an arbitrary number of template parameters of arbitrary type To process the parameters, you need recursion and/or a matching nonvariadic function Operator sizeofâ€¦ yields the number of arguments provided for a parameter pack. â€¢ A typical application of variadic templates is forwarding an arbitrary number of arguments of arbitrary type By using fold expressions, you can apply operators to all arguments of a parameter pack  ","description":"ã€ŠC++ Templateså­¦ä¹ ç¬”è®°ç¬¬å››ç« ã€‹","id":7,"section":"note","tags":["C++ Templates","C++"],"title":"Chapter 4: Variadic Templates","uri":"https://chaphlagical.github.io/zh/note/cpptemplate/ch4/"},{"content":"2.1 Implementation of Class Template Stack 2.1.1 Declaration of Class Templates å£°æ˜ä¸€ä¸ªç±»æ¨¡æ¿ï¼š\n1 2 3 4  template\u0026lt;typename T\u0026gt; class Stack{ ... };   æ¨¡æ¿å½¢å‚T`å¯ä»¥åœ¨ç±»ä¸­ä½¿ç”¨ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12  template\u0026lt;typename T\u0026gt; class Stack{ private: std::vector\u0026lt;T\u0026gt; elems; public: void push(T const\u0026amp; elem); void pop(); T const\u0026amp; top() const; bool empty() const{ return elems.empty(); } };   å¯¹äºç±»å£°æ˜ä¹‹å¤–çš„ï¼Œéœ€è¦æ ‡æ˜æ¨¡æ¿å½¢å‚å®šä¹‰ï¼š\n1 2  template\u0026lt;typename T\u0026gt; bool operator==(Stack\u0026lt;T\u0026gt; const\u0026amp; lhs, Stack\u0026lt;T\u0026gt; const\u0026amp; rhs);   2.1.2 Implementation of Member Functions åœ¨ç±»å£°æ˜å¤–å®ç°ï¼š\n1 2 3 4 5  template\u0026lt;typename T\u0026gt; void Stack\u0026lt;T\u0026gt;::push(T const\u0026amp; elem) { elem.push_back(elem); }   åœ¨ç±»å£°æ˜å†…å®ç°ï¼š\n1 2 3 4 5 6 7 8  template\u0026lt;typename T\u0026gt; class Stack{ ... void push(T const\u0026amp; elem){ elems.push_back(elem); } ... };   2.2 Use of Class Template Stack æ˜¾å¼æŒ‡æ˜æ¨¡æ¿å‚æ•°ï¼š\n1 2 3 4 5 6 7 8  Stack\u0026lt;int\u0026gt; intStack; Stack\u0026lt;std::string\u0026gt; stringStack; intStack.push(7); auto a=intStack.top(); stringStack.push(\u0026#34;Hello\u0026#34;); auto b=stringStack.top();   æ³¨æ„ï¼šåœ¨C++11ä»¥å‰ï¼ŒStack\u0026lt;Stack\u0026lt;int\u0026gt;\u0026gt;ä¸­çš„\u0026gt;\u0026gt;ä¼šä¸è¿ç®—ç¬¦\u0026gt;\u0026gt;å†²çªè€Œå‡ºé”™ï¼Œéœ€è¦æ”¹å†™ä¸ºStack\u0026lt;Stack\u0026lt;int\u0026gt; \u0026gt;ï¼ŒC++11ä¹‹åä¾¿æ²¡æœ‰è¿™ä¸€é—®é¢˜\n2.3 Partial Usage of Class Templates ç¼–å†™çš„ç±»æ¨¡æ¿å¯èƒ½åªèƒ½é€‚ç”¨äºæŸäº›æ¨¡æ¿å‚æ•°ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4 5 6 7 8  template\u0026lt;typename T\u0026gt; class Stack{ ... void PrintOn(std::ostream\u0026amp; strm) const{ for(T const\u0026amp; elem: elems) strm \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } };   PrintOnå‡½æ•°ç”¨äºæ‰“å°æ‰€æœ‰å…ƒç´ ï¼Œç„¶è€Œå¯¹æŸäº›æ¨¡æ¿å®å‚ï¼Œå¦‚std::pairï¼Œè™½ç„¶èƒ½å¤Ÿæ­£å¸¸ä½¿ç”¨ç±»çš„å…¶ä»–åŠŸèƒ½ï¼Œä½†ä¸èƒ½ä½¿ç”¨PrintOn\n2.3.1 Concepts conceptså¸¸ç”¨äºæ¨¡æ¿åº“çš„ç¼–è¯‘æ ¡éªŒï¼Œä½¿å¾—æ¨¡æ¿å‚æ•°æ»¡è¶³ç›¸åº”çš„é™åˆ¶ã€‚ä¾‹å¦‚ï¼Œä¸ºæ»¡è¶³æ¨¡æ¿å‚æ•°æ‹¥æœ‰é»˜è®¤æ„é€ å‡½æ•°ï¼Œå¯ä»¥è¿›è¡Œå¦‚ä¸‹é™æ€æ–­è¨€ï¼š\n1 2 3 4 5  template\u0026lt;typename T\u0026gt; class C { static_assert(std::is_default_constructible\u0026lt;T\u0026gt;::value, \u0026#34;Class C requires default-constructible elements\u0026#34;); };   ä»¥æ–¹ä¾¿æ¨¡æ¿è°ƒè¯•\n2.4 Friends æ“ä½œç¬¦é‡è½½\u0026lt;\u0026lt;æ¥å®ç°æ‰“å°Stackç±»ï¼š\n1 2 3 4 5 6 7 8 9 10 11  template\u0026lt;typename T\u0026gt; class Stack{ ... void PrintOn(std::ostream\u0026amp; strm) const{ ... } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt; (std::ostream\u0026amp; strm, Stack\u0026lt;T\u0026gt; const\u0026amp; s){ s.printOn(strm); return strm; } };   é€šå¸¸æƒ…å†µä¸‹ï¼Œè¿ç®—ç¬¦\u0026lt;\u0026lt;é‡è½½åº”è¯¥å®ç°ä¸ºéæˆå‘˜å‡½æ•°ï¼Œè¿™é‡Œå¯ä»¥çœ‹åˆ°\u0026lt;\u0026lt;å¹¶ä¸æ˜¯ä¸€ä¸ªå‡½æ•°æ¨¡æ¿ï¼Œè€Œæ˜¯ä¸€ä¸ªéœ€è¦ç±»æ¨¡æ¿çš„æ™®é€šå‡½æ•°å®ä¾‹ã€‚\nå¦‚æœå¸Œæœ›å…ˆå£°æ˜ä¸€ä¸ªå‹å…ƒå‡½æ•°ç„¶åä¹‹åå†å®šä¹‰å®ƒï¼Œæœ‰ä¸¤ç§æ–¹æ³•ï¼š\n éšå¼å£°æ˜ä¸€ä¸ªæ–°çš„å‡½æ•°æ¨¡æ¿ï¼Œä½¿ç”¨ä¸åŒçš„æ¨¡æ¿å‚æ•°ï¼š  1 2 3 4 5 6  template\u0026lt;typename T\u0026gt; class Stack{ ... template\u0026lt;typename U\u0026gt; friend std::ostream\u0026amp; operator\u0026lt;\u0026lt; (std::ostream\u0026amp;, Stack\u0026lt;U\u0026gt; const\u0026amp;); };   è¿™æ ·æ— è®ºæ˜¯å†æ¬¡ä½¿ç”¨Tæˆ–è€…è·³è¿‡æ¨¡æ¿å‚æ•°éƒ½æ˜¯å¯ä»¥çš„\nå‰å‘å£°æ˜Stack\u0026lt;T\u0026gt;ï¼š  1 2 3 4  template\u0026lt;typename T\u0026gt; class Stack; template\u0026lt;typename T\u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt; (std::ostream\u0026amp;, Stack\u0026lt;T\u0026gt; const\u0026amp;);   ç„¶åå°†è¯¥å‡½æ•°å£°æ˜ä¸ºå‹å…ƒï¼š\n1 2 3 4 5  template\u0026lt;typename T\u0026gt; class Stack{ ... friend std::ostream\u0026amp; operator\u0026lt;\u0026lt; \u0026lt;T\u0026gt; (std::ostream\u0026amp;, Stack\u0026lt;T\u0026gt; const\u0026amp;); };   è¿™æ ·æˆ‘ä»¬å£°æ˜äº†ä¸€ä¸ªéæˆå‘˜å‡½æ•°æ¨¡æ¿çš„ç‰¹åŒ–ä½œä¸ºå‹å…ƒ\n2.5 Specialization of Class Templates ç±»æ¨¡æ¿ç‰¹åŒ–ï¼š\n1 2 3 4  template\u0026lt;\u0026gt; class Stack\u0026lt;std::string\u0026gt;{ ... };   å¦‚æœè¦è¿›è¡Œç±»æ¨¡æ¿ç‰¹åŒ–ï¼Œå¿…é¡»ç‰¹åŒ–æ‰€æœ‰çš„æˆå‘˜å‡½æ•°ï¼ˆå…¨ç‰¹åŒ–ï¼‰ï¼Œå¦åˆ™å°†æ— æ³•å®ä¾‹åŒ–åŸæ¥çš„æ•´ä¸ªç±»æ¨¡æ¿ï¼ˆæœ‰ç‚¹åƒé‡æ–°å®šä¹‰äº†ä¸€ä¸ªæ–°ç±»ï¼‰\n2.6 Partial Specialization ç±»æ¨¡æ¿çš„åç‰¹åŒ–ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  template\u0026lt;typename T\u0026gt; class Stack\u0026lt;T\u0026gt;{ ... } template\u0026lt;typename T\u0026gt; class Stack\u0026lt;T*\u0026gt;{ private: std::vector\u0026lt;T*\u0026gt; elems; public: void push(T*); T* pop(); T* top() const; bool empty() const{ return elems.empty(); } }; // Implementation // ...   åç‰¹åŒ–çš„ç±»æ¨¡æ¿æ¥å£å¯èƒ½å’ŒåŸæ¥æœ‰æ‰€ä¸åŒ\n2.6.1 Partial Specialization with Multiple Parameters å¤šæ¨¡æ¿å‚æ•°çš„ç‰¹ååŒ–ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // åŸç±»æ¨¡æ¿ template\u0026lt;typename T1, typename T2\u0026gt; class MyClass{ ... }; // åç‰¹åŒ–ï¼šä¸¤ä¸ªæ¨¡æ¿å‚æ•°ç›¸åŒ template\u0026lt;typename T\u0026gt; class MyClass\u0026lt;T,T\u0026gt;{ ... }; // åç‰¹åŒ–ï¼šç¬¬äºŒä¸ªç±»å‹ä¸ºint template\u0026lt;typename T\u0026gt; class MyClass\u0026lt;T,int\u0026gt;{ ... }; // åç‰¹åŒ–ï¼šä¸¤ä¸ªç±»å‹å‡ä¸ºæŒ‡é’ˆç±»å‹ template\u0026lt;typename T\u0026gt; class MyClass\u0026lt;T*,T*\u0026gt;{ ... };   å®ä¾‹åŒ–ï¼š\n1 2 3 4  MyClass\u0026lt;int, float\u0026gt; mif;\t// ä½¿ç”¨MyClass\u0026lt;T1,T2\u0026gt; MyClass\u0026lt;float, float\u0026gt; mif;\t// ä½¿ç”¨MyClass\u0026lt;T,T\u0026gt; MyClass\u0026lt;float, int\u0026gt; mif;\t// ä½¿ç”¨MyClass\u0026lt;T,int\u0026gt; MyClass\u0026lt;int*, float*\u0026gt; mif;\t// ä½¿ç”¨MyClass\u0026lt;T1*,T2*\u0026gt;   å½“å¤šäºä¸€ä¸ªåç‰¹åŒ–ç›¸åŒæ—¶ï¼Œä¼šå‘ç”Ÿå†²çªï¼Œå¦‚ï¼š\n1 2  MyClass\u0026lt;int,int\u0026gt; m;\t// é”™è¯¯ï¼ŒåŒ¹é…åˆ°MyClass\u0026lt;T,T\u0026gt;å’ŒMyClass\u0026lt;T,int\u0026gt; MyClass\u0026lt;int*,int*\u0026gt; m;\t// é”™è¯¯ï¼ŒåŒ¹é…åˆ°MyClass\u0026lt;T,T\u0026gt;å’ŒMyClass\u0026lt;T1*,T2*\u0026gt;   å¯¹äºç¬¬äºŒç§é”™è¯¯ï¼Œå¯ä»¥å¢åŠ ä¸€ä¸ªåç‰¹åŒ–è§£å†³ï¼š\n1 2 3 4  template\u0026lt;typename T\u0026gt; class MyClass\u0026lt;T*,T*\u0026gt;{ ... };   2.7 Default Class Template Arguments è®¾ç½®ç±»æ¨¡æ¿é»˜è®¤å½¢å‚ï¼Œå¦‚ï¼š\n1 2 3 4 5 6 7  template\u0026lt;typename T, typename Cont = std::vector\u0026lt;T\u0026gt;\u0026gt; class Stack{ private: Cont elems; public: ... }   2.8 Type Aliases 2.8.1 Typedefs and Alias Declarations  ä½¿ç”¨å…³é”®å­—typedef  1 2 3  typedef Stack\u0026lt;int\u0026gt; IntStack; void foo(IntStack const\u0026amp; s); IntStack istack[10];   è¿™ç§é‡å‘½åæ–¹æ³•çš„ç»“æœç§°ä¸ºtypedef-name\nä½¿ç”¨å…³é”®å­—usingï¼ˆè‡ªC++11ï¼‰  1 2 3  using IntStack = Stack\u0026lt;int\u0026gt;; void foo(IntStack const\u0026amp; s); IntStack istack[10];   è¿™ç§æ–¹æ³•çš„ç»“æœç§°ä¸ºalias-declaration\n2.8.2 Alias Templates ä»C++11èµ·æ”¯æŒalias templateçš„æ–¹æ³•ï¼š\n1 2  template\u0026lt;typename T\u0026gt; using DequeStack = Stack\u0026lt;T, std::deque\u0026lt;T\u0026gt;\u0026gt;;   typedefåˆ™ä¸æ”¯æŒè¿™ç§æ–¹æ³•\n2.8.3 Alias Templates for Member Types Alias Templateå¯ä»¥å¾ˆæ–¹ä¾¿åœ°ä¸ºç±»æ¨¡æ¿çš„æˆå‘˜ç±»å‹å®šä¹‰ä¸€ä¸ªç®€å†™ï¼Œå¦‚ï¼š\n1 2 3 4 5  template\u0026lt;typename T\u0026gt; struct MyType{ typedef ... iterator; ... };   æˆ–æ˜¯\n1 2 3 4 5  template\u0026lt;typename T\u0026gt; struct MyType{ using iterator = ...; ... };   å®šä¹‰ä¸ºä¾‹å¦‚ï¼š\n1 2  template\u0026lt;typename T\u0026gt; using MyTypeIterator = typename MyType\u0026lt;T\u0026gt;::iterator;   å…è®¸å¦‚ä¸‹ä½¿ç”¨æ–¹æ³•ï¼š\n1 2 3  MyTypeIterator\u0026lt;int\u0026gt; pos; // è€Œä¸éœ€è¦ä½¿ç”¨ï¼š // typename MyType\u0026lt;T\u0026gt;::iterator pos;   2.8.4 Type Traits Suffix_t ä»C++14èµ·ï¼Œä½¿ç”¨äº†Alias Templateå®šä¹‰äº†è®¸å¤štype traitsçš„ç¼©å†™ï¼Œä¾‹å¦‚ï¼š\n1 2  std::add_const_t\u0026lt;T\u0026gt;; // since C++14 typename std::add_const\u0026lt;T\u0026gt;::type;\t// since C++11   2.9 Class Template Argument Deduction åœ¨C++17ä»¥å‰ï¼Œé™¤éç±»æ¨¡æ¿å¸¦æœ‰é»˜è®¤æ¨¡æ¿å½¢å‚ï¼Œå¦åˆ™å¿…é¡»ä¼ å…¥ç›¸åº”çš„æ¨¡æ¿å®å‚ã€‚ä»C++17èµ·ï¼Œå…è®¸ç±»æ¨¡æ¿çš„æ¨¡æ¿å‚æ•°ç±»å‹æ¨æ–­ï¼Œä¾‹å¦‚ï¼š\n1 2 3  Stack\u0026lt;int\u0026gt; intStack1; Stack\u0026lt;int\u0026gt; intStack2 = intStack1; Stack intStack3 = intStack1;\t// since C++17   é€šè¿‡æ„é€ ä¼ å…¥æŸäº›åˆå§‹å‚æ•°çš„æ„é€ å‡½æ•°ï¼Œæ”¯æŒç±»å‹çš„æ¨æ–­ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4 5 6 7 8 9 10 11  template\u0026lt;typename T\u0026gt; class Stack{ private: std::vector\u0026lt;T\u0026gt; elems; public: Stack() = default; Stack(T const\u0026amp; elem) : elem{elem}{ } ... };   é€šè¿‡ä¸Šè¿°å®šä¹‰å¯ä»¥ä½¿ç”¨ä¸‹åˆ—åˆå§‹åŒ–ï¼š\n1  Stack intStack = 0;   è¿™é‡Œæ¨¡æ¿å‚æ•°Tå°†è‡ªåŠ¨è¢«æ¨æ–­ä¸ºint\n2.9.1 Class Template Arguments Deduction with String Literals å¯¹äºä¸Šè¿°å£°æ˜ï¼Œè¿˜å¯ä»¥åˆå§‹åŒ–ä¸ºstring literalsï¼Œä¾‹å¦‚ï¼š\n1  Stack stringStack = \u0026#34;bottom\u0026#34;;   è¿™é‡ŒTå°†è¢«æ¨æ–­ä¸ºchar const[7]ï¼Œè¿™æ ·å…¶å®æ˜¯æœ‰ç¼ºé™·çš„ï¼Œæ¯”å¦‚æˆ‘ä»¬ä¹‹ååªèƒ½åœ¨è¯¥ç±»ä¸­æ·»åŠ é•¿åº¦ä¸º7çš„å­—ç¬¦ä¸²ã€‚æˆ‘ä»¬æ›´å¸Œæœ›Tè¢«æ¨æ–­ä¸ºchar const*ï¼Œé€šè¿‡å£°æ˜æ„é€ å™¨æŒ‰å€¼ä¼ å‚å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼š\n1 2 3 4 5 6 7 8 9 10  template\u0026lt;typename T\u0026gt; class Stack{ private: std::vector\u0026lt;T\u0026gt; elems; public: Stack(T elem) : elems({elem}){ } ... };   è¿™æ ·ä¸€æ¥ï¼Œ\n1  Stack stringStack = \u0026#34;bottom\u0026#34;;   å°†è¢«åˆå§‹åŒ–ä¸ºStack\u0026lt;char const*\u0026gt;ï¼Œè€Œä¸ºäº†é¿å…ä¸å¿…è¦çš„æ‹·è´ï¼Œå¯ä»¥é€šè¿‡ä¸‹è¿°ä»£ç è¿›è¡Œä¼˜åŒ–ï¼š\n1 2 3 4 5 6 7 8 9 10  template\u0026lt;typename T\u0026gt; class Stack{ private: std::vector\u0026lt;T\u0026gt; elems; public: Stack(T elem) : elems({std::move(elem)}){ } ... };   2.9.2 Deduction Guide èƒ½å¤Ÿå®šä¹‰ç‰¹å®šçš„Deduction Guideå¯¹ç‰¹å®šçš„ç±»æ¨¡æ¿å‚æ•°è¿›è¡Œæ¨æ–­ï¼Œå¦‚ï¼š\n1  Stack(char const*)-\u0026gt;Stack\u0026lt;std::string\u0026gt;;   è¯¦çœ‹ç¤ºä¾‹\næ­¤æ—¶å£°æ˜åº”å†™ä¸ºï¼š\n1 2 3 4  Stack stringStack1{\u0026#34;bottom\u0026#34;};\t// since C++17 Stack stringStack2={\u0026#34;bottom\u0026#34;};\t// since C++17 Stack stringStack3={stringStack2};\t// since C++17 // Stack stringStack = \u0026#34;bottom\u0026#34;;æ— æ•ˆ   2.10 Templatized Aggregates èšåˆç±»æ˜¯æŒ‡ï¼šæ²¡æœ‰ç”¨æˆ·æä¾›çš„ã€æ˜¾å¼çš„æˆ–æ˜¯ç»§æ‰¿çš„æ„é€ å‡½æ•°ã€æ²¡æœ‰privateæˆ–protectedéé™æ€æ•°æ®æˆå‘˜ã€æ²¡æœ‰è™šå‡½æ•°ã€privateæˆ–protectedåŸºç±»çš„ç±»\nèšåˆæ¨¡æ¿ç±»ç¤ºä¾‹ï¼š\n1 2 3 4 5  template\u0026lt;typename T\u0026gt; struct ValueWithComment{ T value; std::string comment; };   èšåˆæ¨¡æ¿ç±»çš„ä½¿ç”¨ï¼š\n1 2 3  ValueWithComment\u0026lt;int\u0026gt; vc; vc.value = 42; vc.comment = \u0026#34;initial value\u0026#34;;   C++17ä¹‹åï¼Œå¯è¿›è¡Œç±»å‹æ¨æ–­ï¼š\n1 2 3  ValueWithComment(char const*, char const*) -\u0026gt; ValueWithComment\u0026lt;std::string\u0026gt;; ValueWithComment vc2 = {\u0026#34;hello\u0026#34;, \u0026#34;initial value\u0026#34;};   å¦‚æœæ²¡æœ‰deduction guideï¼Œä¸Šè¿°åˆå§‹åŒ–å°†ä¸å¯èƒ½å®ç°ï¼Œå› ä¸ºèšåˆç±»æ²¡æœ‰æ„é€ å‡½æ•°å¯ä»¥ä½¿å¾—å®ƒèƒ½å¤Ÿè¿›è¡Œç±»å‹æ¨æ–­\n2.11 Summary  A class template is a class that is implemented with one or more type parameters left open To use a class template, you pass the open types as template arguments. The class template is then instantiated (and compiled) for these types For class templates, only those member functions that are called are instantiated You can specialize class templates for certain types You can partially specialize class templates for certain types Since C++17, class template arguments can automatically be deduced from constructors You can define aggregate class templates Call parameters of a template type decay if declared to be called by value Templates can only be declared and defined in global/namespace scope or inside class declarations.  ","description":"ã€ŠC++ Templateså­¦ä¹ ç¬”è®°ç¬¬äºŒç« ã€‹","id":8,"section":"note","tags":["C++ Templates","C++"],"title":"Chapter 2: Class Templates","uri":"https://chaphlagical.github.io/zh/note/cpptemplate/ch2/"},{"content":"1.1 A First Look at Function Templates 1.1.1 Defining The Templates æ¨¡æ¿å£°æ˜ä¸ºï¼š\n1  template\u0026lt;å½¢å‚åˆ—è¡¨\u0026gt;   ä¾‹å¦‚ï¼š\n1 2 3 4 5 6  // max1.hpp template\u0026lt;typename T\u0026gt; T max(T a, T b) { return b \u0026lt; a ? a : b; }   ä¹Ÿå¯ä»¥ç”¨å…³é”®å­—ä»£æ›¿typenameï¼Œå¦‚ï¼š\n1 2 3 4 5  template\u0026lt;class T\u0026gt; T max(T a, T b) { return b \u0026lt; a ? a : b; }   1.1.2 Using the Templates ä¾‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026#34;max1.hpp\u0026#34; int main() { int i = 42; std::cout \u0026lt;\u0026lt; ::max(7, 42) \u0026lt;\u0026lt; std::endl; double f1 = 3.4; double f2 = -6.7; std::cout \u0026lt;\u0026lt; ::max(f1, f2) \u0026lt;\u0026lt; std::endl; std::string s1 = \u0026#34;mathematics\u0026#34;; std::string s2 = \u0026#34;math\u0026#34;; std::cout \u0026lt;\u0026lt; ::max(s1, s2) \u0026lt;\u0026lt; std::endl; }   ä½¿ç”¨æ¨¡æ¿æ—¶ç¼–è¯‘å™¨å°†é’ˆå¯¹æ¯ä¸€å¥—ä½¿ç”¨çš„æ¨¡æ¿å‚æ•°åˆ›å»ºä¸€ä¸ªå®ä¾‹ï¼Œè§ç¤ºä¾‹\næ³¨æ„ï¼š voidä¹Ÿæ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„æ¨¡æ¿å‚æ•°ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4 5 6  template\u0026lt;typename T\u0026gt; T foo(T*) {} void* vp = nullptr; foo(vp);   1.1.3 Two-Phase Translation æ¨¡æ¿çš„ç¼–è¯‘åŒ…å«ä¸¤ä¸ªé˜¶æ®µï¼š\n ç¬¬ä¸€é˜¶æ®µä¸ºä¸åŒ…å«å®ä¾‹çš„definition timeï¼Œå¿½ç•¥æ¨¡æ¿å‚æ•°åœ°æ£€æŸ¥æ¨¡æ¿ä»£ç æœ¬èº«ï¼ŒåŒ…æ‹¬  Syntax errors are discovered, such as missing semicolons Using unknown names(type names, function names, \u0026hellip;) that don\u0026rsquo;t depend on template parameters are discovered Static assertions that don\u0026rsquo;t depend on template parameters are checked   ç¬¬äºŒé˜¶æ®µä¸ºå®ä¾‹é˜¶æ®µï¼Œæ¨¡æ¿ä»£ç è¢«å†æ¬¡ç¡®è®¤æœ‰æ•ˆï¼Œä¾èµ–äºæ¨¡æ¿å‚æ•°çš„éƒ¨åˆ†å°†è¢«ç¡®è®¤  ä¸€ä¸ªä¾‹å­å¸®åŠ©ç†è§£ï¼š\n1 2 3 4 5 6 7 8  template\u0026lt;typename T\u0026gt; void foo(T t) { undeclared();\t// ç¼–è¯‘æœŸç¬¬ä¸€é˜¶æ®µæ£€æŸ¥  undeclared(t);\t// ç¼–è¯‘æœŸç¬¬äºŒé˜¶æ®µæ£€æŸ¥  static_assert(sizeof(int) \u0026gt; 10, \u0026#34;int too small\u0026#34;);\t// always fails if sizeof(int)\u0026lt;=10  static_assert(sizeof(T) \u0026gt; 10. \u0026#34;T too small\u0026#34;);\t// fails if instantiated for T with size\u0026lt;=10 }   1.2 Template Argument Deduction 1.2.1 Type Conversions During Type Deduction ç±»å‹æ¨æ–­æ—¶è‡ªåŠ¨ç±»å‹è½¬æ¢çš„é™åˆ¶ï¼š\n å½“å£°æ˜ä¸ºæŒ‰å¼•ç”¨ä¼ å‚æ—¶ï¼Œå³ä½¿æ˜¯trivialçš„è½¬æ¢éƒ½ä¸èƒ½ç”¨äºç±»å‹æ¨æ–­ã€‚ä¸¤ä¸ªå®å‚å¿…é¡»å®Œå…¨åŒ¹é…æ¨¡æ¿å½¢å‚ï¼Œä¾‹å¦‚ä¸‹è¿°ä»£ç ç¼–è¯‘å°†æŠ¥é”™ï¼š  1 2 3 4 5 6 7 8 9 10 11 12 13  template\u0026lt;typename T\u0026gt; T max(T\u0026amp; a, T\u0026amp; b) { return a \u0026gt; b? a : b; } int main() { const int a=1; int b=2; ::max(a,b);\t// const int å’Œ intåœ¨æŒ‰å¼•ç”¨ä¼ å‚ä¸‹æ— æ³•è½¬æ¢  return 0; }     å½“å£°æ˜ä¸ºæŒ‰å€¼ä¼ å‚æ—¶ï¼Œåˆ™æ”¯æŒé€€åŒ–(decay)çš„trivialè½¬æ¢ï¼š\n Qualifications with const or volatile are ignored References convert to the referenced type Raw arrays or functions convert to the corresponding pointer type  ä¾‹å¦‚ï¼š\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;string\u0026gt; template\u0026lt;typename T\u0026gt; T max(T a, T b) { return a \u0026gt; b? a : b; } int main() { const int a=1; int b=2; std::string s; ::max(a,b);\t// æ­£ç¡®ï¼Œå‘ç”Ÿé€€åŒ–è½¬æ¢  ::max(\u0026#34;hello\u0026#34;, s); // é”™è¯¯ï¼Œchar const[6]æ— æ³•ä¸std::stringå‘ç”Ÿé€€åŒ–è½¬æ¢  ::max(4, 4.5); // é”™è¯¯ï¼Œintä¸doubleæ— æ³•å‘ç”Ÿé€€åŒ–è½¬æ¢  return 0; }   1.2.2 Type Deduction for Default Arguments ç±»å‹æ¨æ–­æ— æ³•ç”¨äºé»˜è®¤å‚æ•°ï¼Œå¿…é¡»åŒæ—¶æŒ‡å®šé»˜è®¤æ¨¡æ¿å½¢å‚ç±»å‹ï¼š\n1 2 3 4  template\u0026lt;typename T = std::string\u0026gt; void f(T = \u0026#34;\u0026#34;); ... f();   1.3 Multiple Template Parameters å½¢å‚\n1 2 3 4 5 6 7 8  template\u0026lt;typename T1, typename T2\u0026gt; T1 max(T1 a, T2 b) { return b\u0026lt;a ? a : b; } ... auto m = ::max(4,7.2);   æ­¤æ—¶è¿”å›ç±»å‹ä¸ºT1ï¼Œè¦ä½¿å¾—è¿”å›ç±»å‹æ›´åŠ ç§‘å­¦ï¼Œæœ‰ä»¥ä¸‹æ–¹æ³•\n1.3.1 Template Parameters for Return Type æ˜¾å¼å®šä¹‰å’Œå£°æ˜è¿”å›ç±»å‹ï¼š\n1 2 3 4  template\u0026lt;typename T1, typename T2, typename RT\u0026gt; RT max(T1 a,T2 b); ... ::max\u0026lt;int, double, double\u0026gt;(4, 7.2);   å¯å°†RTç§»å‰è€ŒT1å’ŒT2äº¤ç»™ç¼–è¯‘å™¨æ¨æ–­ï¼š\n1 2 3 4  template\u0026lt;typename RT, typename T1, typename T2\u0026gt; RT max(T1 a,T2 b); ... ::max\u0026lt;double\u0026gt;(4, 7.2);   1.3.2 Deducing the Return Type ä½¿ç”¨decltypeå…³é”®å­—è¿›è¡Œç±»å‹æ¨æ–­\n1 2 3 4 5  template\u0026lt;typename T1, typename T2\u0026gt; auto max(T1 a, T2 b) -\u0026gt; decltype(b\u0026lt;a?a:b) { return b \u0026lt; a ? a : b; }   æ³¨æ„ï¼š b\u0026lt;a?a:bçš„æœ€ç»ˆç±»å‹ä¸b\u0026lt;aæ— å…³è€Œä¸aå’Œbæ˜¯ç›¸å…³çš„ï¼Œæ•…è¿™é‡Œå¯ä»¥ç›´æ¥ä½¿ç”¨trueæ¥ä»£æ›¿b\u0026lt;a\n1 2 3 4 5  template\u0026lt;typename T1, typename T2\u0026gt; auto max(T1 a, T2 b) -\u0026gt; decltype(true?a:b) { return b \u0026lt; a ? a : b; }   æœ‰æ—¶å€™å¯èƒ½ä¼šè¿”å›å¼•ç”¨ç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨\u0026lt;type_traits\u0026gt;åº“ä¸­çš„std::decay\u0026lt;\u0026gt;::type/std::decay_t\u0026lt;\u0026gt;æ–¹æ³•è¿›è¡Œé€€åŒ–è½¬æ¢ï¼š\n1 2 3 4 5 6 7  #include \u0026lt;type_traits\u0026gt; template\u0026lt;typename T1, typename T2\u0026gt; auto max(T1 a, T2 b) -\u0026gt; typename std::decay_t\u0026lt;decltype(true?a:b)\u0026gt; { return b \u0026lt; a ? a : b; }   1.3.3 Return Type as Common Type ä½¿ç”¨\u0026lt;type_traits\u0026gt;åº“ä¸­çš„std::common_type_t\u0026lt;\u0026gt;/std::common_type\u0026lt;\u0026gt;::typeæ–¹æ³•ï¼Œå¯ä»¥ä»£æ›¿å‰è¿°çš„decltypeæ–¹æ³•ï¼š\n1 2 3 4 5 6 7  #include \u0026lt;type_traits\u0026gt; template\u0026lt;typename T1, typename T2\u0026gt; std::common_type_t\u0026lt;T1, T2\u0026gt; max(T1 a, T2 b) { return b \u0026lt; a ? a : b; }   æ³¨æ„ï¼š\n C++11è§„èŒƒä¸­ä½¿ç”¨std::common_type\u0026lt;\u0026gt;::type C++14è§„èŒƒä¸­å¯ä»¥ä½¿ç”¨std::common_type_t\u0026lt;\u0026gt;  1.4 Default Template Arguments å¾ˆç®€å•ï¼Œæ¨¡æ¿å½¢å‚å¯ä»¥è®¾ç½®é»˜è®¤å€¼ï¼Œä¾‹å¦‚è¿”å›å€¼ç±»å‹å¯ä»¥æ²¿ç”¨typename RTä½†ç”¨decltypeæˆ–common_typeè®¾ç½®é»˜è®¤å½¢å‚\n1.5 Overloading Function Templates å‡½æ•°æ¨¡æ¿èƒ½å¤Ÿè¿›è¡Œé‡è½½\nå½“å‡½æ•°æ¨¡æ¿å®ä¾‹ä¸é‡è½½å‡½æ•°æ¥å£ä¸€æ¨¡ä¸€æ ·æ—¶ï¼Œå°†ä¼˜å…ˆä½¿ç”¨éæ¨¡æ¿å‡½æ•°ï¼Œä¾‹å¦‚ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12  int max(int a, int b) { return b \u0026lt; a? a : b; } template\u0026lt;typename T\u0026gt; T max(T a, T b) { return b \u0026lt; a ? a : b; } ... ::max(7, 42);\t// è°ƒç”¨éæ¨¡æ¿å‡½æ•°   1.6 But, Shouldn\u0026rsquo;t We \u0026hellip;? 1.6.1 Pass by Value or by Reference? åœ¨ä»¥ä¸‹æƒ…å†µä¸‹ï¼Œç›´æ¥ä¼ å€¼æ¯”ä¼ é€’å¼•ç”¨æ•ˆæœæ›´å¥½ï¼š\n The syntax is simple Compilers optimize better Move semantics often makes copies cheap And sometimes there is no copy or move at all  1.6.2 Why not inlineï¼Ÿ æ²¡å¿…è¦åŠ ä¸Šinlineå…³é”®å­—ï¼Œä½†ä¹Ÿåº”å®šä¹‰åœ¨å¤´æ–‡ä»¶ä¸­\n1.6.3 Why not constexprï¼Ÿ åœ¨ç¼–è¯‘æœŸè®¡ç®—çš„å…³é”®å­—\n1 2 3 4 5  template\u0026lt;typename T1, typename T2\u0026gt; constexpr auto max(T1 a, T2 b) { return b \u0026lt; a? a : b; }   1.7 Summary  Function templates define a family of functions for different template arguments When you pass arguments to function parameters depending on template parameters, function templates deduce the template parameters to be instantiated for the corresponding parameter types You can explicitly qualify the leading template parameters You can define default arguments for template parameters. These may refer to previous template parameters and be followed by parameters not having default arguments You can overload function templates When overloading function templates with other function templates, you should ensure that only one of them matches for any call When you overload function templates, limit your changes to specifying template parameters explicitly Ensure the compiler sees all overloaded versions of function templates before you call them.  ","description":"ã€ŠC++ Templateså­¦ä¹ ç¬”è®°ç¬¬ä¸€ç« ã€‹","id":10,"section":"note","tags":["C++ Templates","C++"],"title":"Chapter 1: Function Templates","uri":"https://chaphlagical.github.io/zh/note/cpptemplate/ch1/"},{"content":"è¿‘æ—¥ç¼–å†™ç®€æ˜“æ•°å­¦åº“æ—¶å‘ç°ï¼Œè‡ªå·±å†™çš„å‘é‡ç±»æ— æ³•ä½¿ç”¨æŒ‡é’ˆè¿›è¡Œè¿ç»­å†…å­˜è®¿é—®ï¼Œè€Œæˆ‘çš„ç±»å­˜å‚¨æ•°æ®åº•å±‚ä¸ºstd::arrayï¼Œå±äºé¡ºåºå­˜å‚¨å®¹å™¨ï¼Œå¯ä»¥é€šè¿‡ä¸‹è¿°æ–¹å¼è¿›è¡Œéå†ï¼š\n1 2 3 4  std::array\u0026lt;float, 3\u0026gt; x = { 1,2,3 }; float* p = static_cast\u0026lt;float*\u0026gt;(\u0026amp;x[0]); for (size_t i = 0; i \u0026lt; sizeof(x) / sizeof(float); i++) std::cout \u0026lt;\u0026lt; *(p++) \u0026lt;\u0026lt; std::endl; // è¾“å‡º1,2,3   è€Œæˆ‘çš„å‘é‡ç±»ä¼šå‡ºç°ä¹±ç ï¼Œåªèƒ½è¯´å†…å­˜åˆ†å¸ƒå¹¶ä¸æ˜¯æˆ‘æƒ³çš„é‚£æ ·ï¼Œç”¨sizeof(v)/sizeof(float)æµ‹è¯•åï¼Œå‘ç°è¯¥å€¼æ¯”æ­£å¸¸çš„ç›´æ¥ä½¿ç”¨arrayå­˜å‚¨å¤§äº†è¿‘ä¸€å€ã€‚äºæ˜¯é’ˆå¯¹ç±»å†…çš„æ‰€æœ‰æˆå‘˜å‡½æ•°è¿›è¡Œé€ä¸€æ’æŸ¥ï¼Œæœ€åå°†å…¶ä¸­çš„ä¸€ä¸ªè™šå‡½æ•°åˆ å»ï¼Œå‘ç°å†…å­˜å›åˆ°æˆ‘è¦çš„ç»“æœï¼ŒåŸæ¥æ˜¯è™šè¡¨æŒ‡é’ˆçš„é”…å•Šï¼Œè™½ç„¶ä»¥å‰åœ¨ä¹¦ä¸Šçœ‹åˆ°è¿‡ä½†çœŸæ­£å®è·µèµ·æ¥å´æ²¡èƒ½å¿«é€Ÿæ„è¯†åˆ°ã€‚å€Ÿæ­¤æœºä¼šä¹Ÿæ¸©ä¹ ä¸€ä¸‹è™šå‡½æ•°åœ¨C++ç±»çš„ä¸­çš„å†…å­˜åˆ†å¸ƒã€‚\n1. Visual StudioæŸ¥çœ‹C++ç±»å†…å­˜åˆ†å¸ƒçš„æ–¹æ³• åœ¨é¡¹ç›®çš„å±æ€§ä¸­æ‰¾åˆ°C/C++â†’å‘½ä»¤è¡Œï¼Œåœ¨å…¶ä»–é€‰é¡¹ä¸­æ·»åŠ å‘½ä»¤ï¼š\n/d1 reportSingleClassLayoutXXX\rå…¶ä¸­XXXä¸ºä½ æƒ³æ˜¾ç¤ºçš„ç±»åï¼Œæˆ–è€…ç›´æ¥æ˜¾ç¤ºæ‰€æœ‰ç±»çš„å†…å­˜åˆ†å¸ƒï¼š\n/d1 reportAllClassLayout\r2. æ™®é€šç±»çš„å†…å­˜åˆ†å¸ƒ ä½¿ç”¨æµ‹è¯•ä»£ç ï¼š\n1 2 3 4 5 6 7 8  class Base { public: void test() {} private: int a; int b; };   è¿™æ˜¯ä¸€ä¸ªæå…¶ç®€å•çš„ç±»ï¼Œå®ƒçš„å†…å­˜åˆ†å¸ƒå¦‚ä¸‹ï¼š\nå…¶ä¸­ï¼Œç±»å®ä¾‹åŒ–å¾—åˆ°çš„å¯¹è±¡æ‰€å ç”¨çš„å­˜å‚¨ç©ºé—´åªæ˜¯è¯¥å¯¹è±¡çš„æ•°æ®éƒ¨åˆ†ï¼ˆåŒ…æ‹¬è™šæŒ‡é’ˆå’Œè™šåŸºç±»æŒ‡é’ˆï¼Œåé¢æåˆ°ï¼‰æ‰€å ç”¨çš„å­˜å‚¨ç©ºé—´ï¼Œè€Œä¸åŒ…æ‹¬æˆå‘˜å‡½æ•°ä»£ç æ‰€å ç”¨çš„å­˜å‚¨ç©ºé—´ã€‚è¿™æ˜¯ç”±äºå„å¯¹è±¡çš„å‡½æ•°å ç”¨ç›¸åŒç©ºé—´ï¼š\n3. å¸¦è™šå‡½æ•°çš„ç±»çš„å†…å­˜åˆ†å¸ƒ ä½¿ç”¨æµ‹è¯•ä»£ç ï¼š\n1 2 3 4 5 6 7 8 9  class vBase { public: void test() {} virtual void vtest() {} private: int a; int b; };   å¯ä»¥çœ‹åˆ°å…¶å†…å­˜åˆ†å¸ƒï¼š\nå¤šå‡ºä¸€é¡¹è™šè¡¨æŒ‡é’ˆvfptrï¼ŒæŒ‡å‘è™šå‡½æ•°è¡¨\n4. ç±»ç»§æ‰¿çš„å†…å­˜åˆ†å¸ƒ å†æ¥çœ‹çœ‹ç±»ç»§æ‰¿çš„æƒ…å†µï¼Œæ™®é€šç±»çš„æ´¾ç”Ÿç±»ï¼š\n1 2 3 4 5 6 7  class Derv : public Base { public: void test1() {} private: int c; };   å†…å­˜åˆ†å¸ƒï¼š\næ´¾ç”Ÿç±»ä¸­çš„å†…å­˜æ•°æ®åŒ…æ‹¬åŸºç±»éƒ¨åˆ†å’Œæ´¾ç”Ÿç±»è‡ªå·±çš„éƒ¨åˆ†\nå¸¦è™šå‡½æ•°çš„ç±»çš„æ´¾ç”Ÿç±»ï¼š\n1 2 3 4 5 6 7  class vDerv : public vBase { public: void test1() {} private: int c; };   å†…å­˜åˆ†å¸ƒï¼š\nè™šè¡¨æŒ‡é’ˆè¢«ç»§æ‰¿äº†ï¼Œä¸”ä»ä½äºå†…å­˜æ’å¸ƒçš„èµ·å§‹å¤„ï¼Œè€Œè™šè¡¨åªæœ‰ä¸€ä¸ªï¼Œå­ç±»å¹¶æ²¡æœ‰é‡æ–°ç”Ÿæˆè™šè¡¨æŒ‡é’ˆï¼Œè¿™é‡Œä¸å¯¹çˆ¶ç±»è™šå‡½æ•°è¿›è¡Œé‡è½½ï¼Œå› æ­¤è™šè¡¨ä¸­çš„vtestå‡½æ•°ä»ç„¶æ˜¯çˆ¶ç±»çš„vtestå‡½æ•°\nå†æ¥çœ‹çœ‹é‡è½½äº†çˆ¶ç±»è™šå‡½æ•°çš„æƒ…å†µï¼š\n1 2 3 4 5 6 7 8  class vDerv : public vBase { public: void test1() {} virtual void vtest()override {} private: int c; };   å†…å­˜åˆ†å¸ƒï¼š\nå¯ä»¥çœ‹åˆ°è™šè¡¨ä¸­çš„å‡½æ•°æŒ‡å‘äº†å­ç±»çš„ç»“æœ\nå¯¹äºå¤šé‡ç»§æ‰¿ï¼Œè‹¥æ‰€æœ‰çˆ¶ç±»å‡ä¸å«è™šæˆå‘˜å‡½æ•°ï¼Œå¦‚ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Base1 { public: void test1() {} private: int a; }; class Base2 { public: void test2() {} private: int b; }; class Derv : public Base1, public Base2 { public: void test() {} private: int c; };   å†…å­˜åˆ†å¸ƒï¼š\nå¯è§æ´¾ç”Ÿç±»ä¾æ¬¡ç»§æ‰¿äº†çˆ¶ç±»çš„æ•°æ®éƒ¨åˆ†\nå¸¦è™šå‡½æ•°æ—¶\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class vBase1 { public: void test() {} virtual void vtest1() {} private: int a; int b; }; class vBase2 { public: void test() {} virtual void vtest2() {} private: int c; int d; }; class vDerv : public vBase1, public vBase2 { public: void test1() {} virtual void vtest1()override {} private: int c; };   å†…å­˜åˆ†å¸ƒï¼š\nè¿™é‡ŒvDervç»§æ‰¿è‡ªBase1å’ŒBase2ä¸¤ä¸ªçˆ¶ç±»ï¼Œé‡è½½äº†Base1ä¸­çš„vtest1æ–¹æ³•ï¼Œç»“æœå’Œä¹‹å‰è®¨è®ºçš„ç±»ä¼¼\néœ€è¦ç‰¹åˆ«æ³¨æ„çš„æ˜¯ï¼šç©ºåŸºç±»çš„ç»§æ‰¿é—®é¢˜\nä¾‹å¦‚ï¼š\n1 2 3 4 5 6 7 8 9 10 11  class Empty { }; class Derv : public Empty { public: void test() {} private: int c; };   æ­¤æ—¶å†…å­˜åˆ†å¸ƒå¦‚ä¸‹ï¼š\nå‘ç°ç©ºåŸºç±»æ˜¯ä¸å ç”¨å†…å­˜çš„ï¼Œè¿™ä¼¼ä¹å¾ˆç¬¦åˆå¸¸è¯†ï¼Œä½†ç›´æ¥è®¡ç®—ç©ºç±»çš„å¤§å°æ—¶å¯ä»¥å‘ç°ï¼Œsizeof(Empty)çš„ç»“æœä¸º1ï¼Œä¹Ÿå°±æ˜¯è¯´è™½ç„¶ç©ºç±»ä¸å­˜å‚¨ä»»ä½•æ•°æ®ï¼Œå®ƒä»éœ€è¦å ç”¨ä¸€ä¸ªå­—èŠ‚çš„ç©ºé—´ã€‚è€Œè¿›è¡Œç©ºåŸºç±»ç»§æ‰¿æ—¶ï¼Œä¼šè¿›è¡Œç©ºåŸºç±»ä¼˜åŒ–ï¼ˆempty base class optimization, EBCOï¼‰ï¼ŒèŠ‚çœç©ºé—´å ç”¨ã€‚ç„¶è€Œåœ¨Visual Studioä¸­è¿›è¡Œç©ºåŸºç±»å¤šç»§æ‰¿æ—¶åˆä¼šæœ‰å¥‡æ€ªçš„ç°è±¡å‘ç”Ÿï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Empty1 { }; class Empty2 { }; class Derv : public Empty1, public Empty2 { public: void test() {} private: int c; };   å†…å­˜åˆ†å¸ƒï¼š\nå‘ç°å¤šç»§æ‰¿æ—¶MSVCå¹¶æ²¡æœ‰è¿›è¡ŒEBCOï¼ŒæŸ¥é˜…èµ„æ–™å‘ç°è¿™ç«Ÿç„¶è¿˜æ˜¯MSVCçš„ä¸€ä¸ªbugï¼Œç”±äºæ²¡æœ‰è¿›è¡ŒEBCOï¼Œå¤šå‡ºæ¥çš„å‡ ä¸ªå­—èŠ‚ç”±äºå¯¹é½çš„åŸå› è¿˜å¾—æµªè´¹3ä¸ªå­—èŠ‚æ— ç”¨ç©ºé—´ã€‚äºæ˜¯ä¸ºäº†ä½¿å­ç±»èƒ½å¤Ÿæ‹¥æœ‰ä¸¤ä¸ªåŸºç±»çš„ç‰¹æ€§ï¼Œä¸å¾—ä¸å°†å¤šç»§æ‰¿æ”¹ä¸ºé“¾å¼ç»§æ‰¿æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Empty1 { }; class Empty2: public Empty1 { }; class Derv : public Empty2 { public: void test() {} private: int c; };   å†…å­˜åˆ†å¸ƒï¼š\næ­¤æ—¶å¯ä»¥æˆåŠŸå¯¹é½\n5. å¤ä¹ ï¼šC++çš„å†…å­˜æ ¼å±€  æ ˆï¼šç³»ç»Ÿè‡ªåŠ¨åˆ†é…çš„ç©ºé—´ï¼Œåªè¦ä¸ç‰¹æ®Šå£°æ˜ï¼Œå°±å®šä¹‰åœ¨æ ˆåŒºï¼Œå‡½æ•°çš„åŒºåŸŸä¹Ÿåœ¨æ ˆä¸Šã€‚æ ˆæ˜¯å‘ä¸‹å¢é•¿çš„ã€‚ï¼ˆconst åœ¨æ ˆé‡Œï¼‰ å †ï¼šä½¿ç”¨åŠ¨æ€å†…å­˜åˆ†é…çš„æ–¹å¼å¯ä»¥ç”³è¯·å †ç©ºé—´ï¼Œç”¨å®Œè¦æ‰‹åŠ¨é‡Šæ”¾ã€‚ å…¨å±€åŒºï¼šå…¨å±€å˜é‡ã€é™æ€å˜é‡ï¼ˆstaticï¼‰ å¸¸é‡åŒºï¼šä»£ç ä¸­çš„æ•°å­—ï¼Œå­—ç¬¦ç­‰å¸¸é‡ï¼Œä¾‹å¦‚â€™aâ€™ï¼Œâ€”1.2ç­‰ ä»£ç åŒºï¼šå­˜æ”¾å¯æ‰§è¡Œä»£ç ï¼Œé¿å…é¢‘ç¹çš„è¯»ç¡¬ç›˜ã€‚   Data:æ•°æ®æ®µï¼Œè¦æ”¾åœ¨å¯æ‰§è¡Œæ–‡ä»¶ä¸­çš„æ•°æ®ï¼ŒåŒ…æ‹¬å †ã€æ ˆã€ä»¥åˆå§‹åŒ–çš„å…¨å±€å˜é‡ Bss: æœªåˆå§‹åŒ–çš„å…¨å±€å˜é‡ï¼Œä¸å ç”¨å¯æ‰§è¡Œæ–‡ä»¶çš„å¤§å° Text: åªè¯»åŒºåŸŸï¼ŒåŒ…æ‹¬å¸¸é‡åŒºå’Œä»£ç åŒº  ç¤ºä¾‹ï¼š\n6. å°ç»“ å›åˆ°æœ€å¼€å§‹çš„é—®é¢˜ï¼Œæˆ‘å¸Œæœ›èƒ½è®©æˆ‘çš„ç±»èƒ½å¤Ÿè¿›è¡Œé¡ºåºå­˜å‚¨è®¿é—®ï¼Œç°åœ¨çœ‹æ¥å…¶å®éå¸¸ç®€å•ï¼š\n é¦–å…ˆå¿…é¡»ä½¿ç”¨è¿ç»­å­˜å‚¨ç»“æ„  æˆå‘˜å˜é‡æœ¬èº«å¿…é¡»é¡ºåºå­˜å‚¨ï¼Œå¦‚æ•°ç»„ã€é¡ºåºå®¹å™¨ç­‰ æˆå‘˜å˜é‡ä¸ºå•ä¸ªå˜é‡ä¸ªä½“ï¼ˆæˆå‘˜å˜é‡åœ¨ç±»ä¸­é¡ºåºå­˜å‚¨ï¼‰   é¿å…åœ¨ç±»ä¸­ä½¿ç”¨è™šå‡½æ•°  å¼•å…¥è™šè¡¨æŒ‡é’ˆæ±¡æŸ“å†…å­˜åˆ†å¸ƒ   è‹¥ä½¿ç”¨MSVCï¼Œæ³¨æ„ç©ºåŸºç±»å¤šç»§æ‰¿æ— EBCOçš„å‘  ","description":"æµ…è°ˆC++ç±»çš„å†…å­˜åˆ†å¸ƒ","id":11,"section":"posts","tags":["C++"],"title":"C++ç±»çš„å†…å­˜åˆ†å¸ƒ","uri":"https://chaphlagical.github.io/zh/posts/2020-11-15-c++%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"content":"æˆ‘å°†åœ¨è¿™é‡Œåˆ†äº«æœ‰è¶£çš„çŸ¥è¯†ä¸æŠ€æœ¯\n","description":"My Blog","id":13,"section":"","tags":null,"title":"å…³äº","uri":"https://chaphlagical.github.io/zh/about/"},{"content":"Item 32: Make Sure public inheritance models \u0026ldquo;is-a\u0026rdquo;   public inheritanceï¼ˆå…¬å¼€ç»§æ‰¿ï¼‰æ„å‘³ç€â€œis-aâ€ï¼ˆæ˜¯ä¸€ç§ï¼‰çš„å…³ç³»\n  å¦‚æœä»¤class Dä»¥publicå½¢å¼ç»§æ‰¿class Bï¼Œä¾¿æ˜¯å‘ŠçŸ¥C++ç¼–è¯‘å™¨æ¯ä¸ªç±»å‹ä¸ºDçš„å¯¹è±¡åŒæ—¶ä¹Ÿæ˜¯ä¸€ä¸ªç±»å‹ä¸ºBçš„å¯¹è±¡ï¼Œåä¹‹ä¸æˆç«‹\n  è€ƒè™‘publicç»§æ‰¿\n  1 2  class Person{...}; class student: public Person{...};     æ¯ä¸ªå­¦ç”Ÿéƒ½æ˜¯äººï¼Œä½†å¹¶éæ¯ä¸ªäººéƒ½æ˜¯å­¦ç”Ÿ\n  åœ¨C++ä¸­ï¼Œä»»ä½•å‡½æ•°å¦‚æœæœŸæœ›è·å¾—ä¸€ä¸ªç±»å‹ä¸ºPersonï¼ˆæˆ–pointer-to-Personæˆ–reference-to-Personï¼‰çš„å®å‚ï¼Œä¹Ÿéƒ½æ„¿æ„æ¥å—ä¸€ä¸ªStudentå¯¹è±¡ï¼ˆæˆ–pointer-to-Studentæˆ–reference-to-Studentï¼‰\n  1 2 3 4 5 6 7 8  void eat(const Person\u0026amp; p);\t// all person will eat void study(const Student\u0026amp; s);\t// only students study Person p; Student s; eat(p);\t// âˆš eat(s);\t// âˆš study(p);\t// Ã—ï¼Œ person is not student study(s);\t// âˆš    â€œis-aâ€å¹¶éå”¯ä¸€å­˜åœ¨äºclassesä¹‹é—´çš„å…³ç³»ï¼Œå¦å¤–ä¸¤ä¸ªå¸¸è§çš„å…³ç³»æ˜¯â€œhas-aâ€ï¼ˆæœ‰ä¸€ä¸ªï¼‰å’Œâ€œis-implemented-in-terms-ofâ€ï¼ˆæ ¹æ®æŸç‰©å®ç°å‡ºï¼‰  Item 33: Avoid hiding inherited names  é®æ©åç§°ï¼šä½œç”¨åŸŸç›¸å…³  1 2 3 4 5 6  int x;\t// global variable void someFunc() { double x;\t// local variable  std::cin\u0026gt;\u0026gt;x; }    å½“ç¼–è¯‘å™¨å¤„äºsomeFuncçš„ä½œç”¨åŸŸå†…å¹¶é­å—åç§°xæ—¶ï¼Œå®ƒåœ¨localä½œç”¨åŸŸå†…æŸ¥æ‰¾æ˜¯å¦æœ‰ä»€ä¹ˆä¸œè¥¿å¸¦ç€è¿™ä¸ªåç§°ã€‚å¦‚æœæ‰¾åˆ°äº†å°±ä¸å†æ‰¾å…¶ä»–ä½œç”¨åŸŸ  é®æ©ç»§æ‰¿ï¼šderived classä½œç”¨åŸŸè¢«åµŒå¥—åœ¨base classä½œç”¨åŸŸå†…\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Base{ private: int x; public: virtual void mf1() = 0; virtual void mf2(); void mf3(); ... }; class Derived: public Base{ public: virtual void mf1(); void mf4(); ... };    å‡è®¾derived classå†…çš„mf4çš„å®ç°å¦‚ä¸‹ï¼š  1 2 3 4 5 6  void Derived::mf4() { ... mf2(); ... }     æŸ¥æ‰¾é¡ºåºï¼šlocalä½œç”¨åŸŸ â†’ class Derivedä½œç”¨åŸŸ â†’ base classä½œç”¨åŸŸ â†’ å«Baseçš„namespace â†’ globalä½œç”¨åŸŸ\n  é‡è½½\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Base{ private: int x; public: virtual void mf1() = 0; virtual void mf1(int); virtual void mf2(); void mf3(); void mf3(double); ... }; class Derived: public Base{ public: virtual void mf1(); void mf3(); void mf4(); ... };    base classå†…æ‰€æœ‰åä¸ºmf1å’Œmf3çš„å‡½æ•°éƒ½è¢«derived classå†…çš„mf1å’Œmf3å‡½æ•°é®æ©æ‰ã€‚ä»åç§°æŸ¥æ‰¾è§‚ç‚¹çœ‹ï¼ŒBase::mf1å’ŒBase::mf3ä¸å†è¢«Derivedç»§æ‰¿  1 2 3 4 5 6 7 8  Derived d; int x; ... d.mf1();\t// âˆš è°ƒç”¨Derived::mf1 d.mf1(x);\t// Ã— Derived::mf1é®æ©äº†Base::mf1 d.mf2();\t// âˆš è°ƒç”¨Base::mf2 d.mf3();\t// âˆš è°ƒç”¨Derived::mf3 d.mf3(x);\t// Ã— Derived::mf3é®æ©äº†Base::mf3     ä¸Šè¿°è§„åˆ™å¯¹base classeså’Œderived classeså†…çš„å‡½æ•°æœ‰ä¸åŒçš„å‚æ•°ç±»å‹ä¹Ÿé€‚ç”¨ï¼Œè€Œä¸”æ— è®ºå‡½æ•°æ˜¯virtualè¿˜æ˜¯non-virtualä¹Ÿé€‚ç”¨\n  è‹¥ç»§æ‰¿base classå¹¶åŠ ä¸Šé‡è½½å‡½æ•°ï¼Œæœ‰å¸Œæœ›é‡æ–°å®šä¹‰æˆ–è¦†å†™å…¶ä¸­ä¸€éƒ¨åˆ†ï¼Œåˆ™å¿…é¡»ä¸ºé‚£äº›åŸæœ¬ä¼šè¢«é®æ©çš„æ¯ä¸ªåç§°å¼•å…¥ä¸€ä¸ªusingå£°æ˜å¼ï¼Œå¦åˆ™æŸäº›ä½ å¸Œæœ›ç»§æ‰¿çš„åç§°ä¼šè¢«é®æ©\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Base{ private: int x; public: virtual void mf1() = 0; virtual void mf1(int); virtual void mf2(); void mf3(); void mf3(double); ... }; class Derived: public Base{ public: using Base::mf1; using Base::mf3; virtual void mf1(); void mf3(); void mf4(); ... };     ç»§æ‰¿base classesçš„éƒ¨åˆ†å‡½æ•°\n åœ¨publicç»§æ‰¿ä¸‹æ˜¯ä¸å¯èƒ½å‡ºç°çš„ï¼Œå› ä¸ºè¿åäº†â€œis-aâ€å…³ç³» åœ¨privateç»§æ‰¿ä¸‹æ˜¯æœ‰æ„ä¹‰çš„ï¼Œé€šè¿‡è½¬äº¤å‡½æ•°å®ç°    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Base{ public: virtual void mf1() = 0; virtual void mf1(int); ... }; class Derived: private Base{ public: virtual void mf1() {Base::mf1();}\t// inlineè½¬äº¤å‡½æ•°  ... }; ... Derived d; int x; d.mf1();\t// âˆš è°ƒç”¨Derived::mf1 d.mf1(x);\t// Ã— Base::mf1è¢«é®æ©äº†   Item 34: Differentiate between inheritance of interface and inheritance of implementation   publicç»§æ‰¿ï¼šå‡½æ•°æ¥å£ç»§æ‰¿ã€å‡½æ•°å®ç°ç»§æ‰¿\n  pure virtualå‡½æ•°çš„ç›®çš„æ˜¯ä¸ºäº†è®©derived classåªç»§æ‰¿å‡½æ•°æ¥å£\n  non-virtualå‡½æ•°æ˜¯ä¸ºäº†ä»¤derived classç»§æ‰¿å‡½æ•°æ‰½æ¥å£ä»¥åŠä¸€ä»½å¼ºåˆ¶æ€§å®ç°\n  impure virtualå‡½æ•°çš„ç›®çš„æ˜¯è®©derived classç»§æ‰¿å‡½æ•°çš„æ¥å£å’Œç¼ºçœå®ç°\n impure virtualå‡½æ•°ä¼šè®©derived classåœ¨æœªå£°æ˜äºŒç‚¹æƒ…å†µä¸‹è‡ªåŠ¨ç»§æ‰¿ç¼ºçœå®ç° åˆ‡æ–­virtualå‡½æ•°æ¥å£å’Œç¼ºçœå®ç°çš„ä¸€ä¸ªæ–¹æ³•ï¼š  1 2 3 4 5 6 7 8 9 10 11  class Airplane{ public: virtual void fly(const Airport\u0026amp; destination) = 0; ... protected: void defaultFly(const Airport\u0026amp; destination); }; void Airplane::defaultFly(const Airport\u0026amp; destination) { // implementation }   ä½¿ç”¨ç¼ºçœå®ç°æ—¶ï¼Œåªéœ€è¦ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12  class ModelA: public Airplane{ public: virtual void fly(const Airport\u0026amp; destination) {defaultFly(destination);} ... }; class ModelB: public Airplane{ public: virtual void fly(const Airport\u0026amp; destination) {defaultFly(destination);} ... };   è¿™ç§æ–¹æ³•é¿å…äº†æ„å¤–ç»§æ‰¿çš„ç°è±¡ï¼Œä¸‹é¢æ˜¯è¯¥æ–¹æ³•çš„ä¸€ç§ä¼˜åŒ–æ–¹å¼ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Airplane{ public: virtual void fly(const Airport\u0026amp; destination) = 0; ... }; void Airplane::fly(const Airport\u0026amp; destination) { // implementation } class ModelA: public Airplane{ public: virtual void fly(const Airport\u0026amp; destination) {Airplane::fly(destination);} ... }; class ModelB: public Airplane{ public: virtual void fly(const Airport\u0026amp; destination) {Airplane::fly(destination);} ... };     ","description":"ã€ŠEffective C++å­¦ä¹ ç¬”è®°ç¬¬å…­ç« ã€‹","id":14,"section":"note","tags":["Effective C++","C++"],"title":"Chapter 6: Inheritance and Object-Oriented Design","uri":"https://chaphlagical.github.io/zh/note/effectivecpp/ch6/"},{"content":"1. Bæ ·æ¡åŸºå‡½æ•° 1.1. De Booré€’æ¨ 1.1.1. å•ä½æƒ…å†µ $k$é˜¶ï¼ˆ$k-1$åº¦ï¼‰å•ä½Bæ ·æ¡åŸºå‡½æ•°è¡¨ç¤ºä¸ºï¼š\n$$\nN_i^1(t)=\\begin{cases}\n1,\u0026amp;i\\leq t\u0026lt;i+1\\\\0,\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n$$\n$$\n\\begin{align}\nN_i^k(t)\u0026amp;=\\dfrac{t-i}{(i+k-1)-i}N_i^{k-1}(t)+\\dfrac{(i+k)-t}{(i+k)-(i+1)}N_{i+1}^{k-1}(t)\\\\\n\u0026amp;=\\dfrac{t-i}{k-1}N_i^{k-1}(t)+\\dfrac{i+k-t}{k-1}N_{i+1}^{k-1}(t)\n\\end{align}\n$$\n1.1.2. ä¸€èˆ¬æƒ…å†µ   ç»™å®šï¼šç»“åºåˆ—$t_0\u0026lt;t_1\u0026lt;\\cdots\u0026lt;t_n\u0026lt;\\cdots\u0026lt;t_{n+k}$\nï¼ˆ$(t_0,t_1,\\cdots,t_{n+k})$ç§°ä¸ºç»“å‘é‡ï¼‰\n  å½’ä¸€åŒ–çš„$k$é˜¶ï¼ˆ$k-1$åº¦ï¼‰å•ä½Bæ ·æ¡åŸºå‡½æ•°$N_{i,k}$å®šä¹‰ä¸ºï¼š\n$$\n\\begin{align}\nN_i^1(t)\u0026amp;=\\begin{cases}\n1,\u0026amp;t_i\\leq t\u0026lt;t_{i+1}\\\\0,\u0026amp;\\mathrm{otherwise}\n\\end{cases}\\\\\nN_{i,k}(t)\u0026amp;=\\dfrac{t-t_i}{t_{i+k-1}-t_i}N_{i,k-1}(t)+\\dfrac{t_{i+k}-t}{t_{i+k}-t_{i+1}}N_{i+1,k-1}(t)\n\\end{align}\n$$\nå…¶ä¸­ï¼Œ$k\u0026gt;1$ä¸”$i=0,\\cdots,n$\n  1.2. æ ¸å¿ƒæ€æƒ³  è®¾è®¡åŸºå‡½æ•°$\\pmb b(t)$ æ€§è´¨ï¼š  $\\pmb b(t)$ä¸º$C^2$è¿ç»­ $\\pmb b(t)$æ˜¯ä¸‰æ¬¡åˆ†æ®µå¤šé¡¹å¼ $\\pmb b(t)$å…·æœ‰å±€éƒ¨æ§åˆ¶æ€§è´¨ å åŠ ä½ç§»çš„$\\pmb b(t+i)$ç»„æˆä¸€ä¸ªæ•´ä½“çš„åˆ’åˆ† å¯¹æ‰€æœ‰çš„$t$ï¼Œæœ‰$\\pmb b(t)\\geq 0$   ç®€è€Œè¨€ä¹‹  åŸºå‡½æ•°ä¸­å…·æœ‰æ‰€æœ‰æ‰€éœ€çš„æ€§è´¨ åŸºå‡½æ•°çš„çº¿æ€§ç»„åˆä¹Ÿå°†æœ‰è¿™äº›æ€§è´¨    1.3. åŸºå‡½æ•°æ€§è´¨   å¯¹$t_i\u0026lt;t\u0026lt;t_{i+k}$ï¼Œæœ‰$N_{i,k}(t)\u0026gt;0$\n  å¯¹$t_0\u0026lt;t\u0026lt;t_i$æˆ–$t_{i+k}\u0026lt;t\u0026lt;t_{n+k}$ï¼Œæœ‰$N_{i,k}(t)=0$\n  å¯¹$t_{k-1}\\leq t\\leq t_{n+1}$ï¼Œæœ‰$\\sum_{i=1}^nN_{i,k}(t)=1$\n  å¯¹äº$t_i\\leq t_j\\leq t_{i+k}$ï¼ŒåŸºå‡½æ•°$N_{i,k}(t)$åœ¨ç»“ç‚¹$t_j$å¤„æœ‰$C^{k-2}$è¿ç»­æ€§\n  åŒºé—´$[t_i,t_{i+k}]$ç§°ä¸º$N_{i,k}$çš„æ”¯æ’‘ï¼ˆsupportï¼‰\n  2. Bæ ·æ¡æ›²çº¿ 2.1. Bæ ·æ¡æ›²çº¿ç®€ä»‹   ç»™å®š$n+1$ä¸ªæ§åˆ¶ç‚¹$\\pmb d_0,\\cdots,\\pmb d_n\\in \\mathbb R^3$ï¼Œç»“å‘é‡$T=(t_0,\\cdots,t_n,\\cdots,t_{n+k})$\n  $k$é˜¶Bæ ·æ¡æ›²çº¿$\\pmb x(t)$å®šä¹‰ä¸ºï¼š\n$$\n\\pmb x(t)=\\sum\\limits_{i=0}^nN_{i,k}(t)\\cdot\\pmb d_i\n$$\n  ç‚¹$\\pmb d_i$ç§°ä¸ºde Boor points\n  2.1.1. é‡å¤ç»“å‘é‡   Bæ ·æ¡æ›²çº¿å…è®¸ï¼š$T=(t_0,\\cdots,t_n,\\cdots,t_{n+k})$ï¼Œ$t_0\\leq t_1\\leq \\cdots\\leq t_{n+k}$\n  åªè¦ä¸è¶…è¿‡$k$ä¸ªç»“é‡åˆï¼ŒBæ ·æ¡å‡½æ•°$N_{i,k}(i=0,\\cdots,n)$çš„é€’å½’å®šä¹‰ä¾ç„¶æœ‰æ•ˆ\n  å¤šç»“é‡åˆçš„æ•ˆæœï¼š\n è®¾ï¼š$t_0=t_1=\\cdots=t_{k-1}$ ä¸”$t_{n+1}=t_{n+2}=\\cdots=t_{n+k}$  åˆ™å°†æ’å€¼$\\pmb d_0$å’Œ$\\pmb d_n$\n  2.2. Bæ ·æ¡çš„æ€§è´¨ 2.2.1. Bæ ·æ¡å‡½æ•° vs Bernsteinå¤šé¡¹å¼ ç»“å‘é‡$T=(t_0,t_1,\\cdots,t_{2k-1})=(\\underbrace{0,\\cdots,0}_k,\\underbrace{1,\\cdots,1}_k)$ä¸‹çš„$k$é˜¶Bæ ·æ¡å‡½æ•°$N_{i,k}(i=0,\\cdots,k-1)$ä¸º$k-1$æ¬¡Bernsteinå¤šé¡¹å¼$B_i^{k-1}$\n2.2.2. åŸºæœ¬æ€§è´¨   ç»™å®š\n $T=(\\underbrace{t_0,\\cdots,t_0}_{k\\ \\mathrm{times}},t_k,\\cdots,t_n,\\underbrace{t_{n+1},\\cdots,t_{n+1}}_{k\\ \\mathrm{times}})$ de Boorå¤šè¾¹å½¢$\\pmb d_0,\\cdots,\\pmb d_n$    ç›¸åº”çš„Bæ ·æ¡æ›²çº¿$\\pmb x(t)$æœ‰ä»¥ä¸‹æ€§è´¨ï¼š\n  $\\pmb x(t_0)=\\pmb d_0$ï¼Œ$\\pmb x(t_{n+1})=\\pmb d_n$ï¼ˆè¾¹ç•Œç‚¹æ’å€¼ï¼‰\n  $\\dot{\\pmb x}(t_0)=\\dfrac{k-1}{t_k-t_0}(\\pmb d_1-\\pmb d_0)$ï¼ˆ$\\pmb d_0$å¤„çš„åˆ‡çº¿æ–¹å‘ä¸$\\pmb d_n$å¤„ç›¸ä¼¼ï¼‰\n  $\\pmb x(t)$ç”±$n-k+2$ä¸ª$k-1$æ¬¡å¤šé¡¹å¼æ›²çº¿æ®µæ„æˆ\n  å¤šé‡å†…éƒ¨ç»“$\\Rightarrow$å‡å°äº†$\\pmb x(t)$çš„è¿ç»­é˜¶æ•°\n$l$é‡å†…éƒ¨ç»“$(1\\leq l\u0026lt;k)$æ„å‘³ç€$C^{k-l-1}$é˜¶è¿ç»­\n  de Boorç‚¹çš„å±€éƒ¨å½±å“ï¼šç§»åŠ¨$\\pmb d_i$åªä¼šæ”¹å˜æ›²çº¿çš„$[t_i,t_{i+k}]$åŒºé—´éƒ¨åˆ†\n  æ’å…¥æ–°çš„de Boorç‚¹ä¸ä¼šæ”¹å˜æ›²çº¿æ®µçš„å¤šé¡¹å¼é˜¶æ•°\n    2.2.3. Bæ ·æ¡æ›²çº¿çš„å±€éƒ¨æ€§ 2.2.4. Bæ ·æ¡æ›²çº¿çš„å‡é˜¶   ä½¿ç”¨Bæ ·æ¡å‡½æ•°\n  ä½¿ç”¨de Boorç®—æ³•\nä¸Bezieræ›²çº¿çš„de Casteljauç®—æ³•ç±»ä¼¼ï¼Œåœ¨Boorå¤šè¾¹å½¢ä¸Šè¿›è¡Œä¸€ç³»åˆ—çš„çº¿æ€§æ’å€¼\n  2.3. de Boorç®—æ³•   ç»™å®šï¼š\nde Boorç‚¹ï¼š$\\pmb d_0,\\cdots,\\pmb d_n$\nç»“å‘é‡ï¼š$(t_0,\\cdots,t_{k-1}=t_0,t_k,t_{k+1},\\cdots,t_n,t_{n+1},\\cdots,t_{n+k}=t_{n+1})$\n  ç›®æ ‡ï¼š$k$ç»“Bæ ·æ¡æ›²çº¿çš„æ›²çº¿ç‚¹$\\pmb x(t)$\n  ç®—æ³•æµç¨‹ï¼š\n  ä¸­é—´ç³»æ•°$\\pmb d_i^j(t)$å¯ä»¥è¡¨ç¤ºä¸ºä¸€ä¸ªä¸‹ä¸‰è§’çŸ©é˜µâ€”â€”de Boorå›¾\n$$\n\\begin{matrix}\n\\pmb d_{r-k+1}=\\pmb d^0_{r-k+1}\\\\\n\\pmb d_{r-k+2}=\\pmb d^0_{r-k+2}\u0026amp;\\pmb d_{r-k+2}^1\\\\\n\\vdots\\\\\n\\pmb d_{r-1}=\\pmb d_{r-1}^0\u0026amp;\\pmb d_{r-1}^1\u0026amp;\\cdots\u0026amp;\\pmb d_{r-1}^{k-2}\\\\\n\\pmb d_r=\\pmb d_r^0\u0026amp;\\pmb d_r^1\u0026amp;\\cdots\u0026amp;\\pmb d_r^{k-2}\u0026amp;\\pmb d_r^{k-1}=\\pmb x(t)\n\\end{matrix}\n$$\n  2.4. Bæ ·æ¡æ›²çº¿æ’å€¼   ç»™å®šï¼š$n+1$ä¸ªæ§åˆ¶ç‚¹$\\pmb k_0,\\cdots,\\pmb k_n$ï¼Œç»“åºåˆ—$s_0,\\cdots,s_n$\n  ç›®æ ‡ï¼šåˆ†æ®µä¸‰æ¬¡æ’å€¼Bæ ·æ¡æ›²çº¿$\\pmb x$\n  æ–¹æ³•ï¼šåˆ†æ®µä¸‰æ¬¡$\\Rightarrow k=4$\n $\\pmb x(t)$ç”±$n$æ®µç»„æˆ$\\Rightarrow n+3$ä¸ªde Boorç‚¹    å®ä¾‹ï¼š$n=3$\n  è‹¥é€‰æ‹©ç»“å‘é‡\n$$\n\\begin{align}\nT\u0026amp;=(t_0,t_1,t_2,t_3,t_4,\\cdots,t_{n+2},t_{n+3},t_{n+4},t_{n+5},t_{n+6})\\\\\n\u0026amp;=(s_0,s_0,s_0,s_0,s_1,\\cdots,s_{n-1},s_n,s_n,s_n,s_n)\n\\end{align}\n$$\n  æ’å€¼æ¡ä»¶ï¼š\n$$\n\\begin{align}\n\\pmb x(s_0)\u0026amp;=\\pmb k_0=\\pmb d_0\\\\\n\\pmb x(s_i)\u0026amp;=\\pmb k_i=N_{i,4}(s_i)\\pmb d_i+N_{i+1,4}(s_i)\\pmb d_{i+1}+N_{i+2,4}(s_i)\\pmb d_{i+2}\\\\\n\u0026amp;\\mathrm{for}\\ i=1,\\cdots,n-1\\\\\n\\pmb x(s_n)\u0026amp;=\\pmb k_n=\\pmb d_{n+2}\n\\end{align}\n$$\n  å…±è®¡ï¼š$n+1$ä¸ªæ¡ä»¶è§£$n+3$ä¸ªæœªçŸ¥çš„de Boorç‚¹\n$\\Rightarrow$ 2ä¸ªç»ˆå€¼æ¡ä»¶\n  natural end condition\n$$\n\\begin{align}\n\\ddot{\\pmb x}(s_0)\u0026amp;=0\\Leftrightarrow \\dfrac{\\pmb d_2-\\pmb d_1}{s_2-s_0}=\\dfrac{\\pmb d_1-\\pmb d_0}{s_1-s_0}\\\\\n\\ddot{\\pmb x}(s_n)\u0026amp;=0\\Leftrightarrow \\dfrac{\\pmb d_{n+2}-\\pmb d_{n+1}}{s_n-s_{n-1}}=\\dfrac{\\pmb d_{n+1}-\\pmb d_n}{s_n-s_{n-2}}\n\\end{align}\n$$\n  ç»“æœå¯ä»¥è¡¨ç¤ºä¸ºæ±‚è§£å¯¹è§’ç³»ç»Ÿæ–¹ç¨‹ï¼š\n$$\n\\begin{pmatrix}\n1\\\\\n\\alpha_0\u0026amp;\\beta_0\u0026amp;\\gamma_0\\\\\n\u0026amp;\\alpha_1\u0026amp;\\beta_1\u0026amp;\\gamma_1\\\\\n\u0026amp;\u0026amp;\u0026amp;\\ddots\\\\\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\alpha_{n-1}\u0026amp;\\beta_{n-1}\u0026amp;\\gamma_{n-1}\\\\\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\alpha_n\u0026amp;\\beta_n\u0026amp;\\gamma_n\\\\\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;1\n\\end{pmatrix}\n\\begin{pmatrix}\n\\pmb d_0\\\\pmb d_1\\\\\\pmb d_2\\\\\\vdots\\\\\\pmb d_n\\\\\n\\pmb d_{n+1}\\\\\\pmb d_{n+2}\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\pmb k_0\\\\\\pmb 0\\\\\\pmb k_1\\\\\\vdots\\\\\\pmb k_{n-1}\\\\\n\\pmb 0\\\\\\pmb k_{n}\n\\end{pmatrix}\n$$\nå…¶ä¸­ï¼Œ\n  $$\n\\begin{align}\n\\alpha_0\u0026amp;=s_2-s_0\\\\\n\\beta_0\u0026amp;=-(s_2-s_0)-(s_1-s_0)\\\\\n\\gamma_0\u0026amp;=s_1-s_0\\\\\n\\alpha_n\u0026amp;=s_n-s_{n-1}\\\\\n\\beta_n\u0026amp;=-(s_n-s_{n-1})-(s_n-s_{n-2})\\\\\n\\gamma_n\u0026amp;=s_n-s_{n-2}\\\\\n\\alpha_i\u0026amp;=N_{i,4}(s_i)\\\\\n\\beta_i\u0026amp;=N_{i+1,4}(s_i)\\\\\n\\gamma_i\u0026amp;=N_{i+2,4}(s_i)\\\\\n\\mathrm{for}\u0026amp;\\ i=1,\\cdots,n-1\n\\end{align}\n$$\n  è§£æ³•\n æ‰˜é©¬æ–¯ç®—æ³•â€”â€”è§£å†³å¯¹è§’ç³»ç»Ÿæ–¹ç¨‹ å¤æ‚åº¦$O(n)$ ä»…é€‚ç”¨äºå¯¹è§’å ä¼˜çŸ©é˜µ  å¯¹äºå¯¹è§’ç³»ç»Ÿæ–¹ç¨‹\n$$\n\\begin{pmatrix}\nb_1\u0026amp;c_1\u0026amp;\u0026amp;\u0026amp;0\\\\\na_2\u0026amp;b_2\u0026amp;c_2\\\\\n\u0026amp;a_3\u0026amp;b_3\u0026amp;\\cdot\u0026amp;\\\\\n\u0026amp;\u0026amp;\\cdot\u0026amp;\\cdot\u0026amp;c_{n-1}\\\\\n0\u0026amp;\u0026amp;\u0026amp;a_n\u0026amp;b_n\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1\\\\x_2\\\\\\vdots\\\\x_n\n\\end{pmatrix}=\n\\begin{pmatrix}\nd_1\\\\d_2\\\\\\vdots\\\\d_n\n\\end{pmatrix}\n$$\næ±‚è§£æµç¨‹ï¼š\n  å‰å‘æ¶ˆé™¤é˜¶æ®µ\n  åå‘æ›¿ä»£é˜¶æ®µ\n    2.5. Bezieræ›²çº¿è½¬Bæ ·æ¡æ›²çº¿   ç»™å®š\næ§åˆ¶ç‚¹ï¼š$\\pmb k_0,\\cdots,\\pmb k_n$\nç»“åºåˆ—ï¼š$t_0,\\cdots,t_n$\n2ä¸ªç»ˆå€¼æ¡ä»¶\n$\\pmb b_0,\\cdots,\\pmb b_{3n}$ï¼šç”¨äº$C^2$è¿ç»­æ’å€¼ä¸‰æ¬¡Bezieræ ·æ¡æ›²çº¿çš„Bezierç‚¹\n  ç›®æ ‡ï¼šä¸€äº›Bæ ·æ¡å½¢å¼çš„æ›²çº¿\n  ç»“å‘é‡\n$$\nT=(t_0,t_0,t_0,t_0,t_1,\\cdots,t_{n-1},t_n,t_n,t_n,t_n)\n$$\n  $\\pmb d_0,\\cdots,\\pmb d_{n+2}$ç”±ä¸‹åˆ—å¼å­å†³å®šï¼š\n$$\n\\begin{align}\n\\pmb d_0\u0026amp;=\\pmb b_0\\\\\n\\pmb d_1\u0026amp;=\\pmb b_1\\\\\n\\pmb d_i\u0026amp;=\\pmb b_{3i-4}+\\frac{\\Delta_{i-1}}{\\Delta_{i-2}}(\\pmb b_{3i-4}-\\pmb b_{3i-5})\\ \\mathrm{for}\\ i=2,\\cdots,n\\\\\n\\pmb d_{n+1}\u0026amp;=\\pmb b_{3n-1}\\\\\n\\pmb d_{n+2}\u0026amp;=\\pmb b_{3n}\n\\end{align}\n$$\nå…¶ä¸­ï¼Œ$\\Delta_i=t_{i+1}-t_i\\quad \\mathrm{for}\\quad i=0,\\cdots,n-1$\n  é€†é—®é¢˜åŒæ ·å¯è§£\n  3. Bezierå’ŒBæ ·æ¡æ›²çº¿å°ç»“  ç”±$n+1$ä¸ªæ§åˆ¶ç‚¹$\\pmb b_0,\\cdots,b_n$å†³å®šçš„Bezieræ›²çº¿  $n$æ¬¡å¤šé¡¹å¼æ›²çº¿ ç”±æ§åˆ¶ç‚¹å”¯ä¸€ç¡®å®š è¾¹ç•Œç‚¹ä½œæ’å€¼ï¼Œå…¶ä»–ç‚¹ä½œé€¼è¿‘ æ§åˆ¶ç‚¹çš„ä¼ªå±€éƒ¨å½±å“   ç”±æ§åˆ¶ç‚¹$\\pmb k_0,\\cdots,\\pmb k_n$æ’å€¼çš„ä¸‰æ¬¡Bezieræ ·æ¡æ›²çº¿  ç”±$n$ä¸ªåˆ†æ®µä¸‰æ¬¡æ›²çº¿æ®µç»„æˆ æ§åˆ¶ç‚¹å¤„æœ‰$C^2$è¿ç»­æ€§ ç”±å‚æ•°åŒ–ï¼ˆå¦‚ç»“åºåˆ—ï¼‰å’Œä¸¤ä¸ªç»ˆå€¼æ¡ä»¶å”¯ä¸€ç¡®å®š æ’å€¼æ‰€æœ‰æ§åˆ¶ç‚¹ æ§åˆ¶ç‚¹çš„ä¼ªå±€éƒ¨å½±å“   ç”±æ§åˆ¶ç‚¹$\\pmb d_0,\\cdots,\\pmb d_n$å’Œç»“å‘é‡$T=(t_0,t_0,t_0,t_0,t_1,\\cdots,t_{n-1},t_n,t_n,t_n,t_n)$å¾—åˆ°çš„åˆ†æ®µä¸‰æ¬¡Bæ ·æ¡æ›²çº¿  ç”±åœ¨ç»“ç‚¹å¤„å…·æœ‰$C^2$è¿ç»­çŠ¶æ€çš„$n-2$æ¡åˆ†æ®µä¸‰æ¬¡æ›²çº¿æ®µç»„æˆ ç”±$\\pmb d_i$å’Œ$T$å”¯ä¸€ç¡®å®š è¾¹ç•Œç‚¹æ’å€¼ï¼Œå…¶ä½™ç‚¹é€¼è¿‘ de Boorç‚¹å±€éƒ¨å½±å“   é€šè¿‡æ§åˆ¶ç‚¹$\\pmb k_0,\\cdots,k_n$æ’å€¼ä¸‰æ¬¡Bæ ·æ¡  å¯¹æ¯ä¸ª$x,y,z$åˆ†é‡ï¼Œå¯ä»¥ä½¿ç”¨2ä¸ªç»ˆå€¼æ¡ä»¶å’Œæ±‚è§£ä¸€ä¸ªå¯¹è§’çº¿çŸ©é˜µç³»ç»Ÿæ–¹ç¨‹æ¥å®ç°ç±»ä¼¼3.çš„æ•ˆæœ ä¸2. çš„æ›²çº¿ç›¸åŒ    ","description":"Bæ ·æ¡å­¦ä¹ ç¬”è®°","id":15,"section":"note","tags":["CAGD"],"title":"CAGD(5) | Bæ ·æ¡","uri":"https://chaphlagical.github.io/zh/note/cagd/cagd5/"},{"content":"1. å‚æ•°ä¸å‡ ä½•è¿ç»­æ€§ 1.1. å‚æ•°è¿ç»­æ€§   è¿æ¥æ›²çº¿â€”â€”è¿ç»­æ€§\n  ç»™å®šä¸¤æ¡æ›²çº¿\n$$\n\\begin{align}\n\u0026amp;\\pmb x_1(t)\\ \\mathrm{over}\\ [t_0,t_1]\\\n\u0026amp;\\pmb x_2(t)\\ \\mathrm{over}\\ [t_1,t_2]\n\\end{align}\n$$\n  è‹¥$\\pmb x_1$å’Œ$\\pmb x_2$åœ¨$t_1$å¤„çš„0é˜¶åˆ°$r$é˜¶å¯¼æ•°å‘é‡å‡é‡åˆï¼Œåˆ™$\\pmb x_1$ä¸$\\pmb x_2$åœ¨$t_1$å¤„$C^r$è¿ç»­\n    å¸¸è§çš„å‚æ•°è¿ç»­æ€§ï¼š\n $C^0$ï¼šä½ç½®å˜åŒ–è¿ç»­ï¼ˆposition varies continuouslyï¼‰ $C^1$ï¼šä¸€é˜¶å¯¼æ•°åœ¨äº¤ç•Œå¤„è¿ç»­ï¼ˆFirst derivative is continuous across junctionï¼‰  é€Ÿåº¦å‘é‡ç›¸åŒ   $C^2$ï¼šäºŒé˜¶å¯¼æ•°åœ¨äº¤ç•Œå¤„è¿ç»­ï¼ˆSecond derivative is continuous across junctionï¼‰  åŠ é€Ÿåº¦å‘é‡ç›¸åŒ      1.2. å‡ ä½•è¿ç»­æ€§   æ›²çº¿çš„å‡ ä½•è¿ç»­æ€§\n  ç»™å®šä¸¤æ¡æ›²çº¿\n$$\n\\begin{align}\n\u0026amp;\\pmb x_1(t)\\ \\mathrm{over}\\ [t_0,t_1]\\\n\u0026amp;\\pmb x_2(t)\\ \\mathrm{over}\\ [t_1,t_2]\n\\end{align}\n$$\n  è‹¥$\\pmb x_1$å’Œ$\\pmb x_2$èƒ½å¤Ÿä»¥æŸç§æ–¹å¼é‡æ–°å‚æ•°åŒ–ä½¿å¾—åœ¨$t_1$å¤„$C^r$è¿ç»­ï¼Œåˆ™$\\pmb x_1$å’Œ$\\pmb x_2$åœ¨$t_1$å¤„$G^r$è¿ç»­\n    å¸¸è§çš„å‡ ä½•è¿ç»­æ€§\n $G^0=C^0$ï¼šä½ç½®å˜åŒ–è¿ç»­æ€§ï¼ˆè¿æ¥æ€§ï¼‰ï¼ˆposition varies continuouslyï¼‰ $G^1$ï¼šåˆ‡çº¿æ–¹å‘å˜åŒ–è¿ç»­æ€§ï¼ˆç›¸åŒåˆ‡çº¿ï¼‰ï¼ˆ tangent direction varies continuously ï¼‰  æ­£åˆ™åŒ–åˆ‡çº¿å˜åŒ–è¿ç»­ ç­‰ä»·äºæ›²çº¿èƒ½å¤Ÿé‡æ–°å‚æ•°åŒ–åˆ°$C^1$ ç­‰ä»·äºå•ä½é€Ÿåº¦å‚æ•°åŒ–ä¸º$C^1$   $G^2$ï¼šæ›²ç‡å˜åŒ–è¿ç»­æ€§ï¼ˆç›¸åŒåˆ‡çº¿ä¸æ›²ç‡ï¼‰ï¼ˆcurvature varies continuouslyï¼‰  ç­‰ä»·äºæ›²çº¿èƒ½å¤Ÿé‡æ–°å‚æ•°åŒ–åˆ°$C^2$ ç­‰ä»·äºå•ä½é€Ÿåº¦å‚æ•°åŒ–ä¸º$C^2$      1.3. å‚æ•°è¿ç»­æ€§ vs å‡ ä½•è¿ç»­æ€§    å‚æ•°è¿ç»­æ€§$C^r$ å‡ ä½•è¿ç»­æ€§$G^r$     $C^0,C^1,\\cdots$è¿ç»­ æ›²çº¿æœ¬èº«æ˜¯å¦å…‰æ»‘   åœ¨è¯¥æ›²çº¿ä¸Šè¿åŠ¨çš„ç²’å­æ˜¯å¦æœ‰å…‰æ»‘çš„è½¨è¿¹ï¼Ÿï¼ˆä½ç½®ã€é€Ÿåº¦ã€åŠ é€Ÿåº¦ï¼‰ ç‹¬ç«‹äºå‚æ•°åŒ–æ–¹å¼   å–å†³äºå‚æ•°åŒ–æ–¹å¼ ä¸å»ºæ¨¡æ›´ç›¸å…³ï¼ˆæ›²çº¿è®¾è®¡ï¼‰   åº”ç”¨ï¼šåŠ¨ç”»ï¼ˆç‰©ä½“ç§»åŠ¨ã€æ‘„åƒå¤´è½¨è¿¹ï¼‰     2. Bezieræ ·æ¡å‚æ•°åŒ– 2.1. Bezieræ ·æ¡æ›²çº¿çš„å±€éƒ¨å’Œå…¨å±€å‚æ•°  ç»™å®š  $\\pmb b_0,\\cdots,\\pmb b_n$ $\\pmb y(u)$ï¼šé—´éš”$[0,1]$ä¹‹é—´çš„Bezieræ›²çº¿ $\\pmb x(t)$ï¼šé—´éš”$[t_i,t_{i+1}]$ä¹‹é—´çš„Bezieræ›²çº¿   è®¾ç½®$u(t)=\\dfrac{t-t_i}{t_{i+1}-t_i}$ ç»“æœï¼š$\\pmb x(t)=\\pmb y(u(t))$  å±€éƒ¨å‚æ•°$u$ä»0å˜åŒ–åˆ°1ï¼Œå…¨å±€å‚æ•°$t$ä»$t_i$å˜åŒ–åˆ°$t_{i+1}$\n2.2. Bezieræ ·æ¡æ›²çº¿çš„å¯¼æ•° $$\n\\begin{align}\n\\dot{\\pmb x}(t)\u0026amp;=\\dot{\\pmb y}(u(t))\\cdot\\dot u(t)=\\dfrac{\\dot{\\pmb y}(u(t))}{t_{i+1}-t_i}\\\\\n\\ddot{\\pmb x}(t)\u0026amp;=\\ddot{\\pmb y}(u(t))\\cdot(\\dot u(t))^2+\\dot{\\pmb y}(u(t))\\cdot\\ddot u(t)=\\dfrac{\\ddot{\\pmb y}(u(t))}{(t_{i+1}-t_i)^2}\\\\\n\\cdots\\\\\n\\pmb x^{[n]}(t)\u0026amp;=\\dfrac{\\pmb y^{[n]}(u(t))}{(t_{i+1}-t_i)^n}\n\\end{align}\n$$\n2.3. Bezieræ›²çº¿ $$\n\\pmb f(t)=\\sum_{i=0}^nB_i^n(t)\\pmb p_i\n$$\n  ${0,1}$ä¹‹é—´çš„å‡½æ•°å€¼\n$$\n\\begin{align}\n\\pmb f(0)\u0026amp;=\\pmb p_0\\\n\\pmb f(1)\u0026amp;=\\pmb p_1\\\n\\end{align}\n$$\n  ${0,1}$ä¹‹é—´çš„ä¸€é˜¶å¯¼æ•°å‘é‡\n$$\n\\begin{align}\n\\pmb f'(0)\u0026amp;=n[\\pmb p_1-\\pmb p_0]\\\n\\pmb f'(1)\u0026amp;=n[\\pmb p_n-\\pmb p_{n-1}]\\\n\\end{align}\n$$\n  ${0,1}$ä¹‹é—´çš„äºŒé˜¶å¯¼æ•°å‘é‡\n$$\n\\begin{align}\n\\pmb f''(0)\u0026amp;=n(n-1)[\\pmb p_2-2\\pmb p_1+\\pmb p_0]\\\\\n\\pmb f''(1)\u0026amp;=n(n-1)[\\pmb p_n-2\\pmb p_{n-1}+\\pmb p_{n-2}]\\\n\\end{align}\n$$\n  2.4. Bezieræ ·æ¡æ›²çº¿çš„ç‰¹æ®Šæƒ…å†µ $$\n\\begin{align}\n\\dot{\\pmb x}(t_i)\u0026amp;=\\dfrac{n(\\pmb b_1-\\pmb b_0)}{t_{i+1}-t_i}\\\\\n\\dot{\\pmb x}(t_{i+1})\u0026amp;=\\dfrac{n(\\pmb b_n-\\pmb b_{n-1})}{t_{i+1}-t_i}\\\\\n\\ddot{\\pmb x}(t_i)\u0026amp;=\\dfrac{n(n-1)(\\pmb b_2-2\\pmb b_1+\\pmb b_0)}{(t_{i+1}-t_i)^2}\\\\\n\\ddot{\\pmb x}(t_{i+1})\u0026amp;=\\dfrac{n(n-1)(\\pmb b_n-2\\pmb b_{n-1}+\\pmb b_{n-2})}{(t_{i+1}-t_i)^2}\\\\\n\\end{align}\n$$\n2.5. Bezieræ ·æ¡çš„ä¸€èˆ¬æƒ…å†µ   è¿æ¥Beizeræ›²çº¿\n  ç»™å®šä¸¤æ¡$n$é˜¶Bezieræ›²çº¿ï¼š\n$$\n\\begin{align}\n\\pmb k_{j-1}\u0026amp;=\\pmb b_0^-,\\pmb b_1^-,\\cdots,\\pmb b_n^-=\\pmb k_j\\\\\n\\pmb k_j\u0026amp;=\\pmb b_0^+,\\pmb b_1^+,\\cdots,\\pmb b_n^+=\\pmb k_{j+1}\n\\end{align}\n$$\n  è¦æ±‚ï¼š$\\pmb k_j$å¤„$C^1$è¿ç»­\n  $\\pmb b_{n-1}^-,\\pmb k_j,\\pmb b_1^+$ä¸å…±çº¿ä¸”\n$$\n\\dfrac{\\pmb b_n^\u0026ndash;\\pmb b_{n-1}^-}{t_j-t_{j-1}}=\\dfrac{\\pmb b_1^+-\\pmb b_0^+}{t_{j+1}-t_j}\n$$\n    4. Bezieræ ·æ¡é˜¶æ•° 4.1. å¯é€‰çš„æ–¹æ¡ˆ  $d=0$ï¼Œåˆ†æ®µå¸¸æ•°ï¼ˆpiecewise constantï¼‰ï¼šä¸å…‰æ»‘ $d=1$ï¼Œåˆ†æ®µçº¿æ€§ï¼ˆpiecewise linearï¼‰ï¼šä¸å¤Ÿå…‰æ»‘ $d=2$ï¼Œåˆ†æ®µäºŒæ¬¡ï¼ˆpiecewise quadraticï¼‰ï¼šäºŒé˜¶å¯¼æ•°ä¸ºå¸¸æ•°ï¼Œä¸å¤Ÿçµæ´» $d=3$ï¼Œåˆ†æ®µä¸‰æ¬¡ï¼ˆpiecewise cubicï¼‰ï¼šè®¡ç®—æœºå›¾å½¢å­¦åº”ç”¨ä¸­å¸¸ç”¨çš„é˜¶æ•°  4.2. ä¸‰æ¬¡æ ·æ¡ 4.2.1. ä¸‰æ¬¡åˆ†æ®µå¤šé¡¹å¼   æˆ‘ä»¬å¯ä»¥åœ¨ä¸å›ºå®šæ•´ä¸ªæ›²çº¿çš„äºŒé˜¶å¯¼æ•°çš„æƒ…å†µä¸‹è·å¾—$C^2$è¿ç»­æ€§ï¼ˆï¼Ÿï¼‰\n  $C^2$è¿ç»­æ€§åœ¨ç›´è§‰ä¸Šå¾ˆé‡è¦\n  è¿åŠ¨ï¼šè¿ç»­çš„ä½ç§»ã€é€Ÿåº¦å’ŒåŠ é€Ÿåº¦\néè¿ç»­çš„åŠ é€Ÿåº¦æ˜¯å¯å¯Ÿè§‰çš„ï¼ˆç‰©ä½“ã€æ‘„åƒæœºè¿åŠ¨ï¼‰\n  å¯ä»¥çœ‹åˆ°äºŒé˜¶é˜´å½±ä¸è¿ç»­ï¼ˆåå°„æ€§çš„ç‰©ä½“ï¼‰\n    åœ¨æ‰€æœ‰ç‚¹é›†å†…æ’å¾—åˆ°çš„$C^2$æ›²çº¿ä¸­ï¼ˆæ»¡è¶³ç›¸åŒçš„å§‹æœ«çŠ¶æ€ï¼‰ï¼Œåˆ†æ®µä¸‰æ¬¡æ›²çº¿æ‹¥æœ‰æœ€å°çš„ç§¯åˆ†åŠ é€Ÿåº¦ï¼ˆå³æ‰€èƒ½è·å¾—çš„æœ€å…‰æ»‘çš„æ›²çº¿ï¼‰\n  4.2.3. åº”ç”¨  ä¸‰æ¬¡Bezieræ›²çº¿è¢«å¹¿æ³›ä½¿ç”¨ æ›´é«˜é˜¶çš„Bezieræ›²çº¿è¾ƒå°‘ä½¿ç”¨ï¼ˆæŸäº›CAD/CAMåº”ç”¨ï¼‰ å…¸å‹çš„ï¼š\u0026ldquo;points\u0026amp;handles\u0026quot;æ¥å£ å››ç§æ¨¡å¼  ä¸è¿ç»­ï¼ˆä¸¤æ¡æ›²çº¿ï¼‰ $C^0$è¿ç»­ï¼ˆä¸¤ä¸ªç‚¹é‡åˆï¼‰ $G^1$è¿ç»­ï¼ˆåˆ‡å‘è¿ç»­ï¼‰  å¤„ç†ç‚¹æŒ‡å‘åŒä¸€æ–¹å‘ï¼Œä½†é•¿åº¦ä¸åŒ   $C^1$è¿ç»­  å¤„ç†ç‚¹æœ‰å¯¹ç§°å‘é‡     $C^2$çš„é™åˆ¶æ›´å¤§ï¼šé€šè¿‡$k_i$è¿›è¡Œæ§åˆ¶  5. Bezieræ ·æ¡çš„è¿ç»­æ€§ 5.1. Bezieræ ·æ¡è¿ç»­æ€§è§„åˆ™ è¿æ¥å¤šæ¡æ›²çº¿æ®µï¼Œéœ€è¦ç¡®å®šä½¿æ›²çº¿æœ‰$C^{-1},C^0ï¼ŒC^1ï¼ŒC^2$è¿ç»­æ€§çš„æ§åˆ¶ç‚¹çº¦æŸ\n$C^0$è¿ç»­æ€§\n æ¯ä¸ªæ ·æ¡çº¿æ®µå†…æ’ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªæ§åˆ¶ç‚¹ ç›¸é‚»çº¿æ®µçš„ç‚¹å¿…é¡»é‡åˆä»¥è·å¾—$C^0$è¿ç»­æ€§  $C^1$è¿ç»­æ€§\n åˆ‡å‘é‡ä¸å‘é‡å·®$\\pmb p_1-\\pmb p_0,\\pmb p_n-\\pmb p_{n-1}$æˆæ­£æ¯” è¿™äº›å‘é‡åº”ç›¸åŒä»¥æ»¡è¶³$C^1$è¿ç»­æ€§  $C^2$è¿ç»­æ€§\n $\\mathrm d^2/\\mathrm dt^2$å‘é‡ä¸$\\pmb p_2-2\\pmb p_1+\\pmb p_0$å’Œ$\\pmb p_n-2\\pmb p_{n-1}+\\pmb p_{n-2}$æˆæ­£æ¯” åˆ‡çº¿å¿…é¡»ç›¸åŒ ä¸‹ç¤ºé˜´å½±ä¸‰è§’å½¢å¿…é¡»ç›¸ä¼¼  $G^1$è¿ç»­æ€§\nèƒ½å¤Ÿè¢«å‚æ•°åŒ–ä¸º$C^1$ï¼Œåªéœ€æŒ‰åˆ‡çº¿å‘é‡é•¿åº¦çš„æ¯”ç‡å¢åŠ ç¬¬äºŒä¸ªæ›²çº¿æ®µçš„é€Ÿåº¦\n6. Bezieræ ·æ¡æ›²çº¿ 6.1. åœ¨æŸç‚¹å¤„$C^2$è¿ç»­ è¦æ±‚ï¼šåœ¨$\\pmb k_j$å¤„$C^2$è¿ç»­\n  $C^1$æ„å‘³ç€\n$$\n\\dfrac{\\pmb b_n^\u0026ndash;\\pmb b_{n-1}^-}{t_j-t_{j-1}}=\\dfrac{\\pmb b_1^+-\\pmb b_0^+}{t_{j+1}-t_j}\n$$\n  $C^2$æ„å‘³ç€\n$$\n\\dfrac{\\pmb b_n^\u0026ndash;2\\pmb b_{n-1}^-+\\pmb b_{n-2}^-}{(t_j-t_{j-1})^2}=\\dfrac{\\pmb b_2^+-2\\pmb b_1^++\\pmb b_0^+}{(t_{j+1}-t_j)^2}\n$$\n  ä»¤\n$$\n\\pmb d^-=\\pmb b_{n-1}^-+\\dfrac{\\Delta_j}{\\Delta_{j-1}}(\\pmb b_{n-1}^\u0026ndash;\\pmb b_{n-2}^-)\n$$\nå’Œ\n$$\n\\pmb d^+=\\pmb b_1^+-\\dfrac{\\Delta_{j-1}}{\\Delta_j}(\\pmb b_2^+-\\pmb b_1^+)\n$$\nåˆ™æœ‰ï¼š\n$C^2$è¿ç»­æ€§$\\Leftrightarrow C^1$è¿ç»­æ€§+$\\pmb d^-=\\pmb d^+$\n  6.2. æ›²çº¿çš„$G^2$è¿ç»­æ€§ ä¸€èˆ¬æƒ…å†µä¸‹çš„$G^2$è¿ç»­æ€§ï¼ˆå¯¹æ‰€æœ‰ç±»å‹çš„æ›²çº¿ï¼‰\n  ç»™å®š\n $\\pmb x_1(t)$å’Œ$\\pmb x_2(t)$æ»¡è¶³ $\\pmb x_1(t_i)=\\pmb x_2(t_i)=\\pmb x(t_i)$ $\\dot{\\pmb x}_1(t_i)=\\dot{\\pmb x}_2(t_i)=\\dot{\\pmb x}(t_i)$    æ»¡è¶³åœ¨$t=t_i$å¤„$G^2$è¿ç»­çš„æ¡ä»¶æ˜¯ï¼š\n$$\n\\ddot{\\pmb x}_2(t_i)-\\ddot{\\pmb x}_1(t_i)\\parallel \\dot{\\pmb x}(t_i)\n$$\n  6.3. æŸç‚¹çš„$G^2$è¿ç»­æ€§   è¦æ±‚ï¼šæ›²çº¿åœ¨ç‚¹$\\pmb k_j$å¤„$G^2$è¿ç»­\n  $G^1$è¿ç»­\n  $\\pmb b_{n-2}^-,\\pmb b_{n-1}^-,\\pmb k_j,\\pmb b_1^+,\\pmb b_2^+$äº”ä¸ªå‘é‡å…±é¢\n  ä¸”é¢ç§¯\n$$\n\\dfrac{\\mathrm{area}(\\pmb b_{n-2}^-,\\pmb b_{n-1}^-,\\pmb k_j)}{\\mathrm {area}(\\pmb k_j,\\pmb b_1^+,\\pmb b_2^+)}=\\dfrac{a^3}{b^3}\n$$\n  7. $C^2$ä¸‰æ¬¡Bezieræ ·æ¡æ›²çº¿ 7.1. ä¸‰æ¬¡Bezieræ ·æ¡æ›²çº¿   ç»™å®š\n$$\n\\begin{align}\n\\pmb k_0,\\cdots,\\pmb k_n\u0026amp;\\in\\mathbb R^3\\\\\nt_0,\\cdots,t_n\u0026amp;\\in\\mathbb R\\\\\nt_i\u0026lt;t_{i+1}\\ \\mathrm{for}\\ \u0026amp;i=0,\\cdots,n_1\n\\end{align}\n$$\n  ç›®æ ‡ï¼šæ’å€¼$C^2$è¿ç»­åˆ†æ®µä¸‰æ¬¡Bezieræ ·æ¡æ›²çº¿çš„Bezierç‚¹$\\pmb b_0,\\cdots,\\pmb b_{3n}$\n  ä¾‹å­ï¼š\n $3n+1$æœªçŸ¥ç‚¹ $\\pmb b_{3i}=\\pmb k_i$ï¼Œ$i=0,\\cdots,n$ï¼Œå…±$n+1$ä¸ªæ–¹ç¨‹ ç‚¹$\\pmb k_i$å¤„$C^1$è¿ç»­ï¼Œ$i=1,\\cdots,n-1$ï¼Œå…±$n-1$ä¸ªæ–¹ç¨‹ ç‚¹$\\pmb k_i$å¤„$C^2$è¿ç»­ï¼Œ$i=1,\\cdots,n-1$ï¼Œå…±$n-1$ä¸ªæ–¹ç¨‹ ä¸¤ä¸ªç»“æŸæ¡ä»¶æ–¹ç¨‹    7.2. ç»“æŸæ¡ä»¶ 7.2.1. Bessel end condition   $\\pmb k_0$å¤„çš„åˆ‡å‘é‡ç­‰ä»·äºæ’å€¼${\\pmb k_0,\\pmb k_1,\\pmb k_2}$çš„æŠ›ç‰©çº¿åœ¨$\\pmb k_0$å¤„çš„åˆ‡å‘é‡\n  æŠ›ç‰©çº¿æ’å€¼${\\pmb k_0,\\pmb k_1,\\pmb k_2}$\n$$\n\\pmb p(t)=\n\\dfrac{(t_2-t)(t_1-t)}{(t_2-t_0)(t_1-t_0)}\\pmb k_0+\n\\dfrac{(t_2-t)(t-t_0)}{(t_2-t_1)(t_1-t_0)}\\pmb k_1+\n\\dfrac{(t_0-t)(t_1-t)}{(t_2-t_1)(t_2-t_0)}\\pmb k_2\n$$\n  æ’å€¼æŠ›ç‰©çº¿å¯¼æ•°\n$$\n\\dot{\\pmb p}(t_0)=\n-\\dfrac{(t_2-t_0)+(t_1-t_0)}{(t_2-t_0)(t_1-t_0)}\\pmb k_0+\n\\dfrac{(t_2-t_0)}{(t_2-t_1)(t_1-t_0)}\\pmb k_1-\n\\dfrac{(t_1-t_0)}{(t_2-t_1)(t_2-t_0)}\\pmb k_2\n$$\n  $\\pmb b_1$çš„ä½ç½®\n$$\n\\pmb b_1=\\pmb b_0+\\dfrac{t_1-t_0}{3}\\dot{\\pmb p}(t_0)\n$$\n  7.2.2. Natural end condition $$\n\\begin{align}\n\\ddot {\\pmb x}(t_0)\u0026amp;=0\\Leftrightarrow \\pmb b_1=\\dfrac{\\pmb b_2+\\pmb b_0}{2}\\\\\n\\ddot{\\pmb x}(t_n)\u0026amp;=0\\Leftrightarrow \\pmb b_{3n-1}=\\dfrac{\\pmb b_{3n-2}+\\pmb b_{3n}}{2}\n\\end{align}\n$$\n7.3. å‚æ•°åŒ– 7.3.1. é—®é¢˜æè¿°  ç»™å®šï¼šæ§åˆ¶ç‚¹$\\pmb k_0,\\cdots,\\pmb k_n$ä»¥åŠç»“åºåˆ—$t_0\u0026lt;\\cdots\u0026lt;t_n$ ç›®æ ‡ï¼šæ’å€¼æ›²çº¿ é—®é¢˜ï¼šé€šå¸¸æƒ…å†µä¸‹ï¼Œç»“åºåˆ—æœªç»™å®šï¼Œä½†ä¼šå½±å“æ›²çº¿çš„èµ°åŠ¿  7.3.2. Equidistant (uniform) parameterization  $t_{i+1}-t_i=\\mathrm{const}$ ä¾‹å¦‚ï¼š$t_i=t$ ä¸è€ƒè™‘æ•°æ®ç‚¹çš„å‡ ä½•å½¢çŠ¶  7.3.3. Chordal parameterization  $t_{i+1}-t_i=\\Vert \\pmb k_{i+1}-\\pmb k_i\\Vert$ å‚æ•°é—´éš”ä¸ç›¸é‚»æ§åˆ¶ç‚¹çš„è·ç¦»æˆæ­£æ¯”  7.3.4. Centripetal parameterization  $t_{i+1}-t_i=\\sqrt{\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert}$  7.3.5. Foley parameterization  æ¶‰åŠæ§åˆ¶å¤šè¾¹å½¢çš„è§’åº¦ $t_{i+1}-t_i=\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert\\cdot\\Big(1+\\dfrac{3}{2}\\dfrac{\\hat\\alpha_i\\Vert\\pmb k_i-\\pmb k_{i-1}\\Vert}{\\Vert\\pmb k_i-\\pmb k_{i-1}\\Vert+\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert}+\\dfrac{3}{2}\\dfrac{\\hat\\alpha_{i+1}\\Vert \\pmb k_{i+1}-\\pmb k_i\\Vert}{\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert+\\Vert\\pmb k_{i+2}-\\pmb k_{i+1}\\Vert} \\Big)$ å…¶ä¸­ï¼Œ$\\hat\\alpha_i=\\min\\Big(\\pi-\\alpha_i,\\dfrac{\\pi}{2}\\Big)$ ä¸”$\\alpha_i=\\mathrm{angle}(\\pmb k_{i-1},\\pmb k_i,\\pmb k_{i+1})$  7.3.6. Affine invariant parameterization  åŸºäºä»¿å°„ä¸å˜è·ç¦»æµ‹åº¦çš„å‚æ•°åŒ–  7.4. é—­åˆæ›²çº¿ 7.4.1. é—®é¢˜æè¿°   ç»™å®šï¼š\næ§åˆ¶ç‚¹ï¼š$\\pmb k_0,\\cdots,\\pmb k_{n-1},\\pmb k_n=\\pmb k_0$\nç»“åºåˆ—ï¼š$t_0\u0026lt;\\cdots\u0026lt;t_n$\n  åˆ†æ®µä¸‰æ¬¡æ›²çº¿çš„ç»“æŸæ¡ä»¶ï¼š\n$$\n\\begin{align}\n\\dot{\\pmb x}(t_0)\u0026amp;=\\dot{\\pmb x}(t_n)\\\n\\ddot{\\pmb x}(t_0)\u0026amp;=\\ddot{\\pmb x}(t_n)\n\\end{align}\n$$\n  7.4.2. é—­åˆä¸‰æ¬¡Bezieræ ·æ¡æ›²çº¿   $C^2$è¿ç»­ä¸”æ›²çº¿é—­åˆ\n  é—­åˆæ›²çº¿çš„ä¼˜åŠ¿ï¼šæ— éœ€é€‰æ‹©ç»“æŸæ¡ä»¶\n  ä¾‹å­ï¼š\n$n=3$\n  ","description":"Bezieræ ·æ¡å­¦ä¹ ç¬”è®°","id":16,"section":"note","tags":["CAGD"],"title":"CAGD(4) | Bezieræ ·æ¡","uri":"https://chaphlagical.github.io/zh/note/cagd/cagd4/"},{"content":"Item 26ï¼šPostpone variable definitions as long as possible   åªè¦å®šä¹‰äº†ä¸€ä¸ªå˜é‡è€Œå…¶ç±»å‹å¸¦æœ‰ä¸€ä¸ªæ„é€ å‡½æ•°æˆ–ææ„å‡½æ•°ï¼Œé‚£ä¹ˆå½“ç¨‹åºçš„æ§åˆ¶æµåˆ°è¾¾è¿™ä¸ªå˜é‡å®šä¹‰å¼æ—¶ï¼Œå°±å¾—æ‰¿å—æ„é€ æˆæœ¬ï¼›å½“è¿™ä¸ªå˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œä¾¿å¾—æ‰¿å—ææ„æˆæœ¬ã€‚å³ä½¿è¿™ä¸ªå˜é‡æœ€ç»ˆå¹¶æœªè¢«ä½¿ç”¨ï¼Œä»éœ€è€—è´¹è¿™äº›æˆæœ¬ã€‚\n  è¿‡æ—©å®šä¹‰å˜é‡çš„ä¸€ä¸ªä¾‹å­ï¼š\n  1 2 3 4 5 6 7 8 9 10  std::string encryptPassword(const std::string\u0026amp; password) { using namespace std; string encrypted; if(password.length()\u0026lt;MinimumPasswordLength){ throw logic_error(\u0026#34;Password is too short\u0026#34;); } ... return encrypted; }     å¦‚æœå‡½æ•°encryptPasswordä¸¢å‡ºå¼‚å¸¸ï¼Œä»å¾—ä»˜å‡ºencryptedçš„æ„é€ æˆæœ¬å’Œææ„æˆæœ¬\n  å»¶åå˜é‡çš„å®šä¹‰\n  1 2 3 4 5 6 7 8  std::string encryptPassword(const std::string\u0026amp; password) { ... std::string encrypted(password); encrypt(encrypted); return encrypted; }    å»¶åå˜é‡å®šä¹‰ç›´åˆ°éå¾—ä½¿ç”¨è¯¥å˜é‡çš„å‰ä¸€åˆ»ä¸ºæ­¢ï¼Œç”šè‡³åº”å°è¯•å»¶ååˆ°èƒ½å¤Ÿç»™å®ƒåˆå€¼å®å‚ä¸ºæ­¢ é¿å…æ„é€ /ææ„éå¿…è¦å¯¹è±¡ï¼Œé¿å…æ— æ„ä¹‰çš„defaultæ„é€ è¡Œä¸º  å¾ªç¯æƒ…å†µ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  //\tæ–¹æ³•Aï¼šå®šä¹‰äºå¾ªç¯å¤– Widget w; for(int i=0;i\u0026lt;n;i++) { w=...; ... } //\tæ–¹æ³•Bï¼šå®šä¹‰äºå¾ªç¯å†… for(int i=0;i\u0026lt;n;i++) { Widget w...; ... }    æ–¹æ³•Aï¼š1ä¸ªæ„é€ å‡½æ•°+1ä¸ªææ„å‡½æ•°+nä¸ªèµ‹å€¼æ“ä½œ æ–¹æ³•Bï¼šnä¸ªæ„é€ å‡½æ•°+nä¸ªææ„å‡½æ•° é™¤éä½ çŸ¥é“èµ‹å€¼æˆæœ¬æ¯”â€œææ„+æ„é€ â€ä½ã€ä½ æ­£åœ¨å¤„ç†ä»£ç ä¸­æ•ˆç‡é«˜åº¦æ•æ„Ÿçš„éƒ¨åˆ†ï¼Œå¦åˆ™åº”è¯¥ä½¿ç”¨åšæ³•B  Item 27ï¼šMinimize casting   æ—§å¼è½¬å‹\n (T)expressionï¼šC-style T(expression)ï¼šå‡½æ•°é£æ ¼    æ–°å¼è½¬å‹\n const_cast\u0026lt;T\u0026gt;(expression)  const_casté€šå¸¸ç”¨æ¥å°†å¯¹è±¡çš„å¸¸é‡æ€§ç§»é™¤ï¼Œä¹Ÿæ˜¯å”¯ä¸€å…·æœ‰æ­¤èƒ½åŠ›çš„C++-styleè½¬å‹æ“ä½œç¬¦   dynamic_cast\u0026lt;T\u0026gt;(expression)  dynamic_castä¸»è¦ç”¨æ¥æ‰§è¡Œâ€œå®‰å…¨å‘ä¸‹è½¬å‹â€ï¼Œç”¨æ¥å†³å®šæŸå¯¹è±¡æ˜¯å¦å½’å±ç»§æ‰¿ä½“ç³»ä¸­çš„æŸä¸ªç±»å‹ å”¯ä¸€æ— æ³•ç”±æ—§å¼è¯­æ³•æ‰§è¡Œçš„åŠ¨ä½œï¼Œä¹Ÿæ˜¯å”¯ä¸€å¯èƒ½è€—è´¹é‡å¤§è¿è¡Œæˆæœ¬çš„è½¬å‹åŠ¨ä½œ   reinterpret_cast\u0026lt;T\u0026gt;(expression)  reinterpret_castæ„å›¾æ‰§è¡Œä½çº§è½¬å‹ï¼Œå®é™…åŠ¨ä½œå¯èƒ½å–å†³äºç¼–è¯‘å™¨ï¼Œè¿™ä¹Ÿè¡¨ç¤ºå®ƒä¸å¯ç§»æ¤   static_cast\u0026lt;T\u0026gt;(expression)  static_castç”¨æ¥å¼ºè¿«éšå¼è½¬æ¢      æ–°å¼è½¬å‹ç›¸è¾ƒæ—§å¼è½¬å‹çš„å¥½å¤„\n å®¹æ˜“åœ¨ä»£ç ä¸­è¢«è¾¨è¯†å‡ºæ¥ï¼Œç®€åŒ–â€œæ‰¾å‡ºç±»å‹ç³»ç»Ÿåœ¨å“ªä¸ªåœ°ç‚¹è¢«ç ´åâ€çš„è¿‡ç¨‹ å„è½¬å‹åŠ¨ä½œçš„ç›®æ ‡è¶Šçª„åŒ–ï¼Œç¼–è¯‘å™¨è¶Šå¯èƒ½è¯Šæ–­å‡ºé”™è¯¯çš„è¿ç”¨    ä»»ä½•ä¸€ç§ç±»å‹è½¬æ¢å¾€å¾€çœŸçš„ä»¤ç¼–è¯‘å™¨ç¼–è¯‘å‡ºè¿è¡ŒæœŸé—´æ‰§è¡Œçš„ç ï¼Œè€Œä¸æ˜¯ç®€å•åœ°å°†ä¸€ç§ç±»å‹è§†ä¸ºå¦å¤–ä¸€ç§ç±»å‹\n  å¯¹è±¡åœ°å¸ƒå±€æ–¹å¼å’Œä»–ä»¬çš„åœ°å€è®¡ç®—æ–¹å¼éšç¼–è¯‘å™¨çš„ä¸åŒè€Œä¸åŒï¼Œæ„å‘³ç€â€œç”±äºçŸ¥é“å¯¹è±¡å¦‚ä½•å¸ƒå±€â€è€Œè®¾è®¡çš„è½¬å‹ï¼Œåœ¨æŸä¸€å¹³å°ä¸Šè¡Œå¾—é€šï¼Œåœ¨å…¶ä»–å¹³å°å¹¶ä¸ä¸€å®šè¡Œå¾—é€š\n  ç±»ç»§æ‰¿çš„è½¬å‹é—®é¢˜\n  1 2 3 4 5 6 7 8 9 10 11 12 13  class Window{ public: virtual void onResize() {...} ... }; class SpecialWindow: public Window{ public: virtual void Resize(){ static_cast\u0026lt;Window\u0026gt;(*this).onResize(); ... } ... };    ä¸Šè¿°ä»£ç å¹¶éæ˜¯åœ¨å½“å‰å¯¹è±¡ä¸Šè°ƒç”¨Window::onResizeä¹‹ååœ¨è¯¥å¯¹è±¡ä¸Šæ‰§è¡ŒSpecialWindowä¸“å±åŠ¨ä½œ è€Œæ˜¯åœ¨å½“å‰å¯¹è±¡çš„base classæˆåˆ†çš„å‰¯æœ¬ä¸Šè°ƒç”¨Window::onResizeï¼Œä»»ä½•åœ¨å½“å‰å¯¹è±¡èº«ä¸Šæ‰§è¡ŒSpecialWindowä¸“å±åŠ¨ä½œ  æ­£ç¡®çš„å†™æ³•åº”è¯¥æ˜¯ï¼š\n1 2 3 4 5 6 7 8  class SpecialWindow: public Window{ public: virtual void Resize(){ Window::onResize(); ... } ... };     dynamic_castçš„é¿å…\n dynamic_castçš„åº”ç”¨åœºæ™¯ï¼šä½ æƒ³åœ¨ä¸€ä¸ªä½ è®¤ä¸ºderived classå¯¹è±¡èº«ä¸Šæ‰§è¡Œderived classæ“ä½œå‡½æ•°ï¼Œä½†ä½ çš„æ‰‹ä¸Šåªæœ‰ä¸€ä¸ªæŒ‡å‘baseçš„pointeræˆ–referenceï¼Œåªèƒ½é å®ƒä»¬æ¥è§£å†³é—®é¢˜    æ–¹æ³•ä¸€ï¼šä½¿ç”¨å®¹å™¨å¹¶åœ¨å…¶ä¸­å­˜å‚¨ç›´æ¥æŒ‡å‘derived class å¯¹è±¡çš„æŒ‡é’ˆï¼Œå¦‚æ­¤ä¾¿æ¶ˆé™¤äº†é€šè¿‡base classæ¥å£å¤„ç†å¯¹è±¡çš„éœ€è¦\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Window{...} class SpecialWindow: public Window{ public: void blink(); ... }; // dynamic_castå®ç°æ–¹æ³• typedef std::vector\u0026lt;std::trl::shared_ptr\u0026lt;Window\u0026gt;\u0026gt; VPW; VPW winPtrs; ... for(VPW::iterator iter=winPtrs.begin();iter!=winPtrs.end();++iter) { if(SpecialWindow* psw=dynamic_cast\u0026lt;SpecialWindow*\u0026gt;(iter-\u0026gt;get())) psw-\u0026gt;blink(); } // æ”¹è¿›å®ç°æ–¹æ³• typedef std::vector\u0026lt;std::trl::shared_ptr\u0026lt;SpecialWindow\u0026gt;\u0026gt; VPSW; VPSW winPtrs; ... for(VPSW::iterator iter=winPtrs.begin();iter!=winPtrs.end();++iter) { (*iter)-\u0026gt;blink(); }    è¯¥æ–¹æ³•ä½¿ä½ æ— æ³•åœ¨åŒä¸€ä¸ªå®¹å™¨å†…å­˜å‚¨æŒ‡é’ˆâ€æŒ‡å‘æ‰€ä»¥å¯èƒ½çš„Windowæ´¾ç”Ÿç±»â€œã€‚å¤„ç†å¤šä¸­Windowç±»å‹éœ€è¦å¤šå„å®¹å™¨ï¼Œå®ƒä»¬éƒ½å¿…é¡»å…·å¤‡ç±»å‹å®‰å…¨æ€§  æ–¹æ³•äºŒï¼šé€šè¿‡base classæ¥å£å¤„ç†æ‰€æœ‰å¯èƒ½çš„Windowæ´¾ç”Ÿç±»ï¼Œå³åœ¨base classå†…æä¾›virtualå‡½æ•°åšä½ æƒ³å¯¹å„ä¸ªwindowæ´¾ç”Ÿç±»åšçš„äº‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Window{ public: virtual void blink() { } ... }; class SpecialWindow: public Window{ public: virtual void blink() { ... }; ... }; typedef std::vector\u0026lt;std::trl::shared_ptr\u0026lt;Window\u0026gt;\u0026gt; VPW; VPW winPtrs; ... for(VPW::iterator iter=winPtrs.begin();iter!=winPtrs.end();++iter) (*iter)-\u0026gt;blink();   Item 28ï¼šAvoid returning \u0026ldquo;handles\u0026rdquo; to object internals  è€ƒè™‘çŸ©å½¢ç±»ï¼š  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Point{ public: Point(int x, int y); ... void setX(int newVal); void setY(int newVal); ... }; struct RectData{ Point ulhc; Point lrhc; }; class Rectangle{ ... private: std::trl::shared_ptr\u0026lt;RectData\u0026gt; pData; };     handlesï¼š Referenceã€æŒ‡é’ˆå’Œè¿­ä»£å™¨\n  é™ä½å¯¹è±¡å°è£…æ€§\n  å¯èƒ½å¯¼è‡´è™½ç„¶è°ƒç”¨constæˆå‘˜å‡½æ•°å´é€ æˆå¯¹è±¡çŠ¶æ€è¢«æ›´æ”¹\nä¾‹å¦‚ï¼š\n    1 2 3 4 5 6 7 8 9 10 11 12 13  class Rectangle{ public: ... Point\u0026amp; upperleft() const {return pData-\u0026gt;ulhc;} Point\u0026amp; lowerright() const {return pData-\u0026gt;lrhc;} ... }; Point coord1(0, 0); Point coord2(100, 100); const Rectangle rec(coord1, coord2); rec.upperLeft().setX(50);\t// å°†ä¼šæ”¹å˜recï¼Œè€Œå®šä¹‰ä½¿ç”¨äº†const   â€‹\tè¯¥é—®é¢˜çš„è§£å†³æ–¹æ³•æ˜¯è¿”å›const referenceï¼š\n1 2 3 4 5 6 7  class Rectangle{ public: ... const Point\u0026amp; upperleft() const {return pData-\u0026gt;ulhc;} const Point\u0026amp; lowerright() const {return pData-\u0026gt;lrhc;} ... };     è¿”å›ä»£è¡¨å¯¹è±¡å†…éƒ¨çš„handleså¯èƒ½å¯¼è‡´ç©ºæ‚¬çš„å¥æŸ„ï¼ˆdangling handlesï¼‰ï¼šè¿™ç§handlesæ‰€æŒ‡çš„ä¸œè¥¿ä¸å¤å­˜åœ¨\nä¾‹å¦‚ï¼š\n  1 2 3 4 5  class GUIObject {...}; const Rectangle boundingBox(const GUIObject\u0026amp; obj); GUIObject* pgo; ... const Point* pUpperLeft = \u0026amp;(boundingBox(*pgo).upperLeft());     è¿™é‡ŒboundingBoxç”Ÿæˆä¸€ä¸ªä¸´æ—¶å˜é‡ï¼Œåœ¨è¯­å¥ç»“æŸåå°†è‡ªåŠ¨è¢«é”€æ¯ï¼Œæœ€åpUpperLeftå¾—åˆ°å°†æ˜¯ä¸€ä¸ªç©ºæ‚¬ã€è™šåŠçš„handles\n  è¿”å›handlesçš„ç‰¹ä¾‹ï¼šé‡è½½operator[]ä»¥è·å–æ•°æ®ç­‰\n  Item 29ï¼šStrive for exception-safe code  ä¸¾ä¾‹ä¸€ä¸ªå¸Œæœ›ç”¨äºå¤šçº¿ç¨‹ç¯å¢ƒçš„GUIèœå•ç±»  1 2 3 4 5 6 7 8 9 10  class PrettyMenu{ public: ... void changeBackground(std::istream\u0026amp; imgSrc); ... private: Mutex mutex;\t// äº’æ–¥å™¨  Image* bgImage;\t// ç›®å‰èƒŒæ™¯å›¾ç‰‡  int imageChanges;\t// èƒŒæ™¯å›¾ç‰‡è¢«æ”¹å˜çš„æ¬¡æ•° };   changeBackgroundå‡½æ•°çš„ä¸€ä¸ªå®ç°ï¼š\n1 2 3 4 5 6 7 8  void PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { lock(\u0026amp;mutex);\t// è·å–äº’æ–¥å™¨  delete bgImage;\t// åˆ é™¤æ—§èƒŒæ™¯  ++imageChanges;\t// ä¿®æ”¹å›¾ç‰‡å˜æ›´æ¬¡æ•°  bgImage=new Image(imgSrc);\t// ä½¿ç”¨æ–°èƒŒæ™¯  unlock(\u0026amp;mutex);\t// é‡Šæ”¾äº’æ–¥é” }   ä»â€œå¼‚å¸¸å®‰å…¨æ€§â€ä¸Šçœ‹ï¼Œè¿™ä¸ªå‡½æ•°çš„è®¾è®¡å¾ˆç³Ÿç³•\n  å¼‚å¸¸å®‰å…¨æ€§å‡½æ•°çš„æ»¡è¶³æ¡ä»¶ï¼š\n ä¸æ³„éœ²ä»»ä½•èµ„æº  å¯¹ä¸Šè¿°changeBackgroundå‡½æ•°çš„å®ç°ï¼Œè‹¥new Image(imgSrc)å‘ç”Ÿå¼‚å¸¸ï¼Œåˆ™unlockæ°¸è¿œä¸ä¼šè¢«è°ƒç”¨ï¼Œäº’æ–¥å™¨æ°¸è¿œè¢«æŠŠæŒä½   ä¸å…è®¸æ•°æ®è´¥å  è‹¥new Image(imgSrc)æŠ›å‡ºå¼‚å¸¸ï¼ŒbgImageå°†æŒ‡å‘ä¸€ä¸ªè¢«åˆ é™¤çš„å¯¹è±¡ï¼ŒimageChangesä¹Ÿè¢«ç´¯åŠ ï¼Œè€Œäº‹å®ä¸Šå¹¶æ²¡æœ‰æ–°çš„å›¾åƒåŠ è½½æˆåŠŸ      æ­¤å¤„èµ„æºæ³„éœ²é—®é¢˜å¯ä»¥ä½¿ç”¨èµ„æºç®¡ç†ç±»è§£å†³\n  1 2 3 4 5 6 7  void PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { lock m1(\u0026amp;mutex);\t// è·å–äº’æ–¥å™¨ï¼Œå¹¶ç¡®ä¿æœªæ¥é”€æ¯  delete bgImage;\t// åˆ é™¤æ—§èƒŒæ™¯  ++imageChanges;\t// ä¿®æ”¹å›¾ç‰‡å˜æ›´æ¬¡æ•°  bgImage=new Image(imgSrc);\t// ä½¿ç”¨æ–°èƒŒæ™¯ }     å¼‚å¸¸å®‰å…¨å‡½æ•°æä¾›ä¸‰ä¸ªä¿è¯\n  åŸºæœ¬æ‰¿è¯ºï¼šå¦‚æœå¼‚å¸¸è¢«æŠ›å‡ºï¼Œç¨‹åºå†…çš„ä»»ä½•äº‹ç‰©ä»ç„¶ä¿æŒåœ¨æœ‰æ•ˆçŠ¶æ€ä¸‹ã€‚æ²¡æœ‰ä»»ä½•å¯¹è±¡æˆ–æ•°æ®ç»“æ„ä¼šå› æ­¤è€Œè´¥åï¼Œæ‰€æœ‰å¯¹è±¡å‡å¤„äºä¸€ç§å†…éƒ¨å‰åä¸€è‡´çš„çŠ¶æ€ã€‚ç„¶è€Œç¨‹åºçš„ç°å®çŠ¶æ€ææ€•ä¸å¯é¢„æ–™ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥ç¼–å†™changeBackgroundå‡½æ•°å¼‚å¸¸æŠ›å‡ºæ—¶ï¼ŒPrettyMenuå¯ä»¥ç»§ç»­æ‹¥æœ‰èƒŒæ™¯å›¾ç‰‡ï¼Œæˆ–è€…ä»¤å®ƒæ‹¥æœ‰æŸä¸ªç¼ºçœçš„èƒŒæ™¯å›¾åƒï¼Œä½†å®¢æˆ·æ— æ³•é¢„æœŸæ˜¯å“ªä¸€ç§æƒ…å†µ\n  å¼ºçƒˆä¿è¯ï¼šå¦‚æœå¼‚å¸¸è¢«æŠ›å‡ºï¼Œç¨‹åºçŠ¶æ€ä¸æ”¹å˜ã€‚è°ƒç”¨è¿™æ ·çš„å‡½æ•°éœ€è¦æœ‰è¿™æ ·çš„è®¤çŸ¥ï¼šå¦‚æœå‡½æ•°æˆåŠŸï¼Œå°±æ˜¯å®Œå…¨æˆåŠŸï¼Œå¦‚æœå‡½æ•°å¤±è´¥ï¼Œç¨‹åºä¼šå›é€€åˆ°å‡½æ•°è°ƒç”¨ä¹‹å‰çš„çŠ¶æ€\n  ä¸æŠ›æ·ä¿è¯ï¼šæ‰¿è¯ºç»ä¸æŠ›å‡ºå¼‚å¸¸ï¼Œå› ä¸ºå®ƒä»¬æ€»èƒ½å®Œæˆå®ƒä»¬åŸå…ˆæ‰¿è¯ºçš„åŠŸèƒ½ã€‚ä½œç”¨äºå†…ç½®ç±»å‹èº«ä¸Šçš„æ‰€æœ‰æ“ä½œéƒ½æä¾›nothrowä¿è¯ã€‚ä¾‹å¦‚\n    1  int doSomethin() throw();   â€‹\tå¹¶ä¸æ˜¯è¯´æ˜doSomethingä¸ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œè€Œæ˜¯è¯´å¦‚æœdoSomethingæŠ›å‡ºå¼‚å¸¸ï¼Œå°†æ˜¯ä¸¥é‡é”™è¯¯ï¼Œä¼šæœ‰æ„æƒ³ä¸åˆ°çš„å‡½æ•°è¢«è°ƒç”¨ã€‚åŒæ—¶doSomethingä¹Ÿæ²¡æœ‰æä¾›ä»»ä½•å¼‚å¸¸ä¿è¯\n  å¯¹changeBackgroundå‡½æ•°å®‰å…¨æ€§çš„ä¼˜åŒ–\n æ”¹å˜PrettyMenuçš„bgImageæˆå‘˜å˜é‡ç±»å‹ï¼Œä»ä¸€ä¸ªç±»å‹ä¸ºImage*çš„å†…ç½®æŒ‡é’ˆæ”¹ä¸ºä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆ é‡æ–°æ’åˆ—changeBackgroundå‡½æ•°å†…è¯­å¥æ¬¡åºï¼Œä½¿å¾—åœ¨æ›´æ¢å›¾åƒä¹‹åæ‰ç´¯åŠ imageChanges    1 2 3 4 5 6 7 8 9 10 11  class PrettyMenu{ ... std::tr1::shared_ptr\u0026lt;Image\u0026gt; bgImage; ... }; void PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { Lock m1(\u0026amp;mutex); bgImage.reset(new Image(imgSrc)); ++imageChanges; }    å¦‚æœImageæ„é€ å‡½æ•°æŠ›å‡ºå¼‚å¸¸ï¼Œæœ‰å¯èƒ½è¾“å…¥æµçš„è¯»å–è®°å·å·²è¢«ç§»èµ°ï¼Œè¿™æ ·çš„æ¬ç§»å¯¹ç¨‹åºçš„å…¶ä½™éƒ¨åˆ†æ˜¯ä¸€ç§å¯è§çš„çŠ¶æ€æ”¹å˜ï¼Œåœ¨ä¿è¯changeBackgroundæä¾›å¼ºçƒˆä¿è¯å‰æä¸‹ï¼Œå¯ä»¥ä½¿ç”¨ä¸‹è¿°æ–¹æ³•è§£å†³è¿™ä¸€é—®é¢˜  copy and swapç­–ç•¥ï¼šä¸ºæ‰“ç®—ä¿®æ”¹çš„å¯¹è±¡åšå‡ºä¸€ä»½å‰¯æœ¬ï¼Œç„¶ååœ¨é‚£å‰¯æœ¬èº«ä¸Šåšä¸€åˆ‡å¿…è¦ä¿®æ”¹ã€‚è‹¥æœ‰ä»»ä½•ä¿®æ”¹åŠ¨ä½œæŠ›å‡ºå¼‚å¸¸ï¼ŒåŸå¯¹è±¡ä»ä¿æŒæœªæ”¹å˜çŠ¶æ€ã€‚å¾…æ‰€æœ‰æ”¹å˜éƒ½æˆåŠŸåï¼Œå†å°†ä¿®æ”¹è¿‡çš„é‚£ä¸ªå‰¯æœ¬å’ŒåŸå¯¹è±¡åœ¨ä¸€ä¸ªä¸æŠ›å‡ºå¼‚å¸¸çš„æ“ä½œä¸­ç½®æ¢ å®ç°ï¼šå°†æ‰€æœ‰â€œéš¶å±å¯¹è±¡çš„æ•°æ®â€ä»åŸå¯¹è±¡æ”¾è¿›å¦å¤–ä¸€ä¸ªå¯¹è±¡å†…ï¼Œå¦‚ä½•èµ‹äºˆåŸå¯¹è±¡ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘é‚£ä¸ªæ‰€è°“çš„å®ç°å¯¹è±¡ï¼ˆå³å‰¯æœ¬ï¼‰ã€‚è¯¥æ‰‹æ³•å¸¸ç§°ä¸ºpimpl idiom    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  struct PMImpl{ std::tr1::shared_ptr\u0026lt;Image\u0026gt; bgImage; int imageChanges; }; class PrettyMenu{ ... private: Mutex mutex; std::tr1::shared_ptr\u0026lt;PMImpl\u0026gt; pImpl; }; void PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { using std::swap; Lock ml(\u0026amp;mutex); std::tr1::shared_ptr\u0026lt;PMImpl\u0026gt; pNew(new PMImpl(*pImpl)); pNew-\u0026gt;bgImage.reset(new Image(imgSrc)); ++pNew-\u0026gt;imageChanges; swap(pImpl, pNew); }    copy-and-swapç­–ç•¥æ˜¯å¯¹å¯¹è±¡çŠ¶æ€åšå‡ºå…¨æœ‰æˆ–å…¨æ— æ”¹å˜çš„ä¸€ä¸ªå¾ˆå¥½æ–¹æ³•ï¼Œä½†ä¸€èˆ¬è€Œè¨€å®ƒå¹¶ä¸ä¿è¯æ•´ä¸ªå‡½æ•°å…·æœ‰å¼ºçƒˆçš„å¼‚å¸¸å®‰å…¨æ€§ï¼Œè€ƒè™‘ä»£ç ï¼š  1 2 3 4 5 6 7  void someFunc() { ... f1(); f2(); ... }     å¦‚æœf1æˆ–f2çš„å¼‚å¸¸å®‰å…¨æ€§æ¯”â€œå¼ºçƒˆä¿è¯â€ä½ï¼Œå°±å¾ˆéš¾è®©someFuncæˆä¸ºâ€œå¼ºçƒˆå¼‚å¸¸å®‰å…¨â€ã€‚ä¾‹å¦‚ï¼Œå‡è®¾f1åªæä¾›åŸºæœ¬ä¿è¯ï¼Œåˆ™ä¸ºäº†ä½¿someFuncæä¾›å¼ºçƒˆä¿è¯ï¼Œå¿…é¡»å†™å‡ºä»£ç è·å¾—è°ƒç”¨f1ä¹‹å‰çš„æ•´ä¸ªç¨‹åºçŠ¶æ€ã€æ•æ‰f1æ‰€æœ‰å¯èƒ½å¼‚å¸¸ã€ç„¶åæ¢å¤åŸçŠ¶æ€\n  å¦‚æœf1å’Œf2éƒ½æ˜¯â€œå¼ºçƒˆå¼‚å¸¸å®‰å…¨â€ï¼Œå¦‚æœf1åœ†æ»¡ç»“æŸï¼Œç¨‹åºçŠ¶æ€åœ¨ä»»ä½•æ–¹é¢éƒ½å¯èƒ½æœ‰æ‰€æ”¹å˜ï¼Œå› æ­¤å¦‚æœf2éšåæŠ›å‡ºå¼‚å¸¸ï¼Œç¨‹åºçŠ¶æ€å’ŒsomeFuncè¢«è°ƒç”¨å‰å¹¶ä¸ç›¸åŒï¼Œç”šè‡³å½“f2æ²¡æœ‰æ”¹å˜ä¸œè¥¿æ—¶ä¹Ÿæ˜¯å¦‚æ­¤\n  å‡½æ•°æä¾›çš„â€œå¼‚å¸¸å®‰å…¨ä¿è¯â€é€šå¸¸æœ€é«˜åªç­‰äºå…¶æ‰€è°ƒç”¨ä¹‹å„ä¸ªå‡½æ•°çš„â€œå¼‚å¸¸å®‰å…¨ä¿è¯â€ä¸­çš„æœ€å¼±è€…\n  Item 30ï¼šUnderstand the ins and outs of inlining   åœ¨ä¸€å°å†…å­˜æœ‰é™çš„æœºå™¨ä¸Šï¼Œè¿‡åº¦çƒ­è¡·inliningä¼šé€ æˆç¨‹åºä½“ç§¯å¤ªå¤§ï¼ˆå¯¹å¯ç”¨ç©ºé—´è€Œè¨€ï¼‰ã€‚å³ä½¿æ‹¥æœ‰è™šå†…å­˜ï¼Œinlineé€ æˆçš„ä»£ç è†¨èƒ€äº¦ä¼šå¯¼è‡´é¢å¤–çš„æ¢é¡µè¡Œä¸ºï¼Œé™ä½æŒ‡ä»¤é«˜é€Ÿç¼“å­˜è£…ç½®çš„å‡»ä¸­ç‡ï¼Œä»¥åŠä¼´éšè¿™äº›è€Œæ¥çš„æ•ˆç‡æŸå¤±\n  å¦‚æœinlineå‡½æ•°æœ¬ä½“å¾ˆå°ï¼Œç¼–è¯‘å™¨é’ˆå¯¹å‡½æ•°æœ¬ä½“æ‰€äº§ç”Ÿçš„ç å¯èƒ½æ¯”é’ˆå¯¹å‡½æ•°è°ƒç”¨æ‰€äº§ç”Ÿçš„ç æ›´å°ã€‚è¿™æ ·çš„è¯ï¼Œå°†å‡½æ•°inliningç¡®å®å¯èƒ½å¯¼è‡´è¾ƒå°çš„ç›®æ ‡ç å’Œè¾ƒé«˜çš„æŒ‡ä»¤é«˜é€Ÿç¼“å­˜è£…ç½®å‡»ä¸­ç‡\n  inlineåªæ˜¯å¯¹ç¼–è¯‘å™¨çš„ä¸€ä¸ªç”³è¯·ï¼Œä¸æ˜¯å¼ºåˆ¶å‘½ä»¤\n å¯ä»¥æ˜ç¡®æå‡º    1 2 3 4 5  template\u0026lt;typename T\u0026gt; inline const T\u0026amp; std::max(const T\u0026amp; a, const T\u0026amp;b) { return a\u0026lt;b? b : a; }    ä¹Ÿå¯ä»¥éšå–»æ–¹å¼æå‡ºï¼Œå³å°†å‡½æ•°å®šä¹‰äºclasså®šä¹‰å¼å†…  1 2 3 4 5 6 7 8  class Person{ public: ... int age() const {return theAge;} ... private: int theAge; };     inlineå‡½æ•°é€šå¸¸ä¸€å®šè¢«ç½®äºå¤´æ–‡ä»¶å†…ï¼Œå› ä¸ºå¤§å¤šæ•°å»ºç½®ç¯å¢ƒåœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­è¿›è¡Œinliningï¼Œè€Œä¸ºäº†å°†ä¸€ä¸ªâ€œå‡½æ•°è°ƒç”¨â€æ›¿æ¢ä¸ºâ€œè¢«è°ƒç”¨å‡½æ•°çš„æœ¬ä½“â€ï¼Œç¼–è¯‘å™¨å¿…é¡»çŸ¥é“é‚£ä¸ªå‡½æ•°é•¿ä»€ä¹ˆæ ·ã€‚inliningåœ¨å¤§å¤šæ•°C++ç¨‹åºä¸­æ˜¯ç¼–è¯‘æœŸè¡Œä¸º\n  templateé€šå¸¸ä¹Ÿè¢«ç½®äºå¤´æ–‡ä»¶å†…ï¼Œå› ä¸ºå®ƒä¸€æ—¦è¢«ä½¿ç”¨ï¼Œç¼–è¯‘å™¨ä¸ºäº†å°†å®ƒå…·ç°åŒ–ï¼Œéœ€è¦çŸ¥é“å®ƒé•¿ä»€ä¹ˆæ ·ã€‚è€Œtemplateä¸inliningæ— å…³ï¼Œæ‰€ä»¥ä¸åº”è¯¥å°†æ‰€æœ‰çš„tempalte functionå£°æ˜ä¸ºinline\n  æ‰€æœ‰å¯¹virtualå‡½æ•°çš„è°ƒç”¨ä¹Ÿéƒ½ä¼šä½¿inliningè½ç©ºï¼Œå› ä¸ºvirtualæ„å‘³ç€â€œç­‰å¾…ï¼Œç›´åˆ°è¿è¡ŒæœŸæ‰ç¡®å®šè°ƒç”¨å“ªä¸ªå‡½æ•°â€ï¼Œè€Œinlineæ„å‘³ç€â€œæ‰§è¡Œå‰ï¼Œå…ˆå°†è°ƒç”¨åŠ¨ä½œæ›¿æ¢ä¸ºè¢«è°ƒç”¨å‡½æ•°çš„æœ¬ä½“â€\n  ä¸€ä¸ªè¡¨é¢çœ‹ä¼¼inlineçš„å‡½æ•°æ˜¯å¦çœŸçš„èƒ½inlineå–å†³äºå»ºç½®ç¯å¢ƒï¼Œä¸»è¦å–å†³äºç¼–è¯‘å™¨ã€‚å¤§éƒ¨åˆ†ç¼–è¯‘å™¨å¯¹æ— æ³•inlineçš„å‡½æ•°éƒ½ä¼šæŠ›å‡ºä¸€ä¸ªè­¦å‘Šä¿¡æ¯\n  æœ‰æ—¶å€™è™½ç„¶ç¼–è¯‘å™¨æœ‰æ„æ„¿inliningæŸä¸ªå‡½æ•°ï¼Œä½†å¯èƒ½è¿˜æ˜¯ä¸ºè¯¥å‡½æ•°ç”Ÿæˆä¸€ä¸ªå‡½æ•°æœ¬ä½“ã€‚ä¾‹å¦‚ï¼Œå¦‚æœç¨‹åºéœ€è¦å–æŸä¸ªinlineå‡½æ•°çš„åœ°å€ï¼Œç¼–è¯‘å™¨é€šå¸¸å¿…é¡»ä¸ºæ­¤å‡½æ•°ç”Ÿæˆä¸€ä¸ªoutlinedå‡½æ•°æœ¬ä½“ã€‚ç¼–è¯‘å™¨é€šå¸¸ä¸å¯¹â€œé€šè¿‡å‡½æ•°æŒ‡é’ˆè€Œè¿›è¡Œçš„è°ƒç”¨â€å®æ–½inliningï¼Œè¿™æ„å‘³ç€inlineå‡½æ•°çš„è°ƒç”¨å¯èƒ½è¢«inlinedï¼Œä¹Ÿå¯èƒ½ä¸è¢«inlinedï¼Œå–å†³äºè¯¥è°ƒç”¨çš„å®æ–½æ–¹å¼ï¼š\n  1 2 3 4 5  inline void f() { .. } void (*pf)()=f; ... f(); pf();     æœ‰æ—¶å€™ç¼–è¯‘å™¨ä¼šç”Ÿæˆæ„é€ å‡½æ•°å’Œææ„å‡½æ•°çš„outlineå‰¯æœ¬ï¼Œæ„é€ å‡½æ•°å’Œææ„å‡½æ•°ä¸é€‚åˆè¿›è¡Œinliningï¼Œå³ä½¿å…¶å‡½æ•°å†…å®¹ä¸ºç©º\n æ„é€ å‡½æ•°å’Œææ„å‡½æ•°å¹¶éçœŸçš„ä¸ºç©ºï¼Œæ´¾ç”Ÿç±»æ„é€ å‡½æ•°è‡³å°‘ä¸€å®šä¼šé™†ç»­è°ƒç”¨å…¶æˆå‘˜å˜é‡å’ŒåŸºç±»ä¸¤è€…çš„æ„é€ å‡½æ•°ï¼Œè¿™äº›è°ƒç”¨ä¼šå½±å“ç¼–è¯‘å™¨æ˜¯å¦å¯¹æ­¤ç©ºç™½å‡½æ•°inlining    inlineå‡½æ•°æ— æ³•éšç¨‹åºåº“çš„å‡çº§è€Œå‡çº§\n å¦‚æœfæ˜¯ç¨‹åºåº“å†…çš„ä¸€ä¸ªinlineå‡½æ•°ï¼Œå®¢æˆ·å°†få‡½æ•°æœ¬ä½“ç¼–è¿›å…¶ç¨‹åºä¸­ï¼Œä¸€æ—¦ç¨‹åºåº“è®¾è®¡è€…å†³å®šæ”¹å˜fï¼Œæ‰€æœ‰ç”¨åˆ°fçš„å®¢æˆ·ç«¯ç¨‹åºéƒ½å¿…é¡»é‡æ–°ç¼–è¯‘ å¦‚æœfæ˜¯non-inlineå‡½æ•°ï¼Œä¸€æ—¦å®ƒæœ‰ä»»ä½•ä¿®æ”¹ï¼Œå®¢æˆ·ç«¯åªéœ€é‡æ–°è¿æ¥å°±å¥½ï¼Œè¿œæ¯”é‡æ–°ç¼–è¯‘çš„è´Ÿæ‹…å°‘å¾ˆå¤šã€‚å¦‚æœç¨‹åºåº“é‡‡å–åŠ¨æ€é“¾æ¥ï¼Œå‡çº§ç‰ˆå‡½æ•°ç”šè‡³å¯ä»¥ä¸çŸ¥ä¸è§‰åœ°è¢«åº”ç”¨ç¨‹åºå¸çº³    Item 31ï¼šMinimize compilation dependencies between files  C++â€œæ¥å£ä»å®ç°åˆ†ç¦»â€çš„ç¼ºé™·ï¼šclassçš„å®šä¹‰å¼ä¸æ­¢è¯¦ç»†å™è¿°äº†classæ¥å£ï¼Œè¿˜åŒ…æ‹¬åè¶³çš„å®ç°ç»†èŠ‚  1 2 3 4 5 6 7 8 9 10 11 12  class Person{ public: Person(const std::string\u0026amp; name, cosnt Date\u0026amp; birthday, const Address\u0026amp; addr); std::string name() const; std::string birthDate() const; std::string address() const; ... private: std::string theName; Date theBirthDate; Address theAddress; };   ä¸Šè¿°ä»£ç æ— æ³•é€šè¿‡ç¼–è¯‘ï¼Œå› ä¸ºæ‰¾ä¸åˆ°std::stringï¼ŒDateå’ŒAddressçš„å®šä¹‰ ï¼Œéœ€è¦åŒ…å«ç›¸å…³å¤´æ–‡ä»¶ã€‚è€Œå½“ç›¸å…³ä¾èµ–å¤´æ–‡ä»¶ä¿®æ”¹æ—¶ï¼Œæ¯ä¸€ä¸ªåŒ…å«è¯¥å¤´æ–‡ä»¶çš„æºæ–‡ä»¶å‡éœ€è¦è¿›è¡Œç¼–è¯‘\n  ä¼˜åŒ–æ–¹æ³•ï¼šä»¥â€œå£°æ˜çš„ä¾å­˜æ€§â€æ›¿æ¢â€œå®šä¹‰çš„ä¾å­˜æ€§â€\n  å¦‚æœä½¿ç”¨object referenceæˆ–object pointerå¯ä»¥å®Œæˆä»»åŠ¡ï¼Œå°±ä¸è¦ä½¿ç”¨object\n å®šä¹‰ä¸€ä¸ªç±»å‹çš„referenceæˆ–pointeråªéœ€è¦ä¸€ä¸ªç±»å‹å£°æ˜å¼ å®šä¹‰æŸç±»å‹çš„objectséœ€è¦ç”¨åˆ°è¯¥ç±»å‹çš„å®šä¹‰å¼    å°½é‡ä»¥classå£°æ˜å¼æ›¿æ¢classå®šä¹‰å¼\n  ä¸ºå£°æ˜å¼å’Œå®šä¹‰å¼æä¾›ä¸åŒçš„å¤´æ–‡ä»¶\n ç±»ä¼¼\u0026lt;iosfwd\u0026gt;ï¼Œ\u0026lt;iosfwd\u0026gt;å«iostreamå„ç»„ä»¶çš„å£°æ˜å¼ï¼Œå…¶å¯¹åº”å®šä¹‰åˆ™åˆ†å¸ƒåœ¨è‹¥å¹²ä¸åŒçš„å¤´æ–‡ä»¶å†…ï¼ŒåŒ…æ‹¬\u0026lt;sstream\u0026gt;ã€\u0026lt;streambuf\u0026gt;ã€\u0026lt;fstream\u0026gt;å’Œ\u0026lt;iostream\u0026gt;      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;string\u0026gt;#include \u0026lt;memory\u0026gt; class PersonImpl;\t// Personå®ç°ç±»çš„å‰ç½®å£°æ˜ class Date; class Address; class Person{ public: Person(const std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr); std::string name() const; std::string birthDate() const; std::string address() const; ... private: std::tr1::shared_ptr\u0026lt;PersonImpl\u0026gt; pImpl; };     ä½¿ç”¨pimpl idiomçš„classesé€šå¸¸ç§°ä¸ºHandles classes\n å°†å®ƒä»¬æ‰€æœ‰å‡½æ•°è½¬äº¤ç»™ç›¸åº”çš„å®ç°ç±»å¹¶ç”±åè€…å®Œæˆå®é™…å·¥ä½œ    1 2 3 4 5 6  #include \u0026#34;Person.h\u0026#34;#include \u0026#34;PersonImpl.h\u0026#34; Person::Person(const std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr) : pImpl(new PersonImpl(name, birthday, addr)){} std::string Person::name() const{return pImpl-\u0026gt;name();}    Interface classï¼šæŠ½è±¡åŸºç±»ï¼Œç”¨äºæè¿°derived classesçš„æ¥å£ï¼Œé€šå¸¸ä¸å¸¦æˆå‘˜å˜é‡ä¹Ÿæ²¡æœ‰æ„é€ å‡½æ•°ï¼Œåªæœ‰ä¸€ä¸ªvirtualææ„å‡½æ•°å’Œä¸€ç»„pure virtualå‡½æ•°æ¥å™è¿°æ•´ä¸ªæ¥å£  1 2 3 4 5 6 7 8  class Person{ public: virtual ~Person(); virtual std::string name() const = 0; virtual std::string birthDate() const = 0; virtual std::string address() const = 0; ... };    interface classçš„å®¢æˆ·å¿…é¡»æœ‰åŠæ³•ä¸ºè¿™ç§classåˆ›å»ºå¯¹è±¡ã€‚é€šå¸¸è°ƒç”¨ä¸€ä¸ªç‰¹æ®Šå‡½æ•°ï¼Œæ­¤å‡½æ•°æ‰®æ¼”â€œçœŸæ­£è¢«å…·ç°åŒ–â€çš„é‚£ä¸ªderived classesçš„æ„é€ å‡½æ•°è§’è‰²ï¼Œè¿™ç§å‡½æ•°é€šå¸¸ç§°ä¸ºå·¥å‚å‡½æ•°ï¼ˆfactoryï¼‰æˆ–virtualæ„é€ å‡½æ•°ã€‚å®ƒä»¬è¿”å›æŒ‡é’ˆï¼ŒæŒ‡å‘åŠ¨æ€åˆ†é…æ‰€å¾—å¯¹è±¡ï¼Œè€Œè¯¥å¯¹è±¡æ”¯æŒinterface classæ¥å£ã€‚è¿™ç±»å‡½æ•°åœ¨interface classä¸­å¸¸å£°æ˜ä¸ºstaticå¦‚  1 2 3 4 5 6  class Person{ public: ... static std::tr1::shared_ptr\u0026lt;Person\u0026gt; create(cosnt std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr); ... };    å®¢æˆ·ä½¿ç”¨å¦‚ä¸‹ï¼š  1 2 3 4 5 6  std::string name; Date dateOfBirth; Address address; std::tr1::shared_ptr\u0026lt;Person\u0026gt; pp(Person::create(name, dateOfBirth, address)); ...   æ”¯æŒinterface classæ¥å£çš„é‚£ä¸ªå…·è±¡ç±»å¿…é¡»è¢«å®šä¹‰å‡ºæ¥ï¼Œä¸”çœŸæ­£çš„æ„é€ å‡½æ•°å¿…é¡»è¢«è°ƒç”¨ï¼Œå¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class RealPerson: public Person{ public: RealPerson(const std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr) : theName(name), theBirthDate(birthday), theAddress(addr){} virtual ~RealPerson(){} std::string name() const; std::string birthDate() const; std::string address() const; private: std::string theName; Date theBirthDate; Address theAddress; }; std::tr1::shared_ptr\u0026lt;Person\u0026gt; Person::create(cosnt std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr) { return std::tr1::shared_ptr\u0026lt;Person\u0026gt;(new RealPerson(name, birthday, addr)); }   ä¸Šè¿°ä»£ç ç¤ºèŒƒäº†interface classesçš„ä¸€ç§æœ€å¸¸è§æœºåˆ¶ï¼šä»interface classç»§æ‰¿æ¥å£è§„èŒƒï¼Œç„¶åå®ç°å‡ºæ¥å£æ‰€è¦†ç›–çš„å‡½æ•°\n  Handles classeså’Œinterface classesè§£é™¤äº†æ¥å£å’Œå®ç°ä¹‹é—´çš„è€¦åˆå…³ç³»ï¼Œé™ä½æ–‡ä»¶ä¹‹é—´çš„ç¼–è¯‘ä¾å­˜æ€§\n  ä»£ä»·åˆ†æï¼š\n  å¯¹äºHandles classesï¼Œæˆå‘˜å‡½æ•°å¿…é¡»é€šè¿‡implementation pointerå–å¾—å¯¹è±¡æ•°æ®ã€‚è¿™å°†ä¸ºæ¯æ¬¡è®¿é—®å¢åŠ ä¸€å±‚é—´æ¥æ€§ã€‚è€Œæ¯ä¸€ä¸ªå¯¹è±¡æ¶ˆè€—çš„å†…å­˜æ•°é‡å¿…é¡»å¢åŠ implementation pointerçš„å¤§å°ã€‚æœ€åimplementation pointerå¿…é¡»è¿›è¡Œåˆå§‹åŒ–ï¼ˆåœ¨Handles classesæ„é€ å‡½æ•°å†…ï¼‰ï¼ŒæŒ‡å‘ä¸€ä¸ªåŠ¨æ€åˆ†é…å¾—åˆ°çš„implementation objectï¼Œå› æ­¤å°†è’™å—å› åŠ¨æ€å†…å­˜åˆ†é…åŠå…¶é‡Šæ”¾æ‰€å¸¦æ¥çš„é¢å¤–å¼€é”€ï¼Œä»¥åŠé­é‡bad_allocå¼‚å¸¸ï¼ˆå†…å­˜ä¸è¶³ï¼‰çš„å¯èƒ½\n  å¯¹äºInterface classesï¼Œç”±äºæ¯ä¸ªå‡½æ•°éƒ½æ˜¯virtualï¼Œå› æ­¤æ¯æ¬¡è°ƒç”¨éƒ½åº”ä»˜å‡ºä¸€ä¸ªé—´æ¥è·³è·ƒä»£ä»·ã€‚æ­¤å¤–interface classæ´¾ç”Ÿå¯¹è±¡å¿…é¡»å†…å«ä¸€ä¸ªvirtual table pointerï¼ˆvtprï¼‰ï¼Œè¿™ä¸ªæŒ‡é’ˆå¯èƒ½å¢åŠ å­˜æ”¾å¯¹è±¡æ‰€éœ€çš„å†…å­˜æ•°é‡â€”â€”å®é™…å–å†³äºè¿™ä¸ªå¯¹è±¡é™¤äº†interface classä¹‹å¤–æ˜¯å¦æœ‰å…¶ä»–virtualå‡½æ•°æ¥æº\n  æ— è®ºHandles classesè¿˜æ˜¯Interface classesï¼Œä¸€æ—¦è„±ç¦»inlineå‡½æ•°éƒ½æ— æ³•æœ‰å¤ªå¤§ä½œä¸º\n    ","description":"ã€ŠEffective C++å­¦ä¹ ç¬”è®°ç¬¬äº”ç« ã€‹","id":17,"section":"note","tags":["Effective C++","C++"],"title":"Chapter 5: Implementations","uri":"https://chaphlagical.github.io/zh/note/effectivecpp/ch5/"},{"content":"1. å‚æ•°æ›²çº¿ 1.1. ç›´è§‚ç®€ä»‹  å‚æ•°æ›²çº¿$c$å¯ä»¥è§†ä¸ºç§»åŠ¨ç²’å­çš„è¿åŠ¨è½¨è¿¹ å‚æ•°$t$å¯è§†ä¸ºæ—¶é—´å‚æ•°  1.2. æ•°å­¦æè¿° 1.2.1. å®šä¹‰ $\\mathbb R^n$ä¸­çš„æ›²çº¿ç±»$C^k(k\\geq 1)$çš„å‚æ•°åŒ–æ˜¯å…‰æ»‘æ˜ å°„$c:I=[a,b]\\subset \\mathbb R\\rightarrow\\mathbb R^n$ï¼Œå…¶ä¸­$c$å±äºç±»$C^k$\n1.2.2. è¿¹çº¿ï¼ˆtraceï¼‰ å›¾åƒé›†åˆ$c(I)$ç§°ä¸ºæ›²çº¿çš„è¿¹çº¿\n ä¸åŒçš„å‚æ•°åŒ–å¯èƒ½æœ‰ç›¸åŒçš„è¿¹çº¿  1.2.3. è‡ªç›¸äº¤ï¼ˆself-intersectionï¼‰ è¿¹çº¿ä¸­çš„ä¸€ä¸ªç‚¹å¯¹åº”å¤šä¸ªå‚æ•°å€¼$t$ï¼Œåˆ™ç§°æ›²çº¿çš„è‡ªç›¸äº¤\n1.2.4. é€Ÿåº¦å‘é‡ æ›²çº¿$c$åœ¨æ—¶åˆ»$t$çš„å¯¼æ•°$c'(t)$ç§°ä¸ºæ›²çº¿çš„é€Ÿåº¦å‘é‡\n $c'(t)$ç»™å®šç§»åŠ¨çš„æ–¹å‘ $|c'(t)|$ç»™å®šé€Ÿåº¦å¤§å°  1.3. æ­£åˆ™å‚æ•°æ›²çº¿ï¼ˆRegular parametric curvesï¼‰  æ­£åˆ™å‚æ•°åŒ–  å¯¹äºæ‰€æœ‰çš„$t$ï¼Œæœ‰$c'(t)\\neq 0$ æ­£åˆ™æ›²çº¿ä¸Šçš„ç‚¹ç§°ä¸ºå¹³å‡¡ï¼ˆordinaryï¼‰ç‚¹ éæ­£åˆ™æ›²çº¿ä¸Šçš„ç‚¹ç§°ä¸ºå¥‡å¼‚ï¼ˆsingularï¼‰ç‚¹    1.4. å‚æ•°çš„å˜æ¢ ç»™å®šä¸€ä¸ªå…‰æ»‘çš„æ­£åˆ™å‚æ•°åŒ–ï¼Œå‚æ•°æ‰€å…è®¸çš„æ›´æ”¹ä¸ºä»»æ„å…‰æ»‘ï¼ˆå¯å¾®ï¼‰å‡½æ•°\n$$\nf:I_1\\rightarrow I\\ \\mathrm{such}\\ \\mathrm{that}\nf'\\neq 0\\ \\mathrm{on}\\ I_1\n$$\nå½“$f'\u0026gt;0$å°†ä¿æŒæ–¹å‘\n æˆ‘ä»¬å¯ä»¥å°†æ­£åˆ™æ›²çº¿è§†ä¸ºæ­£åˆ™å‚æ•°åŒ–çš„é›†åˆï¼Œå…¶ä¸­ä»»æ„ä¸¤ä¸ªå‚æ•°éƒ½æ˜¯å½¼æ­¤ä¹‹é—´çš„é‡æ–°å‚æ•°åŒ–ï¼ˆç­‰ä»·ç±»ï¼‰ æˆ‘ä»¬å¯¹å‚æ•°å˜æ¢ä¸‹çš„ä¸å˜é‡æ„Ÿå…´è¶£  1.5. å‡ ä½•è§‚å¯Ÿ åˆ‡çº¿å‘é‡ï¼ˆTangent vectorï¼‰\n æ­£åˆ™æ›²çº¿$c(t)$åœ¨ç‚¹$\\pmb p_0=\\pmb c(t_0)$å¤„çš„æ­£å¼¦çº¿å®šä¹‰ä¸ºæ»¡è¶³$\\pmb p-\\pmb p_0\\parallel\\pmb c_0'$çš„ç‚¹$\\pmb p$ï¼Œå…¶ä¸­$\\pmb c'_0=\\pmb c'(t_0)$ å½’ä¸€åŒ–å‘é‡$\\pmb t=\\dfrac{\\pmb c'}{\\vert c'\\vert}$ç§°ä¸ºåˆ‡çº¿å‘é‡  æ³•å¹³é¢ï¼ˆNormal planeï¼‰\næ³•å¹³é¢æè¿°ä¸ºæ»¡è¶³$\\pmb p-\\pmb p_0\\perp\\pmb c_0'$çš„ç‚¹$\\pmb p$ï¼Œå³\n$$\n(\\pmb p-\\pmb p_0)\\cdot\\pmb c_0'=0\n$$\nå¯†åˆ‡å¹³é¢ï¼ˆOsculating planeï¼‰\n  å‡è®¾æ›²çº¿$\\pmb c(t)$ä¸æ˜¯ä¸€æ¡ç›´çº¿ï¼Œä»»æ„ä¸‰ä¸ªä¸å…±çº¿çš„ç‚¹$\\pmb p_1,\\pmb p_2,\\pmb p_3$ï¼Œèƒ½å¤Ÿå†³å®šä¸€ä¸ªå¹³é¢\n  å¦‚æœ$\\pmb p_1,\\pmb p_2,\\pmb p_3$è¶‹äºäºæ›²çº¿$\\pmb c$ä¸Šçš„åŒä¸€ä¸ªç‚¹$\\pmb p_0$ï¼Œé‚£ä¹ˆå…¶æ„æˆçš„å¹³é¢ç§°ä¸ºæ›²çº¿$\\pmb c$åœ¨ç‚¹$\\pmb p_0$å¤„çš„å¯†åˆ‡å¹³é¢$T$\n  è‹¥æ›²çº¿åœ¨ç‚¹$\\pmb p_0$å¤„çš„ä¸€é˜¶å¯¼æ•°$\\pmb c_0'$å’ŒäºŒé˜¶å¯¼æ•°$\\pmb c''_0$çº¿æ€§ç‹¬ç«‹ï¼Œåˆ™å¯†åˆ‡å¹³é¢ç»™å®šä¸ºï¼š\n$$\n(\\pmb c_0'\\times\\pmb c_0'')\\cdot(\\pmb p-\\pmb p_0)=0\n$$\n  è§‚å¯Ÿ$\\pmb p(t+\\Delta t)$ä¸ä»¥$\\pmb a$ä¸ºæ³•å‘é‡ä¸”ç©¿è¿‡ç‚¹$\\pmb p(t)$çš„å¹³é¢çš„è·ç¦»ï¼Œæœ‰\n$$\n\\pmb a\\cdot(\\pmb p(t_0+\\Delta t)-\\pmb p(t_0))=\\pmb a\\cdot \\Big(\\dot{\\pmb p}(t_0)\\Delta t+\\dfrac{\\ddot{\\pmb p}(t_0)}{2!}\\Delta t^2+\\cdots \\Big)\n$$\nå½“è·ç¦»å–æœ€å°å€¼æ—¶ï¼Œæœ‰\n$$\n\\pmb a\\cdot\\dot{\\pmb P}(t_0)=0,\\ \\ \\\n\\pmb a\\cdot\\ddot{\\pmb P}(t_0)=0\n$$\næ­¤æ—¶å–å¾—å¯†åˆ‡å¹³é¢ï¼Œå¯†åˆ‡å¹³é¢æ˜¯æ›²çº¿åœ¨$\\pmb p(t_0)$å¤„çš„æœ€ä¼˜æ‹Ÿåˆå¹³é¢\nä»åˆ‡å¹³é¢ï¼ˆRectifying planeï¼‰\nåŒæ—¶å‚ç›´äºå¯†åˆ‡å¹³é¢å’Œæ³•å¹³é¢çš„å¹³é¢ç§°ä¸ºä»åˆ‡å¹³é¢$R$ï¼Œä»åˆ‡å¹³é¢ä¸Šçš„ç‚¹$\\pmb p$æ»¡è¶³\n$$\n(\\pmb c_0'\\times(\\pmb c_0'\\times\\pmb c_0''))\\cdot(\\pmb p-\\pmb p_0)=0\n$$\næ³•å‘é‡\næ³•å¹³é¢å†…çš„ä»»ä½•å‘é‡å‡ä¸ºæ›²çº¿çš„æ³•å‘é‡ï¼Œç‰¹åˆ«åœ°\n  ç‚¹$\\pmb p_0$å¤„åŒæ—¶ä½äºå¯†åˆ‡å¹³é¢å†…çš„æ³•å‘é‡$\\pmb n$ï¼ˆå¯†åˆ‡å¹³é¢ä¸æ³•å¹³é¢äº¤çº¿ï¼‰ç§°ä¸ºä¸»æ³•å‘é‡ï¼ˆprincipal normal ï¼‰\n$$\n(\\pmb c_0'\\times\\pmb c_0'')\\times\\pmb c_0'\n$$\n  ç‚¹$\\pmb p_0$å¤„åŒæ—¶ä½äºä»åˆ‡å¹³é¢çš„æ³•å‘é‡$\\pmb b$ç§°ä¸ºå‰¯æ³•å‘é‡ï¼ˆbinormalï¼‰\n$$\n\\pmb c_0'\\times\\pmb c_0''\n$$\n  Frenetæ ‡æ¶\né€šè¿‡ä»¥ä¸‹ä¸‰ä¸ªæ­£äº¤å‘é‡æ„é€ æ›²çº¿ä¸Šçš„å±€éƒ¨åæ ‡æ¶\n  åˆ‡çº¿å‘é‡\n$$\n\\pmb t=\\dfrac{\\pmb c'}{|\\pmb c_0'|}\n$$\n  å‰¯æ³•å‘é‡\n$$\n\\pmb b=\\dfrac{\\pmb c_0'\\times\\pmb c_0''}{|\\pmb c_0'\\times\\pmb c_0''|}\n$$\n  ä¸»æ³•å‘é‡\n$$\n\\pmb n=\\pmb b\\times\\pmb t\n$$\n  å¯¹åº”çš„å…³è”å¹³é¢ï¼š\n  æ³•å¹³é¢\n$$\n(\\pmb p-\\pmb p_0)\\cdot\\pmb t=0\n$$\n  å¯†åˆ‡å¹³é¢\n$$\n(\\pmb p-\\pmb p_0)\\cdot\\pmb b=0\n$$\n  ä»åˆ‡å¹³é¢\n$$\n(\\pmb p-\\pmb p_0)\\cdot\\pmb n=0\n$$\n  æ›²ç‡\n  æ›²ç‡çš„åŸºæœ¬æ¦‚å¿µ\n æµ‹é‡æ›²çº¿çš„å¼¯æ›²ç¨‹åº¦ ç›´çº¿æ²¡æœ‰å¼¯æ›² â†’ æ›²ç‡ä¸º0 åœ†æœ‰å›ºå®šçš„å¼¯æ›²ç¨‹åº¦ â†’ æ›²ç‡ä¸ºå¸¸æ•°    æ›²ç‡çš„è®¡ç®—\n$$\n\\kappa(t)=\\dfrac{|\\pmb c'(t)\\times\\pmb c''(t)|}{|\\pmb c'(t)|^3}\n$$\nç‰¹åˆ«åœ°ï¼Œå¯¹äºå¹³é¢æ›²çº¿$\\pmb c(t)=(x(t),y(t))$\n$$\n\\kappa(t)=\\dfrac{|x\u0026rsquo;y''-x'\u0026lsquo;y\u0026rsquo;|}{(x'^2+y'^2)^{\\frac{3}{2}}}\n$$\næ›²ç‡åŠå¾„:$r(t)=\\dfrac{1}{\\kappa(t)}$\n  æŒ ç‡\n  å®šä¹‰\n  æŒ ç‡$\\tau$è¡¡é‡å‰¯æ³•å‘é‡çš„å˜åŒ–\n  ï¼ˆæ›²çº¿ä»å…¶åœ¨å¯†åˆ‡å¹³é¢ä¸Šçš„æŠ•å½±çš„åç§»é‡å¯ä»¥è§†ä¸ºæ›²çº¿ç¦»å¹³é¢æ›²çº¿æœ‰å¤šè¿œï¼‰ï¼Œç”±ä¸‹å¼ç»™å‡º\n$$\n\\tau(t)=\\dfrac{(\\pmb c'\\times\\pmb c'')\\cdot\\pmb c'''}{|\\pmb c'\\times\\pmb c''|^2}\n$$\n    æ›²çº¿çš„é•¿åº¦\n  æ›²çº¿çš„å¼§é•¿\n  æ­£åˆ™æ›²çº¿$C$çš„å¼§é•¿å®šä¹‰ä¸ºï¼š\n$$\n\\mathrm{length}_c=\\int_a^b|\\dot{\\pmb c}|\\mathrm dt\n$$\n  ç‹¬ç«‹äºå‚æ•°çš„é€‰å–\n    2. å¼§é•¿æ›²çº¿æ›²çº¿ 2.1. å¼§é•¿å‚æ•°åŒ–   è€ƒè™‘$\\pmb c(t)$ä»0åˆ°$t$è·¨åº¦çš„éƒ¨åˆ†ï¼Œè¯¥æ®µå¼§é•¿$s$ä¸ºä¸€ä¸ªå…³äº$t$çš„å‡½æ•°\n$$\ns(t)=\\int_0^t|\\pmb c'(u)|\\mathrm du\n$$\n  ç”±äº$\\dfrac{\\mathrm ds}{\\mathrm dt}=\\vert\\vert \\pmb c'(u)\\vert\\vert\u0026gt;0$ï¼Œ$s$å¯ä»¥ä½œä¸ºæ–°çš„å‚æ•°åŒ–æ–¹å¼\n  æ˜“å¾—ï¼š\n$$\n\\pmb c'(s)=\\dfrac{\\mathrm d\\pmb c}{\\mathrm ds}=\\dfrac{\\mathrm d\\pmb c/\\mathrm dt}{\\mathrm ds/\\mathrm dt}\\Rightarrow |\\pmb c'(s)|=1\n$$\n  $\\pmb c(s)$ç§°ä¸ºå¼§é•¿ï¼ˆå•ä½é€Ÿåº¦ï¼‰å‚æ•°åŒ–æ›²çº¿ï¼Œå‚æ•°$s$ç§°ä¸ºå¼§é•¿æˆ–è‡ªç„¶å‚æ•°\n  2.2. ç”¨å¼§é•¿è¿›è¡Œå‚æ•°åŒ–  å¼§é•¿ï¼ˆæˆ–å•ä½é€Ÿåº¦ï¼‰å‚æ•°åŒ–  ä»»æ„æ­£åˆ™æ›²çº¿éƒ½å­˜åœ¨å¼§é•¿å‚æ•°åŒ– ä¸æ„å‘³ç€å¼§é•¿å‚æ•°åŒ–èƒ½å¤Ÿè¢«è®¡ç®—    2.3. å¼§é•¿å‚æ•°åŒ–çš„å‡ ä½•ç»“æœ   ç”±äº$\\vert\\vert\\pmb c'(u)\\vert\\vert=1$ï¼Œæœ‰$\\pmb c'\\cdot\\pmb c'=1$ï¼Œå–å¯¼æ•°å¾—åˆ°$\\pmb c'\\cdot\\pmb c''=0$\n  $\\pmb c''$ä¸$\\pmb c'$äº’ç›¸å‚ç›´ï¼ˆå‡ä½äºå¯†åˆ‡å¹³é¢ï¼‰\n  å› æ­¤$\\pmb c''$çš„æ–¹å‘å‘é‡å¯ä½œä¸ºä¸»æ³•å‘é‡ï¼ˆ$\\pmb c''\\neq \\pmb 0$ï¼‰\n$$\n\\pmb n=\\dfrac{\\pmb c''}{|\\pmb c''|}\n$$\n  2.4. æ›²ç‡   å¼§é•¿å‚æ•°æ›²çº¿$\\pmb c(u)$çš„æ›²ç‡ä¸º\n$$\n\\kappa=|\\pmb c''(u)|\n$$\n  3. Frenetæ›²çº¿ 3.1. åŸºæœ¬æ¦‚å¿µ  Frenetæ›²çº¿  Frenetæ›²çº¿æ˜¯$\\mathbb R^n$å†…çš„å¼§é•¿å‚æ•°æ›²çº¿$\\pmb c$ï¼Œæ»¡è¶³$\\pmb c'(s),\\pmb c''(s),\\cdots,\\pmb c^{n-1}(s)$çº¿æ€§ç‹¬ç«‹   Frenetæ ‡æ¶  æ¯æ¡Frenetæ›²çº¿éƒ½æœ‰ä¸€ä¸ªç‹¬ä¸€æ— äºŒçš„Frenetæ ‡æ¶$\\pmb e_1(s),\\pmb e_2(s),\\cdots,\\pmb e_n(s)$ï¼Œæ»¡è¶³  $\\pmb e_1(s),\\pmb e_2(s),\\cdots,\\pmb e_n(s)$æ­£äº¤ä¸”æ­£å‘   å¯¹${\\pmb c',\\pmb c'',\\cdots,\\pmb c^n}$åº”ç”¨Gram-Schmidtæ­£äº¤åŒ–    3.2. Gram-Schmidtå¤„ç†  è¾“å…¥ï¼šçº¿æ€§ç‹¬ç«‹å‘é‡é›†åˆ${\\pmb v_1,\\pmb v_2,\\cdots,\\pmb v_n}$ è¾“å‡ºï¼šæ­£äº¤å‘é‡é›†åˆ${\\pmb b_1,\\pmb b_2,\\cdots,\\pmb b_n}$  è®¾$\\pmb b_1=\\dfrac{\\pmb v_1}{\\vert\\vert\\pmb v_1\\vert\\vert}$ å¾ªç¯ï¼šFor $k=2,\\cdots,n$  $\\tilde{\\pmb b_k}=\\pmb v_k-\\sum_{i=1}^{k-1}\\langle \\pmb v_k,\\pmb b_i\\rangle \\pmb b_i$ $\\pmb b_k=\\dfrac{\\tilde {\\pmb b_k}}{\\vert\\vert\\tilde {\\pmb b_k}\\vert\\vert}$      3.3. å¹³é¢æ›²çº¿ ç°åœ¨ç”¨Frenetæ ‡æ¶ä¸‹å¼§é•¿å‚æ•°åŒ–è¡¨ç¤ºå¹³é¢æ›²çº¿\næ³•å‘é‡ï¼š\n$$\n\\pmb e_2(s)=R^{90^\\circ}\\pmb e_1(s)\n$$\næ ‡æ¶æ–¹ç¨‹ï¼š\n$$\n\\begin{pmatrix}\n\\pmb e_1(s)\\\\\\pmb e_2(s)\n\\end{pmatrix}'=\n\\begin{pmatrix}\n0\u0026amp;\\kappa(s)\\\\\n-\\kappa(s)\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\pmb e_1(s)\\\\\\pmb e_2(s)\n\\end{pmatrix}\n$$\næœ‰å‘æ›²ç‡ï¼š\n$$\n\\kappa(s)=\\langle\\pmb e_1'(s),\\pmb e_2(s)\\rangle=\\dfrac{\\langle\\ddot {\\pmb c}(t),R^{90^\\circ}\\dot{\\pmb c}(t) \\rangle}{|\\dot{\\pmb c}(t)|^3}\n$$\nå¯†åˆ‡åœ†ï¼š\n åŠå¾„ï¼š$1/\\kappa$ åœ†å¿ƒï¼š$\\pmb c(s)+\\dfrac{1}{\\kappa}\\pmb e_2(s)$  å¹³é¢æ›²çº¿çš„åŸºæœ¬å®šç†\n ä»¤$\\kappa:(a,b)\\rightarrow\\mathbb R$æ˜¯ä¸€ä¸ªå…‰æ»‘å‡½æ•°ã€‚å¯¹äºæŸäº›$s_0\\in(a,b)$ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ç»™å®šç‚¹$\\pmb p_0$å’Œä¸¤ä¸ªæ­£äº¤å‘é‡$\\pmb t_0$å’Œ$\\pmb n_0$ï¼Œåˆ™å­˜åœ¨å”¯ä¸€ä¸€ä¸ªFrenetæ›²çº¿$\\pmb c:(a,b)\\rightarrow\\mathbb R^2$ï¼Œæœ‰ï¼š  $\\pmb c(s_0)=\\pmb p_0$ $\\pmb e_1(s_0)=\\pmb t_0$ $\\pmb e_2(s_0)=\\pmb n_0$ æ›²çº¿$\\pmb c$çš„æ›²ç‡$c$ç­‰äºç»™å®šå‡½æ•°$\\pmb \\kappa$   æ¢å¥è¯è¯´ï¼Œå¯¹äºä»»æ„å…‰æ»‘å‡½æ•°ï¼Œå­˜åœ¨å”¯ä¸€ä¸€æ¡ç›´çº¿ä»¥è¯¥å‡½æ•°ä½œä¸ºå…¶æ›²ç‡  3.4. æ€§è´¨   åˆšæ€§è¿åŠ¨\n åˆšæ€§è¿åŠ¨ï¼š$\\pmb x\\rightarrow A\\pmb x+\\pmb b$ï¼Œå…¶ä¸­$A$ä¸ºæ­£äº¤çŸ©é˜µï¼ˆä¿è·ç¦»çš„ä»¿å°„æ˜ å°„ï¼‰  å½“$\\det \\pmb A=+1$æ—¶ä¿æ–¹å‘ï¼ˆéé•œé¢ï¼‰ é•œé¢$\\det\\pmb A=-1$      å¹³é¢æ›²çº¿åœ¨åˆšæ€§è¿åŠ¨ä¸‹çš„ä¸å˜æ€§\n æ›²ç‡åœ¨åˆšæ€§è¿åŠ¨ä¸‹ä¸å˜  ç»å¯¹å€¼ä¸å˜ å¦‚æœæ˜¯ä¿æ–¹å‘åˆšæ€§è¿åŠ¨ï¼Œåˆ™æœ‰å‘å€¼ä¸å˜      å¹³é¢æ›²çº¿çš„åˆšåº¦\n  å…·æœ‰ç›¸åŒæœ‰å‘æ›²ç‡å‡½æ•°çš„ä¸¤æ¡Frenetæ›²çº¿çš„åŒºåˆ«ä»…å› ä¿æ–¹å‘åˆšæ€§è¿åŠ¨è€Œä¸åŒ\n  å¼§é•¿å¯¼æ•°\n  å¼§é•¿å‚æ•°åŒ–\n æ‰¾åˆ°å‚æ•°æ›²çº¿çš„ä¸€ä¸ªå¼§é•¿å‚æ•°åŒ–å¾€å¾€æ˜¯å¾ˆå›°éš¾çš„ Frenetæ ‡æ¶åŠå…¶å¯¼æ•°ä¾æ—§æ˜¯å¯ä»¥è®¡ç®—çš„ï¼Œè¿™é‡Œå®šä¹‰äº†å¼§é•¿å¯¼æ•°    å¼§é•¿å¯¼æ•°\n å¯¹äºå‚æ•°æ›²çº¿$\\pmb c:[a,b]\\rightarrow\\mathbb R^n$ï¼Œå®šä¹‰ä»»æ„å¯å¾®å‡½æ•°$f:[a,b]\\rightarrow\\mathbb R$çš„å¼§é•¿å¯¼æ•°ä¸º\n$$\n\\pmb f'(t)=\\dfrac{1}{|\\dot{\\pmb c}(t)|}\\dot{\\pmb f}(t)\n$$      3.5. ç©ºé—´æ›²çº¿ $\\mathbb R^3$ä¸­çš„Frenetæ ‡æ¶\n  åˆ‡çº¿å‘é‡\n$$\n\\pmb e_1(s)=\\pmb c'(s)\n$$\n  æ³•å‘é‡\n$$\n\\pmb e_2(s)=\\dfrac{1}{|\\pmb c''(t)|}\\pmb c''(t)\n$$\n  å‰¯æ³•å‘é‡\n$$\n\\pmb e_3(s)=\\pmb e_1(s)\\times\\pmb e_2(s)\n$$\n  Frenet-Serretæ–¹ç¨‹ï¼š\n  $$\n\\begin{pmatrix}\n\\pmb e_1(s)\\\\\\pmb e_2(s)\\\\\\pmb e_3(s)\n\\end{pmatrix}=\n\\begin{pmatrix}\n0\u0026amp;\\kappa(s)\u0026amp;0\\\\-\\kappa(s)\u0026amp;0\u0026amp;\\tau(s)\\\\0\u0026amp;-\\tau(s)\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\pmb e_1(s)\\\\\\pmb e_2(s)\\\\\\pmb e_3(s)\n\\end{pmatrix}\n$$\n  æœ‰å‘æ›²ç‡ï¼š$\\kappa(s)=\\langle \\pmb e_1'(s),\\pmb e_2(s)\\rangle$\n  æŒ ç‡ï¼š$\\tau(s)=\\langle\\pmb e_2'(s),\\pmb e_3(s)\\rangle$ï¼Œæµ‹é‡æ›²çº¿å¦‚ä½•å¼¯æ›²è¶…å‡º$\\pmb e_1$å’Œ$\\pmb e_2$çš„å¹³é¢\n  $\\mathbb R^n$ä¸­æ›²çº¿çš„Frenetæ–¹ç¨‹è¡¨ç¤ºä¸ºï¼š\n  $$\n\\begin{pmatrix}\n\\pmb e_1(s)\\\\\\pmb e_2(s)\\\\\\vdots\\\\\\pmb e_n(s)\n\\end{pmatrix}=\n\\begin{pmatrix}\n0\u0026amp;\\kappa_1(s)\u0026amp;0\u0026amp;\\cdots\u0026amp;0\u0026amp;0\\\\\n-\\kappa_1(s)\u0026amp;0\u0026amp;\\kappa_2(s)\u0026amp;\\cdots\u0026amp;0\u0026amp;0\\\\\n0\u0026amp;-\\kappa_2(s)\u0026amp;0\u0026amp;\\cdots\u0026amp;0\u0026amp;0\\\\\n\\vdots\u0026amp;\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\u0026amp;\\vdots\\\\\n0\u0026amp;0\u0026amp;0\u0026amp;\\cdots\u0026amp;0\u0026amp;\\kappa_{n-1}(s)\\\\\n0\u0026amp;0\u0026amp;0\u0026amp;\\cdots\u0026amp;-\\kappa_{n-1}(s)\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\pmb e_1(s)\\\\\\pmb e_2(s)\\\\\\vdots\\\\\\pmb e_n(s)\n\\end{pmatrix}\n$$\n å‡½æ•°$\\kappa_i(s)$ç§°ä¸º$i$æ¬¡Frenentæ›²ç‡  å°ç»“   å¯¹äºæ­£åˆ™æ›²çº¿\n åˆ‡çº¿å‘é‡ï¼š$\\pmb t=\\dfrac{\\pmb c'}{\\vert\\vert\\pmb c'\\vert\\vert}$ï¼Œæ³•å¹³é¢ï¼š$(\\pmb p-\\pmb p_0)\\cdot\\pmb t=0$ å‰¯æ³•å‘é‡ï¼š$\\pmb b=\\dfrac{\\pmb c'\\times\\pmb c''}{\\vert\\vert\\pmb c'\\times\\pmb c''\\vert\\vert}$ï¼Œå¯†åˆ‡å¹³é¢ï¼š$(\\pmb p-\\pmb p_0)\\cdot\\pmb b=0$ ä¸»æ³•å‘é‡ï¼š$\\pmb n=\\pmb b\\times\\pmb t$ï¼Œä»åˆ‡å¹³é¢ï¼š$(\\pmb p-\\pmb p_0)\\cdot\\pmb n=0$ æ›²ç‡ï¼š$\\kappa(t)=\\dfrac{\\pmb c'\\times\\pmb c''}{\\vert\\vert\\pmb c'\\vert\\vert^3}$ æŒ ç‡ï¼š$\\tau(t)=\\dfrac{(\\pmb c'\\times\\pmb c'')\\cdot\\pmb c'''}{\\vert\\vert\\pmb c'\\times\\pmb c''\\vert\\vert^2}$    å¼§é•¿å‚æ•°ï¼ˆå•ä½é€Ÿåº¦ï¼‰æ›²çº¿$\\pmb c(s)$\n åˆ‡çº¿å‘é‡ï¼š$\\pmb t=\\pmb c'$ å‰¯æ³•å‘é‡ï¼š$\\pmb b=\\pmb t\\times\\pmb n$ ä¸»æ³•å‘é‡ï¼š$\\pmb n=\\dfrac{\\pmb t'}{\\vert\\vert\\pmb t'\\vert\\vert}=\\dfrac{\\pmb c''}{\\vert\\vert\\pmb c''\\vert\\vert}$ æ›²ç‡ï¼š$\\kappa(t)=\\vert\\vert\\pmb t'\\vert\\vert=\\vert\\vert\\pmb c''\\vert\\vert$ æœ‰å‘æ›²ç‡ï¼š$\\kappa(s)=\\pmb t'=\\pmb c''$ æŒ ç‡ï¼š$\\tau(t)=-\\pmb b'\\cdot\\pmb n$    ç‰¹æ®Šæƒ…å†µï¼šå¹³é¢æ›²çº¿\n  å¯¹äºæ­£åˆ™å¹³é¢æ›²çº¿$\\pmb c(t)=(x(t),y(t))$ï¼Œå…¶æ›²ç‡å®šä¹‰ä¸º\n$$\n\\kappa(t)=\\dfrac{|x\u0026rsquo;y''-x'\u0026lsquo;y\u0026rsquo;|}{(x'^2+y'^2)^{\\frac{3}{2}}}\n$$\n  æœ‰å‘æ›²ç‡\n$$\n\\kappa(t)=\\dfrac{x\u0026rsquo;y''-x'\u0026lsquo;y\u0026rsquo;}{(x'^2+y'^2)^{\\frac{3}{2}}}\n$$\n    ","description":"æ›²çº¿å¾®åˆ†å‡ ä½•å­¦ä¹ ç¬”è®°","id":18,"section":"note","tags":["CAGD"],"title":"CAGD(3) |  æ›²çº¿å¾®åˆ†å‡ ä½•","uri":"https://chaphlagical.github.io/zh/note/cagd/cagd3/"},{"content":"Item 18ï¼šMake interfaces easy to use correctly and hard to use incorrectly  è€ƒè™‘ä¸€ä¸ªè¡¨ç°æ—¥æœŸçš„classè®¾è®¡æ„é€ å‡½æ•°ï¼š  1 2 3 4 5  class Date{ public: Date(int month, int day, int year); ... };   è¿™ä¸ªæ¥å£å¾ˆå®¹æ˜“å‘ç”Ÿè¯¯ç”¨ï¼š\n1 2  Date d(30, 3, 1995);\t// æ— æ•ˆæœˆä»½ Date d(2, 30, 1995);\t// æ— æ•ˆå¤©æ•°    ä¼˜åŒ–ä¸€ï¼šå¯¼å…¥å¤–è¦†ç±»å‹åŒºåˆ«å¤©æ•°ã€æœˆä»½å’Œå¹´ä»½  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  struct Day{ explicit Day(int d) : val(d) { } int val; }; struct Month{ explicit Month(int m) : val(m) { } int val; }; struct Year{ explicit Year(int y) : val(y) { } int val; }; class Date{ public: Date(const Month\u0026amp; m, const Day\u0026amp; d, const Year\u0026amp; y); ... }; Date d(30, 3, 1995);\t// é”™è¯¯ç±»å‹ Date d(Day(30), Month(3), Year(1995));\t// é”™è¯¯ç±»å‹ Date d(Month(3), Day(30), Year(1995));\t// æ­£ç¡®    ä¼˜åŒ–äºŒï¼šé™åˆ¶ç±»å‹å€¼  1 2 3 4 5 6 7 8 9 10 11 12  class Month{ public: static Month Jan() { return Month(1); } static Month Feb() { return Month(2); } ... static Month Dec() { return Month(12); } ... private: explicit Month(int m); ... }; Date d(Month::Mar(), Day(30), Year(1995));     ä¼˜åŒ–ä¸‰ï¼šé™åˆ¶ç±»å‹å†…ä»€ä¹ˆäº‹å¯ä»¥åšï¼Œä»€ä¹ˆäº‹ä¸èƒ½åš\n å¸¸è§çš„é™åˆ¶æ˜¯åŠ ä¸Šconst    ä¿ƒè¿›æ­£ç¡®ä½¿ç”¨çš„æ–¹æ³•åŒ…æ‹¬ï¼š\n æ¥å£ä¸€è‡´æ€§ï¼ˆå¦‚STLï¼‰ ä¸å†…ç½®ç±»å‹çš„è¡Œä¸ºå…¼å®¹    é˜²æ­¢è¯¯ç”¨çš„æ–¹æ³•åŒ…æ‹¬ï¼š\n å»ºç«‹æ–°ç±»å‹ é™åˆ¶ç±»å‹ä¸Šçš„æ“ä½œ æŸç¼šå¯¹è±¡å€¼ æ¶ˆé™¤å®¢æˆ·çš„èµ„æºç®¡ç†è´£ä»»ï¼ˆæ™ºèƒ½æŒ‡é’ˆï¼‰    Item 19ï¼šTreat class designs as type design å¸¸è§çš„è®¾è®¡è§„èŒƒï¼š\n æ–°typeçš„å¯¹è±¡åº”è¯¥å¦‚ä½•è¢«åˆ›å»ºå’Œé”€æ¯ï¼Ÿ  å½±å“åˆ°classçš„æ„é€ å‡½æ•°ã€ææ„å‡½æ•°ä»¥åŠå†…å­˜åˆ†é…å‡½æ•°å’Œé‡Šæ”¾å‡½æ•°   å¯¹è±¡çš„åˆå§‹åŒ–å’Œå¯¹è±¡çš„èµ‹å€¼è¯¥æœ‰ä»€ä¹ˆæ ·çš„å·®åˆ«ï¼Ÿ  å†³å®šæ„é€ å‡½æ•°å’Œèµ‹å€¼æ“ä½œç¬¦çš„è¡Œä¸ºåŠå…¶é—´çš„å·®åˆ«   æ–°typeçš„å¯¹è±¡å¦‚æœè¢«pass-by-valueæ„å‘³ç€ä»€ä¹ˆï¼Ÿ  copyæ„é€ å‡½æ•°ç”¨æ¥å®šä¹‰ä¸€ä¸ªtypeçš„pass-by-valueè¯¥å¦‚ä½•å®ç°   ä»€ä¹ˆæ˜¯æ–°typeçš„åˆæ³•å€¼  å¯¹classæˆå‘˜å˜é‡è€Œè¨€ï¼Œé€šå¸¸åªæœ‰æŸäº›æ•°å€¼é›†æ˜¯æœ‰æ•ˆçš„ é‚£äº›æ•°å€¼é›†å†³å®šäº†ä½ çš„classå¿…é¡»ç»´æŠ¤çš„çº¦æŸæ¡ä»¶ï¼Œä¹Ÿå†³å®šäº†ä½ çš„æˆå‘˜å‡½æ•°ï¼ˆå°¤å…¶æ˜¯æ„é€ å‡½æ•°ã€èµ‹å€¼æ“ä½œç¬¦å’Œsetterå‡½æ•°ï¼‰å¿…é¡»è¿›è¡Œçš„é”™è¯¯æ£€æŸ¥å·¥ä½œ ä¹Ÿå½±å“å‡½æ•°æŠ›å‡ºçš„å¼‚å¸¸ä»¥åŠå°‘æ•°å‡½æ•°å¼‚å¸¸æ˜ç»†åˆ—   ä½ çš„æ–°typeéœ€è¦é…åˆæŸä¸ªç»§æ‰¿å›¾ç³»å—ï¼Ÿ  å¦‚æœä½ ç»§æ‰¿è‡ªæŸäº›æ—¢æœ‰çš„classesï¼Œä½ å°±å—åˆ°é‚£äº›classesçš„è®¾è®¡æŸç¼šï¼Œå°¤å…¶æ˜¯å—åˆ°virtualå’Œnon-virtualå‡½æ•°çš„å½±å“ å¦‚æœä½ å…è®¸å…¶ä»–classesç»§æ‰¿ä½ çš„classesï¼Œå°†ä¼šå½±å“ä½ æ‰€å£°æ˜çš„å‡½æ•°ï¼Œå°¤å…¶æ˜¯ææ„å‡½æ•°æ˜¯å¦ä¸ºvirtual   ä»€ä¹ˆæ ·çš„æ“ä½œç¬¦å’Œå‡½æ•°å¯¹æ­¤æ–°typeè€Œè¨€æ˜¯åˆç†çš„ï¼Ÿ  å†³å®šä½ çš„classå£°æ˜å“ªäº›å‡½æ•°   ä»€ä¹ˆæ ·çš„æ ‡å‡†å‡½æ•°åº”è¯¥è¢«é©³å›  é‚£äº›æ­£æ˜¯ä½ å¿…é¡»å£°æ˜ä¸ºprivateçš„æ ‡å‡†å‡½æ•°   è°è¯¥å–ç”¨æ–°typeçš„æˆå‘˜ï¼Ÿ  å†³å®šå“ªäº›æˆå‘˜ä¸ºpublicï¼Œå“ªäº›ä¸ºprotectedï¼Œå“ªäº›ä¸ºprivate å†³å®šå“ªäº›classesæˆ–functionsä¸ºfriend   ä»€ä¹ˆæ˜¯æ–°typeçš„â€œæœªå£°æ˜æ¥å£â€ï¼Ÿ  å¯¹æ•ˆç‡ã€å¼‚å¸¸å®‰å…¨æ€§ä»¥åŠèµ„æºè¿ç”¨æä¾›ä¿è¯æ‰€éœ€çš„ç›¸åº”çš„çº¦æŸæ¡ä»¶   ä½ çš„æ–°typeæœ‰å¤šä¹ˆä¸€èˆ¬åŒ–ï¼Ÿ  è‹¥å®šä¹‰äº†ä¸€æ•´ä¸ªtypeså®¶æ—ï¼Œåˆ™åº”è€ƒè™‘ä½¿ç”¨template   ä½ çœŸçš„éœ€è¦ä¸€ä¸ªæ–°çš„typeå—ï¼Ÿ  åº”å°½å¯èƒ½è€ƒè™‘èƒ½å¦åœ¨æ—¢æœ‰classesåŸºç¡€ä¸Šæ–°å¢å‡½æ•°æˆ–æ¨¡æ¿    Item 20ï¼šPrefer pass-by-reference-to-const to pass-by-value   ç¼ºçœæƒ…å†µä¸‹C++ä»¥pass-by-valueæ–¹å¼ä¼ é€’å¯¹è±¡è‡³å‡½æ•°ã€‚å‡½æ•°å‚æ•°éƒ½æ˜¯ä»¥å®é™…å®å‚çš„å¤ä»¶ä¸ºåˆå€¼ï¼Œè€Œè°ƒç”¨ç«¯æ‰€è·å¾—çš„äº¦æ˜¯å‡½æ•°è¿”å›å€¼çš„ä¸€ä¸ªå¤ä»¶ï¼Œè¿™äº›å¤ä»¶ç”±å¯¹è±¡çš„copyæ„é€ å‡½æ•°äº§ç”Ÿï¼Œè¿™å¯èƒ½ä½¿å¾—pass-by-valueæˆä¸ºæ˜‚è´µçš„æ“ä½œ\nä¸¾ä¾‹ï¼šæœ‰ä¸¤ä¸ªç±»å®šä¹‰å¦‚ä¸‹\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Person{ public: Person(); virtual ~Person(); ... private: std::string name; std::string address; }; class Student: public Person{ public: Student(); ~Student(); ... private: std::string schoolName; std::string schoolAddress; };   è€ƒè™‘è°ƒç”¨\n1 2 3  bool validateStudent(Student s); Student plato; bool platoIsOK = validateStudent(plato);     ä»¥by valueæ–¹å¼ä¼ é€’ä¸€ä¸ªStudentå¯¹è±¡ä¼šå¯¼è‡´è°ƒç”¨ä¸€æ¬¡Student copyæ„é€ å‡½æ•°ã€ä¸€æ¬¡Person copyæ„é€ å‡½æ•°ã€å››æ¬¡string copyæ„é€ å‡½æ•°\n  å½“å‡½æ•°å†…å“ªä¸ªStudentå¤ä»¶è¢«é”€æ¯ï¼Œæ¯ä¸€ä¸ªæ„é€ å‡½æ•°è°ƒç”¨åŠ¨ä½œéƒ½éœ€è¦ä¸€ä¸ªå¯¹åº”çš„ææ„å‡½æ•°è°ƒç”¨åŠ¨ä½œ\n  ä»¥by valueæ–¹å¼ä¼ é€’çš„æ€»æˆæœ¬ä¸ºå…­æ¬¡æ„é€ å‡½æ•°å’Œå…­æ¬¡ææ„å‡½æ•°\n  pass by reference-to-const\n  1  bool validateStudent(const Student\u0026amp; s);     æ²¡æœ‰ä»»ä½•æ„é€ å‡½æ•°å’Œææ„å‡½æ•°è¢«è°ƒç”¨ï¼Œå› ä¸ºæ²¡æœ‰ä»»ä½•æ–°å¯¹è±¡è¢«åˆ›å»º\n  constçš„å¿…è¦æ€§ï¼šé˜²æ­¢å‡½æ•°å¯¹å¼•ç”¨è¿›è¡Œä¿®æ”¹\n  é¿å…å¯¹è±¡åˆ‡å‰²é—®é¢˜ï¼šå½“ä¸€ä¸ªderived classå¯¹è±¡ä»¥by valueæ–¹å¼ä¼ é€’å¹¶è¢«è§†ä¸ºä¸€ä¸ªbase classå¯¹è±¡ï¼Œbase classçš„copyæ„é€ å‡½æ•°å°†è¢«è°ƒç”¨ï¼Œè€Œé€ æˆderived classçš„ç‰¹åŒ–æ€§è´¨è¢«åˆ‡å‰²æ‰ï¼Œä»…ä»…ç•™ä¸‹ä¸€ä¸ªbase classå¯¹è±¡\n  ä¸é€‚åˆä½¿ç”¨pass by reference-to-constçš„åº”ç”¨åœºæ™¯æœ‰:\n å†…ç½®ç±»å‹ã€STLè¿­ä»£å™¨å’Œå‡½æ•°å¯¹è±¡ referenceså¾€å¾€ä»¥æŒ‡é’ˆå®ç°å‡ºæ¥ï¼Œå› æ­¤pass-by-referenceé€šå¸¸æ„å‘³çœŸæ­£ä¼ é€’çš„æŒ‡é’ˆ å¦‚æœå¯¹è±¡å±äºå†…ç½®ç±»å‹ï¼ˆæˆ–STLè¿­ä»£å™¨ã€å‡½æ•°å¯¹è±¡ï¼‰ï¼Œpass by valueå¾€å¾€æ¯”pass by referenceçš„æ•ˆç‡é«˜äº›    Item 21ï¼šPrefer pass-by-reference-to -const to pass-by-value  è€ƒè™‘ä»£ç æ®µ  1 2 3 4 5 6 7 8 9 10  class Rational { public: Rational(int numerator = 0, int denominator = 1); ... private: int n,d; friend const Rational\u0026amp; operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs); }   opertaor*çš„å®ç°ï¼Œéœ€è¦è¿”å›ä¸€ä¸ªreferenceæŒ‡å‘çš„Rationalå¯¹è±¡ï¼Œæ–¹æ³•ä»¥ä¸‹ï¼š\n åœ¨stackç©ºé—´ä¸Šåˆ›å»ºlocalå˜é‡  1 2 3 4 5  const Rational\u0026amp; operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { Rational result(lhs.n * rhs.n, lhs.d * rhs.d); return result; }    è¿”å›çš„æ˜¯localå˜é‡ï¼Œè€Œlocalå˜é‡å°†åœ¨å‡½æ•°ç»“æŸæ—¶è¢«é”€æ¯ï¼Œå°†å¸¦æ¥æ„å¤–é£é™©  åœ¨heapç©ºé—´ä¸Šåˆ›å»ºå¯¹è±¡ï¼Œå¹¶è¿”å›referenceæŒ‡å‘å®ƒ  1 2 3 4 5  const Rational\u0026amp; operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { Rational* result = new Rational(lhs.n * rhs.n, lhs.d * rhs.d); return *result; }    newä¹‹åçš„å¯¹è±¡æ²¡èƒ½è¿›è¡Œdeleteï¼Œå°†å¸¦æ¥å†…å­˜æ³„æ¼  è¿”å›referenceæŒ‡å‘ä¸€ä¸ªè¢«å®šä¹‰äºå‡½æ•°å†…éƒ¨çš„static Rationalå¯¹è±¡  const Rational\u0026amp; operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs)\r{\rstatic Rational result;\rresult = ...;\rreturn *result;\r}\r  å¤šçº¿ç¨‹å®‰å…¨\n  å…¶ä»–é”™è¯¯ï¼š\n  1 2 3 4 5 6 7 8 9 10 11  bool operator==(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs); Rational a, b, c, d; ... if((a * b) == (c * d)) { ... } else { ... }     è¿™é‡Œç”±äºoperator*è¿”å›static Rationalçš„referenceï¼Œå› æ­¤å‡½æ•°æ€»æ˜¯çœ‹åˆ°å®ƒä»¬çš„ç°å€¼ï¼Œæ•…operator==åˆ¤æ–­æ€»æ˜¯ä¸ºtrue\n  æ­£ç¡®çš„å†™æ³•åº”è¯¥æ˜¯ï¼š\n  1 2 3 4  inline const Rational lhs, const Rational\u0026amp; rhs) { return Rational(lhs.n * rhs.n, lhs.d * rhs.d); }   è€Œä¸åº”è¿”å›reference\nItem 22ï¼šDeclare data members private   è¯­æ³•ä¸€è‡´æ€§\n å¦‚æœæˆå‘˜å˜é‡ä¸æ˜¯publicï¼Œå®¢æˆ·å”¯ä¸€èƒ½å¤Ÿè®¿é—®å¯¹è±¡çš„åŠæ³•å°±æ˜¯é€šè¿‡æˆå‘˜å‡½æ•°    å¯¹æˆå‘˜å˜é‡çš„å¤„ç†æœ‰æ›´åŠ ç²¾ç¡®çš„æ§åˆ¶ï¼Œä¾‹å¦‚ï¼š\n  1 2 3 4 5 6 7 8 9 10 11 12 13  class AccessLevels{ public: ... int getReadOnly() const { return readOnly; } void SetReadWrite(int value) { readWrite = value; } int getReadWrite() const { return readWrite; } void setWriteOnly(int value) { writeOnly = value; } private: int noAccess;\t// ä¸æ“ä½œ  int readOnly;\t// åªè¯»  int readWrite;\t// è¯»å†™  int writeOnly;\t// åªå†™ };    å°è£…  å¯¹å®¢æˆ·éšè—æˆå‘˜å˜é‡ï¼ˆå°è£…ï¼‰ï¼Œå¯ä»¥ç¡®ä¿classçš„çº¦æŸæ¡ä»¶æ€»æ˜¯ä¼šè·å¾—ç»´æŠ¤ï¼Œå› ä¸ºåªæœ‰æˆå‘˜å‡½æ•°å¯ä»¥å½±å“å®ƒä»¬ publicæ„å‘³ç€ä¸å°è£… protectedæˆå‘˜å˜é‡åŒæ ·ç¼ºä¹å°è£…æ€§ ä»å°è£…è§’åº¦çœ‹ï¼Œåªæœ‰ä¸¤ç§è®¿é—®æƒé™ï¼šprivateå’Œå…¶ä»–    Item 23ï¼šPrefer non-member non-friend functions to member functions  ä»£ç æ®µç¤ºä¾‹ï¼š  1 2 3 4 5 6 7 8 9  class WebBrowser { public: ... void clearCache(); void clearHistory(); void removeCookies(); ... };   ç°åœ¨éœ€è¦å®ç°WebBrowserçš„æ¸…é™¤åŠŸèƒ½ï¼Œå¯ä»¥æœ‰ä¸¤ç§æ–¹æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class WebBrowser { public: ... void ClearEverything();\t// æ¸…é™¤å‡½æ•°ä½œä¸ºç±»æˆå‘˜å‡½æ•°  ... }; void clearBrower(WebBrower\u0026amp; wb) { wb.clearCache(); wb.clearHistory(); wb.removeCookies(); }     äº‹å®ä¸Šï¼Œmemberå‡½æ•°ClearEverythingçš„å°è£…æ€§æ¯”non-memberå‡½æ•°clearBrowerä½\n  æä¾›non-memberå‡½æ•°å¯å…è®¸å¯¹WebBrowerç›¸å…³æœºèƒ½æœ‰è¾ƒå¤§çš„åŒ…è£¹å¼¹æ€§ï¼Œè€Œé‚£æœ€ç»ˆå¯¼è‡´è¾ƒä½çš„ç¼–è¯‘ä¾èµ–åº¦ï¼Œå¢åŠ WebBrowerçš„å¯å»¶ä¼¸æ€§\n  è¾ƒå¤§å°è£…æ€§çš„æ˜¯non-member non-friendå‡½æ•°ï¼Œå› ä¸ºå®ƒå¹¶ä¸å¢åŠ â€œèƒ½å¤Ÿè®¿é—®classå†…çš„privateæˆåˆ†â€çš„å‡½æ•°æ•°é‡\n  classå®šä¹‰å¼å¯¹å®¢æˆ·è€Œè¨€æ˜¯ä¸èƒ½æ‰©å±•çš„ã€‚å®¢æˆ·æ´¾ç”Ÿçš„æ–°çš„classesæ— æ³•è®¿é—®base classesä¸­è¢«å°è£…çš„æˆå‘˜\n  Item 24ï¼šDeclare non-member functions when type conversions should apply to all parameters  å¯¹æœ‰ç†æ•°ç±»ï¼š  1 2 3 4 5 6 7 8 9  class Rational { public: Rational(int numerator = 0, int denominator = 1); // å…è®¸int-to-Rationaléšå¼è½¬æ¢  int numerator() const; int denominator() const; private: ... };    å€˜è‹¥åœ¨ç±»å†…å®ç°operator*è¿ç®—ç¬¦çš„é‡è½½ï¼Œå³  1 2 3 4 5 6  class Rational { public: ... const Rational operator*(const Rational\u0026amp; rhs) const; };   æ­¤æ—¶\n1 2 3 4 5 6  Rational oneEnglish(1, 8); Rational oneHalf(1, 2); Rational result = oneHalf * oneEnglish;\t// very good! result = result * oneEnglish;\t// very good! result = oneHalf * 2;\t// very good! result = 2 * oneHalf;\t// wrong!   è¦å®ç°æœ€åä¸€å¥çš„æ•ˆæœï¼Œå¿…é¡»é€šè¿‡ï¼š\n1 2  const Rational temp(2); result = oneHalf * temp;   è€Œå¯¹äºexplicitæ„é€ å‡½æ•°çš„Rationalç±»ï¼Œåˆ™ä¸‹é¢ä¸¤å¥å‡ä¸èƒ½é€šè¿‡ç¼–è¯‘ï¼š\n1 2  result = oneHalf * 2; result = 2 * oneHalf;    è¦ä½¿å¾—ä¸¤å¥å‡å¯é€šè¿‡ç¼–è¯‘ï¼Œåº”ä½¿ç”¨non-memberå‡½æ•°ï¼Œå…è®¸ç¼–è¯‘å™¨åœ¨æ¯ä¸€ä¸ªå®å‚ä¸Šæ‰§è¡Œéšå¼ç±»å‹è½¬æ¢  1 2 3 4 5 6 7 8 9 10 11 12  class Rational{ ... }; const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { return Rational(lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator()); } Rational oneFourth(1, 4); Rational result; result = oneFourth * 2;\t// result = 2 * oneFourth;\t// å‡å¯æ­£ç¡®ç¼–è¯‘è¿è¡Œ   Item 25ï¼šConsider support for a non-throwing swap  æ ‡å‡†åº“å®ç°æ³•  1 2 3 4 5 6 7 8 9  namespace std{ template\u0026lt;typename T\u0026gt; void swap(T\u0026amp; a, T\u0026amp; b) { T temp(a); a = b; b = temp; } }    pimplæ‰‹æ³•ï¼ˆpointer to implementationï¼‰  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class WidgetImpl{ public: ... private: int a, b, c; std::vector\u0026lt;double\u0026gt; v; ... }; class Widget{ public: Widget(const Widget\u0026amp; rhs); Widget\u0026amp; operator=(const Widget\u0026amp; rhs) { ... *pImpl = *(rhs.pImpl);\t// è¯¦è§Item 10, 11, 12  ... } ... private: WidgetImpl* pImpl; };     å¤åˆ¶ä¸‰ä¸ªWidgetsï¼Œå¤åˆ¶ä¸‰ä¸ªWidgetImplå¯¹è±¡ï¼Œéå¸¸ç¼ºä¹æ•ˆç‡\n  æ¨¡æ¿åç‰¹åŒ–\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Widget{ public: ... void swap(Widget\u0026amp; other) { using std::swap; swap(pImpl, other.pImpl); } ... }; namespace std{ template\u0026lt;\u0026gt; void swap\u0026lt;Widget\u0026gt;(Widget\u0026amp; a, Widget\u0026amp; b) { a.swap(b); } }    åŠ å…¥ç±»æ¨¡æ¿  1 2 3 4 5 6 7 8 9 10 11 12  namespace WidgetStuff{ ... ... template\u0026lt;typename T\u0026gt; class WidgetImpl{...}; template\u0026lt;typename T\u0026gt; class Widget{...}; ... ... template\u0026lt;typename T\u0026gt; void swap(Widget\u0026lt;T\u0026gt;\u0026amp; a, Widget\u0026lt;T\u0026gt;\u0026amp; b){ a.swap(b); } }    æ€»ç»“  å½“std::swapå¯¹ä½ çš„ç±»å‹æ•ˆç‡ä¸é«˜æ—¶ï¼Œæä¾›ä¸€ä¸ªswapæˆå‘˜å‡½æ•°ï¼Œå¹¶ç¡®å®šè¿™ä¸ªå‡½æ•°ä¸æŠ›å‡ºå¼‚å¸¸ å¦‚æœæä¾›ä¸€ä¸ªmember swapï¼Œä¹Ÿè¯¥æä¾›ä¸€ä¸ªnon-member swapæ¥è°ƒç”¨å‰è€…ã€‚å¯¹äºclassä¹Ÿè¯·ç‰¹åŒ–std::swap è°ƒç”¨swapæ—¶åº”é’ˆå¯¹std::swapä½¿ç”¨usingå£°æ˜å¼ï¼Œç„¶åè°ƒç”¨swapä¸”ä¸å¸¦ä»»ä½•â€œå‘½åç©ºé—´èµ„æ ¼ä¿®é¥°â€ ä¸ºâ€œç”¨æˆ·å®šä¹‰ç±»å‹â€è¿›è¡Œstd templateå…¨ç‰¹åŒ–æ˜¯å¥½çš„ï¼Œä½†ä¸è¦åœ¨stdåç§°ç©ºé—´ä¸­åŠ å…¥æ–°ä¸œè¥¿    ","description":"ã€ŠEffective C++å­¦ä¹ ç¬”è®°ç¬¬å››ç« ã€‹","id":19,"section":"note","tags":["Effective C++","C++"],"title":"Chapter 4: Designs and Declarations","uri":"https://chaphlagical.github.io/zh/note/effectivecpp/ch4/"},{"content":"1. æ›²çº¿çš„è¡¨ç¤º 1.1. éšå¼è¡¨ç¤º æ›²çº¿éšå¼è¡¨ç¤ºä¸º$f(x,y)=0$ï¼Œè¯¥æ–¹æ³•æœ‰è¯¸å¤šå±€é™æ€§ï¼š\n å¯¹äºåŒä¸€ä¸ª$x$æ¨ªåæ ‡å€¼å¯¹åº”å¤šä¸ªçºµåæ ‡å€¼ å­˜åœ¨ä¸€äº›ä½ç½®ï¼Œå¯¼æ•°$\\dfrac{\\mathrm dy}{\\mathrm dx}$æ²¡æœ‰å®šä¹‰ å…³äºè½´å˜æ¢éä¸å˜  1.2. å‚æ•°è¡¨ç¤º æ›²çº¿å‚æ•°è¡¨ç¤ºä¸º$c(t)=(x(t),y(t))$\n æ±‚å€¼æ–¹ä¾¿ å‚æ•°$t$å¯ä½œä¸ºæ—¶é—´è¿›è¡Œæ’å€¼ æ›²çº¿å¯ä»¥ç†è§£ä¸ºè¿åŠ¨ç²’å­çš„è¿åŠ¨è½¨è¿¹è·Ÿè¸ª  2. æ›²çº¿å»ºæ¨¡ä¸¾ä¾‹ 2.1. ç”¨å¹‚å‡½æ•°åŸºè¿›è¡Œå»ºæ¨¡ ä»¥æŠ›ç‰©çº¿$\\pmb f(t)=\\pmb at^2+\\pmb bt+\\pmb c$ä¸ºä¾‹\n å¹‚å‡½æ•°åŸºçš„ç³»æ•°ç¼ºå°‘ç›´è§‰ä¸Šçš„å‡ ä½•æ„ä¹‰  2.2. ä¸€ç§æ”¹è¿›çš„ç”»æ³• å…¶ä¸­ï¼Œ\n $\\pmb b_0^1=(1-t)\\pmb b_0+t\\pmb b_1$ $\\pmb b_1^1=(1-t)\\pmb b_1+t\\pmb b_2$  $$\n\\begin{align}\n\\pmb b_0^2\n\u0026amp;=(1-t)\\pmb b_0^1+t\\pmb b_1^1\\\\\n\u0026amp;=(1-t)[(1-t)\\pmb b_0+t\\pmb b_1]+t[(1-t)\\pmb b_1+t\\pmb b_2]\\\\\n\u0026amp;=(1-t)^2\\pmb b_0+2t(1-t)\\pmb b_1+t^2\\pmb b_2\n\\end{align}\n$$\nä»¥ä¹‹å‰çš„ä¾‹å­\n$$\n\\pmb f(t)=\\begin{pmatrix}1\\\\1\\end{pmatrix}t^2+\\begin{pmatrix}-2\\\\0\\end{pmatrix}t+\\begin{pmatrix}1\\\\0\\end{pmatrix}\n$$\nè½¬ä¸ºä¸Šè¿°å½¢å¼ï¼š\n$$\n\\pmb f(t)=\\begin{pmatrix}1\\\\0\\end{pmatrix}(1-t)^2+\\begin{pmatrix}0\\\\0\\end{pmatrix}2t(1-t)+\\begin{pmatrix}0\\\\1\\end{pmatrix}t^2\n$$\nåœ¨å›¾ä¸Šè¡¨ç¤ºä¸º\n å„ç³»æ•°å‡æœ‰ç›¸åº”çš„å‡ ä½•æ„ä¹‰ æ›´å¤šç›´è§‰ä¸Šçš„æ›²çº¿æ“ä½œ  å¯¹äºå››ä¸ªæ§åˆ¶ç‚¹ï¼ŒåŒæ ·æœ‰ï¼š\n$$\n\\begin{matrix}\n\\pmb p_0^0(t)=\\pmb p_0,\u0026amp;\\pmb p_1^0(t)=\\pmb p_1,\u0026amp;\\pmb p_2^0(t)=\\pmb p_2,\u0026amp;\\pmb p_3^0(t)=\\pmb p_3\n\\end{matrix}\n$$\nç¬¬ä¸€æ¬¡è¿­ä»£ï¼š\n$$\n\\begin{align}\n\\pmb p_0^1\u0026amp;=(1-t)\\pmb p_0+t\\pmb p_1\\\\\n\\pmb p_1^1\u0026amp;=(1-t)\\pmb p_1+t\\pmb p_2\\\\\n\\pmb p_2^1\u0026amp;=(1-t)\\pmb p_2+t\\pmb p_3\n\\end{align}\n$$\nç¬¬äºŒæ¬¡è¿­ä»£ï¼š\n$$\n\\begin{align}\n\\pmb p_0^2=(1-t)^2\\pmb p_0+2t(1-t)\\pmb p_1+t^2\\pmb p_2\\\\\n\\pmb p_1^2=(1-t)^2\\pmb p_1+2t(1-t)\\pmb p_2+t^2\\pmb p_3\\\n\\end{align}\n$$\næœ€ç»ˆå¾—åˆ°çš„æ›²çº¿æ–¹ç¨‹ï¼š\n$$\n\\pmb c(t)=(1-t)^3\\pmb p_0+3t(1-t)^2\\pmb p_1+3t^2(1-t)\\pmb p_2+t^3\\pmb p_3\n$$\n3. De Casteljauç®—æ³• 3.1. åŠ¨æœº  å¯¹ç»™å®š$t$è®¡ç®—$\\pmb x(t)$  æŒ‰æ¯”ä¾‹$t:(1-t)$å¹³åˆ†æ§åˆ¶å¤šè¾¹å½¢ ç”¨çº¿è¿æ¥æ–°ç‚¹ï¼ˆç›¸é‚»çº¿æ®µï¼‰ ç”¨ç›¸åŒæ¯”ä¾‹è¿›è¡Œæ’å€¼ è¿­ä»£ï¼Œç›´åˆ°åªå‰©ä¸‹ä¸€ä¸ªç‚¹    3.2. ç®—æ³•æè¿°   è¾“å…¥ç‚¹ï¼š$\\pmb b_0,\\pmb b_1,\\cdots,\\pmb b_n\\in\\mathbb R^3$\n  è¾“å‡ºæ›²çº¿ï¼š$\\pmb x(t),t\\in [0,1]$\n  å¯¹ç»™å®š$t$è¿›è¡Œç‚¹$\\pmb x(t)$çš„å‡ ä½•æ„é€ \n$$\n\\begin{align}\n\\pmb b_i^0(t)\u0026amp;=\\pmb b_i,\\ \\ \\ \\ i=0,\\cdots,n\\\\\n\\pmb b_i^r(t)\u0026amp;=(1-t)\\pmb b_i^{r-1}(t)+t\\pmb b_{i+1}^{r-1}(t)\\\\\nr=\u0026amp;1,\\cdots,n\\ \\ \\ \\ i=0,\\cdots,n-r\n\\end{align}\n$$\n  æœ€åï¼Œ$\\pmb b_0^n(t)$ä¸ºæ‰€æ‰¾çš„æ›²çº¿ç‚¹$\\pmb x(t)$åœ¨å‚æ•°å€¼$t$çš„å–å€¼\n  æ‰€æœ‰ç³»æ•°å¯å†™ä¸ºä¸‹ä¸‰è§’çŸ©é˜µï¼š\n$$\n\\begin{matrix}\n\\pmb b_0=\\pmb b_0^0\\\\\n\\pmb b_1=\\pmb b_1^0\u0026amp;\\pmb b_0^1\\\\\n\\pmb b_2=\\pmb b_2^0\u0026amp;\\pmb b_1^1\u0026amp;\\pmb b_0^2\\\\\n\\pmb b_3=\\pmb b_3^0\u0026amp;\\pmb b_2^1\u0026amp;\\pmb b_1^2\u0026amp;\\pmb b_0^3\\\\\n\\vdots\u0026amp;\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\ddots\\\\\n\\pmb b_{n-1}=\\pmb b_{n-1}^0\u0026amp;\\pmb b_{n-2}^1\u0026amp;\\cdots\u0026amp;\\cdots\u0026amp;\\cdots\u0026amp;\\pmb b_0^{n-1}\\\\\n\\pmb b_n=\\pmb b_n^0\u0026amp;\\pmb b_{n-1}^1\u0026amp;\\cdots\u0026amp;\\cdots\u0026amp;\\cdots\u0026amp;\\pmb b_1^{n-1}\u0026amp;\\pmb b_0^n=\\pmb x(t)\n\\end{matrix}\n$$\nä¼ªä»£ç ï¼š\n3.3. De Casteljauç®—æ³•æ€§è´¨   åŒ…å«ç‚¹$\\pmb b_0,\\cdots,\\pmb b_n$çš„å¤šè¾¹å½¢ç§°ä¸ºBezierå¤šè¾¹å½¢\n  ç‚¹$\\pmb b_i$ç§°ä¸ºBezierç‚¹ï¼ˆæ§åˆ¶ç‚¹ï¼‰\n  ç”±Bezierç‚¹$\\pmb b_0,\\cdots,\\pmb b_n$å’ŒDe Casteljauç®—æ³•æ‰€å®šä¹‰çš„æ›²çº¿ç§°ä¸ºBezieræ›²çº¿\n  De Casteljauç®—æ³•æ˜¯æ•°å€¼ç¨³å®šçš„ï¼Œå› ä¸ºåªä½¿ç”¨äº†å‡¸ç»„åˆ\n  De Casteljauç®—æ³•å¤æ‚åº¦\n æ—¶é—´å¤æ‚åº¦$O(n^2)$ ç©ºé—´å¤æ‚åº¦$O(n)$ å…¶ä¸­$n$ä¸ºBezierç‚¹çš„æ•°é‡    Bezieræ›²çº¿çš„æ€§è´¨\n  ç»™å®šBezierç‚¹$\\pmb b_0,\\cdots,\\pmb b_n$å’ŒBezieræ›²çº¿$\\pmb x(t)$\n  Bezieræ›²çº¿æ˜¯$n$é˜¶å¤šé¡¹å¼æ›²çº¿\n  ç«¯ç‚¹$\\pmb x(0)=\\pmb b_0,\\pmb x(1)=\\pmb b_n$æ’å€¼ï¼Œå…¶ä½™çš„Bezierç‚¹ä»…ä»…æ˜¯å¤§è‡´çš„è¿‘ä¼¼å€¼\n  å‡¸åŒ…æ€§è´¨ï¼š\n Bezieræ›²çº¿å®Œå…¨åœ¨å…¶Bezierå¤šè¾¹å½¢çš„å‡¸åŒ…å†…éƒ¨    å˜åŒ–å‡å°‘\n æ²¡æœ‰ç›´çº¿ä¸Bezieræ›²çº¿çš„äº¤ç‚¹æ¯”Bezierå¤šè¾¹å½¢å¤š    Bezierç‚¹çš„å½±å“ï¼šå…¨å±€ä½†ä¼ªå±€éƒ¨\n å…¨å±€ï¼šç§»åŠ¨Bezierç‚¹ä¼šæ”¹å˜æ•´ä¸ªæ›²çº¿çš„å½¢çŠ¶ ä¼ªå±€éƒ¨ï¼šç‚¹$\\pmb b_i$å¯¹$x(t)$åœ¨$t=\\dfrac{i}{n}$æœ‰æœ€å¤§çš„å½±å“    ä»¿å°„ä¸å˜æ€§\n Bezieræ›²çº¿å’ŒBezierå¤šè¾¹å½¢åœ¨ä»¿å°„å˜æ¢ä¸‹ä¸å˜    ä»¿å°„å‚æ•°å˜æ¢ä¸å˜æ€§\n  å¯¹ç§°æ€§\n ä»¥ä¸‹ä¸¤æ¡Bezieræ›²çº¿é‡åˆï¼Œå®ƒä»¬ä»…åœ¨ç›¸åçš„æ–¹å‘ä¸Šç§»åŠ¨ï¼š  $$\n\\begin{matrix}\n\\pmb x(t)=[\\pmb b_0,\\cdots,\\pmb b_n]\u0026amp;\n\\pmb x'(t)=[\\pmb b_n,\\cdots,\\pmb b_0]\n\\end{matrix}\n$$\n  çº¿æ€§ç²¾ç¡®\n å½“$\\pmb b_0,\\cdots,\\pmb b_n$å…±çº¿æ—¶ï¼ŒBezieræ›²çº¿ä¸ºçº¿æ®µ    é‡å¿ƒç»„åˆä¸‹çš„ä¸å˜æ€§\n    4. Bezieræ›²çº¿ Bezieræ›²çº¿è¡¨ç¤ºä¸ºåŸºå‡½æ•°ç»„åˆï¼š\n$$\n\\pmb x(t)=\\sum\\limits_{i=0}^n\\pmb B_i^n(t)\\cdot b_i\n$$\n4.1. æœŸæœ›ç‰¹æ€§  å¯¹åŸºåº•çš„è¦æ±‚ï¼š  è‰¯å¥½æ€§è´¨çš„æ›²çº¿  å…‰æ»‘çš„åŸºå‡½æ•°   å±€éƒ¨æ§åˆ¶ï¼ˆæˆ–è€…è‡³å°‘åŠå±€éƒ¨ï¼‰  ç´§è‡´çš„åŸºå‡½æ•°   ä»¿å°„ä¸å˜æ€§  å¯¹æ§åˆ¶ç‚¹æˆ–æ›²çº¿è¿›è¡Œä»¿å°„å˜æ¢$\\pmb x=A\\pmb x+b$åº”è¯¥æœ‰ç›¸åŒçš„æ•ˆæœ ä¾‹å¦‚ï¼šæ—‹è½¬ã€å¹³ç§» å¦åˆ™äº¤äº’å¼ç¼–è¾‘æ›²çº¿å°†éå¸¸å›°éš¾   å‡¸åŒ…æ€§è´¨  æ›²çº¿å¤„äºå…¶æ§åˆ¶ç‚¹çš„å‡¸åŒ…å†… è‡³å°‘èƒ½å¤Ÿé¿å…å¥‡æ€ªçš„éœ‡è¡   ä¼˜ç‚¹  è®¡ç®—ä¼˜åŠ¿ï¼ˆé€’å½’ç›¸äº¤æµ‹è¯•ï¼‰ æ›´å¤šå¯é¢„æµ‹çš„è¡Œä¸º      4.2. ä»¿å°„ä¸å˜æ€§  ä»¿å°„å˜æ¢ï¼š$\\pmb x\\rightarrow A\\pmb x+\\pmb b$  4.2.1. çº¿æ€§ä¸å˜æ€§ Bezieræ›²çº¿çš„çº¿æ€§ä¸å˜æ€§æ˜¯æ˜¾ç„¶çš„ï¼ŒBezieræ›²çº¿è¡¨ç¤ºä¸ºåŸºå‡½æ•°çš„çº¿æ€§ç»„åˆï¼š\n$$\n\\pmb f(t)=\\sum\\limits_{i=1}^nb_i(t)\\pmb p_i=\\sum\\limits_{i=1}^nb_i(t)\\begin{pmatrix}\np_i^{(x)}\\\\p_i^{(y)}\\\\p_i^{(z)}\n\\end{pmatrix}\n$$\nå› æ­¤\n$$\nA(\\pmb f(t))=A\\Big(\\sum\\limits_{i=1}^nb_i(t)\\pmb p_i \\Big)=\\sum\\limits_{i=1}^nb_i(t)(A\\pmb p_i)\n$$\n4.2.2. å¹³ç§»ä¸å˜æ€§ $$\n\\sum\\limits_{i=1}^nb_i(t)(\\pmb p_i+\\pmb b)=\\sum\\limits_{i=1}^nb_i(t)\\pmb p_i+\\sum\\limits_{i=1}^nb_i(t)\\pmb b=\\pmb f(t)+\\Big(\\sum\\limits_{i=1}^nb_i(t)\\Big)\\pmb b\n$$\n ä¸ºäº†æ»¡è¶³å¹³ç§»ä¸å˜æ€§ï¼ŒåŸºå‡½æ•°çš„å’Œåº”æ’ä¸º1 è¿™ä¹Ÿç§°ä¸º\u0026quot;partition of unity property\u0026quot;ï¼Œå•ä½åˆ’åˆ†æ€§è´¨ $\\pmb b_i$æ˜¯æ§åˆ¶ç‚¹$\\pmb p_i$çš„â€œä»¿å°„ç»„åˆâ€ è¯¥æ€§è´¨å¯¹å»ºæ¨¡éå¸¸é‡è¦  4.3. å‡¸åŒ…æ€§è´¨   å‡¸ç»„åˆ\n  ç‚¹é›†${\\pmb p_1,\\cdots,\\pmb p_n}$çš„ä¸€ä¸ªå‡¸ç»„åˆä¸ºå¦‚ä¸‹å½¢å¼\n$$\n\\sum\\limits_{i=1}^n\\lambda_i\\pmb p_i\\ \\mathrm{with}\\sum\\limits_{i=1}^n\\lambda_i=1\\ \\mathrm{and}\\ \\forall i=1,\\cdots,n:0\\leq\\lambda_i\\leq 1\n$$\n  æ‰€æœ‰å…è®¸çš„å‡¸ç»„åˆçš„é›†åˆå½¢æˆç‚¹é›†çš„å‡¸åŒ…\n å‡¸åŒ…æ˜¯åŒ…å«æ‰€æœ‰ç‚¹é›†${\\pmb p_1,\\cdots,\\pmb p_n}$ä»¥åŠé›†åˆä¸­ä¸¤ä¸ªå…ƒç´ ä¹‹é—´çš„æ¯æ¡å®Œæ•´è¿çº¿çš„æœ€å°é›†åˆ      ç›¸åº”åœ°\n  å¦‚æœæˆ‘ä»¬æœ‰æ€§è´¨ï¼š\n$$\n\\forall t\\in\\Omega:\\sum\\limits_{i=1}^nb_i(t)=1\\ \\mathbb {and}\\ \\forall t\\in\\Omega,\\forall i:b_i(t)\\geq 0\n$$\næ‰€æ„é€ åœ°æ›²çº¿/æ›²é¢å°†æ»¡è¶³ï¼š\n ä»¿å°„ä¸å˜æ€§ï¼ˆå¹³ç§»ï¼Œçº¿æ€§æ˜ å°„ï¼‰ é™åˆ¶åœ¨æ§åˆ¶ç‚¹çš„å‡¸åŒ…ä¸­    æ¨è®ºï¼šæ›²çº¿å°†æœ‰linear precisionï¼ˆçº¿æ€§ç²¾ç¡®ï¼‰\n å½“æ‰€æœ‰æ§åˆ¶ç‚¹å…±çº¿æ—¶ï¼Œæ›²çº¿ä¸ºç›´çº¿æ®µ å…·æœ‰å¹³é¢æ§åˆ¶ç‚¹çš„æ›²é¢ä¹Ÿå°†æ˜¯å¹³é¢      å‡¸åŒ…æ€§è´¨åœ¨å®è·µä¸­ååˆ†æœ‰ç”¨\n é¿å…ä¸è‰¯éœ‡è¡  è¢«é™åˆ¶åœ¨å‡¸åŒ…å†…ï¼Œä¸åƒå¤šé¡¹å¼æ’å€¼   çº¿æ€§ç²¾ç¡®æ€§è´¨æ¯”è¾ƒç›´è§‚ï¼ˆç”¨æˆ·å‹å¥½ï¼‰ å¯ç”¨äºå¿«é€ŸèŒƒå›´æ£€æŸ¥  ç›¸äº¤æµ‹è¯•å¯ä»¥å…ˆå¯¹å‡¸åŒ…è¿›è¡Œï¼Œç„¶åå†å¯¹ç‰©ä½“è¿›è¡Œ é€’å½’ç›¸äº¤ç®—æ³•ä¸ç»†åˆ†è§„åˆ™ç»“åˆä½¿ç”¨      4.4. Bezieræ›²çº¿çš„å¤šé¡¹å¼æè¿°   ç»™å®š$(n+1)$ä¸ªæ§åˆ¶ç‚¹$\\pmb b_0,\\cdots,\\pmb b_n$\n  ç›®æ ‡ï¼šBezieræ›²çº¿$\\pmb x(t)$ï¼Œå…¶ä¸­$t\\in[0,1]$\n  å®šä¹‰$n+1$ä¸ªåŸºå‡½æ•°ï¼Œé€šè¿‡å…¶çº¿æ€§ç»„åˆæ¥æè¿°ä¸€ä¸ªBezieræ›²çº¿\n$$\nB_0^n(t),\\cdots,B_n^n(t)\\ \\mathbb{over}\\ [0,1]\n$$\n$$\n\\pmb x(t)=\\sum\\limits_{i=0}^nB_i^n(t)\\cdot\\pmb b_i\n$$\n  4.4.1. BernsteinåŸºå‡½æ•° BernsteinåŸºå‡½æ•°ï¼š$B={B_0^{(n)},B_1^{(n)},\\cdots,B_n^{(n)} }$\n  $n$æ¬¡BernsteinåŸºå‡½æ•°\n$$\nB_i^{(n)}(t)=\\begin{pmatrix}n\\\\ i\\end{pmatrix}\nt^i(1-t)^{n-i}\n$$\nå…¶ä¸­ï¼ŒäºŒé¡¹å¼ç³»æ•°\n$$\n\\begin{pmatrix}n\\\\i\\end{pmatrix}=\n\\begin{cases}\n\\dfrac{n!}{(n-i)!!}\u0026amp;\\mathrm {for}\\ 0\\leq i\\leq n\\\\\n0\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n$$\næ¨æ°ä¸‰è§’ï¼š\nå‰ä¸‰ç»„BernsteinåŸºå‡½æ•°\n  4.4.2. BernsteinåŸºå‡½æ•°çš„æ€§è´¨ $$\nB={B_0^{(n)},B_1^{(n)},\\cdots,B_n^{(n)}},\\ \\ \\\nB_i^{(n)}=\\begin{pmatrix}n\\\\i\\end{pmatrix}t^i(1-t)^{n-i}\n$$\nå…‰æ»‘æ€§\nåŸºå‡½æ•°ä¸º$n$æ¬¡å¤šé¡¹å¼â€”â€”æ˜¾ç„¶å…‰æ»‘\nå±€éƒ¨æ§åˆ¶\næ¯ä¸ªåŸºå‡½æ•°$B_i^{(n)}$åœ¨$t=\\dfrac{i}{n}$å¤„å–æœ€å¤§å€¼â€”â€”å¯¹è¯¥å¤„æœ‰æœ€å¤§å½±å“\nå‡¸åŒ…æ€§è´¨å’Œä»¿å°„ä¸å˜æ€§\nç»„åˆæ•°çš„æ€§è´¨ï¼š\n$$\n\\sum\\limits_{i=0}^nB_i^{(n)}(t)=(t+(1-t))^n=1\n$$\né€’å½’è®¡ç®—ç‰¹æ€§\n$$\n\\begin{align}\nB_i^n(t):=(1-t)B_i^{(n-1)}(t)+tB_{i-1}^{(n-1)}(1-t)\\\\ \\mathrm{with}\\ B_0^0(t)=1,B_i^n(t)=0\\ \\ \\mathrm {for}\\ i\\not\\in{0,\\cdots,n}\n\\end{align}\n$$\nå¯¹ç§°æ€§\n$$\nB_i^n(t)=B_{n-i}^n(1-t)\n$$\néè´Ÿæ€§\n$$\nB_i^{(n)}(t)\\geq 0\\ \\mathrm{for}\\ t\\in[0,\\cdots,1]\n$$\n$$\nB_i^{(n)}(t)\u0026gt;0\\ \\mathrm{for}\\ 0\u0026lt;t\u0026lt;1\n$$\n$$\n\\begin{align}\nB_0^{(n)}(0)=1,\\ \\ \\ \\ B_1^{(n)}(0)=\\cdots=B_n^{(n)}(0)=0\\\\\nB_0^{(n)}(1)=\\cdots=B_{n-1}^{(n)}=0,\\ \\ \\ \\ B_n^{(n)}(1)=1\n\\end{align}\n$$\nå¯¼æ•°\n$$\n\\begin{align}\n\\dfrac{\\mathrm d}{\\mathrm dt}B_i^{(n)}(t)\u0026amp;=\\begin{pmatrix}n\\\\ i\\end{pmatrix}(it^{i-1}(1-t)^{n-i}-(n-i)t^i(1-t)^{n-i-1})\\\\\\ \u0026amp;=\\dfrac{n!}{(n-i)!i!}it^{i-1}(1-t)^{n-i}-\\dfrac{n!}{(n-i)!i!}(n-i)t^i(1-t)^{n-i-1}\\\\\u0026amp;=n\\Bigg[\\begin{pmatrix}n-1\\\\ i-1\\end{pmatrix}t^{i-1}(1-t)^{n-i}-\\begin{pmatrix}n-1\\\\ i\\end{pmatrix}t^i(1-t)^{n-i-1} \\Bigg]\\\\ \u0026amp;=n\\Big[B^{(n-1)}_{i-1}(t)-B_i^{(n-1)}(t)\\Big]\n\\end{align}\n$$\n$$\n\\begin{align}\n\\dfrac{\\mathrm d^2}{\\mathrm dt^2}B_i^{(n)}(t)\u0026amp;=\\dfrac{\\mathrm d}{\\mathrm dt}\\Big[B_{i-1}^{(n-1)}(t)-B_i^{(n-1)}(t) \\Big]\\\\ \u0026amp;=n\\Big[(n-1)\\Big(B_{i-2}^{(n-2)}(t)-B_{i-1}^{(n-2)}(t) \\Big)-(n-1)\\Big(B_{i-1}^{(n-2)}(t)-B_i^{(n-2)}(t) \\Big) \\Big]\\\\ \u0026amp;=n(n-1)\\Big[B_{i-2}^{(n-2)}(t)-2B_{i-2}^{(n-2)}(t)+B_i^{(n-2)}(t) \\Big]\n\\end{align}\n$$\n4.5. Bezieræ›²çº¿çš„æ€§è´¨ 4.5.1. å‰é¢æåˆ°è¿‡çš„æ€§è´¨ï¼š   ä»¿å°„ä¸å˜æ€§\n  å‡¸åŒ…æ€§è´¨\n  æ§åˆ¶ç‚¹å½±å“æ€§\n  4.5.2. å¯¼æ•°æ€§è´¨ å¯¹äº$t\\in[0,1]$ï¼Œæœ‰\n$$\n\\pmb f(t)=\\sum\\limits_{i=0}^{n-1}\\begin{pmatrix}n\\\\i\\end{pmatrix}t^i(1-t)^{n-i}\\pmb p_i\\\n\\Rightarrow \\pmb f(0)=\\pmb p_0\\ \\ \\ \\ \\pmb f(1)=\\pmb p_1\n$$\nä¸€é˜¶å¯¼æ•°\n$$\n\\begin{align}\n\\dfrac{\\mathrm d}{\\mathrm dt}\\pmb f(t)\u0026amp;=n\\sum\\limits_{i=0}^{n-1}\\Big[B_{i-1}^{(n-1)}(t)-B_i^{(n-1)}(t) \\Big]\\pmb p_i\\\\\n\u0026amp;=n\\Big(\\Big[-B_0^{(n-1)}(t) \\Big]\\pmb p_0+\\Big[B_0^{n-1}(t)-B_1^{(n-1)}(t) \\Big]\\pmb p_1+\\cdots\\Big)\n\\end{align}\n$$\n$$\n\\begin{matrix}\n\\dfrac{\\mathrm d}{\\mathrm dt}\\pmb f(0)=n(\\pmb p_1-\\pmb p_0)\u0026amp;\\dfrac{\\mathrm d}{\\mathrm dt}\\pmb f(1)=n(\\pmb p_n-\\pmb p_{n-1})\n\\end{matrix}\n$$\nä»¥æ­¤ç±»æ¨ï¼Œå¯¹äºè¾¹ç•Œç‚¹${0,1}$ï¼Œæœ‰\n$$\n\\begin{align}\n\\pmb f(0)\u0026amp;=\\pmb p_0\\\\\n\\pmb f(1)\u0026amp;=\\pmb p_1\\\\\n\\pmb f'(0)\u0026amp;=n[\\pmb p_1-\\pmb p_0]\\\\\n\\pmb f'(1)\u0026amp;=n[\\pmb p_n-\\pmb p_{n-1}]\\\\\n\\pmb f''(0)\u0026amp;=n(n-1)[\\pmb p_2-2\\pmb p_1+\\pmb p_0]\\\\\n\\pmb f''(1)\u0026amp;=n(n-1)[\\pmb p_n-2\\pmb p_{n-1}+\\pmb p_{n-2}]\n\\end{align}\n$$\nå¯¹äºä¸€é˜¶å¯¼æ•°ï¼Œè¿˜æœ‰ï¼š\n$$\n\\begin{align}\n\\pmb f'(t)\u0026amp;=\\sum_{i=0}^n\\dfrac{\\mathrm d}{\\mathrm dt}B_i^{(n)}(t)\\pmb p_i\\\\\n\u0026amp;=n\\sum_{i=0}^n\\Big(B_{i-1}^{(n-1)}(t)-B_i^{(n-1)}(t) \\Big)\\pmb p_i\\\\\n\u0026amp;=n\\sum_{i=0}^nB_{i-1}^{(n-1)}(t)\\pmb p_i-n\\sum_{i=0}^nB_i^{(n-1)}(t)\\pmb p_i\\\\\n\u0026amp;=n\\sum_{i=-1}^{n-1}B_i^{(n-1)}(t)\\pmb p_{i+1}-n\\sum\\limits_{i=0}^nB_i^{(n-1)}(t)\\pmb p_i\\\\\n\u0026amp;=n\\sum_{i=0}^{n-1}B_i^{(n-1)}(t)\\pmb p_{i+1}-n\\sum\\limits_{i=0}^{n-1}B_i^{(n-1)}(t)\\pmb p_i\\\\\n\u0026amp;=n\\sum\\limits_{i=0}^{n-1}B_i^{(n-1)}(t)(\\pmb p_{i+1}-\\pmb p_i)\n\\end{align}\n$$\né«˜é˜¶å¯¼æ•°ï¼š\n$$\n\\pmb f^{[r]}(t)=\\dfrac{n!}{(n-r)!}\\sum\\limits_{i=0}^{n-r}B_i^{(n-r)}(t)\\cdot\\Delta^r\\pmb p_i\n$$\n4.6. Bezieræ›²çº¿å‡é˜¶ï¼ˆDegree Evaluationï¼‰   ç»™å®šï¼š$\\pmb b_0,\\cdots,\\pmb b_n\\rightarrow \\pmb x(t)$\n  ç›®æ ‡ï¼š$\\overline{\\pmb b}_0,\\cdots,\\overline{\\pmb b_n},\\overline{\\pmb b}_{n+1} \\rightarrow \\overline{\\pmb x}(t)$ with $\\pmb x=\\overline{\\pmb x}$\n  è§£å†³æ–¹æ³•ï¼š\n  $$\n\\begin{align}\n\\overline{\\pmb b}_0\u0026amp;=\\pmb b_0\\\\\n\\overline{\\pmb b}_{n+1}\u0026amp;=\\pmb b_n\\\\\n\\overline{\\pmb b}_j\u0026amp;=\\dfrac{j}{n+1}\\pmb b_{j-1}+\\Big(1-\\dfrac{j}{n+1}\\Big)\\pmb b_j\\ \\mathrm{for}\\ j=1,\\cdots,n\n\\end{align}\n$$\n  è¯æ˜ï¼š\nè€ƒè™‘\n$$\n\\begin{align}\n(1-t)B_i^n(t)\u0026amp;=(1-t)\\begin{pmatrix}n\\\\i\\end{pmatrix}\n(1-t)^{n-i}t^i\\\\\n\u0026amp;=\\begin{pmatrix}n\\\\i\\end{pmatrix}(1-t)^{n+1-i}t^i\\\\\n\u0026amp;=\\dfrac{n+1-i}{n+1}\\begin{pmatrix}n+1\\\\i\\end{pmatrix}(1-t)^{n+1-i}t^i\\\\\n\u0026amp;=\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)\n\\end{align}\n$$\nç±»ä¼¼åœ°ï¼Œ\n$$\ntB_i^n(t)=\\dfrac{i+1}{n+1}B_i^{n+1}(t)\n$$\nä»è€Œæœ‰ï¼š\n$$\n\\begin{align}\n\\pmb f(t)\u0026amp;=[(1-t)+t]\\pmb f(t)\\\\\n\u0026amp;=[(1-t)+t]\\sum\\limits_{i=0}^nB_i^n(t)\\pmb P_i\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\Big[(1-t)B_i^n(t)+tB_i^n(t)\\Big]\\pmb P_i\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\Bigg[\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)+\\dfrac{i+1}{n+1}B_{i+1}^{n+1}(t) \\Bigg]\\pmb P_i\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)\\pmb P_i+\\sum\\limits_{i=0}^n\\dfrac{i+1}{n+1}B_{i+1}^{n+1}(t) \\pmb P_i\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)\\pmb P_i+\\sum\\limits_{i=1}^n\\dfrac{i}{n+1}B_{i}^{n+1}(t) \\pmb P_{i-1}\\\\\n\u0026amp;=\\sum\\limits_{i=0}^{n+1}\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)\\pmb P_i+\\sum\\limits_{i=0}^n\\dfrac{i}{n+1}B_{i}^{n+1}(t) \\pmb P_{i-1}\\\\\n\u0026amp;=\\sum\\limits_{i=0}^{n+1}B_i^{n+1}(t)\\Bigg[\\dfrac{n+1-i}{n+1}\\pmb P_i+\\dfrac{i}{n+1}\\pmb P_{i-1} \\Bigg]\n\\end{align}\n$$\n  4.7. ç»†åˆ†   ç»™å®š\n$$\n\\pmb b_0,\\cdots,\\pmb b_n\\rightarrow \\pmb x(t),t\\in[0,1]\n$$\n  ç›®æ ‡\n$$\n\\begin{align}\n\\pmb b_0^{(1)},\\cdots,\\pmb b_n^{(1)}\\rightarrow \\pmb x^{(1)}(t)\\\\\n\\pmb b_0^{(2)},\\cdots,\\pmb b_n^{(2)}\\rightarrow \\pmb x^{(2)}(t)\\\\\n\\mathrm{with}\\quad \\pmb x=\\pmb x^{(1)}\\cup\\pmb x^{(2)}\n\\end{align}\n$$\n  è§£å†³æ–¹æ³•\n$$\n\\pmb b_i^{(1)}=\\pmb b_0^i,\\pmb b_i^{(2)}=\\pmb b_0^{n-i}\\ \\mathrm{for}\\ i=0,\\cdots,n\n$$\n  4.8. æ›²çº¿èŒƒå›´ 4.9. çŸ©é˜µå®ç° ä¸‰æ¬¡Bezieræ›²çº¿\n$$\n\\pmb P(t)=\\pmb V_0B_{0,3}+\\pmb V_1B_{1,3}+\\pmb V_2B_{2,3}+\\pmb V_3B_{3,3}\n$$\n$$\n\\begin{align}\nB_{0,3}\u0026amp;=\\dfrac{3!}{0!3!}t^0(1-t)^3=(1-t)^3\\\\\nB_{1,3}\u0026amp;=\\dfrac{3!}{1!2!}t^1(1-t)^2=3t(1-t)^2\\\\\nB_{2,3}\u0026amp;=\\dfrac{3!}{2!1!}t^2(1-t)^1=3t^2(1-t)\\\\\nB_{3,3}\u0026amp;=\\dfrac{3!}{3!0!}t^3(1-t)^0=t^3\n\\end{align}\n$$\nçŸ©é˜µå½¢å¼è¡¨ç¤ºï¼š\n$$\n\\pmb P(t)=\\begin{bmatrix}t^3\u0026amp;t^2\u0026amp;t\u0026amp;1\\end{bmatrix}\n\\begin{pmatrix}\n-1\u0026amp;3\u0026amp;-3\u0026amp;1\\\\3\u0026amp;-6\u0026amp;3\u0026amp;0\\\\-3\u0026amp;0\u0026amp;3\u0026amp;0\\\\1\u0026amp;4\u0026amp;1\u0026amp;0\n\\end{pmatrix}\n\\begin{bmatrix}\nV_{i-1}\\\\V_i\\\\V_{i+1}\\\\V_{i+2}\n\\end{bmatrix}\n$$\nå¯¼æ•°çš„çŸ©é˜µè¡¨ç¤ºï¼š\n$$\n\\pmb P'(t)=\\begin{bmatrix}3t^2\u0026amp;2t\u0026amp;1\u0026amp;0\\end{bmatrix}\n\\begin{pmatrix}\n-1\u0026amp;3\u0026amp;-3\u0026amp;1\\\\3\u0026amp;-6\u0026amp;3\u0026amp;0\\\\-3\u0026amp;0\u0026amp;3\u0026amp;0\\\\1\u0026amp;4\u0026amp;1\u0026amp;0\n\\end{pmatrix}\n\\begin{bmatrix}\nV_{i-1}\\\\V_i\\\\V_{i+1}\\\\V_{i+2}\n\\end{bmatrix}\n$$\n","description":"Bezieræ›²çº¿å­¦ä¹ ç¬”è®°","id":20,"section":"note","tags":["CAGD"],"title":"CAGD(2) | Bezieræ›²çº¿","uri":"https://chaphlagical.github.io/zh/note/cagd/cagd2/"},{"content":"Item 13ï¼šUse objects to manage resources   ä»¥å¯¹è±¡ç®¡ç†èµ„æºçš„ä¸¤ä¸ªå…³é”®æƒ³æ³•\n è·å¾—èµ„æºåç«‹å³æ”¾å…¥ç®¡ç†å¯¹è±¡  èµ„æºå–å¾—æ—¶æœºä¾¿æ˜¯åˆå§‹åŒ–æ—¶æœºï¼ˆResource Acquisition Is Initializationï¼›RAIIï¼‰   ç®¡ç†å¯¹è±¡è¿ç”¨ææ„å‡½æ•°ç¡®ä¿èµ„æºè¢«é‡Šæ”¾    æ™ºèƒ½æŒ‡é’ˆç®€ä»‹\n auto_ptr  è¢«é”€æ¯æ—¶ä¼šè‡ªåŠ¨åˆ é™¤å®ƒæ‰€æŒ‡ä¹‹ç‰© è‹¥é€šè¿‡copyæ„é€ å‡½æ•°æˆ–copy assignmentæ“ä½œç¬¦å¤åˆ¶å®ƒä»¬ï¼Œå®ƒä»¬å°†å˜æˆnullï¼Œè€Œå¤åˆ¶å¾—åˆ°çš„æŒ‡é’ˆå–å¾—èµ„æºçš„å”¯ä¸€æ‰€æœ‰æƒ å—auto_ptrsç®¡ç†çš„èµ„æºå¿…é¡»ç»å¯¹æ²¡æœ‰ä¸€ä¸ªä»¥ä¸Šçš„auto_ptråŒæ—¶æŒ‡å‘å®ƒ ç°ä»£C++ä¸­å¸¸ç”¨unique_pträ»£æ›¿auto_ptr   shared_ptr  å±äºå¼•ç”¨è®¡æ•°å‹æ™ºèƒ½æŒ‡é’ˆï¼ˆReference-counting smart pointer;RCSPï¼‰ æŒç»­è¿½è¸ªå…±æœ‰å¤šå°‘å¯¹è±¡æŒ‡å‘æŸç¬”èµ„æºï¼Œå¹¶åœ¨æ— äººæŒ‡å‘å®ƒæ—¶è‡ªåŠ¨åˆ é™¤è¯¥èµ„æº      æ™ºèƒ½æŒ‡é’ˆauto_ptrå’Œtr1::shared_ptrçš„ææ„å‡½æ•°å†…è¿›è¡Œçš„åˆ é™¤æ“ä½œä¸ºdeleteï¼Œå› æ­¤ä¸å»ºè®®åœ¨åŠ¨æ€åˆ†é…å¾—åˆ°çš„æ•°ç»„ä¸Šä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ\n  Item 14ï¼šThink carefully about copying behavior in resource-managing classes   å¤åˆ¶RAIIå¯¹è±¡å¿…é¡»ä¸€å¹¶å¤åˆ¶å®ƒæ‰€ç®¡ç†çš„èµ„æºï¼Œæ‰€ä»¥èµ„æºçš„copyè¡Œä¸ºå†³å®šRAIIçš„copyè¡Œä¸º\n  å¸¸è§çš„RAIIcopyè¡Œä¸ºæœ‰ï¼š\n    ç¦æ­¢å¤åˆ¶\n å°†copyæ“ä½œå£°æ˜ä¸ºprivate    å¯¹åº•å±‚èµ„æºä½¿ç”¨â€œå¼•ç”¨è®¡æ•°â€ï¼ˆshared_ptrï¼‰\n ä¿æœ‰èµ„æºç›´åˆ°å…¶æœ€åä¸€ä¸ªä½¿ç”¨è€…è¢«é”€æ¯ï¼Œè¯¥æƒ…å†µä¸‹å¤åˆ¶RAIIå¯¹è±¡ï¼Œå…¶è¢«å¼•ç”¨æ•°å°†é€’å¢ shared_ptrå…è®¸æŒ‡å®šåˆ é™¤å™¨ï¼Œå¼•ç”¨æ¬¡æ•°ä¸º0æ—¶å°†è‡ªåŠ¨è°ƒç”¨åˆ é™¤å™¨ï¼Œå¦‚ï¼š    1 2 3 4 5 6 7 8 9 10  class Lock{ public: explicit Lock(Mutex* pm) : mutexPtr(pm, unlock)\t// æŒ‡å®šunlockå‡½æ•°ä½œä¸ºåˆ é™¤å™¨  { lock(mutexPtr.get()); } private: std::tr1::shared_ptr\u0026lt;Mutex\u0026gt; mutexPtr; }   å¤åˆ¶åº•éƒ¨èµ„æº  å¤åˆ¶èµ„æºç®¡ç†å¯¹è±¡æ—¶ï¼Œåº”è¯¥åŒæ—¶å¤åˆ¶å…¶æ‰€åŒ…è¦†çš„èµ„æºï¼Œå³è¿›è¡Œæ·±åº¦æ‹·è´   è½¬ç§»åº•éƒ¨èµ„æºçš„æ‰€æœ‰æƒï¼ˆauto_ptrï¼‰  å¸Œæœ›ç¡®ä¿æ°¸è¿œåªæœ‰ä¸€ä¸ªRAIIå¯¹è±¡æŒ‡å‘ä¸€ä¸ªåŸå§‹èµ„æº å½“RAIIå¯¹è±¡è¢«å¤åˆ¶æ—¶ï¼Œèµ„æºçš„æ‹¥æœ‰æƒä»è¢«å¤åˆ¶å¯¹è±¡è½¬ç§»åˆ°ç›®æ ‡å¯¹è±¡    Item 15ï¼šåœ¨èµ„æºç®¡ç†ç±»ä¸­æä¾›å¯¹åŸå§‹èµ„æºçš„è®¿é—®   å¾€å¾€æ˜¯æ¥å£éœ€è¦\n  æ˜¾å¼è½¬æ¢ä¸éšå¼è½¬æ¢\n  1 2 3 4 5 6 7 8 9 10 11  FontHandle getFont();\t// C API void releaseFont(FontHandle fh);\t// C API class Font{ public: explicit Font(FontHandle fh) :f(fh) {} ~Font(){releaseFont(f);} private: FontHandle f; };    æ˜¾å¼è½¬æ¢  1 2 3 4 5 6  class Font{ public: ... FontHandle get() const {return f;} ... };   æ¯æ¬¡ä½¿ç”¨æ—¶å¿…é¡»è°ƒç”¨get\n1 2 3 4 5  void changeFontSize(FontHandle f, int newSize); Font f(getFont()); int newFontSize; ... changeFontSize(f.get(),newFontSize);   è¿™ç§åšæ³•æš´éœ²äº†åŸå§‹èµ„æºï¼Œå¢åŠ èµ„æºæ³„éœ²çš„é£é™©\n éšå¼è½¬æ¢  1 2 3 4 5 6 7  class Font{ public: ... operator FontHandle() const {return f;} ... };   è¿™ç§æ–¹æ³•å®¢æˆ·ç«¯è°ƒç”¨æ›´åŠ è‡ªç„¶\n1 2 3 4  Font f(getFont()); int newFontSize; ... changeFontSize(f, newFontSize);   éšå¼è½¬æ¢ä¹Ÿä¼šå¢åŠ å‘ç”Ÿé”™è¯¯çš„æœºä¼šï¼Œæ¯”å¦‚å®¢æˆ·å¯èƒ½åœ¨éœ€è¦Fontçš„æ—¶å€™æ„å¤–åˆ›å»ºä¸€ä¸ªFontHandle\n1 2 3  Font f1(getFont()); ... FontHandle f2=f1;    ä¸€èˆ¬è€Œè¨€ï¼Œæ˜¾å¼è½¬æ¢æ¯”è¾ƒå®‰å…¨ï¼Œè€Œéšå¼è½¬æ¢æ›´åŠ å®¢æˆ·å‹å¥½  Item 16ï¼šUse the same form in corresponding uses of new and delete   ä½¿ç”¨newæ—¶ï¼Œæœ‰ä¸¤ä»¶äº‹å‘ç”Ÿ\n å†…å­˜è¢«åˆ†é…å‡ºæ¥ é’ˆå¯¹æ­¤å†…å­˜ä¼šæœ‰ä¸€ä¸ªæˆ–æ›´å¤šæ„é€ å‡½æ•°è¢«è°ƒç”¨    ä½¿ç”¨deleteæ—¶ï¼Œæœ‰ä¸¤ä»¶äº‹å‘ç”Ÿ\n é’ˆå¯¹æ­¤å†…å­˜ä¼šæœ‰ä¸€ä¸ªæˆ–æ›´å¤šææ„å‡½æ•°è¢«è°ƒç”¨ å†…å­˜è¢«é‡Šæ”¾    æ•°ç»„çš„åˆ é™¤\n å’Œå•ä¸€å¯¹è±¡çš„å†…å­˜å¸ƒå±€ä¸åŒï¼Œæ•°ç»„æ‰€ç”¨å†…å­˜é€šå¸¸è¿˜åŒ…æ‹¬â€œæ•°ç»„å¤§å°â€çš„è®°å½•ï¼Œä»¥ä¾¿åˆ é™¤å‡½æ•°ç›´åˆ°éœ€è¦è°ƒç”¨å¤šå°‘æ¬¡ææ„å‡½æ•° å¯¹äºæ•°ç»„çš„åˆ é™¤ï¼Œåº”å½“ä½¿ç”¨delete[]    ä½¿ç”¨äº†typedef\n  1 2 3 4  typedef std::string AddressLines[4]; std::string* pal = new AddressLines; delete pal;\t// è¡Œä¸ºæœªå®šä¹‰ deletep[] pal;\t// æ­£ç¡®   ä¸ºå‡å°‘é”™è¯¯çš„äº§ç”Ÿï¼Œå°½é‡ä¸è¦å¯¹æ•°ç»„å½¢å¼åštypedefæ“ä½œ\nItem 17ï¼šStored newed objects in smart pointers in standalone statement  æ™ºèƒ½æŒ‡é’ˆæ„é€ å‡½æ•°éœ€è¦ä¸€ä¸ªåŸå§‹æŒ‡é’ˆï¼Œä½†è¯¥æ„é€ å‡½æ•°æ˜¯ä¸ªexplicitæ„é€ å‡½æ•°ï¼Œæ— æ³•è¿›è¡Œéšå¼è½¬æ¢  1 2  int priority(); void processWidget(std::tr1::shared_ptr\u0026lt;Widget\u0026gt; pw, int priority);   è€ƒè™‘è°ƒç”¨\n1  processWidget(new Widget, priority());   å°†ä¸èƒ½é€šè¿‡ç¼–è¯‘ï¼Œæ¬²ä½¿ç¨‹åºæ­£å¸¸ç¼–è¯‘ï¼Œåº”æ˜¾å¼è°ƒç”¨ï¼š\n1  processWidget(std::tr1::shared_ptr\u0026lt;Widget\u0026gt;(new Widget), priority());     std::tr1::shared_ptr\u0026lt;Widget\u0026gt;(new Widget)è°ƒç”¨è¿‡ç¨‹ï¼š\n æ‰§è¡Œnew Widgetè¡¨è¾¾å¼ è°ƒç”¨std::tr1::shared_ptræ„é€ å‡½æ•°    è°ƒç”¨processWidgetå‰ç¼–è¯‘å™¨çš„å·¥ä½œï¼š\n  è°ƒç”¨priority\n  æ‰§è¡Œnew Widgetè¡¨è¾¾å¼\n  è°ƒç”¨std::tr1::shared_ptræ„é€ å‡½æ•°\n  C++å®Œæˆä¸Šè¿°ä»»åŠ¡çš„é¡ºåºå¼¹æ€§å¾ˆå¤§ï¼Œä¸è¿‡å¯ä»¥è‚¯å®šçš„æ˜¯new Widgetä¸€å®šåœ¨std::tr1::shared_ptræ„é€ å‡½æ•°è¢«è°ƒç”¨å‰æ‰§è¡Œã€‚\nå€˜è‹¥è°ƒç”¨priorityåœ¨å…¶ä»–ä¸¤ä¸ªæ“ä½œä¸­é—´ï¼Œæ­¤æ—¶å¦‚æœpriorityè°ƒç”¨å¼‚å¸¸ï¼Œnew Widgetå¾—åˆ°çš„æŒ‡é’ˆå°†æ— æ³•é€åˆ°æ™ºèƒ½æŒ‡é’ˆå¤„ï¼Œå¯¼è‡´èµ„æºæ³„éœ²\n  ç§‘å­¦çš„æ–¹æ³•æ˜¯ä½¿ç”¨åˆ†ç¦»è¯­å¥\n  1 2  std::tr1::shared_ptr\u0026lt;Widget\u0026gt; pw(new Widget); processWidget(pw, priority());   ","description":"ã€ŠEffective C++å­¦ä¹ ç¬”è®°ç¬¬ä¸‰ç« ã€‹","id":21,"section":"note","tags":["Effective C++","C++"],"title":"Chapter 3: Resource Management","uri":"https://chaphlagical.github.io/zh/note/effectivecpp/ch3/"},{"content":"Item 5: Know what functions C++ silently writes and calls   C++å¯¹ç±»ä¼šæä¾›é»˜è®¤çš„å‡½æ•°ï¼Œæ‰€æœ‰è¿™äº›å‡½æ•°éƒ½æ˜¯publicä¸”inlineçš„\n é»˜è®¤å‡½æ•°åŒ…æ‹¬defaultæ„é€ å‡½æ•°ï¼Œcopyæ„é€ å‡½æ•°ï¼Œcopy assignmentæ“ä½œç¬¦ï¼Œææ„å‡½æ•°    ä¸‹é¢ä¸¤å—ä»£ç ç­‰ä»·ï¼š\n  1  class Empty{};   1 2 3 4 5 6 7 8 9  class Empty{ public: Empty(){...} Empty(const Empty\u0026amp; rhs){...} ~Empty(){...} Empty\u0026amp; operator=(const Empty\u0026amp; rhs){...} }     ç¼–è¯‘å™¨äº§ç”Ÿçš„ææ„å‡½æ•°æ˜¯ä¸ªnon-virtualå‡½æ•°ï¼Œé™¤éè¿™ä¸ªclass çš„åŸºç±»è‡ªèº«å£°æ˜æœ‰virtualææ„å‡½æ•°\n  ç¼–è¯‘å™¨ç”Ÿæˆçš„å¤åˆ¶æ„é€ å‡½æ•°å’Œå¤åˆ¶èµ‹å€¼æ“ä½œç¬¦ç®€å•åœ°å¤åˆ¶äº†æºå¯¹è±¡æ¯ä¸ªéé™æ€æ•°æ®æˆå‘˜åˆ°ç›®æ ‡å¯¹è±¡\n  Item 6: Explicitly disallow the use of compiler-generated functions you do not want   C++çš„é»˜è®¤æ„é€ å‡½æ•°å’Œææ„å‡½æ•°æ˜¯è‡ªåŠ¨ç”Ÿæˆçš„ï¼Œå¦‚ä¸éœ€è¦ï¼Œå¿…é¡»æ‰‹åŠ¨è¿›è¡Œç¦ç”¨\n  å¯ä»¥å°†ç›¸å…³å‡½æ•°å£°æ˜ä¸ºprivateå¹¶ä¸”ä¸å»å®šä¹‰å®ƒ\n  1 2 3 4 5 6 7 8  class HomeForSale{ public: ... private: ... HomeForSale(const HomeForSale\u0026amp;); HomeForSale\u0026amp; operator=(const HomeForSale\u0026amp;); };    ä¹Ÿå¯ä»¥é€šè¿‡è®¾è®¡ä»¥ä¸‹ç±»è¿›è¡Œç»§æ‰¿ä»¥å‡å°‘ä»£ç é‡å¤ï¼š  1 2 3 4 5 6 7 8 9  class Uncopyable{ protected: Uncopyable(){} ~Uncopyable(){} private: Uncopyable(const Uncopyable\u0026amp;); Uncopyable\u0026amp; operator=(const Uncopyable\u0026amp;); };    ä½¿ç”¨æ—¶ï¼Œåªéœ€è¦  1 2 3  class HomeForScale:private Uncopyable{ ... };   Item 7: Declare destructors virtual in polymorphic base classes  å¯¹äºå¤šæ€ç±»ï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªåŸºç±»åŠå…¶æ´¾ç”Ÿç±»ï¼Œåˆ©ç”¨æŒ‡å‘åŸºç±»çš„æŒ‡é’ˆï¼Œé‡æ–°æŒ‡å‘æ´¾ç”Ÿç±»è¿›è¡Œæ“ä½œ ä½†å¯¹æŒ‡å‘æ´¾ç”Ÿç±»çš„åŸºç±»æŒ‡é’ˆè¿›è¡Œå†…å­˜é‡Šæ”¾æ—¶ï¼ŒæŒ‡é’ˆå°†ä½œä¸ºåŸºç±»æŒ‡é’ˆè¿›è¡Œåˆ é™¤ï¼Œå¦‚æœåŸºç±»å­˜åœ¨ä¸€ä¸ªévirtualææ„å‡½æ•°ï¼Œåˆ™åªä¼šåˆ é™¤æ‰€æŒ‡æ´¾ç”Ÿç±»çš„åŸºç±»éƒ¨åˆ†ï¼Œè€Œå¯¹äºæ´¾ç”Ÿç±»å‰©ä½™éƒ¨åˆ†å°†é€ æˆå†…å­˜æ³„æ¼ è§£å†³æ–¹æ³•ï¼šå°†åŸºç±»çš„ææ„å‡½æ•°å£°æ˜ä¸ºvirtualå‡½æ•°ï¼Œåˆ é™¤æ´¾ç”Ÿç±»æ—¶å°†ä¼šæŠŠæ•´ä¸ªå¯¹è±¡åˆ é™¤ï¼ŒåŒ…æ‹¬æ´¾ç”Ÿç±»éƒ¨åˆ† virtualå‡½æ•°çš„åŸç†ï¼š  è¦å®ç°virtualå‡½æ•°ï¼Œå¯¹è±¡å¿…é¡»æºå¸¦æŸäº›ä¿¡æ¯ï¼Œä¸»è¦ç”¨æ¥åœ¨è¿è¡ŒæœŸå†³å®šå“ªä¸ªvirtualå‡½æ•°è¯¥è¢«è°ƒç”¨ è¯¥ä¿¡æ¯ç”±è™šè¡¨æŒ‡é’ˆï¼ˆvptrï¼Œvirtual table pointerï¼‰æŒ‡é’ˆæŒ‡å‡º vptræŒ‡å‘ä¸€ä¸ªç”±å‡½æ•°æŒ‡é’ˆæ„æˆçš„æ•°ç»„ï¼Œç§°ä¸ºè™šè¡¨(vtblï¼Œvirtual table) æ¯ä¸€ä¸ªå¸¦æœ‰virtualå‡½æ•°çš„classéƒ½æœ‰ç›¸åº”çš„vtbl å½“å¯¹è±¡è°ƒç”¨æŸä¸€virtualå‡½æ•°ï¼Œå®é™…è¢«è°ƒç”¨çš„å‡½æ•°å–å†³äºè¯¥å¯¹è±¡çš„vptræ‰€æŒ‡å‘çš„é‚£ä¸ªvtblâ€”â€”ç¼–è¯‘å™¨åœ¨å…¶ä¸­å¯»æ‰¾åˆé€‚çš„å‡½æ•°æŒ‡é’ˆ   å¦‚æœä¸€ä¸ªç±»ä¸æ‰“ç®—ä½œä¸ºåŸºç±»æˆ–ä¸ºäº†å…·å¤‡å¤šæ€æ€§ï¼Œåˆ™æœ€å¥½ä¸è¦ä½¿ç”¨virtualå‡½æ•° å¤šæ€åŸºå‡½æ•°åº”è¯¥å£°æ˜ä¸€ä¸ªvirtualææ„å‡½æ•°ï¼Œå¦‚æœclasså¸¦æœ‰ä»»ä½•virtualå‡½æ•°ï¼Œå°±åº”è¯¥æ‹¥æœ‰ä¸€ä¸ªvirtualææ„å‡½æ•° å¦‚æœç±»ä¸­å«æœ‰çº¯virtualå‡½æ•°ï¼Œåˆ™è¯¥ç±»å°†å˜æˆæŠ½è±¡å‡½æ•°ï¼Œä¸èƒ½è¿›è¡Œå®ä¾‹åŒ–  å¦‚æœå¸Œæœ›å£°æ˜ä¸€ä¸ªæ²¡æœ‰çº¯virtualæˆå‘˜å‡½æ•°çš„æŠ½è±¡ç±»ï¼Œå¯ä»¥åœ¨ç±»ä¸­å£°æ˜ä¸€ä¸ªçº¯virtualçš„ææ„å‡½æ•° çº¯virtualææ„å‡½æ•°åº”æä¾›å®šä¹‰   ä¸ºåŸºç±»æä¾›virtualæ‹Ÿææ„å‡½æ•°çš„è§„åˆ™ä»…é€‚ç”¨äºå¤šæ€åŸºç±»ï¼Œå¹¶éæ‰€æœ‰åŸºç±»éƒ½ä¼šç”¨äºå¤šæ€  STLå®¹å™¨å‡ä¸è®¾è®¡ä¸ºåŸºç±» åƒUncopyableè¿™ç±»åŸºç±»ä¹Ÿä¸è®¾è®¡ä¸ºå¤šæ€    Item 8: Prevent exceptions from leaving destructors   C++çš„ææ„å‡½æ•°ä¸­å‘ç”Ÿå¼‚å¸¸æ˜¯ä¸€ä»¶å¾ˆéº»çƒ¦çš„äº‹\n  ä¸€èˆ¬C++ç¨‹åºå‘ç”Ÿå¼‚å¸¸å¯èƒ½ä¼šå‡ºç°ä¸¤ç§æƒ…å†µï¼š\n ç¨‹åºæå‰ç»ˆæ­¢ ç¨‹åºå‘ç”ŸæœªçŸ¥è¡Œä¸º  è€Œææ„å‡½æ•°å‘ç”Ÿå¼‚å¸¸æ—¶å¸¸å‡ºç°ç¬¬äºŒç§æƒ…å†µ\n  è§£å†³æ–¹æ³•ï¼š\n   æ‰‹åŠ¨ç»ˆæ­¢ç¨‹åº  1 2 3 4 5 6 7 8  DBConn::~DBConn() { try{db.close();} catch (...){ //\tLog here  std::abort(); } }   å½“ç¨‹åºæ— æ³•æ­£å¸¸è¿è¡Œæ—¶å°†è¿›å…¥å¼‚å¸¸å¤„ç†å‡½æ•°ï¼Œè°ƒç”¨abortä»¥ç»“æŸç¨‹åº\nå¿½ç•¥å¼‚å¸¸  1 2 3 4 5 6 7  DBConn::~DBConn() { try{db.close();} catch (...){ //\tLog here  } }   ä¸€èˆ¬æƒ…å†µä¸‹ä¸æ¨èåšæ³•ï¼Œä½†åœ¨ç¨‹åºè¦æ±‚æŒç»­å¯é è¿è¡Œæ—¶æ˜¯ä¸ªä¸é”™çš„é€‰æ‹©\né‡æ–°è®¾è®¡æ¥å£ï¼ˆæ¨èåšæ³•ï¼‰  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class DBConn{ public: ... void close() { db.close(); closed=true; } ~DBConn() { if(!closed){ try{ db.close(); } catch(...){ // logging  ... } } } private: DBConnection db; bool closed; };    æä¾›è‡ªèº«çš„closeå‡½æ•°ï¼Œèµ‹äºˆå®¢æˆ·ç«¯ä¸€ä¸ªæœºä¼šå¾—ä»¥æ‰‹åŠ¨å¤„ç†å¼‚å¸¸ åŒæ—¶DBConnä¹Ÿå¯è¿½è¸ªå…¶ç®¡ç†çš„DBConnectionæ˜¯å¦å…³é—­ï¼Œå¹¶åœ¨ç­”æ¡ˆä¸ºå¦çš„æ—¶å€™è°ƒç”¨ææ„å‡½æ•°å°†å…¶å…³é—­  Item 9: Never call virtual functions during construction or destruction  åœ¨æ„é€ å‡½æ•°å’Œææ„å‡½æ•°ä¸­ä¸åº”è¯¥è°ƒç”¨virtualå‡½æ•°ï¼Œå› ä¸ºæ‰€è°ƒç”¨çš„virtualå‡½æ•°å¯èƒ½ä¸æ˜¯ä½ æƒ³è°ƒç”¨çš„é‚£ä¸ªvirtualå‡½æ•°ï¼Œä¸¾ä¾‹ï¼š  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Transaction{ public: Transaction(); virtual void logTransaction() const = 0; ... }; Transaction::Transaction() { ... logTransaction(); } class BugTransaction:public Transaction{ public: virtual void logTransaction() const; ... }; class SellTransaction:public Transaction{ public: virtual void logTransaction() const; ... }; // æ‰§è¡Œ BuyTransaction b;     åœ¨è°ƒç”¨BuyTransactionæ„é€ å‡½æ•°ä¹‹å‰ï¼ŒåŸºç±»Transactionæ„é€ å‡½æ•°ä¼šå…ˆè¢«è°ƒç”¨\n  Transactionæ„é€ å‡½æ•°è°ƒç”¨äº†virtualå‡½æ•°ï¼Œä¸”è¯¥virtualå‡½æ•°æ­¤æ—¶ä¸ºTransactionç‰ˆæœ¬\n  å¯¹è±¡åœ¨æ´¾ç”Ÿç±»æ„é€ å‡½æ•°å¼€å§‹æ‰§è¡Œå‰ä¸ä¼šæˆä¸ºä¸€ä¸ªæ´¾ç”Ÿç±»å¯¹è±¡\n å› ä¸ºæ­¤æ—¶æ´¾ç”Ÿç±»æˆå‘˜å˜é‡æœªå®šå€¼    ä¸€ä¸ªæ½œè—çš„é—®é¢˜\n  1 2 3 4 5 6 7 8 9 10 11 12  class Transaction{ public: Transaction(){init();} virtual void logTransaction() const = 0; ... private: void init() { ... logTransaction(); } };     æ„é€ å‡½æ•°è°ƒç”¨å¾—å‡½æ•°ä¸­å¸¦æœ‰virtualå‡½æ•°\n  è‹¥virtualå‡½æ•°ä¸ºçº¯virtualå‡½æ•°æ—¶ï¼Œå°†å‘ç”Ÿé“¾æ¥é”™è¯¯\n  è€Œè‹¥virtualå‡½æ•°æœ‰å®šä¹‰æ—¶ï¼Œæ´¾ç”Ÿç±»çš„æ„é€ å°†å¾—åˆ°é”™è¯¯çš„ç»“æœ\n  å‡è®¾æœ‰ä¸€ä¸ªåŸºç±»å’Œå¤šä¸ªæ´¾ç”Ÿç±»ï¼ŒåŸºç±»çš„æ„é€ å‡½æ•°ä¸­è°ƒç”¨äº†ä¸€ä¸ªvirtualæˆå‘˜å‡½æ•°ï¼Œæ­¤æ—¶éœ€è¦å®šä¹‰ä¸€ä¸ªæ´¾ç”Ÿç±»å¯¹è±¡\n è‹¥virtualå‡½æ•°ä¸ºçº¯virtualå‡½æ•°ï¼ŒåŸºç±»æ„é€ å‡½æ•°å°†è°ƒç”¨ä¸€ä¸ªåŸºç±»ä¸‹çš„çº¯virtualå‡½æ•°ï¼Œå‘ç”Ÿé”™è¯¯ è‹¥virtualå‡½æ•°ä¸ºæ™®é€švirtualå‡½æ•°ï¼ŒåŸºç±»æ„é€ å‡½æ•°å°†è°ƒç”¨ä¸€ä¸ªåŸºç±»ä¸‹çš„virtualå‡½æ•°ï¼Œè€Œä¸æ˜¯æ´¾ç”Ÿç±»ä¸­çš„å¤šæ€å‡½æ•°ï¼Œæ— æ³•å°†æ´¾ç”Ÿç±»çš„ä¿¡æ¯ä¼ é€’åˆ°åŸºç±»    è§£å†³é—®é¢˜çš„æ–¹æ³•ï¼š\n ä½¿ç”¨explicitå…³é”®å­—ä¿®é¥°å¸¦å‚æ•°çš„æ„é€ å‡½æ•° å°†åŸæ¥çš„virtualæˆå‘˜å‡½æ•°å®šä¹‰ä¸ºévirtualæˆå‘˜å‡½æ•° åœ¨æ´¾ç”Ÿç±»ä¸­ï¼Œä½¿ç”¨æˆå‘˜åˆå§‹åŒ–åˆ—è¡¨å¯¹åŸºç±»è¿›è¡Œä¼ å‚åˆå§‹åŒ–ï¼Œè¿™æ ·å³å®ç°äº†å°†ä¿¡æ¯ä»æ´¾ç”Ÿç±»ä¼ é€’åˆ°åŸºç±»çš„æ„é€ å‡½æ•°ä¸­  ä¸¾ä¾‹ï¼š\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Transaction{ public: explicit Transaction(const std::string\u0026amp; logInfo); void logTransaction(const std::string\u0026amp; logInfo) const; ... }; Transaction::Transaction(const std::string\u0026amp; logInfo) { ... logTransaction(logInfo); } class BuyTransaction: public Transaction{ public: BuyTransaction(parameters) :Transaction(createLogString(parameters)) {...} ... private: static std::string createLogString(parameters); };    ä»¤æ´¾ç”Ÿç±»å°†å¿…è¦çš„æ„é€ ä¿¡æ¯å‘ä¸Šä¼ åˆ°åŸºç±»æ„é€ å‡½æ•°  Item 10: Have assignment operators return a reference to *this  C++æ”¯æŒé“¾å¼èµ‹å€¼æ“ä½œï¼š  1 2  int x,y,z; x=y=z=15;   ä¹Ÿç­‰ä»·äº\n1  x=(y=(z=15))    å› æ­¤åœ¨å®šä¹‰èµ‹å€¼è¿ç®—ç¬¦é‡è½½æ—¶ï¼Œæœ€å¥½ä¹Ÿè¿”å›*this  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Widget{ public: ... Widget\u0026amp; operator=(const Widget\u0026amp; rhs) { ... return *this; } Widget\u0026amp; operator+=(const Widget\u0026amp; rhs) { ... return *this; } Widget\u0026amp; operator*=(const Widget\u0026amp; rhs) { ... return *this; } ... }    è¿™åªæ˜¯ä¸ªåè®®è§„èŒƒï¼Œå¹¶æ— å¼ºåˆ¶æ€§  Item 11: Handle assignment to self in operator=  å°†æœ¬èº«çš„å€¼èµ‹å€¼ç»™æœ¬èº«å¾€å¾€å®¹æ˜“å‡ºç°é”™è¯¯ï¼Œä¾‹å¦‚ï¼š  1 2 3 4 5 6 7 8 9 10 11 12 13  class Bitmap{...}; class Widget{ ... private: Bitmap* pb; }; Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { delete pb; pb=new Bitmap(*ths.pb); return *this; }   è¿™é‡Œthså¯èƒ½å°±æ˜¯å…¶è‡ªå·±æœ¬èº«ï¼Œè€Œæ•´ä¸ªä»£ç è¿è¡Œåå°†è¿”å›ä¸€ä¸ªæŒ‡å‘å·²åˆ é™¤å¯¹è±¡çš„æŒ‡é’ˆ\n ä¼ ç»Ÿçš„è§£å†³æ–¹æ³•æ˜¯è¿›è¡Œæµ‹è¯•  1 2 3 4 5 6 7 8  Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { if(this==\u0026amp;rhs)return *this; delete pb; pb=new Bitmap(*rhs.pb); return *this; }   è¿™ç§æ–¹æ³•æ˜¯æœ‰ç¼ºé™·çš„ï¼Œå‡è®¾åœ¨æ–°å»ºBitmapçš„è¿‡ç¨‹ä¸­å‡ºç°å¼‚å¸¸ï¼Œå¾—åˆ°çš„æŒ‡é’ˆå°†æ˜¯æœ‰å®³çš„ï¼Œä½ å°†ä¸èƒ½å®‰å…¨çš„åˆ é™¤å®ƒä»¬ï¼Œç”šè‡³æ˜¯è¯»å–å®ƒä»¬\n ä¸€ç§å®‰å…¨çš„åšæ³•æ˜¯ä¿å­˜ä¸‹æŒ‡é’ˆåŸæ¥æ‰€æŒ‡çš„å€¼  1 2 3 4 5 6 7  Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { Bitmap *pOrig = pb; pb = new Bitmap(*rhs.pb); delete pOrig; return *this; }   éœ€è¦å¤åˆ¶ï¼Œæ•ˆç‡ä¸å¤Ÿé«˜\n å¤åˆ¶å’Œäº¤æ¢ï¼ˆcopy and swapï¼‰æŠ€æœ¯ã€‚ç¡®ä¿å®ç°æ—¢æ˜¯å¼‚å¸¸å®‰å…¨åˆæ˜¯å¤åˆ¶å®‰å…¨  1 2 3 4 5 6 7  Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { Widget temp(rhs); swap(temp);\t// äº¤æ¢*thiså’Œ*temp  return *this; }   Item 12: Copy all parts of an object   ä¸€èˆ¬çš„å¤åˆ¶å‡½æ•°åŒ…æ‹¬ï¼šå¤åˆ¶æ„é€ å‡½æ•°å’Œå¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦\n  é»˜è®¤çš„å¤åˆ¶å‡½æ•°å°†å¤åˆ¶å¯¹è±¡ä¸­æ‰€æœ‰çš„æ•°æ®\n  è‡ªå®šä¹‰çš„å¤åˆ¶å‡½æ•°å¿…é¡»è¦æŠŠæ‰€æœ‰æ•°æ®éƒ½è¿›è¡Œæ‹·è´ï¼ˆåŒ…æ‹¬åŸºç±»æ•°æ®ï¼‰\n æ³¨æ„ç±»ç»§æ‰¿æ—¶å®¹æ˜“å‡ºç°ä¸å®Œå…¨æ‹·è´çš„æƒ…å†µï¼Œå¤åˆ¶å‡½æ•°åº”ç¡®ä¿å¤åˆ¶å¯¹è±¡å†…æ‰€æœ‰æˆå‘˜å˜é‡å’Œæ‰€æœ‰åŸºç±»æˆåˆ†    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class Data{...} class Customer{ public: ... private: std::string name; Data lastTransaction; }; class PriorityCustomer: public Customer{ public: ... PriorityCustomer(const PriorityCustomer\u0026amp; rhs); PriorityCustomer\u0026amp; operator=(const PriorityCustomer\u0026amp; rhs); ... private: int priority; }; PriorityCustomer::PriorityCustomer(const PriorityCustomer\u0026amp; rhs) :Customer(rhs),priority(ths.priority) { logCall(\u0026#34;PriorityCustomer copy constructor\u0026#34;); } PriorityCustomer\u0026amp; PriorityCustomer::operator=(const PriorityCustomer\u0026amp; rhs) { logCall(\u0026#34;PriorityCustomer copy assignment operator\u0026#34;); Customer::operator=(rhs); priority=rhs.priority; return *this; }   ","description":"ã€ŠEffective C++å­¦ä¹ ç¬”è®°ç¬¬äºŒç« ã€‹","id":22,"section":"note","tags":["Effective C++","C++"],"title":"Chapter 2: Constructors, Destructors, and Assignment Operators","uri":"https://chaphlagical.github.io/zh/note/effectivecpp/ch2/"},{"content":"Item 1: View C++ as a federation of languages   C++çš„å¤šé‡èŒƒå‹æ€§ï¼šæ”¯æŒè¿‡ç¨‹å½¢å¼ã€é¢å‘å¯¹è±¡å½¢å¼ã€å‡½æ•°å½¢å¼ã€æ³›å‹å½¢å¼ã€å…ƒç¼–ç¨‹å½¢å¼\n  å°†C++è§†ä¸ºæ¬¡è¯­è¨€çš„é›†åˆï¼š\n Cï¼šåŒºå—blocksã€è¯­å¥statementsã€é¢„å¤„ç†å™¨preprocessorï¼Œå†…ç½®æ•°æ®ç»“æ„built-in data typesã€æ•°ç»„arraysã€æŒ‡é’ˆpointersç­‰ Object-Oriented C++ï¼šclassesï¼ˆæ„é€ ä¸ææ„å‡½æ•°ï¼‰ã€å°è£…encapsulationã€ç»§æ‰¿inheritanceã€å¤šæ€polymorphismã€virtualå‡½æ•°ï¼ˆåŠ¨æ€ç»‘å®šï¼‰ç­‰ Template C++ï¼šæ¨¡æ¿å…ƒç¼–ç¨‹TMP STLï¼štemplateç¨‹åºåº“ï¼Œå®¹å™¨containersã€è¿­ä»£å™¨iteratorsã€ç®—æ³•algorithmsã€å‡½æ•°å¯¹è±¡function objects    Item 2: Prefer consts, enums, and inlines to #define #defineçš„ç¼ºé™·\n  #defineä¸ä¼šè¢«ç¼–è¯‘å™¨çœ‹åˆ°ï¼Œç”šè‡³åœ¨é¢„å¤„ç†æœŸå°±è¢«æ›¿æ¢æ‰äº†ï¼Œåç§°ä¸ä¼šè¿›å…¥ç¬¦å·è¡¨ï¼Œç›´æ¥æ›¿æ¢æˆç›®æ ‡ï¼Œå®¹æ˜“é€ æˆè°ƒè¯•ä¸Šçš„å›°éš¾\nä¾‹å¦‚ï¼š\n  1  #define ASPECT_RATIO 1.653   å½“ä½¿ç”¨å¸¸é‡`ASPECT_RATIO`ä¸”è·å¾—ä¸€ä¸ªç¼–è¯‘é”™è¯¯ä¿¡æ¯æ—¶ï¼Œè¯¥é”™è¯¯ä¿¡æ¯å¯èƒ½æåˆ°1.653è€Œä¸æ˜¯`ASPECT_RATIO`ï¼Œè¿½è¸ªä¸è°ƒè¯•å°†å¸¦æ¥éº»çƒ¦\r   #defineå®šä¹‰çš„å®å¯ä»¥å®ç°ç±»ä¼¼å‡½æ•°çš„åŠŸèƒ½ï¼Œä¸”ä¸ä¼šå¸¦æ¥å‡½æ•°è°ƒç”¨çš„å¼€é”€ï¼Œä½†æ˜¯å®ä¹Ÿå­˜åœ¨å¾ˆå¤§çš„ç¼ºé™·\nä¾‹å¦‚ï¼š\n  1  #define CALL_WITH_MAX(a,b) f((a)\u0026gt;(b)?(a):(b))   ç¼–å†™å®æ—¶åº”ç»™æ¯ä¸ªå˜é‡åŠ æ‹¬å·ï¼Œä½†å³ä½¿åŠ äº†æ‹¬å·è¿˜æ˜¯ä¼šæœ‰è‡ªå¢è‡ªå‡æ¬¡æ•°é—®é¢˜ï¼Œå¦‚ï¼š\n1 2 3  int a=5,b=0; CALL_WITH_MAX(++a,b);\t// aè¢«ç´¯åŠ ä¸¤æ¬¡ CALL_WITH_MAX(++a,b+10);\t// aè¢«ç´¯åŠ ä¸€æ¬¡   ç”¨constä¿®é¥°å¸¸é‡\n  constä¿®é¥°çš„å¸¸é‡åç§°èƒ½å¤Ÿè¢«ç¼–è¯‘å™¨çœ‹åˆ°ï¼Œä¼šè¿›å…¥ç¬¦å·è¡¨\n  constä¿®é¥°å¸¸é‡æŒ‡é’ˆï¼Œé€šå¸¸å®šä¹‰åœ¨å¤´æ–‡ä»¶ä¸­ï¼Œå¯¹äºå¸¸é‡å­—ç¬¦ä¸²ï¼Œæœ€å¥½å¦‚ä¸‹å®šä¹‰ï¼š\n  1 2  const char* const authorName = \u0026#34;Scott Meyers\u0026#34;;\t// char*-base const std::string authorName = \u0026#34;Scott Meyers\u0026#34;;\t// string class    constä¿®é¥°classä¸“å±å¸¸é‡ï¼Œä¸ºäº†å°†å¸¸é‡çš„ä½œç”¨åŸŸé™åˆ¶åœ¨classå†…ï¼Œéœ€è¦è®©å®ƒæˆä¸ºclassçš„ä¸€ä¸ªæˆå‘˜ï¼Œä¸”å£°æ˜ä¸ºstaticä»¥ä¿è¯æ­¤å¸¸é‡è‡³å¤šåªæœ‰ä¸€ä»½å®ä½“ï¼Œä¾‹å¦‚ï¼š  1 2 3 4 5 6 7 8 9 10 11 12 13  class GamePlayer{ private: static const int NumTurns = 5;\t// å£°æ˜å¹¶å®šä¹‰ \tint scores[NumTurns]; ... }; class CostEstimate{ private: static const double FudgeFactor;\t// å¤´æ–‡ä»¶å†…å£°æ˜ \t... }; const double ConstEstimate::FudgeFactor = 1.35;\t// åœ¨å®ç°æ–‡ä»¶ä¸­å®šä¹‰   ç”¨enumä¿®é¥°å¸¸é‡\n  enumæ¯”constæ›´æ¥è¿‘äº#defineï¼Œconstä¿®é¥°çš„å¸¸é‡å¯å–åœ°å€è€Œenumä¿®é¥°çš„ä¸èƒ½ï¼ˆå¯ç”¨äºä¿æŠ¤å¸¸é‡ï¼‰ï¼Œenumä¸ä¼šé€ æˆä¸å¿…è¦çš„å†…å­˜ç”³è¯·ï¼ˆé¿å…ä»–äººå¯¹è¯¥å¸¸é‡å–åœ°å€å–æŒ‡é’ˆï¼‰\n  enumæ˜¯æ¨¡æ¿å…ƒç¼–ç¨‹çš„åŸºç¡€æŠ€æœ¯\n  ä¸¾ä¾‹ï¼š\n  1 2 3 4 5 6  class GamePlayer{ private: enum{ NumTurns = 5 }; int scores[NumTurns]; ... };   ç”¨inlineä»£æ›¿å®\n ä½¿ç”¨inlineå…³é”®å­—å®šä¹‰å†…è”å‡½æ•°ï¼Œä¾‹å¦‚ï¼š  1 2 3 4 5  template\u0026lt;typename T\u0026gt; inline void callWithMax(const T\u0026amp; a, const T\u0026amp; b) { f(a\u0026gt;b?a:b); }   Item 3: Use const whenever possible constä¿®é¥°æŒ‡é’ˆä¸å¸¸é‡çš„ç”¨æ³•\n å½“conståœ¨æ˜Ÿå·å·¦ä¾§æ—¶ï¼ŒæŒ‡é’ˆæŒ‡å‘çš„ä¸ºå¸¸å€¼ å½“conståœ¨æ˜Ÿå·å³ä¾§æ—¶ï¼ŒæŒ‡é’ˆæœ¬èº«ä¸ºå¸¸å€¼ å½“constæ˜Ÿå·ä¸¤ä¾§éƒ½æœ‰æ—¶ï¼ŒæŒ‡é’ˆæœ¬èº«åŠå…¶æŒ‡å‘å‡ä¸ºå¸¸å€¼ å½“æŒ‡é’ˆæŒ‡å‘å¸¸å€¼æ—¶ï¼Œconståœ¨ç±»å‹åå‰åæ„æ€ç›¸åŒ  1 2 3 4 5 6 7  char greeting[] = \u0026#34;Hello\u0026#34;; char* p = greeting;\t// non-const pointer, non-const data const char* p = greeting;\t// non-const pointer, const data char* const p = greeting;\t// const pointer, non-const data const char* const p = greeting;\t// const pointer, const data void f1(const Widget *pw); void f1(Widget const *pw);\t// ä¸¤ä¸ªæ„æ€ç›¸åŒ   STLè¿­ä»£å™¨çš„const\n const iteratorç›¸å½“äºT* const const_iteratorç›¸å½“äºconst T*  1 2 3 4 5 6 7 8  std::vector\u0026lt;int\u0026gt; vec; ... const std::vector\u0026lt;int\u0026gt;::iterator iter = vec.begin();\t// ç›¸å½“äºT* const *iter = 10;\t// æ­£ç¡® ++iter;\t//é”™è¯¯ std::vector\u0026lt;int\u0026gt;::const_iterator cIter = vec.begin();\t// ç›¸å½“äºconst T* *cIter = 10;// é”™è¯¯ ++cIter;\t// æ­£ç¡®   constä¿®é¥°å‡½æ•°è¿”å›å€¼\n é™ä½å®¢æˆ·é”™è¯¯è€Œé€ æˆçš„æ„å¤–ï¼Œåˆä¸è‡³äºæ”¾å¼ƒå®‰å…¨æ€§å’Œé«˜æ•ˆæ€§  1 2  class Rational{...} const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs);    è‹¥ä¸åŠ constï¼Œåˆ™é”™è¯¯(a*b)=cï¼ˆå®é™…æ˜¯æƒ³è¿›è¡Œæ¯”è¾ƒ(a*b)==cï¼‰å°†éš¾ä»¥è¢«å‘ç°  constä¿®é¥°æˆå‘˜å‡½æ•°\n  ç›®çš„ï¼š\n ä½¿å¾—classæ¥å£æ¯”è¾ƒå®¹æ˜“è¢«ç†è§£ ä½¿â€œæ“ä½œconstå¯¹è±¡â€æˆä¸ºå¯èƒ½    ä¸¾ä¾‹ï¼š\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class TextBlock{ public: ... const char\u0026amp; operator[](std::size_t position) const { return text[position]; }\t// è¿”å›constå¯¹è±¡  char\u0026amp; operator[](std::size_t position) { return text[position]; }\t// è¿”å›non-constå¯¹è±¡ private: std::string text; }; // usage TextBlock tb(\u0026#34;Hello\u0026#34;); TextBlock ctb(\u0026#34;Hello\u0026#34;); std::cout\u0026lt;\u0026lt;tb[0];\t// æ­£ç¡®ï¼Œè¯»non-const tb[0]=\u0026#39;x\u0026#39;;\t// æ­£ç¡®ï¼Œå†™non-const std::cout\u0026lt;\u0026lt;ctb[0];\t// æ­£ç¡®ï¼Œè¯»const ctb[0]=\u0026#39;x\u0026#39;;\t// é”™è¯¯ï¼Œå†™const     Bitwise-constness \u0026amp; Logical-constness\n  Bitwise-constnessï¼šæˆå‘˜å‡½æ•°åªæœ‰åœ¨ä¸æ›´æ”¹å¯¹è±¡çš„ä»»ä½•æˆå‘˜å˜é‡ï¼ˆstaticé™¤å¤–ï¼‰æ—¶æ‰å¯è¯´æ˜¯const\n  Logical-constnessï¼šä¸€ä¸ªconstæˆå‘˜å‡½æ•°å¯ä»¥ä¿®æ”¹å®ƒæ‰€å¤„ç†å¯¹è±¡å†…çš„æŸäº›bitsï¼Œä½†åªæœ‰åœ¨å®¢æˆ·ç«¯ä¾¦æµ‹ä¸å‡ºæ¥çš„æƒ…å†µä¸‹æ‰æ»¡è¶³const\n ä½¿ç”¨mutableå…³é”®å­—ï¼Œä½¿å¾—æˆå‘˜å˜é‡èƒ½å¤Ÿåœ¨constæˆå‘˜å‡½æ•°å†…è¢«ä¿®æ”¹ï¼Œä¾‹å¦‚ï¼š      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class CTextBlock{ public: ... std::size_t length() const; private: char* pText; mutable std::size_t textLength; mutable bool lengthIsValid; }; std::size_t CTextBlock::length() const { if(!lengthIsValid) { textLength = std::strlen(pText); lengthIsValid = true; } return textLength; }   constå’Œnon-constæˆå‘˜å‡½æ•°é¿å…é‡å¤\n ä½¿ç”¨ç±»å‹è½¬æ¢ ä¸¾ä¾‹ï¼š  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class TextBlock{ public: ... const char\u0026amp; operator[](std::size_t position) const { ... ... ... return text[position]; } char\u0026amp; operator[](std::size_t position) { return const_cast\u0026lt;char\u0026amp;\u0026gt;(static_cast\u0026lt;const TextBlock\u0026amp;\u0026gt;(*this)[position]); } ... };    static_caståŠ constå¼ºåˆ¶å®‰å…¨è½¬æ¢ï¼ˆé˜²æ­¢å‡ºç°é€’å½’è°ƒç”¨ï¼‰ const_castç§»é™¤const  Item 4: Make sure that objects are initialized before they\u0026rsquo;re used å†…ç½®ç±»å‹çš„åˆå§‹åŒ–\n å¯¹äºæ— ä»»ä½•æˆå‘˜çš„å†…ç½®ç±»å‹ï¼Œæ‰‹å·¥è¿›è¡Œåˆå§‹åŒ– ä¸¾ä¾‹ï¼š  1 2 3 4 5  int x = 0;\t// æ‰‹å·¥åˆå§‹åŒ–int const char* text = \u0026#34;A C-style string\u0026#34;;\t// å¯¹æŒ‡é’ˆè¿›è¡Œæ‰‹å·¥åˆå§‹åŒ–  double d; std::cin\u0026gt;\u0026gt;d;\t//è¯»å–è¾“å…¥æµä»¥åˆå§‹åŒ–   æˆå‘˜å¯¹è±¡çš„åˆå§‹åŒ–\n  å†…ç½®ç±»å‹ä»¥å¤–çš„ä»»ä½•ä¸œè¥¿ï¼Œåˆå§‹åŒ–ç”±æ„é€ å‡½æ•°constructorså®Œæˆ\n  æˆå‘˜å¯¹è±¡çš„åˆå§‹åŒ–ï¼šæˆå‘˜åˆå€¼åˆ—è¡¨ï¼ˆmember initialization listï¼‰\n ä¸¾ä¾‹ï¼š    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class PhoneNumber{...}; class ABEntry{ public: ABEntry(const std::string\u0026amp; name, const std::string\u0026amp; address, const std::list\u0026lt;PhoneNumber\u0026gt;\u0026amp; phones); private: std::string theName; std::string theAddress; std::list\u0026lt;PhoneNumber\u0026gt; thePhones; int numTimesConsulted; }; /* ABEntry::ABEntry(const std::string\u0026amp; name, const std::string\u0026amp; address, const std::list\u0026lt;PhoneNumber\u0026gt;\u0026amp; phones) { theName = name; theAddress = address; thePhones = phones; numTimesConsulted = 0; }\t// èµ‹å€¼ */ ABEntry::ABEntry(const std::string\u0026amp; name, const std::string\u0026amp; address, const std::list\u0026lt;PhoneNumber\u0026gt;\u0026amp; phones) :theName(name), theAddress(address), thePhones(phones), numTimesConsulted(0) { }\t// åˆå§‹åŒ–    èµ‹å€¼ vs åˆå§‹åŒ–  èµ‹å€¼ï¼šé¦–å…ˆè°ƒç”¨é»˜è®¤æ„é€ å‡½æ•°ä¸ºæˆå‘˜å˜é‡èµ‹åˆå€¼ï¼Œç„¶åç«‹åˆ»å†å¯¹å®ƒä»¬èµ‹æ–°å€¼ ä½¿ç”¨æˆå‘˜åˆå€¼åˆ—è¡¨é¿å…èµ‹å€¼çš„é—®é¢˜ï¼Œæ•ˆç‡è¾ƒé«˜   æ²¡æœ‰åœ¨æˆå‘˜åˆå€¼åˆ—è¡¨ä¸­æŒ‡å®šåˆå€¼çš„æˆå‘˜å˜é‡ï¼š  å¯¹äºç”¨æˆ·è‡ªå®šä¹‰ç±»å‹çš„æˆå‘˜å˜é‡ï¼Œå°†ä¼šè‡ªåŠ¨è°ƒç”¨å…¶è‡ªèº«çš„é»˜è®¤æ„é€ å‡½æ•° å¯¹äºå†…ç½®ç±»å‹çš„æˆå‘˜å˜é‡ï¼Œåˆ™å¯èƒ½å‡ºç°éšæœºç»“æœï¼Œå¸¦æ¥é—®é¢˜    åˆå§‹åŒ–é¡ºåºé—®é¢˜\n  ä¸€ä¸ªæºæ–‡ä»¶åŠå…¶æ‰€æœ‰#includeçš„æ–‡ä»¶ç§°ä¸ºä¸€ä¸ªç¼–è¯‘å•å…ƒtranslation unit\n  ä¸¤ç§staticå¯¹è±¡ï¼šå‡½æ•°å†…çš„staticå¯¹è±¡ç§°ä¸ºlocal staticå¯¹è±¡ï¼Œå…¶ä»–staticå¯¹è±¡ç§°ä¸ºnon-local staticå¯¹è±¡\n  å¦‚æœä¸€ä¸ªç¼–è¯‘å•å…ƒçš„non-local staticå¯¹è±¡çš„åˆå§‹åŒ–ç”¨åˆ°å¦å¤–ä¸€ä¸ªä¸åŒçš„ç¼–è¯‘å•å…ƒä¸­çš„non-local staticå¯¹è±¡ï¼Œåˆ™è¿™ä¸ªè¢«ç”¨åˆ°çš„å¯¹è±¡å¯èƒ½æœªè¢«åˆå§‹åŒ–\n C++å¯¹å®šä¹‰ä¸åŒç¼–è¯‘å•å…ƒä¸­çš„non-local staticå¯¹è±¡çš„åˆå§‹åŒ–é¡ºåºæ²¡æœ‰æ˜ç¡®å®šä¹‰    è§£å†³æ–¹æ³•ï¼šå°†æ¯ä¸ªnon-local staticå¯¹è±¡ç§»åŠ¨åˆ°å„è‡ªçš„å‡½æ•°ï¼Œè¿™äº›å‡½æ•°å†…æŠŠå¯¹è±¡å£°æ˜ä¸ºstaticï¼Œå‡½æ•°çš„è¿”å›åŒ…å«å®ƒä»¬åŒ…å«çš„å¯¹è±¡çš„å¼•ç”¨ã€‚å®¢æˆ·ç«¯è°ƒç”¨å‡½æ•°è€Œä¸æ˜¯ç›´æ¥ä½¿ç”¨å¯¹è±¡ï¼Œè¿™æ ·ä¸€æ¥å°†non-local staticå¯¹è±¡è½¬åŒ–ä¸ºlocal staticå¯¹è±¡ï¼ˆå®é™…ä¸Šå°±æ˜¯è®¾è®¡æ¨¡å¼ä¸­çš„å•ä¾‹æ¨¡å¼ï¼‰\n åŸç†ï¼šC++ä¿è¯å‡½æ•°å†…çš„local-staticå¯¹è±¡ä¼šåœ¨\u0026quot;è¯¥å‡½æ•°è¢«è°ƒç”¨æœŸé—´\u0026quot;ä»¥åŠ\u0026quot;é¦–æ¬¡é‡åˆ°è¯¥å¯¹è±¡çš„å®šä¹‰å¼\u0026quot;æ—¶è¢«åˆå§‹åŒ–    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class FileSystem{...}; FileSystem\u0026amp; tfs() { static FileSystem fs; return fs; } class Directory{...}; Directory::Directory(params) { ... std::size_t disks = tfs().numDisks(); ... } Directory\u0026amp; tempDir() { static Directory td; return td; }    è¿™ç§æ–¹æ³•åœ¨å¤šçº¿ç¨‹ç³»ç»Ÿå†…å…·æœ‰ä¸ç¡®å®šæ€§ï¼Œè§£å†³æ–¹æ³•ï¼šå¯ä»¥åœ¨ç¨‹åºçš„å•çº¿ç¨‹å¯åŠ¨éƒ¨åˆ†æœŸé—´æ‰‹åŠ¨è°ƒç”¨æ‰€æœ‰è¿”å›å¼•ç”¨çš„å‡½æ•°ï¼Œæ¶ˆé™¤ä¸åˆå§‹åŒ–ç›¸å…³çš„ç«äº‰å½¢åŠ¿  å°ç»“\nåˆå§‹åŒ–ä¸‰éƒ¨æ›²:\n æ‰‹åŠ¨åˆå§‹åŒ–å†…ç½®å‹non-memberå¯¹è±¡ ä½¿ç”¨æˆå‘˜åˆå€¼åˆ—è¡¨member initialization listså¤„ç†æˆå‘˜å¯¹è±¡åˆå§‹åŒ– é’ˆå¯¹åˆå§‹åŒ–æ¬¡åºä¸ç¡®å®šæ€§åŠ å¼ºè®¾è®¡  ","description":"ã€ŠEffective C++å­¦ä¹ ç¬”è®°ç¬¬ä¸€ç« ã€‹","id":23,"section":"note","tags":["Effective C++","C++"],"title":"Chapter 1: Accustoming Yourself to C++","uri":"https://chaphlagical.github.io/zh/note/effectivecpp/ch1/"},{"content":"1. æ’å€¼ 1.1. æ’å€¼é—®é¢˜çš„æè¿° 1.1.1. é—®é¢˜çš„ä¸€èˆ¬å½¢å¼   å¯»æ‰¾å®šä¹‰åŸŸ$\\Omega\\subseteq \\mathbb R^d $ï¼Œå€¼åŸŸ$\\mathbb R$ä¸Šçš„å‡½æ•°$f:\\Omega\\rightarrow\\mathbb R$\n  åŸºå‡½æ•°é›†åˆï¼š$B={b_1,\\cdots,b_n}$ï¼Œ$b_i:\\Omega\\rightarrow\\mathbb R$\n  å°†$f$è¡¨ç¤ºä¸ºåŸºå‡½æ•°çš„çº¿æ€§ç»„åˆ\n  $$\nf_\\lambda(x)=\\sum\\limits_{k=0}^n\\lambda_ib_i(x)\n$$\nâ€‹\tå…¶ä¸­ï¼Œ$f$ç”±$\\lambda=\\begin{pmatrix}\\lambda_1 \\\\ \\vdots\\\\ \\lambda_n\\end{pmatrix}$å”¯ä¸€ç¡®å®š\n å‡½æ•°å€¼${(x_1,y_1), \\cdots,(x_n,y_n)}$ï¼Œ$(x_i,y_i)\\in \\mathbb R^d\\times\\mathbb R$ ç›®æ ‡æ‰¾åˆ°$\\lambda$ä½¿å¾—$f_\\lambda(x_i)=y_i$å¯¹æ‰€æœ‰$i$æˆç«‹  1.1.2. æ’å€¼é—®é¢˜åº”ç”¨ä¸¾ä¾‹ æœ€ç®€å•çš„å…‰æ»‘æ›²çº¿æ›²é¢å»ºæ¨¡é—®é¢˜ï¼š\n ç»™å®šæ›²çº¿æˆ–æ›²é¢ä¸Šçš„ä¸€ç»„ç‚¹ é€‰æ‹©ä¸€ç»„å¯å¼ æˆåˆé€‚å‡½æ•°ç©ºé—´çš„åŸºå‡½æ•°  å…‰æ»‘åŸºå‡½æ•° ä»»æ„çº¿æ€§ç»„åˆä¹Ÿä¸ºå…‰æ»‘å‡½æ•°   æ‰¾åˆ°ä¸€ä¸ªçº¿æ€§ç»„åˆèƒ½å¤Ÿä½¿å¾—æ›²çº¿æˆ–æ›²é¢èƒ½æ’å€¼ç»™å®šç‚¹  1.2. æ’å€¼é—®é¢˜çš„æ±‚è§£ æ„é€ çº¿æ€§æ–¹ç¨‹ç»„ï¼š\n åœ¨æ•°æ®ç‚¹$x_i$ä¸Šè®¡ç®—åŸºå‡½æ•°ï¼š  $$\n\\forall i\\in{1,\\cdots,n}:\\sum\\limits_{i=1}^n\\lambda_ib_i(x_i)=y_i\n$$\n å†™æˆçŸ©é˜µå½¢å¼ï¼š  $$\n\\begin{pmatrix}\nb_1(x_1)\u0026amp;\\cdots\u0026amp;b_n(x_1)\\\\\n\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\\nb_1(x_n)\u0026amp;\\cdots\u0026amp;b_n(x_n)\n\\end{pmatrix}\n\\begin{pmatrix}\n\\lambda_1\\\\ \\vdots\\\\ \\lambda_n\n\\end{pmatrix}=\n\\begin{pmatrix}\ny_1\\\\ \\vdots\\\\ y_n\n\\end{pmatrix}\n$$\n1.2.1. å¤šé¡¹å¼æ’å€¼ç¤ºä¾‹   ä½¿ç”¨å¤šé¡¹å¼åŸº$B={1,x,x^2,x^3,\\cdots,x^{n-1}}$\n  æ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„\n  $$\n\\begin{pmatrix}\n1\u0026amp;x_1\u0026amp;\\cdots\u0026amp;x_1^{n-1}\\\\\n1\u0026amp;x_2\u0026amp;\\cdots\u0026amp;x_2^{n-1}\\\\\n\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\\n1\u0026amp;x_n\u0026amp;\\cdots\u0026amp;x_n^{n-1}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\lambda_1\\\\ \\lambda_2\\\\ \\vdots\\\\ \\lambda_n\n\\end{pmatrix}=\n\\begin{pmatrix}\ny_1\\\\ y_2\\\\ \\vdots\\\\ y_n\n\\end{pmatrix}\n$$\n1.2.2. å¤šé¡¹å¼æ’å€¼å­˜åœ¨çš„é—®é¢˜  ç³»ç»ŸçŸ©é˜µç¨ å¯† ä¾èµ–äºåŸºå‡½æ•°é€‰å–ï¼ŒçŸ©é˜µå¯èƒ½ç—…æ€ï¼Œå¯¼è‡´éš¾ä»¥æ±‚è§£ï¼ˆæ±‚é€†ï¼‰  ç—…æ€é—®é¢˜\n  è¾“å…¥æ•°æ®çš„ç»†å¾®å˜åŒ–å¯¼è‡´è¾“å‡ºï¼ˆè§£ï¼‰çš„å‰§çƒˆå˜åŒ–\n  å°†çº¿æ€§æ–¹ç¨‹çœ‹æˆç›´çº¿ï¼ˆè¶…å¹³é¢ï¼‰\n å½“ç³»ç»Ÿç—…æ€æ—¶ï¼Œç›´çº¿ç¼–ç¨‹è¿‘ä¼¼å¹³è¡Œ æ±‚è§£ï¼ˆå³ç›´çº¿æ±‚äº¤ï¼‰å˜å¾—å›°éš¾ã€ä¸ç²¾ç¡®    ä¸¾ä¾‹ï¼š\n  è€ƒè™‘äºŒå…ƒæ–¹ç¨‹ç»„\n$x_1+0.5x_2=1.5$ å’Œ $0.667x_1+0.333x_2=1$\nè§£ä¸º$(1,1)$\n  å¯¹ç¬¬äºŒä¸ªæ–¹ç¨‹å³è¾¹é¡¹æ‰°åŠ¨0.001\n$x_1+0.5x_2=1.5$ å’Œ $0.667x_1+0.333x_2=0.999$\nè§£ä¸º$(0,3)$\n  å¯¹çŸ©é˜µç³»æ•°è¿›è¡Œæ‰°åŠ¨\n$x_1+0.5x_2=1.5$ å’Œ $0.667x_1+0.334x_2=0.999$\nè§£ä¸º$(2,-1)$\n    1.2.3. çŸ©é˜µæ¡ä»¶æ•° $$\n\\kappa_2(A)=\\dfrac{\\max\\limits_{x\\neq 0}\\dfrac{|Ax|}{|x|}}{\\min\\limits_{x\\neq 0}\\dfrac{|Ax|}{|x|}}\n$$\n ç­‰äºæœ€å¤§ç‰¹å¾å€¼å’Œæœ€å°ç‰¹å¾å€¼ä¹‹é—´çš„æ¯”ä¾‹ æ¡ä»¶æ•°å¤§æ„å‘³ç€åŸºå…ƒä¹‹é—´æœ‰å¤ªå¤šç›¸å…³æ€§  è€ƒè™‘å¤šé¡¹å¼æ’å€¼\n å¤šé¡¹å¼æ’å€¼é—®é¢˜æ˜¯ç—…æ€çš„  å¯¹äºç­‰è·åˆ†å¸ƒçš„æ•°æ®ç‚¹$x_i$ï¼ŒèŒƒå¾·è’™çŸ©é˜µçš„æ¡ä»¶æ•°éšç€æ•°æ®ç‚¹æ•°$n$å‘ˆæŒ‡æ•°çº§å¢é•¿ï¼ˆå¤šé¡¹å¼æœ€é«˜æ¬¡æ•°ä¸º$n-1$ï¼‰    åŸå› ï¼š\n  å¹‚ï¼ˆå•é¡¹å¼ï¼‰å‡½æ•°åŸº\n å¹‚å‡½æ•°ä¹‹é—´å·®åˆ«éšæ¬¡æ•°å¢åŠ è€Œå‡å° ä¸åŒå¹‚å‡½æ•°ä¹‹é—´å”¯ä¸€å·®åˆ«ä¸ºå¢é•¿é€Ÿåº¦    1.2.4. å‡½æ•°äº’ç›¸æŠµæ¶ˆ   å¯¹äºå•é¡¹å¼å‡½æ•°åŸºï¼Œä»å·¦åˆ°å³ï¼Œé¦–å…ˆç”±å¸¸å‡½æ•°1ä¸»å®°ï¼Œæ¥ç€$x$å¢é•¿æœ€å¿«ï¼Œæ¥ç€$x^2$å¢é•¿æœ€å¿«ï¼Œæ¥ç€$x^3$å¢é•¿æœ€å¿«\u0026hellip;\n  å¥½çš„åŸºå‡½æ•°ä¸€èˆ¬éœ€è¦ç³»æ•°äº¤æ›¿ä»¥è¾¾åˆ°å‡½æ•°çš„äº’ç›¸æŠµæ¶ˆ\n  è§£å†³æ–¹æ³•ï¼š\n ä½¿ç”¨æ­£äº¤å¤šé¡¹å¼åŸº æ­£äº¤åŸºè·å¾—æ–¹æ³•ï¼šGram-Schmidtæ­£äº¤åŒ–  1.3. æ‹‰æ ¼æœ—æ—¥æ’å€¼æ–¹æ³• æ‹‰æ ¼æœ—æ—¥æ’å€¼æ–¹æ³•é¿å…æ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„\n1.3.1. æ‹‰æ ¼æœ—æ—¥æ’å€¼çš„ä¸€èˆ¬å½¢å¼   æ„é€ æ’å€¼é—®é¢˜çš„é€šç”¨è§£\n  ç»™å®š$n+1$ä¸ªç‚¹${(x_0,y_0),\\cdots,(x_n,y_n) }$ï¼Œå¯»æ‰¾ä¸€ç»„æ¬¡æ•°ä¸º$n$çš„å¤šé¡¹å¼åŸºå‡½æ•°$l_i$ä½¿å¾—\n$$\nl_i(x_j)=\\begin{cases}\n1,\u0026amp;è‹¥i=j\\\n0,\u0026amp;è‹¥i\\neq j\n\\end{cases}\n$$\n    æ’å€¼é—®é¢˜çš„è§£ä¸º\n$$\nP(x)=y_0l_0(x)+y_1l_1(x)+\\cdots+y_nl_n(x)=\\sum\\limits_{i=0}^ny_il_i(x)\n$$\n  1.3.2. æ‹‰æ ¼æœ—æ—¥å¤šé¡¹å¼çš„è®¡ç®—   $n$é˜¶å¤šé¡¹å¼ï¼Œä¸”æœ‰ä»¥ä¸‹$n$ä¸ªæ ¹\n$$\nx_0,x_1,x_2,\\cdots,x_{i-1},x_{i+1}\\cdots,x_n\n$$\n  å¯è¡¨ç¤ºä¸º\n$$\n\\begin{align}\nl_i(x)\u0026amp;=C_i(x-x_0)(x-x_1)\\cdots(x-x_{i-1})(x-x_{i+1})\\cdots(x-x_n)\\\\\n\u0026amp;=C_i\\prod_{j\\neq i}(x-x_j)\n\\end{align}\n$$\n  ç”±$l_i(x_i)=1$ï¼Œå¯å¾—\n$$\n1=C_i\\prod_{j\\neq i}(x_i-x_j)\\Rightarrow C_i=\\dfrac{1}{\\prod_{j\\neq i}(x_i-x_j)}\n$$\n  æœ€ç»ˆçš„å¤šé¡¹å¼åŸºå‡½æ•°ä¸º\n$$\nl_i(x)=\\dfrac{\\prod_{j\\neq i}(x-x_j)}{\\prod_{j\\neq i}(x_i-x_j)}\n$$\nå¤šé¡¹å¼$l_i(x)$ç§°ä¸ºæ‹‰æ ¼æœ—æ—¥å¤šé¡¹å¼\n  1.3.3. æ‹‰æ ¼æœ—æ—¥æ’å€¼ vs å•é¡¹å¼åŸºæ’å€¼ äº‹å®ä¸Šï¼Œç»™å®šåŒä¸€ç»„è¾“å…¥ç‚¹ï¼Œåˆ©ç”¨æ‹‰æ ¼æœ—æ—¥å¤šé¡¹å¼å’Œåˆ©ç”¨èŒƒå¾·è’™çŸ©é˜µï¼ˆå•é¡¹å¼åŸºï¼‰è¿›è¡Œæ’å€¼æ‰€å¾—åˆ°çš„è§£å®Œå…¨ç›¸åŒ\n å‡è®¾è§£ä¸åŒã€‚è®°ä¸¤ä¸ªè§£çš„å·®åˆ«å¤šé¡¹å¼ä¸º$R_n$ï¼Œ$R_n$é˜¶æ•°è‡³å¤šä¸º$n$ é‚£ä¹ˆ$R_n(x_i)=0$ï¼Œ$i=0,1,\\cdots,n$ï¼Œ$x_i$ä¸ºä¸åŒæ’å€¼ç‚¹ã€‚å› æ­¤$R_n$æ˜¯æœ‰$n+1$ä¸ªæ ¹çš„$n$é˜¶å¤šé¡¹å¼ï¼Œå› æ­¤$R_n=0$  1.3.4. å¤šé¡¹å¼æ’å€¼åˆ†æ  å¤šé¡¹å¼æ’å€¼ä¸ç¨³å®š æ§åˆ¶ç‚¹çš„å¾®å°å˜åŒ–å¯å¯¼è‡´å®Œå…¨ä¸åŒçš„ç»“æœ æŒ¯è¡ç°è±¡ï¼šå¤šé¡¹å¼éšç€æ’å€¼ç‚¹æ•°ï¼ˆå¯ä»¥æ˜¯ç»†å¾®çš„ï¼‰å¢åŠ è€Œæ‘†åŠ¨  è§£å†³æ–¹æ³•ï¼š\n ä½¿ç”¨æ›´å¥½çš„åŸºå‡½æ•°åšæ’å€¼ï¼Œä¾‹å¦‚ï¼šåˆ†ç‰‡å¤šé¡¹å¼  2. é€¼è¿‘ 2.1. åŠ¨æœº 2.1.1. ä½¿ç”¨é€¼è¿‘çš„åŸå›   æ•°æ®ç‚¹å«å™ªå£°ï¼ˆé‡‡æ ·ï¼‰ æ›´ç´§å‡‘çš„è¡¨è¾¾ è®¡ç®—ç®€å•  2.1.2. å¸¸ç”¨çš„é€¼è¿‘å‡½æ•°  å¤šé¡¹å¼ æœ‰ç†å‡½æ•°ï¼ˆå¤šé¡¹å¼å•†ï¼‰ ä¸‰è§’å‡½æ•°  2.2. å¤šé¡¹å¼é€¼è¿‘ 2.2.1. ä¸‡èƒ½é€¼è¿‘å®šç† åˆå«Weierstrasså®šç†ï¼š\nä»¤$f$ä¸ºé—­åŒºé—´$[a,b]$ä¸Šä»»æ„è¿ç»­å‡½æ•°ï¼Œåˆ™å¯¹ä»»æ„ç»™å®š$\\varepsilon$ï¼Œå­˜åœ¨$n$å’Œå¤šé¡¹å¼$P_n$ä½¿å¾—\n$$\n|f(x)-P_n(x)|\u0026lt;\\varepsilon,\\forall x\\in[a,b]\n$$\nWeierstrassåªè¯æ˜äº†å­˜åœ¨æ€§ï¼Œè€Œæœªç»™å‡ºå¤šé¡¹å¼\n2.2.2. Bernsteinå¤šé¡¹å¼é€¼è¿‘ Bernsteinå¤šé¡¹å¼æ„é€ å®šç†\nå¯¹$[0,1]$åŒºé—´ä¸Šä»»æ„è¿ç»­å‡½æ•°$f(x)$å’Œä»»æ„æ­£æ•´æ•°$n$ï¼Œä»¥ä¸‹ä¸ç­‰å¼å¯¹æ‰€æœ‰$x\\in[0,1]$æˆç«‹\n$$\n|f(x)-B_n(f,x)|\u0026lt;\\dfrac{9}{4}m_{f,n}\n$$\n $m_{f,n}=\\mathop {\\mathrm {lower\\ upper\\ bound}}\\limits_{y_1,y_2\\in[0,1]ä¸”|y_1-y_2|\u0026lt;\\frac{1}{\\sqrt{n}}}|f(y_1)-f(y_2)|$ $B_n(f,x)=\\sum_{j=0}^nf(x_j)b_{n,j}(x)$ï¼Œå…¶ä¸­$x_j$ä¸º$[0,1]$ä¸Šç­‰è·é‡‡æ ·ç‚¹ $b_{n,j}=\\begin{pmatrix}n\\\\ j\\end{pmatrix}x^j(1-x)^{n-j}$ä¸ºBernsteinå¤šé¡¹å¼  Bernsteinå¤šé¡¹å¼é€¼è¿‘ç‰¹ç‚¹\n é€¼è¿‘ç»“æœä¼˜ç§€ï¼Œä½†éœ€è¦é«˜é˜¶ è®¡ç®—æ˜‚è´µ å®¹æ˜“å¸¦æ¥è¯¯å·®  2.3. æœ€å°äºŒä¹˜é€¼è¿‘ 2.3.1. é€¼è¿‘é—®é¢˜  ç»™å®šä¸€ç»„çº¿æ€§æ— å…³çš„è¿ç»­å‡½æ•°é›†åˆ$B={b_1,\\cdots,b_n}$å’Œä¸€ç»„ç»“ç‚¹${(x_1,y_1),\\cdots,(x_m,y_m)}$ï¼Œå…¶ä¸­$m\u0026gt;n$ åœ¨$B$å¼ æˆç©ºé—´ä¸­å¯»æ‰¾å¯¹ç»“ç‚¹é€¼è¿‘æœ€å¥½çš„å‡½æ•°$f\\in\\mathrm{span}(B)$  2.3.2. æœ€ä½³é€¼è¿‘çš„å®šä¹‰ æœ€å°äºŒä¹˜é€¼è¿‘\n$$\n\\mathop{\\mathrm{argmin}}\\limits_{f\\in\\mathrm{span(B)}}\n\\sum\\limits_{j=1}^m(f(x_j)-y_j)^2\n$$\n$$\n\\begin{align}\n\\sum\\limits_{j=1}^m(f(x_j)-y_j)^2\u0026amp;=\\sum\\limits_{j=1}^m\\Big(\\sum\\limits_{i=1}^n\\lambda_ib_i(x_j)-y_j\\Big)^2\\\\\n\u0026amp;=(M\\pmb\\lambda-\\pmb y)^T(M\\pmb \\lambda-\\pmb y)\\\\\n\u0026amp;=\\pmb y^T\\pmb y-2\\pmb y^TM\\pmb \\lambda+\\pmb \\lambda^TM^TM\\pmb \\lambda\n\\end{align}\n$$\nå…¶ä¸­ï¼Œ$\\pmb \\lambda=(\\lambda_1,\\lambda_2,\\cdots,\\lambda_n)^T$ï¼Œ$\\pmb y=(y_1,y_2,\\cdots,y_m)^T$ï¼Œ$M=\\begin{pmatrix}b_1(x_1)\u0026amp;\\cdots\u0026amp;b_n(x_1)\\\\ \\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\ b_1(x_m)\u0026amp;\\cdots\u0026amp;b_n(x_m) \\end{pmatrix}$\n2.3.3. æœ€å°äºŒä¹˜è§£   å…³äº$\\pmb\\lambda$çš„äºŒæ¬¡å¤šé¡¹å¼\n$$\n\\pmb\\lambda^TM^TM\\pmb\\lambda-2\\pmb y^TM\\pmb \\lambda+\\pmb y^T\\pmb y\n$$\n  æœ€å°è§£æ»¡è¶³\n$$\nM^TM\\pmb\\lambda=M^T\\pmb y\n$$\n  ","description":"æ’å€¼ä¸é€¼è¿‘å­¦ä¹ ç¬”è®°","id":24,"section":"note","tags":["CAGD"],"title":"CAGD(1) | æ’å€¼ä¸é€¼è¿‘","uri":"https://chaphlagical.github.io/zh/note/cagd/cagd1/"},{"content":"è¯¾å†…èµ„æ–™ ç”µå­è®¾è®¡å®è·µï¼šè¯¾ç¨‹èµ„æ–™\näººå·¥æ™ºèƒ½å¯¼è®ºï¼šè¯¾ç¨‹èµ„æ–™\nçº¿æ€§ç”µå­çº¿è·¯ï¼šè¯¾ç¨‹èµ„æ–™\næ•°å­—é€»è¾‘ç”µè·¯ï¼šè¯¾ç¨‹èµ„æ–™\næ¨¡å¼è¯†åˆ«å¯¼è®ºï¼šè¯¾ç¨‹èµ„æ–™\nè‡ªåŠ¨æ§åˆ¶åŸç†ï¼šè¯¾ç¨‹èµ„æ–™\næ‰§è¡Œå™¨æŠ€æœ¯ï¼šè¯¾ç¨‹èµ„æ–™\nè¿ç­¹å­¦åŸºç¡€ï¼šè¯¾ç¨‹èµ„æ–™\nä¼ æ„Ÿå™¨åŸç†ä¸æŠ€æœ¯ï¼šè¯¾ç¨‹èµ„æ–™\nè®¡ç®—æœºç½‘ç»œï¼šè¯¾ç¨‹èµ„æ–™ æœŸæœ«æ€»å¤ä¹ \nç°ä»£æ§åˆ¶ç†è®ºï¼šè¯¾ç¨‹èµ„æ–™ æœŸæœ«æ€»å¤ä¹ \nå¾®æœºåŸç†ä¸åµŒå…¥å¼ï¼šè¯¾ç¨‹èµ„æ–™ æœŸæœ«æ€»å¤ä¹ \nç†è®ºåŠ›å­¦ï¼šè¯¾ç¨‹èµ„æ–™ æœŸæœ«æ€»å¤ä¹ \nç³»ç»Ÿè¾¨è¯†ï¼šè¯¾ç¨‹èµ„æ–™\nå›¾åƒå¤„ç†åŸºç¡€ï¼šè¯¾ç¨‹èµ„æ–™\nå¤šåª’ä½“ç³»ç»Ÿæ¦‚è®ºï¼šè¯¾ç¨‹èµ„æ–™\nè®¡ç®—æœºå›¾å½¢å­¦ï¼šè¯¾ç¨‹èµ„æ–™ æœŸæœ«æ€»å¤ä¹ \næ•°å­¦å­¦ä¹ èµ„æº EE364a Convex Optimizationï¼šä¸»é¡µé“¾æ¥\næœºå™¨äººå­¦å­¦ä¹ èµ„æº è½¨è¿¹ä¼˜åŒ–ï¼šä¸»é¡µé“¾æ¥\næ¦‚ç‡æœºå™¨äººï¼šä¸»é¡µé“¾æ¥\näººå·¥æ™ºèƒ½å­¦ä¹ èµ„æº CSE 599W: Systems for MLï¼šä¸»é¡µé“¾æ¥\nCS231n Convolutional Neural Networks for Visual Recognitionï¼šä¸»é¡µé“¾æ¥\nè®¡ç®—æœºå›¾å½¢å­¦ Ray Tracingç³»åˆ—ï¼šä¸»é¡µé“¾æ¥\nPBRBç½‘é¡µç‰ˆï¼šä¸»é¡µé“¾æ¥\nSPHæ•™ç¨‹ï¼šä¸»é¡µé“¾æ¥\nFluid Simulation for Computer Animationï¼šä¸»é¡µé“¾æ¥\nå¸¸ç”¨çš„Githubå¼€æºé¡¹ç›® Immediate Mode GUI Frameworkï¼šDear ImGui\nImGuiçš„æ‰©å±•ï¼šimplotï¼ŒImGuiFileDialogï¼ŒImGuizmoï¼Œimgui-markdown\nImGuiçš„Pythonç‰ˆæœ¬ï¼šDearPyGuiã€pyimgui\nå¼€æºè‡ªåˆ¶æ¸¸æˆå¼•æ“ï¼šoctoonï¼ŒOverloadï¼ŒHazelï¼Œluna-Engineï¼ŒLumixEngine\nç‰©ç†å¼•æ“ï¼šbox2d\næ¨¡å‹å¯¼å…¥åº“ï¼štinyobjloaderï¼Œassimp\nLogging Systemï¼šspdlog\nè·å–æ–‡ä»¶/è·¯å¾„ä¿¡æ¯ï¼šdirent\nEntity Component Systemï¼šentt\ncmakeèµ„æºï¼šawesome-cmake\n","description":"æœ¬ç§‘è¯¾ç¨‹èµ„æ–™ï¼ˆPPTã€å¤ä¹ ï¼‰ä»¥åŠä¸€äº›æœ¬äººæ„Ÿå…´è¶£çš„å­¦ä¹ èµ„æº","id":25,"section":"posts","tags":["Resource"],"title":"èµ„æºèµ„æ–™","uri":"https://chaphlagical.github.io/zh/posts/2020-09-25-resource/"}]