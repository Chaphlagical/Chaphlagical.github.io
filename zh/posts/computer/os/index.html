<!DOCTYPE html>
<html lang="zh" dir="ltr">

<head prefix="og: http://ogp.me/ns#">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>分布式操作系统总结 – Chaf&#39;s Blog</title>
    


  
  <script defer src="/js/fuse.min.8dfbf8696f107ab8b55732efbb04c5c51576692a4a2cce6effef9f6e92d341a7.js"></script>



<script src="/js/enquire.min.aa37bdcb743826eecdae5c5d177fc7d6552340f1b4378ffaa9c82b2c6111400b.js"></script>

<script defer src="/js/lazysizes.min.498676c34eb225e85357ab0ce19c3c1244f3bd0bf595e5684d1b9d50ea4fbc42.js"></script>

<script defer src="/js/helper/getParents.min.ccd45f158c1b17849307ba913a72beac239c410f2b6e648496a79842da84e55b.js"></script>

<script defer src="/js/helper/fadeinout.min.1d13d3e810c3940e80cbba6216a1c76fbf42b5431fc83537ea6997863802362b.js"></script>

<script defer src="/js/helper/closest.min.js"></script>
  
<script>
  "use strict";

  
  
  if (window.NodeList && !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = Array.prototype.forEach;
  }

  
  if (!String.prototype.includes) {
    String.prototype.includes = function (search, start) {
      'use strict';

      if (search instanceof RegExp) {
        throw TypeError('first argument must not be a RegExp');
      }
      if (start === undefined) { start = 0; }
      return this.indexOf(search, start) !== -1;
    };
  }

  
  Document.prototype.append = Element.prototype.append = function append() {
    this.appendChild(_mutation(arguments));
  };
  function _mutation(nodes) {
    if (!nodes.length) {
      throw new Error('DOM Exception 8');
    } else if (nodes.length === 1) {
      return typeof nodes[0] === 'string' ? document.createTextNode(nodes[0]) : nodes[0];
    } else {
      var
      fragment = document.createDocumentFragment(),
      length = nodes.length,
      index = -1,
      node;

      while (++index < length) {
        node = nodes[index];

        fragment.appendChild(typeof node === 'string' ? document.createTextNode(node) : node);
      }

      return fragment;
    }
  }

  
  if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (searchString, position) {
      position = position || 0;
      return this.indexOf(searchString, position) === position;
    };
  }
  


  document.addEventListener('DOMContentLoaded', function () {
    
    var navCollapseBtn = document.querySelector('.navbar__burger');
    navCollapseBtn ? navCollapseBtn.addEventListener('click', function (e) {
      var navCollapse = document.querySelector('.navbarm__collapse');

      if (navCollapse) {
        var dataOpen = navCollapse.getAttribute('data-open');

        if (dataOpen === 'true') {
          navCollapse.setAttribute('data-open', 'false');
          navCollapse.style.maxHeight = 0;
          navCollapseBtn.classList.remove('is-active');
        } else {
          navCollapse.setAttribute('data-open', 'true');
          navCollapse.style.maxHeight = navCollapse.scrollHeight + "px";
          navCollapseBtn.classList.add('is-active');
        }
      }
    }) : null;
    


    
    var tables = document.querySelectorAll('.single__contents > table');
    for (let i = 0; i < tables.length; i++) {
      var table = tables[i];
      var wrapper = document.createElement('div');
      wrapper.className = 'table-wrapper';
      table.parentElement.replaceChild(wrapper, table);
      wrapper.appendChild(table);
    }
    


    
    var footNoteRefs = document.querySelectorAll('.footnote-ref');
    var footNoteBackRefs = document.querySelectorAll('.footnote-backref');

    footNoteRefs ? 
    footNoteRefs.forEach(function(elem, idx) {
      elem.onmouseenter = function () {
        if (navbar.classList.contains('scrolling')) {
          navbar.classList.remove('scrolling');
        }
      }

      elem.onmouseleave = function () {
        if (!navbar.classList.contains('scrolling')) {
          setTimeout(function () {
            navbar.classList.add('scrolling');
          }, 100);
        }
      }

      elem.onclick = function () {
        if (!navbar.classList.contains('scrolling')) {
          navbar.classList.remove('navbar--show');
          navbar.classList.remove('navbar--hide');
          navbar.classList.add('navbar--hide');
        }
      }
    }) : null;

    footNoteBackRefs ? 
    footNoteBackRefs.forEach(function(elem, idx) {
      elem.onmouseenter = function () {
        if (navbar.classList.contains('scrolling')) {
          navbar.classList.remove('scrolling');
        }
      }

      elem.onmouseleave = function () {
        if (!navbar.classList.contains('scrolling')) {
          setTimeout(function() {
            navbar.classList.add('scrolling');
          }, 100);
        }
      }

      elem.onclick = function () {
        if (!navbar.classList.contains('scrolling')) {
          navbar.classList.remove('navbar--show');
          navbar.classList.remove('navbar--hide');
          navbar.classList.add('navbar--hide');
        }
      }
    }) : null;
    


    
    var summaryContainer = document.querySelector('.summary__container');
    var searchResult = document.querySelector('.search-result');
    var searchResultCloseBtn = document.querySelector('.search-result__close');
    searchResultCloseBtn ? searchResultCloseBtn.addEventListener('click', function (e) {
      searchResult.setAttribute('data-display', 'none');
      summaryContainer.setAttribute('data-display', 'block');
    }) : null;
    


    
    document.querySelectorAll('.tab') ? 
    document.querySelectorAll('.tab').forEach(function(elem, idx) {
      var containerId = elem.getAttribute('id');
      var containerElem = elem;
      var tabLinks = elem.querySelectorAll('.tab__link');
      var tabContents = elem.querySelectorAll('.tab__content');
      var ids = [];

      tabLinks && tabLinks.length > 0 ?
      tabLinks.forEach(function(link, index, self) {
        link.onclick = function(e) {
          for (var i = 0; i < self.length; i++) {
            if (index === parseInt(i, 10)) {
              if (!self[i].classList.contains('active')) {
                self[i].classList.add('active');
                tabContents[i].style.display = 'block';
              }
            } else {
              self[i].classList.remove('active');
              tabContents[i].style.display = 'none';
            }
          }
        }
      }) : null;
    }) : null;
    


    
    document.querySelectorAll('.codetab') ? 
    document.querySelectorAll('.codetab').forEach(function(elem, idx) {
      var containerId = elem.getAttribute('id');
      var containerElem = elem;
      var codetabLinks = elem.querySelectorAll('.codetab__link');
      var codetabContents = elem.querySelectorAll('.codetab__content');
      var ids = [];

      codetabLinks && codetabLinks.length > 0 ?
      codetabLinks.forEach(function(link, index, self) {
        link.onclick = function(e) {
          for (var i = 0; i < self.length; i++) {
            if (index === parseInt(i, 10)) {
              if (!self[i].classList.contains('active')) {
                self[i].classList.add('active');
                codetabContents[i].style.display = 'block';
              }
            } else {
              self[i].classList.remove('active');
              codetabContents[i].style.display = 'none';
            }
          }
        }
      }) : null;
    }) : null;
    


    
    var gttBtn = document.getElementById("gtt");
    gttBtn.style.display = "none";
    gttBtn.addEventListener('click', function () {
      if (window.document.documentMode) {
        document.documentElement.scrollTop = 0;
      } else {
        scrollToTop(250);
      }
    });

    function scrollToTop(scrollDuration) {
      var scrollStep = -window.scrollY / (scrollDuration / 15);
      var scrollInterval = setInterval(function () {
        if (window.scrollY != 0) {
          window.scrollBy(0, scrollStep);
        }
        else clearInterval(scrollInterval);
      }, 15);
    }

    var scrollFunction = function () {
      if (document.body.scrollTop > 250 || document.documentElement.scrollTop > 250) {
        gttBtn.style.display = "block";
      } else {
        gttBtn.style.display = "none";
      }
    }
    


    
    var expandBtn = document.querySelectorAll('.expand__button');

    for (let i = 0; i < expandBtn.length; i++) {
      expandBtn[i].addEventListener("click", function () {
        var content = this.nextElementSibling;
        if (content.style.maxHeight) {
          content.style.maxHeight = null;
          this.querySelector('svg').classList.add('expand-icon__right');
          this.querySelector('svg').classList.remove('expand-icon__down');
        } else {
          content.style.maxHeight = content.scrollHeight + "px";
          this.querySelector('svg').classList.remove('expand-icon__right');
          this.querySelector('svg').classList.add('expand-icon__down');
        }
      });
    }
    


    
    var lastScrollTop = window.pageYOffset || document.documentElement.scrollTop;
    var tocElem = document.querySelector('.toc');
    var tableOfContentsElem = tocElem ? tocElem.querySelector('#TableOfContents') : null;
    var toggleTocElem = document.getElementById('toggle-toc');
    var singleContentsElem = document.querySelector('.single__contents');
    var navbar = document.querySelector('.navbar');
    var tocFlexbox = document.querySelector('.toc__flexbox');
    var tocFlexboxOuter = document.querySelector('.toc__flexbox--outer');
    var expandContents = document.querySelectorAll('.expand__content');
    var boxContents = document.querySelectorAll('.box');
    var notAllowedTitleIds = null;

    
    var tocFolding = JSON.parse("true");
    
    var tocLevels = JSON.parse("[\"h2\",\"h3\",\"h4\"]");
    
    if (tocLevels) {
      tocLevels = tocLevels.toString();
    } else {
      tocLevels = "h1, h2, h3, h4, h5, h6";
    }

    
    singleContentsElem && singleContentsElem.querySelectorAll(".tab") ?
    singleContentsElem.querySelectorAll(".tab").forEach(function (elem) {
      elem.querySelectorAll(tocLevels).forEach(function (element) {
        notAllowedTitleIds = Array.isArray(notAllowedTitleIds) ?
          notAllowedTitleIds.concat(element.getAttribute('id')) :
          [element.getAttribute('id')];
      });
    }) : null;

    
    expandContents ? expandContents.forEach(function(elem) {
      elem.querySelectorAll(tocLevels).forEach(function (element) {
        notAllowedTitleIds = Array.isArray(notAllowedTitleIds) ?
          notAllowedTitleIds.concat(element.getAttribute('id')) :
          [element.getAttribute('id')];
      });
    }) : null;

    
    boxContents ? boxContents.forEach(function(elem) {
      elem.querySelectorAll(tocLevels).forEach(function (element) {
        notAllowedTitleIds = Array.isArray(notAllowedTitleIds) ?
          notAllowedTitleIds.concat(element.getAttribute('id')) :
          [element.getAttribute('id')];
      });
    }) : null;

    
    window.onscroll = function () {
      scrollFunction();
      
      var st = window.pageYOffset || document.documentElement.scrollTop;
      if (st > lastScrollTop) { 
        if (st < 250) {
          gttBtn.style.display = "none";
        } else {
          gttBtn.style.display = "block";
        }

        if (st < 45) {
          return null;
        }

        if (navbar.classList.contains('scrolling')) {
          if (!navbar.classList.contains('navbar--hide')) {
            navbar.classList.add('navbar--hide');
          } else if (navbar.classList.contains('navbar--show')) {
            navbar.classList.remove('navbar--show');
          }
        }

        if (singleContentsElem) {
          if (singleContentsElem.querySelectorAll(tocLevels).length > 0) {
            singleContentsElem.querySelectorAll(tocLevels).forEach(function (elem) {
              if (toggleTocElem && !toggleTocElem.checked) {
                return null;
              }

              if (notAllowedTitleIds && notAllowedTitleIds.includes(elem.getAttribute('id'))) {
                return null;
              }
              
              if (document.documentElement.scrollTop >= elem.offsetTop) {
                if (tableOfContentsElem) {
                  var id = elem.getAttribute('id');
                  tocElem.querySelectorAll('a').forEach(function (elem) {
                    elem.classList.remove('active');
                  });
                  tocElem.querySelector('a[href="#' + id + '"]') ?
                    tocElem.querySelector('a[href="#' + id + '"]').classList.add('active') : null;

                  if (false === tocFolding) {
                    
                  } else {
                    tableOfContentsElem.querySelectorAll('ul') ?
                      tableOfContentsElem.querySelectorAll('ul').forEach(function (rootUl) {
                        rootUl.querySelectorAll('li').forEach(function (liElem) {
                          liElem.querySelectorAll('ul').forEach(function (ulElem) {
                            ulElem.style.display = 'none';
                          });
                        });
                      }) : null;
                  }

                  var curElem = tableOfContentsElem.querySelector("[href='#" + id + "']");
                  if (curElem && curElem.nextElementSibling) {
                    curElem.nextElementSibling.style.display = 'block';
                  }
                  getParents(curElem, 'ul') ?
                    getParents(curElem, 'ul').forEach(function (elem) {
                      elem.style.display = 'block';
                    }) : null;
                }
              }
            });
          } else {
            if (tocFlexbox) {
              tocFlexbox.setAttribute('data-position', '');
              if (!tocFlexbox.classList.contains('hide')) {
                tocFlexbox.classList.add('hide');
              }
            }
            if (tocFlexboxOuter) {
              tocFlexboxOuter.setAttribute('data-position', '');
              if (!tocFlexboxOuter.classList.contains('hide')) {
                tocFlexboxOuter.classList.add('hide');
              }
            }
          }
        }
      } else { 
        if (st < 250) {
          gttBtn.style.display = "none";
        }

        if (navbar.classList.contains('scrolling')) {
          if (navbar.classList.contains('navbar--hide')) {
            navbar.classList.remove('navbar--hide');
          } else if (!navbar.classList.contains('navbar--show')) {
            navbar.classList.add('navbar--show');
          }
        }

        if (singleContentsElem) {
          if (singleContentsElem.querySelectorAll(tocLevels).length > 0) {
            singleContentsElem.querySelectorAll(tocLevels).forEach(function (elem) {
              if (toggleTocElem && !toggleTocElem.checked) {
                return null;
              }
              
              if (notAllowedTitleIds && notAllowedTitleIds.includes(elem.getAttribute('id'))) {
                return null;
              }

              if (document.documentElement.scrollTop >= elem.offsetTop) {
                if (tableOfContentsElem) {
                  var id = elem.getAttribute('id');
                  tocElem.querySelectorAll('a').forEach(function (elem) {
                    elem.classList.remove('active');
                  });
                  tocElem.querySelector('a[href="#' + id + '"]') ?
                    tocElem.querySelector('a[href="#' + id + '"]').classList.add('active') : null;

                  if (false === tocFolding) {
                    
                  } else {
                    tableOfContentsElem.querySelectorAll('ul') ?
                      tableOfContentsElem.querySelectorAll('ul').forEach(function (rootUl) {
                        rootUl.querySelectorAll('li').forEach(function (liElem) {
                          liElem.querySelectorAll('ul').forEach(function (ulElem) {
                            ulElem.style.display = 'none';
                          });
                        });
                      }) : null;
                  }

                  var curElem = tableOfContentsElem.querySelector("[href='#" + id + "']");
                  if (curElem && curElem.nextElementSibling) {
                    curElem.nextElementSibling.style.display = 'block';
                  }
                  getParents(curElem, 'ul') ?
                    getParents(curElem, 'ul').forEach(function (elem) {
                      elem.style.display = 'block';
                    }) : null;
                }
              }
            });
          } else {
            if (tocFlexbox && !tocFlexbox.classList.contains('hide')) {
              tocFlexbox.classList.add('hide');
            }
            if (tocFlexboxOuter && !tocFlexboxOuter.classList.contains('hide')) {
              tocFlexboxOuter.classList.add('hide');
            }
          }
          
        }

        if (tableOfContentsElem && document.documentElement.scrollTop < 250) {
          if (false === tocFolding) {

          } else {
            tableOfContentsElem.querySelector('ul') ?
              tableOfContentsElem.querySelector('ul').querySelectorAll('li').forEach(function (liElem) {
                liElem.querySelectorAll('ul').forEach(function (ulElem) {
                  ulElem.style.display = 'none';
                });
              }) : null;
          }
        }
      }
      lastScrollTop = st <= 0 ? 0 : st;
    };
  


  
    var localTheme = localStorage.getItem('theme');
    var rootEleme = document.getElementById('root');
    var selectThemeElem = document.querySelectorAll('.select-theme');
    var selectThemeItemElem = document.querySelectorAll('.select-theme__item');
    
    
    var skinDarkCode = JSON.parse("\"dark\"");
    
    var skinLightCode = JSON.parse("\"light\"");
    
    var skinHackerCode = JSON.parse("\"hacker\"");
    
    var skinSolarizedCode = JSON.parse("\"solarized\"");
    
    var skinKimbieCode = JSON.parse("\"kimbie\"");

    var setMetaColor = function(themeColor) {
      var metaMsapplicationTileColor = document.getElementsByName('msapplication-TileColor')[0];
      var metaThemeColor = document.getElementsByName('theme-color')[0];
      var metaMsapplicationNavbuttonColor = document.getElementsByName('msapplication-navbutton-color')[0];
      var metaAppleMobileWebAappStatusBarStyle = document.getElementsByName('apple-mobile-web-app-status-bar-style')[0];

      if (themeColor.includes('dark')) {
        metaMsapplicationTileColor.setAttribute('content', '#fcfcfa');
        metaThemeColor.setAttribute('content', '#403E41');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#403E41');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#403E41');
      } else if (themeColor.includes('light')) {
        metaMsapplicationTileColor.setAttribute('content', '#555');
        metaThemeColor.setAttribute('content', '#eee');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#eee');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#eee');
      } else if (themeColor.includes('hacker')) {
        metaMsapplicationTileColor.setAttribute('content', '#e3cd26');
        metaThemeColor.setAttribute('content', '#252526');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#252526');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#252526');
      } else if (themeColor.includes('solarized')) {
        metaMsapplicationTileColor.setAttribute('content', '#d3af86');
        metaThemeColor.setAttribute('content', '#51412c');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#51412c');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#51412c');
      } else if (themeColor.includes('kimbie')) {
        metaMsapplicationTileColor.setAttribute('content', '#586e75');
        metaThemeColor.setAttribute('content', '#eee8d5');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#eee8d5');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#eee8d5');
      }
    }

    var parseSkinCode = function(themeText) {
      if (themeText === skinDarkCode) {
        return 'dark';
      } else if (themeText === skinLightCode) {
        return 'light';
      } else if (themeText === skinHackerCode) {
        return 'hacker';
      } else if (themeText === skinSolarizedCode) {
        return 'solarized';
      } else if (themeText === skinKimbieCode) {
        return 'kimbie';
      }
    }
    
    if (localTheme) {
      selectThemeItemElem ? 
      selectThemeItemElem.forEach(function (elem) {
        if (elem.text.trim() === localTheme) {
          elem.classList.add('is-active');
        } else {
          elem.classList.remove('is-active');
        }
      }) : null;

      setMetaColor(localTheme);
    } else {
      setMetaColor(rootEleme.className);
    }

    selectThemeItemElem ? 
    selectThemeItemElem.forEach(function (v, i) {
      v.addEventListener('click', function (e) {
        var selectedThemeVariant = parseSkinCode(e.target.text.trim());
        localStorage.setItem('theme', selectedThemeVariant);
        setMetaColor(selectedThemeVariant);

        rootEleme.removeAttribute('class');
        rootEleme.classList.add('theme__' + selectedThemeVariant);
        selectThemeElem.forEach(function(rootElem) {
          rootElem.querySelectorAll('a').forEach(function (elem) {
            if (elem.classList) {
              if (elem.text.trim() === selectedThemeVariant) {
                if (!elem.classList.contains('is-active')) {
                  elem.classList.add('is-active');
                }
              } else {
                if (elem.classList.contains('is-active')) {
                  elem.classList.remove('is-active');
                }
              }
            }
          });
        });

        if (window.mermaid) {
          if (selectedThemeVariant === "dark" || selectedThemeVariant === "hacker") {
            mermaid.initialize({ theme: 'dark' });
            location.reload();
          } else {
            mermaid.initialize({ theme: 'default' });
            location.reload();
          }
        }

        var utterances = document.getElementById('utterances');
        if (utterances) {
          utterances.querySelector('iframe').contentWindow.postMessage({
            type: 'set-theme',
            theme: selectedThemeVariant === "dark" || selectedThemeVariant === "hacker" ? 'photon-dark' : selectedThemeVariant === 'kimbie' ? 'github-dark-orange' : 'github-light',
          }, 'https://utteranc.es');
        }

        var twitterCards = document.querySelectorAll('.twitter-timeline');
        if (twitterCards) {
          window.postMessage({
            type: 'set-twitter-theme',
            theme: selectedThemeVariant === 'light' || selectedThemeVariant === 'solarized' ? 'light' : 'dark',
          });
        }
      });
    }) : null;
  


  
    
    var baseurl = JSON.parse("\"https://chaphlagical.github.io\"");
    
    var permalink = JSON.parse("\"https://chaphlagical.github.io/zh/posts/computer/os/\"");
    
    var langprefix = JSON.parse("\"/zh\"");
    var searchResults = null;
    var searchMenu = null;
    var searchText = null;
    
    
    var enableSearch = JSON.parse("true");
    
    var searchDistance = JSON.parse("null");
    
    var searchThreshold = JSON.parse("null");
    
    var searchContent = JSON.parse("null");
    
    var enableSearchHighlight = JSON.parse("true");
    
    var searchResultPosition = JSON.parse("\"main\"");
    
    var sectionType = JSON.parse("\"posts\"");
    
    var kind = JSON.parse("\"page\"");
    
    var fuse = null;

    if (enableSearch) {
      (function initFuse() {
        var xhr = new XMLHttpRequest();
        if (sectionType === "publication" && kind !== "page") {
          xhr.open('GET', permalink + "index.json");
        } else {
          xhr.open('GET', baseurl + langprefix + "/index.json");
        }
        
        xhr.setRequestHeader('Content-Type', 'application/json; charset=utf-8');
        xhr.onload = function () {
          if (xhr.status === 200) {
            fuse = new Fuse(JSON.parse(xhr.response.toString('utf-8')), {
              keys: sectionType.includes('publication') ? ['title', 'abstract'] : 
                searchContent ? ['title', 'description', 'content'] : ['title', 'description'],
              includeMatches: enableSearchHighlight,
              shouldSort: true, 
              threshold: searchThreshold ? searchThreshold : 0.4, 
              location: 0, 
              distance: searchDistance ? searchDistance : 100, 
              maxPatternLength: 32,
              minMatchCharLength: 1,
              isCaseSensitive: false, 
              findAllMatches: false, 
              useExtendedSearch: false, 
            });
            window.fuse = fuse;
          }
          else {
            console.error('[' + xhr.status + ']Error:', xhr.statusText);
          }
        };
        xhr.send();
      })();
    }

    function makeLi(ulElem, obj) {
      var li = document.createElement('li');
      li.className = 'search-result__item';
      
      var a = document.createElement('a');
      a.innerHTML = obj.item.title;
      a.setAttribute('class', 'search-result__item--title');
      a.setAttribute('href', obj.item.uri);

      var descDiv = document.createElement('div');
      descDiv.setAttribute('class', 'search-result__item--desc');
      if (obj.item.description) {
        descDiv.innerHTML = obj.item.description;
      } else if (obj.item.content) {
        descDiv.innerHTML = obj.item.content.substring(0, 225);
      }
      
      li.appendChild(a);
      li.appendChild(descDiv);
      ulElem.appendChild(li);
    }

    function makeHighlightLi(ulElem, obj) {
      var li = document.createElement('li');
      li.className = 'search-result__item';
      var descDiv = null;

      var a = document.createElement('a');
      a.innerHTML = obj.item.title;
      a.setAttribute('class', 'search-result__item--title');
      a.setAttribute('href', obj.item.uri);

      if (obj.matches && obj.matches.length) {
        for (var i = 0; i < obj.matches.length; i++) {
          if ('title' === obj.matches[i].key) {
            a = document.createElement('a');
            a.innerHTML = generateHighlightedText(obj.matches[i].value, obj.matches[i].indices);
            a.setAttribute('class', 'search-result__item--title');
            a.setAttribute('href', obj.item.uri);
          }
          
          if ('description' === obj.matches[i].key) {
            descDiv = document.createElement('div');
            descDiv.setAttribute('class', 'search-result__item--desc');
            descDiv.innerHTML = generateHighlightedText(obj.item.description, obj.matches[i].indices);
          } else if ('content' === obj.matches[i].key) {
            if (!descDiv) {
              descDiv = document.createElement('div');
              descDiv.setAttribute('class', 'search-result__item--desc');
              descDiv.innerHTML = generateHighlightedText(obj.item.content.substring(0, 150), obj.matches[i].indices);
            }
          } else {
            if (obj.item.description) {
              descDiv = document.createElement('div');
              descDiv.setAttribute('class', 'search-result__item--desc');
              descDiv.innerHTML = obj.item.description;
            } else {
              descDiv = document.createElement('div');
              descDiv.setAttribute('class', 'search-result__item--desc');
              descDiv.innerHTML = obj.item.content.substring(0, 150);
            }
          }
        }

        li.appendChild(a);
        if (descDiv) {
          li.appendChild(descDiv);
        }
        if (li) {
          ulElem.appendChild(li);
        }
      }
    }

    function renderSearchResultsSide(searchText, results) {
      searchResults = document.getElementById('search-results');
      searchMenu = document.getElementById('search-menu');
      searchResults.setAttribute('class', 'dropdown is-active');
      
      var ul = document.createElement('ul');
      ul.setAttribute('class', 'dropdown-content search-content');

      if (results.length) {
        results.forEach(function (result) {
          var li = document.createElement('li');
          var a = document.createElement('a');
          a.setAttribute('href', result.uri);
          a.setAttribute('class', 'dropdown-item');
          a.appendChild(li);

          var titleDiv = document.createElement('div');
          titleDiv.innerHTML = result.title;
          titleDiv.setAttribute('class', 'menu-item__title');

          var descDiv = document.createElement('div');
          descDiv.setAttribute('class', 'menu-item__desc');
          if (result.description) {
            descDiv.innerHTML = result.description;
          } else if (result.content) {
            descDiv.innerHTML = result.content.substring(0, 150);
          }

          li.appendChild(titleDiv);
          li.appendChild(descDiv);
          ul.appendChild(a);
        });
      } else {
        var li = document.createElement('li');
        li.setAttribute('class', 'dropdown-item');
        li.innerText = 'No results found';
        ul.appendChild(li);
      }

      while (searchMenu.hasChildNodes()) {
        searchMenu.removeChild(
          searchMenu.lastChild
        );
      }
      
      searchMenu.appendChild(ul);
    }

    function renderSearchHighlightResultsSide(searchText, results) {
      searchResults = document.getElementById('search-results');
      searchMenu = document.getElementById('search-menu');
      searchResults.setAttribute('class', 'dropdown is-active');

      var ul = document.createElement('ul');
      ul.setAttribute('class', 'dropdown-content search-content');

      if (results.length) {
        results.forEach(function (result) {
          var li = document.createElement('li');
          var a = document.createElement('a');
          var descDiv = null;

          a.setAttribute('href', result.item.uri);
          a.setAttribute('class', 'dropdown-item');
          a.appendChild(li);

          var titleDiv = document.createElement('div');
          titleDiv.innerHTML = result.item.title;
          titleDiv.setAttribute('class', 'menu-item__title');
          
          if (result.matches && result.matches.length) {
            for (var i = 0; i < result.matches.length; i++) {
              if ('title' === result.matches[i].key) {
                titleDiv.innerHTML = generateHighlightedText(result.matches[i].value, result.matches[i].indices);
              }

              if ('description' === result.matches[i].key) {
                descDiv = document.createElement('div');
                descDiv.setAttribute('class', 'menu-item__desc');
                descDiv.innerHTML = generateHighlightedText(result.item.description, result.matches[i].indices);
              } else if ('content' === result.matches[i].key) {
                if (!descDiv) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'menu-item__desc');
                  descDiv.innerHTML = generateHighlightedText(result.item.content.substring(0, 150), result.matches[i].indices);
                }
              } else {
                if (result.item.description) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'menu-item__desc');
                  descDiv.innerHTML = result.item.description;
                } else {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'menu-item__desc');
                  descDiv.innerHTML = result.item.content.substring(0, 150);
                }
              }
            }
            
            li.appendChild(titleDiv);
            if (descDiv) {
              li.appendChild(descDiv);
            }
            ul.appendChild(a);
          }
        });
      } else {
        var li = document.createElement('li');
        li.setAttribute('class', 'dropdown-item');
        li.innerText = 'No results found';
        ul.appendChild(li);
      }

      while (searchMenu.hasChildNodes()) {
        searchMenu.removeChild(
          searchMenu.lastChild
        );
      }
      searchMenu.appendChild(ul);
    }

    function renderSearchResultsMobile(searchText, results) {
      searchResults = document.getElementById('search-mobile-results');

      var content = document.createElement('div');
      content.setAttribute('class', 'mobile-search__content');

      if (results.length > 0) {
        results.forEach(function (result) {
          var item = document.createElement('a');
          item.setAttribute('href', result.uri);
          item.innerHTML = '<div class="mobile-search__item"><div class="mobile-search__item--title">📄 ' + result.title + '</div><div class="mobile-search__item--desc">' + (result.description ? result.description : result.content) + '</div></div>';
          content.appendChild(item);
        });
      } else {
        var item = document.createElement('span');
        content.appendChild(item);
      }

      let wrap = document.getElementById('search-mobile-results');
      while (wrap.firstChild) {
        wrap.removeChild(wrap.firstChild)
      }
      searchResults.appendChild(content);      
    }

    function renderSearchHighlightResultsMobile(searchText, results) {
      searchResults = document.getElementById('search-mobile-results');

      var ul = document.createElement('div');
      ul.setAttribute('class', 'mobile-search__content');

      if (results.length) {
        results.forEach(function (result) {
          var li = document.createElement('li');
          var a = document.createElement('a');
          var descDiv = null;

          a.setAttribute('href', result.item.uri);
          a.appendChild(li);
          li.setAttribute('class', 'mobile-search__item');

          var titleDiv = document.createElement('div');
          titleDiv.innerHTML = result.item.title;
          titleDiv.setAttribute('class', 'mobile-search__item--title');
          
          if (result.matches && result.matches.length) {
            for (var i = 0; i < result.matches.length; i++) {
              if ('title' === result.matches[i].key) {
                titleDiv.innerHTML = generateHighlightedText(result.matches[i].value, result.matches[i].indices);
              }

              if ('description' === result.matches[i].key) {
                descDiv = document.createElement('div');
                descDiv.setAttribute('class', 'mobile-search__item--desc');
                descDiv.innerHTML = generateHighlightedText(result.item.description, result.matches[i].indices);
              } else if ('content' === result.matches[i].key) {
                if (!descDiv) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'mobile-search__item--desc');
                  descDiv.innerHTML = generateHighlightedText(result.item.content.substring(0, 150), result.matches[i].indices);
                }
              } else {
                if (result.item.description) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'mobile-search__item--desc');
                  descDiv.innerHTML = result.item.description;
                } else {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'mobile-search__item--desc');
                  descDiv.innerHTML = result.item.content.substring(0, 150);
                }
              }
            }
            
            li.appendChild(titleDiv);
            if (descDiv) {
              li.appendChild(descDiv);
            }
            ul.appendChild(a);
          }
        });
      } else {
        var item = document.createElement('span');
        ul.appendChild(item);
      }

      let wrap = document.getElementById('search-mobile-results');
      while (wrap.firstChild) {
        wrap.removeChild(wrap.firstChild)
      }
      searchResults.appendChild(ul);
    }

    function generateHighlightedText(text, regions) {
      if (!regions) {
        return text;
      }

      var content = '', nextUnhighlightedRegionStartingIndex = 0;

      regions.forEach(function(region) {
        if (region[0] === region[1]) {
          return null;
        }
        
        content += '' +
          text.substring(nextUnhighlightedRegionStartingIndex, region[0]) +
          '<span class="search__highlight">' +
            text.substring(region[0], region[1] + 1) +
          '</span>' +
        '';
        nextUnhighlightedRegionStartingIndex = region[1] + 1;
      });

      content += text.substring(nextUnhighlightedRegionStartingIndex);

      return content;
    };

    var searchElem = document.getElementById('search');
    var searchMobile = document.getElementById('search-mobile');
    var searchResultsContainer = document.getElementById('search-results');

    searchElem ?
    searchElem.addEventListener('input', function(e) {
      if (!e.target.value | window.innerWidth < 770) {
        searchResultsContainer ? searchResultsContainer.setAttribute('class', 'dropdown') : null;
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
        return null;
      }

      searchText = e.target.value;
      var results = fuse.search(e.target.value);
      
      if (searchResultPosition === "main") {
        if (enableSearchHighlight) {
          renderSearchHighlightResultsMain(searchText, results);
        } else {
          renderSearchResultsMain(searchText, results);
        }
      } else {
        if (enableSearchHighlight) {
          renderSearchHighlightResultsSide(searchText, results);
        } else {
          renderSearchResultsSide(searchText, results);
        }
        
        var dropdownItems = searchResultsContainer.querySelectorAll('.dropdown-item');
        dropdownItems ? dropdownItems.forEach(function(item) {
          item.addEventListener('mousedown', function(e) {
            e.target.click();
          });
        }) : null;
      }
    }) : null;

    searchElem ? 
    searchElem.addEventListener('blur', function() {
      if (window.innerWidth < 770) {
        return null;
      }
      searchResultsContainer ? searchResultsContainer.setAttribute('class', 'dropdown') : null;
    }) : null;

    searchElem ? 
    searchElem.addEventListener('click', function(e) {
      if (window.innerWidth < 770) {
        return null;
      }
      if (!e.target.value) {
        searchResultsContainer ? searchResultsContainer.setAttribute('class', 'dropdown') : null;
        return null;
      }

      searchText = e.target.value;
      var results = fuse.search(e.target.value);

      if (searchResultPosition === "main") {
        if (enableSearchHighlight) {
          renderSearchHighlightResultsMain(searchText, results);
        } else {
          renderSearchResultsMain(searchText, results);
        }
      } else{
        if (enableSearchHighlight) {
          renderSearchHighlightResultsSide(searchText, results);
        } else {
          renderSearchResultsSide(searchText, results);
        }

        var dropdownItems = searchResultsContainer.querySelectorAll('.dropdown-item');
        dropdownItems ? dropdownItems.forEach(function (item) {
          item.addEventListener('mousedown', function (e) {
            e.target.click();
          });
        }) : null;
      }
    }) : null;

    var searchMenuElem = document.getElementById("search-menu");
    var activeItem = document.querySelector('#search-menu .dropdown-item.is-active');
    var activeIndex = null;
    var items = null;
    var searchContainerMaxHeight = 350;

    searchElem ? 
    searchElem.addEventListener('keydown', function(e) {
      if (window.innerWidth < 770) {
        return null;
      }

      if (e.key === 'Escape') {
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
      }

      var items = document.querySelectorAll('#search-menu .dropdown-item');
      var keyCode = e.which || e.keyCode;

      if (!items || !items.length) {
        return null;
      }
      
      if (e.key === 'ArrowDown' || keyCode === 40) {
        if (activeIndex === null) {
          activeIndex = 0;
          items[activeIndex].classList.remove('is-active');
        } else {
          items[activeIndex].classList.remove('is-active');
          activeIndex = activeIndex === items.length - 1 ? 0 : activeIndex + 1;
        }
        items[activeIndex].classList.add('is-active');

        let overflowedPixel = items[activeIndex].offsetTop + items[activeIndex].clientHeight - searchContainerMaxHeight;
        if (overflowedPixel > 0) {
          document.querySelector(".search-content").scrollTop += items[activeIndex].getBoundingClientRect().height;
        } else if (activeIndex === 0) {
          document.querySelector(".search-content").scrollTop = 0;
        }
      } else if (e.key === 'ArrowUp' || keyCode === 38) {
        if (activeIndex === null) {
          activeIndex = items.length - 1;
          items[activeIndex].classList.remove('is-active');
        } else {
          items[activeIndex].classList.remove('is-active');
          activeIndex = activeIndex === 0 ? items.length - 1 : activeIndex - 1;
        }
        items[activeIndex].classList.add('is-active');
        
        let overflowedPixel = items[activeIndex].offsetTop + items[activeIndex].clientHeight - searchContainerMaxHeight;
        if (overflowedPixel < 0) {
          document.querySelector(".search-content").scrollTop -= items[activeIndex].getBoundingClientRect().height;
        } else {
          document.querySelector(".search-content").scrollTop = overflowedPixel + items[activeIndex].getBoundingClientRect().height;
        }
      } else if (e.key === 'Enter' || keyCode === 13) {
        if (items[activeIndex] && items[activeIndex].getAttribute('href')) {
          location.href = items[activeIndex].getAttribute('href');
        }
      } else if (e.key === 'Escape' || keyCode === 27) {
        e.target.value = null;
        if (searchResults) {
          searchResults.classList.remove('is-active');
        }
      }
    }) : null;

    searchMobile ? 
    searchMobile.addEventListener('input', function(e) {
      if (!e.target.value) {
        let wrap = document.getElementById('search-mobile-results');
        while (wrap.firstChild) {
          wrap.removeChild(wrap.firstChild);
        }
        return null;
      }

      searchText = e.target.value;
      var results = fuse.search(e.target.value);
      renderSearchResultsMobile(searchText, results);
      if (enableSearchHighlight) {
        renderSearchHighlightResultsMobile(searchText, results);
      } else {
        renderSearchResultsMobile(searchText, results);
      }
    }) : null;
  


  
    var mobileSearchInputElem = document.querySelector('#search-mobile');
    var mobileSearchClassElem = document.querySelector('.mobile-search');
    var mobileSearchBtnElems = document.querySelectorAll('.navbar-search');
    var mobileSearchCloseBtnElem = document.querySelector('#search-mobile-close');
    var mobileSearchContainer = document.querySelector('#search-mobile-container');
    var mobileSearchResultsElem = document.querySelector('#search-mobile-results');
    var htmlElem = document.querySelector('html');

    if (mobileSearchClassElem) {
      mobileSearchClassElem.style.display = 'none';
    }

    mobileSearchBtnElems ? 
    mobileSearchBtnElems.forEach(function (elem, idx) {
      elem.addEventListener('click', function () {
        if (mobileSearchContainer) {
          mobileSearchContainer.style.display = 'block';
        }

        if (mobileSearchInputElem) {
          mobileSearchInputElem.focus();
        }

        if (htmlElem) {
          htmlElem.style.overflowY = 'hidden';
        }
      });
    }) : null;

    mobileSearchCloseBtnElem ? 
    mobileSearchCloseBtnElem.addEventListener('click', function() {
      if (mobileSearchContainer) {
        mobileSearchContainer.style.display = 'none';
      }

      if (mobileSearchInputElem) {
        mobileSearchInputElem.value = '';
      }
      
      if (mobileSearchResultsElem) {
        while (mobileSearchResultsElem.firstChild) {
          mobileSearchResultsElem.removeChild(mobileSearchResultsElem.firstChild);
        }
      }

      if (htmlElem) {
        htmlElem.style.overflowY = 'visible';
      }
    }) : null;

    mobileSearchInputElem ?
    mobileSearchInputElem.addEventListener('keydown', function(e) {
      var keyCode = e.which || e.keyCode;
      if (e.key === 'Escape' || keyCode === 27) {
        if (mobileSearchContainer) {
          mobileSearchContainer.style.display = 'none';
        }
        
        if (mobileSearchInputElem) {
          mobileSearchInputElem.value = '';
        }

        if (mobileSearchResultsElem) {
          while (mobileSearchResultsElem.firstChild) {
            mobileSearchResultsElem.removeChild(mobileSearchResultsElem.firstChild);
          }
        }
        if (htmlElem) {
          htmlElem.style.overflowY = 'visible';
        }
      }
    }) : null;
  


  
    function renderSearchResultsMain(searchText, results) {
      var searchBody = document.querySelector('.search-result__body');
      var originUl = searchBody.querySelector('ul');
      var ul = document.createElement('ul');
      
      if (!searchText) {
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
      } else if (results) {
        if (results && results.length) {
          results.forEach(function (result) {
            makeLi(ul, result);
          });

          searchResult ? searchResult.setAttribute('data-display', 'block') : null;
          summaryContainer ? summaryContainer.setAttribute('data-display', 'none') : null;
        }
      }

      originUl.parentNode.replaceChild(ul, originUl);
    }

    function renderSearchHighlightResultsMain(searchText, results) {
      var searchBody = document.querySelector('.search-result__body');
      var originUl = searchBody.querySelector('ul');
      var ul = document.createElement('ul');

      if (!searchText) {
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
      } else if (results) {
        if (results && results.length) {
          results.forEach(function (result) {
            makeHighlightLi(ul, result);
          });

          searchResult ? searchResult.setAttribute('data-display', 'block') : null;
          summaryContainer ? summaryContainer.setAttribute('data-display', 'none') : null;
        }
      }

      originUl.parentNode.replaceChild(ul, originUl);
    }
  
  });
</script>
    
    


<link rel="stylesheet" href="/css/main.min.css">


    
<meta name="description" content="分布式操作系统总结" />


<meta name="keywords" content="OS">

<meta name="created" content="2022-06-10T10:20:11&#43;0100">
<meta name="modified" content="2022-06-10T10:20:11&#43;0100">
<meta property="article:published_time" content="2022-06-10T10:20:11&#43;0100">

<meta name="author" content="Wenbo Chen">


<meta property="og:site_name" content="Chaf&#39;s Blog">
<meta property="og:title" content="分布式操作系统总结">
<meta property="og:url" content="https://chaphlagical.github.io/zh/posts/computer/os/">
<meta property="og:type" content="article">
<meta property="og:description" content="分布式操作系统总结">

  
    <meta property="og:image" content="https://chaphlagical.github.io/images/posts/application_mathematics.jpg">
    <meta property="og:image:url" content="https://chaphlagical.github.io/images/posts/application_mathematics.jpg">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:app:name:iphone" content="Chaf&#39;s Blog">
    <meta property="twitter:title" content="分布式操作系统总结">
    <meta property="twitter:description" content="分布式操作系统总结">
  

<meta name="generator" content="Hugo 0.82.0" />
<meta name="msapplication-TileColor" content="#fff">

<meta name="theme-color" content="#fff">

<meta name="msapplication-navbutton-color" content="#fff">

<meta name="apple-mobile-web-app-status-bar-style" content="#fff">

<link rel="canonical" href="https://chaphlagical.github.io/zh/posts/computer/os/">

<link rel="manifest" href="/manifest.json">

  <link rel="apple-touch-icon" sizes="57x57" href="/favicon/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/favicon/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/favicon/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/favicon/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/favicon/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/favicon/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/favicon/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/favicon/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/favicon/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/favicon/android-icon-512x512.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/favicon/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">


    <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebPage",
    "headline": "分布式操作系统总结",
    "datePublished": "2022-06-10T10:20:11+01:00",
    "dateModified": "2022-06-10T10:20:11+01:00",
    "url" : "https://chaphlagical.github.io/zh/posts/computer/os/",
    "description": "分布式操作系统总结",
    "keywords": ["OS"],
    "image" : "https://chaphlagical.github.io/images/posts/application_mathematics.jpg",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://chaphlagical.github.io"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Chaf's Blog",
      "url": "https://chaphlagical.github.io"
    }
  }
</script>

    
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-151337983-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-151337983-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>








    
</head>

<body id="root" class="theme__dark">
    <script>
        var localTheme = localStorage.getItem('theme');
        if (localTheme) {
            document.getElementById('root').className = 'theme__' + localTheme;
        }
    </script>
    <div id="container">
        





        <div class="wrapper" data-type="posts" data-kind="page">
            <nav class="navbar scrolling" role="navigation" aria-label="main navigation" data-dir="ltr">
  <div class="navbar__brand">
    
    <a href="/zh/" title="主页" rel="home" class="navbar__logo-link">
      <img src="/logo.png" alt="Home" class="navbar__logo">
    </a>
    
    
      <a href="/zh/" title="主页" rel="home" class="navbar__title-link">
        <h6 class="navbar__title">Chaf</h6>
      </a>
    
  </div>

  
<div class="theme theme-mobile" data-ani="true">
  <div class="dropdown">
    <button class="dropdown-trigger navbar__slide-down" aria-label="Select Theme Button" style="" data-ani="true">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24"><path fill="none" d="M24 0H0v24h24V0z"/><path fill="currentColor" d="M6.34 7.93c-3.12 3.12-3.12 8.19 0 11.31C7.9 20.8 9.95 21.58 12 21.58s4.1-.78 5.66-2.34c3.12-3.12 3.12-8.19 0-11.31l-4.95-4.95c-.39-.39-1.02-.39-1.41 0L6.34 7.93zM12 19.59c-1.6 0-3.11-.62-4.24-1.76C6.62 16.69 6 15.19 6 13.59s.62-3.11 1.76-4.24L12 5.1v14.49z"/></svg>      
    </button>
    <div class="dropdown-content select-theme">
      
        
        <a href="#" class="dropdown-item select-theme__item is-active">
          dark
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          light
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          hacker
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          solarized
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          kimbie
        </a>
        
      
    </div>
  </div>
</div>


<div class="mobile-search__btn navbar-search" data-ani="true">
  <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M15.5 14h-.79l-.28-.27c1.2-1.4 1.82-3.31 1.48-5.34-.47-2.78-2.79-5-5.59-5.34-4.23-.52-7.79 3.04-7.27 7.27.34 2.8 2.56 5.12 5.34 5.59 2.03.34 3.94-.28 5.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
</div>

<div id="search-mobile-container" class="mobile-search hide" data-dir="ltr">
  <div class="mobile-search__top">
    <input id="search-mobile" type="text" aria-label="Mobile Search" placeholder="搜索" class="mobile-search__top--input"/>
    <div id="search-mobile-close" class="mobile-search__top--icon">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24"><path opacity=".87" fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm3.59-13L12 10.59 8.41 7 7 8.41 10.59 12 7 15.59 8.41 17 12 13.41 15.59 17 17 15.59 13.41 12 17 8.41z"/></svg>
    </div>
  </div>
  <div id="search-mobile-results" class="mobile-search__body">
    
  </div>
</div>


<a role="button" class="navbar__burger" aria-label="menu" aria-expanded="false"
  data-ani="true">
  <span aria-hidden="true"></span>
  <span aria-hidden="true"></span>
  <span aria-hidden="true"></span>
</a>
<div class="navbarm__collapse" data-open="false">
  <ul dir="ltr">
    
    
      
      
      
      

      
        <li class="navbarm__menu--item ">
          <a href="/zh/about">简介</a>
        </li>
      
      
    
      
      
      
      

      
        <li class="navbarm__menu--item active">
          <a href="/zh/posts">文章</a>
        </li>
      
      
    
      
      
      
      

      
        <li class="navbarm__menu--item ">
          <a href="/zh/showcase">项目</a>
        </li>
      
      
    
      
      
      
      

      
        <li class="navbarm__menu--item ">
          <a href="/zh/archive">归档</a>
        </li>
      
      
    
      
      
      
      

      
        <li class="navbarm__menu--item ">
          <a href="/zh/publication">发表</a>
        </li>
      
      
    

    
      <li class="navbarm__menu--item ">
        <a href="/zh/tags" class="navbarm__menu--term" data-index="0">
          标签
        </a>
      </li>
    
      <li class="navbarm__menu--item ">
        <a href="/zh/categories" class="navbarm__menu--term" data-index="1">
          分类
        </a>
      </li>
    
      <li class="navbarm__menu--item ">
        <a href="/zh/series" class="navbarm__menu--term" data-index="2">
          系列
        </a>
      </li>
    
  </ul>
</div>
  <div class="navbar__menu">
  
  
  
<div class="theme" data-ani="true">
  <div class="dropdown">
    <button class="dropdown-trigger navbar__slide-down" aria-label="Select Theme Button" data-ani="true">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24"><path fill="none" d="M24 0H0v24h24V0z"/><path fill="currentColor" d="M6.34 7.93c-3.12 3.12-3.12 8.19 0 11.31C7.9 20.8 9.95 21.58 12 21.58s4.1-.78 5.66-2.34c3.12-3.12 3.12-8.19 0-11.31l-4.95-4.95c-.39-.39-1.02-.39-1.41 0L6.34 7.93zM12 19.59c-1.6 0-3.11-.62-4.24-1.76C6.62 16.69 6 15.19 6 13.59s.62-3.11 1.76-4.24L12 5.1v14.49z"/></svg>      
    </button>
    <div class="dropdown-content select-theme">
      
        
        <a href="#" class="dropdown-item select-theme__item is-active">
          dark
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          light
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          hacker
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          solarized
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          kimbie
        </a>
        
      
    </div>
  </div>
</div>

  
  
  
  
  
  
  
  <a href="/zh/about" class="navbar__menu-item navbar__slide-down " dir="ltr" data-ani="true">简介</a>
  
  
  
  
  
  
  
  <a href="/zh/posts" class="navbar__menu-item navbar__slide-down active" dir="ltr" data-ani="true">文章</a>
  
  
  
  
  
  
  
  <a href="/zh/showcase" class="navbar__menu-item navbar__slide-down " dir="ltr" data-ani="true">项目</a>
  
  
  
  
  
  
  
  <a href="/zh/archive" class="navbar__menu-item navbar__slide-down " dir="ltr" data-ani="true">归档</a>
  
  
  
  
  
  
  
  <a href="/zh/publication" class="navbar__menu-item navbar__slide-down " dir="ltr" data-ani="true">发表</a>
  
  
</div>
</nav>
            
            

<main class="single__main main">
  
    <nav class="breadcrumb hide" aria-label="breadcrumbs">
  <script>document.querySelector('.breadcrumb').classList.remove('hide')</script>
  <ol>
    
  
  
  
  
  
  <li >
    
      <a href="https://chaphlagical.github.io/zh/" class="capitalize">Chaf&#39;s Blog</a>
    
  </li>
  
  
  <li >
    
      <a href="https://chaphlagical.github.io/zh/posts/" class="capitalize">Posts</a>
    
  </li>
  
  
  <li  class="is-active" >
    
      <span>分布式操作系统总结</span>
    
  </li>
  
  </ol>
  
</nav>
  
  
  <div class="single ">
    <div class="single__nojs">Please enable Javascript to view the contents</div>
    <script>document.querySelector('.single').classList.remove('hide'); document.querySelector('.single__nojs').classList.add('hide');</script>
    <h2 class="single__title" data-ani="true">分布式操作系统总结</h2>
    <h3 class="single__subtitle"></h3>
    <div class="single__meta">
      
<div class="single__infos">
  <time class="single__info" title="创建日期">📅&nbsp;2022年06月10日 </time>
  
  &nbsp;&middot;&nbsp; <span class="single__info" title="阅读时长"> ☕&nbsp;118&nbsp;分钟 </span>
  
  <span class="single__info">
    
  </span>
</div>

      
<ul class="single__tags caption">
  
  🏷️
  

  <li><a href="https://chaphlagical.github.io/zh/tags/os/" class="single__tag" title="OS">#OS</a></li>

</ul>

    </div>
    <article class="single__contents" data-dir="ltr" data-ani="true">
      
      <h2 id="1-分布式系统简介">1. 分布式系统简介</h2>
<h3 id="11-分布式系统的诞生和定义">1.1. 分布式系统的诞生和定义</h3>
<ul>
<li>
<p>诞生原因</p>
<ul>
<li>大规模、超大规模以及极大规模集成电路性能价格比发生了巨大变化</li>
<li>多机互连结构和通信技术的日益成熟</li>
<li>用户对计算机的要求越来越高，越来越复杂</li>
</ul>
</li>
<li>
<p>分布式系统的好处</p>
<ul>
<li>
<p>扩展性</p>
<p>价格低廉</p>
</li>
<li>
<p>响应时间短，吞吐率高</p>
</li>
<li>
<p>可靠性高，鲁棒性好</p>
</li>
</ul>
</li>
<li>
<p>分布式系统的定义</p>
<ul>
<li>一个分布式系统是多个独立计算机的集合，该系统在用户看来就象一台单个计算机一样
<ul>
<li>硬件方面：机器是独立自治的</li>
<li>软件方面：用户把系统看作为单一的一台计算机系统</li>
</ul>
</li>
</ul>
</li>
<li>
<p>分布式系统的三个特性</p>
<ul>
<li>模块性</li>
<li>并行性</li>
<li>自治性</li>
</ul>
</li>
</ul>
<h3 id="12-分布式系统发展的动力">1.2. 分布式系统发展的动力</h3>
<ul>
<li>技术上的变化
<ul>
<li>大规模、超大规模和极大规模集成电路以及微处理机的价格大幅下降</li>
<li>独立拥有大型计算机硬件和软件的代价太高</li>
<li>设计操作系统的着眼点已不再是获得最佳的硬件利用率</li>
<li>通信技术的发展以及计算机网络资源共享的日益改善</li>
</ul>
</li>
<li>用户的需求
<ul>
<li>用户希望系统提供的服务可被不断地扩充</li>
<li>用户希望能以最低的成本获得最大的收益</li>
<li>系统可被裁减以满足不同用户的需要</li>
<li>用户要求为分散的用户提供各种服务</li>
</ul>
</li>
</ul>
<h3 id="13-分布式系统的目标">1.3. 分布式系统的目标</h3>
<ul>
<li>增加处理能力</li>
<li>可扩展性</li>
<li>可靠性和鲁棒性</li>
<li>资源共享</li>
</ul>
<h3 id="14-分布式系统的优缺点">1.4. 分布式系统的优缺点</h3>
<h4 id="141-分布式系统同集中式系统相比之优点">1.4.1. 分布式系统同集中式系统相比之优点</h4>
<ul>
<li>
<p>Grosch定律</p>
<p>CPU的计算能力与价格的平方成正比：即付出双倍的价钱，你就会得到四倍的性能</p>
</li>
<li>
<p>分布式系统与并行系统的区别</p>
<ul>
<li>执行粒度：并行系统是指令级，而分布式系统是任务级</li>
<li>CPU之间的距离：并行系统是一个机器内部多个板卡之间，在1米以内，而分布式系统是多个机器之间，1公里以内</li>
<li>传输速度：并行系统是内部总线之间传输信息，速度可以忽略不计，而分布式系统是在机器之间传输信息，速度为10Mbps、100Mbps或者是1000Mbps，目前，可达到10000Mbps</li>
<li>具有多个分店的连锁超市</li>
<li>计算机支持的合作工作</li>
</ul>
</li>
<li>
<p>优点</p>
<ul>
<li>分布式系统比单一的大型集中系统有更好的性能价格比，微处理器集合还可以达到任何一个大型机也无法达到的性能</li>
<li>可扩展性，采用分布式系统，系统只需逐渐增加便宜的处理器便可以扩展其计算能力</li>
</ul>
</li>
</ul>
<h4 id="142-分布式系统与独立pc相比之优点">1.4.2. 分布式系统与独立PC相比之优点</h4>
<ul>
<li>数据共享</li>
<li>设备共享</li>
<li>通信方便</li>
<li>灵活性强</li>
</ul>
<h4 id="143-分布式系统的缺点">1.4.3. 分布式系统的缺点</h4>
<ul>
<li>软件问题：目前，由于分布式系统软件较少，所以，人们对设计、实现以及使用分布式软件并无太多经验</li>
<li>网络通信：网络容易饱和且能引起其它问题</li>
<li>网络安全</li>
</ul>
<h3 id="15-计算机网络与分布式系统的关系">1.5. 计算机网络与分布式系统的关系</h3>
<ul>
<li>计算机网络：计算机网络是将地理位置不同的若干计算机用通信电缆相互连接起来的系统。其目的在于实现计算机之间的有效通信和整个网络内的软、硬件资源的共享</li>
<li>分布式系统：分为四个层次
<ol>
<li>硬件/固件层</li>
<li>含有进程通信的内核层</li>
<li>服务层</li>
<li>应用层</li>
</ol>
</li>
<li>相同之处：从层次观点出发，计算机网络与分布式系统在资源分布、互连拓扑、通信协议这几个层次上有着共同的结构模型。即都提供了一个面向报文的异构型通信环境，从低层硬件和通信软件来看，二者没有什么区别</li>
<li>不同之处：在全局管理、并行操作、自治控制等方面分布式系统有着更高的要求，其主要区别在于系统的高层软件（操作系统、语言、数据库、应用软件）上</li>
</ul>
<h3 id="16-分布式系统硬件">1.6. 分布式系统硬件</h3>
<h4 id="161-分布式系统硬件分类">1.6.1. 分布式系统硬件分类</h4>
<ol>
<li>
<p>具有单一指令流、单一数据流的计算机称为SISD，从个人计算机到大型机，所有的传统的单处理器计算机均属此类</p>
</li>
<li>
<p>单指令流、多数据流SIMD。这一类是指只有一个指令单元的处理器阵列。指令单元取一条指令，然后控制多个数据单元并行地进行数据处理,每个数据单元均有自己的数据</p>
</li>
<li>
<p>多指令流、单数据流MISD。目前，没有一个已知的计算机属于这一类</p>
</li>
<li>
<p>多指令流、多数据流MIMD。它是一组独立计算机的集合，每一个独立计算机都具有程序计数器、程序以及数据。所有的分布式系统都属于MIMD，MIMD分为两类：</p>
<ul>
<li>具有共享存储器的多处理器系统</li>
<li>没有共享存储器的多计算机系统</li>
</ul>
<p>两者的区别在于：在一个多处理器系统中，所有CPU共享一个单一的虚拟地址空间。在多计算机系统中，每台机器均有它私有的存储器</p>
<p>根据互连网络结构的不同，以上两个分类还可进一步细分：</p>
<ul>
<li>总线型：是指单一的主干线、总线、线缆或其它把所有机器连接起来的介质（例如有线电视）</li>
<li>开关型：机器与机器之间有专门的线路连接。它可以有许多种布线方式。信息沿着线路传输。由一个开关来选择信息的下一条出发线（例如公用电话系统）</li>
</ul>
<p>另一种分类：</p>
<ul>
<li>紧耦合：信息从一台处理机发向另一台处理机的延迟是短暂的且数据传输率（每秒传输位的数目）较高（如两个在同一印刷线路板上由蚀刻在板上的线路连接在一起的CPU）</li>
<li>松散耦合：机器间发送信息的延迟较长且数据传输率较低（如由一个2400位/秒的调制解调器通过电话系统连接的两台计算机）</li>
</ul>
<p>一般来说，紧耦合系统更多地用于并行系统（用来解决单一的问题）而中等松散耦合系统（即局域网）主要用于分布式系统（用来解决多个相关性不大的问题）</p>
</li>
</ol>
<h4 id="162-基于总线的多处理器">1.6.2. 基于总线的多处理器</h4>
<p><img src="image-20220606101843771.png" alt="image-20220606101843771" style="zoom:50%;" /></p>
<ul>
<li>基于总线的多处理器系统是由多个连接在一根公共总线上的CPU以及单个存储器模块所组成</li>
<li>简单的例子：使用一块高速的母板，在上面可插入CPU和存储器条
<ul>
<li>一条典型的总线有32或64条地址线、32或64条数据线以及32条或更多的控制线，这些线都是并行工作的。为了从存储器中读出一个数据，CPU首先将所需数据的地址放到地址总线上，然后在适当的控制线上设置一个信号以表示读。作为响应，存储器将对应地址中的数据放到数据线上以便CPU读入。写的过程与此类似</li>
</ul>
</li>
<li>基于总线多处理器存在的问题：当有4-5个CPU时，通常总线会过载而造成性能急剧下降
<ul>
<li>解决方法：在CPU和总线之间加一个高速缓存。高速缓存保存最常访问的数据。所有存储器的访问请求均经过缓存。如果所要访问的数据在高速缓存中，则高速缓存响应CPU，无需进行总线请求</li>
<li>如果高速缓存足够大，那么,所要访问的数据在高速缓存的可能性即命中率将会很高，而每个CPU的总线通信量将会大幅降低，这将允许更多的CPU连到总线上</li>
</ul>
</li>
<li>缓存的问题：高速缓存的不一致性
<ul>
<li>解决方法：
<ul>
<li>高速缓存写：即当在高速缓存中写入一个字时，同时也往存储器对应单元写入。高速缓存读的成功不会引起总线通信，而高速缓存读的失效以及所有高速缓存写的成功和失败均会造成总线通信</li>
<li>窃听高速缓存：所有的高速缓存都一直监视着总线，每当一个高速缓存发现它的一个单元在存储器中对应的单元被写时。它要么从高速缓存中去掉该单元，要么用新值更新这个高速缓存单元</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="163-基于开关的多处理器系统">1.6.3. 基于开关的多处理器系统</h4>
<p><img src="image-20220606101917867.png" alt="image-20220606101917867" style="zoom:50%;" /></p>
<ul>
<li>
<p>把存储器分成模块并用交叉杆开关将它们与CPU相连接，每个交叉点都是一个由硬件控制开或关的小电子交叉点开关，当CPU要访问某个特定的存储模块时，连接它们的交叉点开关会立即合上,允许对存储模块的访问</p>
<ul>
<li>优点：多个CPU可以同时访问存储模块</li>
<li>缺点：当两个CPU要同时访问相同的存储模块时，它们当中之一必须等待。如果有$n$个CPU和$n$个存储模块， 则交叉点开关必须有$n^2$个，当n较大时,交叉点的数目将急剧增加</li>
</ul>
</li>
<li>
<p>多级互连网络MINS</p>
<ul>
<li>
<p>$N\times N$ Omega网络，如上图所示，是一个4X4Omega网络。这个网络含有4个2╳2开关，每一个开关有两个输入及两个输出。每个开关都可以设置成通过和交叉两种形式。当正确地设置开关时，每个CPU可以访问任意一个存储模块。开关设置仅需几纳秒或更短的时间。</p>
<ul>
<li>一般情况即$N$个CPU和$N$个存储模块，Omega网络需要$\log N$开关级，每级有$N/2$个开关，总开关数为$(N\log N)/2$。虽然对于$N$,开关总数要比$N^2$少得多，但仍然相当庞大</li>
<li>Omega网络的问题：
<ul>
<li>延迟</li>
<li>阻塞：当$N$个不同的CPU同时访问$N$个不同存储模块时，$N\times N$ Omega网共有$N!$个置换，其中$2^{N/2}$个置换不存在阻塞</li>
</ul>
</li>
</ul>
</li>
<li>
<p>除了$n$级Omega网以外，还有baseline和Intercube网，以及这三个网180°翻转的三个Omega^-1^，Baselin^-1^和Inercube^-1^网，即6个$n$级MINs</p>
<ul>
<li>
<p>这6个$n$级MINs在拓扑上是等价的：这对六者中的任意一个，重排其每级开关position，就能转成其他五个的同级输出</p>
</li>
<li>
<p>减少阻塞：增加级数，对于$n+k$级的Omega网，随$k$增加，非阻塞的置换增加</p>
</li>
<li>
<p>已证明$2n-1$级baseline+Baseline^-1^网即Benes网对所有$N!$个置换都是非阻塞的</p>
<ul>
<li>4级Baseline网+4级Baseline^-1^网</li>
</ul>
<p><img src="image-20220606110649223.png" alt="image-20220606110649223" style="zoom:50%;" /></p>
<ul>
<li>将4级Baseline网的最后1级与Baseline^-1^网的第1级重合形成1级，这就是$N=16,n=4,2\times4-1=7$级的Benes网</li>
</ul>
<p><img src="image-20220606110947625.png" alt="image-20220606110947625" style="zoom:50%;" /></p>
</li>
<li>
<p>$N=8,n=3,2\times3-1=5$级的Inercube+Intercube^-1^网。而它与5级的Benes网在拓扑等价的，所以，它也是对所有置换是无阻塞的</p>
<p><img src="image-20220606111047349.png" alt="image-20220606111047349" style="zoom:50%;" /></p>
</li>
<li>
<p>目前，人们只能证明$N=8,n=3, 2n-1=5$级Omega+Omega是非阻塞的</p>
</li>
<li>
<p>已证明对于任意2个$n+k$级网，如果它们的拓扑序列相等,则它们在拓扑上是等价的,其中,前$n$级网可以是6种$n$级网中任意一种,而后面$k$级网可以是6种$n$级网中任意$k$级</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="164-基于总线的多计算机系统">1.6.4. 基于总线的多计算机系统</h4>
<p><img src="image-20220606111604775.png" alt="image-20220606111604775" style="zoom:50%;" /></p>
<ul>
<li>在一个无共享存储器的多计算机系统中。每个CPU都与自己的局部存储器直接相连。这一类系统所涉及的问题是CPU间的通讯。由于CPU之间的通信量要比CPU到存储器之间的通信量少多个数量级，所以，采用一个总线来连接网络</li>
<li>拓扑结构与基于总线的多处理器很相似。由于通信量少，所以，不需要高速主干总线，一个速度较低的<strong>LAN</strong>就足够了</li>
</ul>
<h4 id="165-基于开关的多计算机系统">1.6.5. 基于开关的多计算机系统</h4>
<ul>
<li>
<p>每个CPU都可以直接访问自己的私有存储器而拒绝其它CPU访问自己的私有存储器</p>
</li>
<li>
<p>常见的拓扑结构：网孔和超立方体</p>
<ul>
<li>网孔比较规整且易于布线。最适合那些具有两维性质的问题，如图论或视觉</li>
<li>一个超立方体是一个$n$维立方体</li>
</ul>
<p><img src="image-20220606111936925.png" alt="image-20220606111936925" style="zoom:50%;" /></p>
</li>
<li>
<p>如果把4维超立方体扩展成5维超立方体，则只需将这两个4维超立方体的对应顶点连接起来即可</p>
<ul>
<li>$d$维超立方体有$2^{d-3}$个立方体</li>
</ul>
</li>
<li>
<p>对于一个$n$维的超立方体，每个CPU都与其它$n$个CPU相连。这样，布线复杂度将随维数的大小成对数增加。只有相邻的CPU才直接相连，许多信息在到达目的地前必须经过几个段。这样，最长路径也随维数的大小成对数增加</p>
</li>
<li>
<p>网孔的最长路径将随CPU数目成平方根增加</p>
</li>
</ul>
<h3 id="17-分布式系统软件">1.7. 分布式系统软件</h3>
<h4 id="171-网络操作系统">1.7.1. 网络操作系统</h4>
<ul>
<li>网络操作系统是运行在松散耦合硬件之上的松散耦合软件，除了共享资源以外，用户能够明显地知道系统有多少个服务器存在。是用户和网络之间的一个接口，它除了应该具备通常操作系统所应具备的基本功能外，还应该具有联网功能，支持网络体系结构和各种网络通信协议，提供网络互连能力，支持有效可靠安全地数据传输</li>
<li>早期网络操作系统功能较为简单，仅提供基本的数据通信、文件和打印服务等。随着网络的规模化和复杂化，现代网络的功能不断扩展，性能大幅度提高，很多网络操作系统把通信协议作为内置功能来实现，提供与局域网和广域网的连接</li>
<li>网络操作系统的特征：
<ul>
<li>硬件独立性：网络操作系统可以运行在不同的网络硬件上，可以通过网桥或网关与别的网络连接</li>
<li>支持多用户：能同时支持多个用户对网络的访问，对信息资源提供安全和保护功能</li>
<li>支持网络实用程序及其管理功能：系统备份、安全管理、容错和性能控制</li>
<li>支持多种客户端：如WindowsNT 可以支持MS-DOS、OS/2、Windows98、Windows for wrokgroup、UNIX 等多种客户端，极大地方便了网络用户的使用</li>
<li>提供目录服务：以单一逻辑的方式让用户访问所有网络服务和资源的技术</li>
<li>支持多种增值服务：如文件服务、打印服务、通信服务、数据库服务、WWW服务等等</li>
<li>可操作性：允许多种操作系统和厂商的产品共享相同的网络电缆系统，且彼此可以连通访问</li>
</ul>
</li>
<li>网络操作系统的三种类型：
<ul>
<li>集中模式：是由分时操作系统加上网络功能演变而成的，系统的基本单元是一台主机和若干台与主机相连的终端构成，把多台主机连接起来就形成了网络，而信息的处理和控制都是集中的，UNIX 系统是这类系统的典型例子</li>
<li>客户/服务器模式：网络中连接许多台计算机，其中，一部分计算机称为服务器，提供文件、打印、通信、数据库访问等功能，提供集中的资源管理和安全控制。而另外一些计算机称客户机，它向服务器请求服务，如文件下载和信息打印等
<ul>
<li>服务器通常配置高，运算能力强，有时还需要专职网络管理员维护</li>
<li>客户机与集中式网络中的终端不同的是，客户机有独立处理和计算能力，仅在需要某种服务时才向服务器发出请求</li>
<li>客户/服务器模式在逻辑上是星形结构，以服务器为中心，服务器与各客户间采用点到点通信方式</li>
</ul>
</li>
<li>对等模式：让网络中的每台计算机同时具有客户和服务器两种功能，既可以向其他机器提供服务，又可以向其他机器请求服务，而网络中没有中央控制手段</li>
</ul>
</li>
<li>如果客户和服务器运行不同的操作系统，那么,对于所有需要交换的信息,他们至少在信息的格式及意义上要保持一致。因此,每台机器具有高度的自治性并且对系统范围内的要求较少</li>
</ul>
<h4 id="172-分布式操作系统">1.7.2. 分布式操作系统</h4>
<ul>
<li>分布式操作系统是在松散耦合（即多计算机）硬件上运行紧耦合软件，从用户上看整个计算机网络就象一个单一的分时系统一样，而不是各种机器的集合，这被称之为单系统映像。分布式操作系统实际上是一个在网络计算机集合上运行的系统，整个系统就象一个单一的虚拟处理器一样。用户不知道也不必知道系统有多个台计算机的存在。</li>
<li>分布式操作系统的特征
<ul>
<li>有一个统一的全局进程间通信机制来保证每一个进程可以与任意一个其它进程进行联系。不允许在不同机器上采用不同的通信机制或者对本地通信与远程通信采用不同的通信机制</li>
<li>有一个全局保护方案。仅把访问控制列表和UNIX的保护位以及各种能力堆砌在一起是形成不了单一的系统映像的</li>
<li>所有机器上的进程管理必须相同即进程的创建、撤消、运行和停止不能因机器而异</li>
<li>所有机器上有统一的一组系统调用，并且这些调用必须适应分布式环境</li>
<li>所有机器上的文件系统也必须一样。在某些地方文件长度有11个字符的限制而在其它一些地方则没有，这种情况是不允许出现的</li>
<li>除了受保护及安全性限制以外，每个文件应在任何一个地方都是可访问的</li>
<li>系统中所有的CPU必须运行相同内核。这样做比较容易协调全局活动</li>
<li>需要一个全局的文件系统</li>
<li>每个内核对自己的局部资源应有较大的控制权
<ul>
<li>由于没有共享存储器，应该允许每个内核来管理它自己的存储器</li>
<li>如果某个机器上需要换页，那么，应由该机器CPU的内核自己来进行换页</li>
<li>如果在某个CPU上有多个进程在运行，那么，也应该在该CPU上进行进程调度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="173-多处理器分时操作系统">1.7.3. 多处理器分时操作系统</h4>
<ul>
<li>在紧耦合硬件上运行的紧耦合软件，典型紧耦合硬件是多处理器计算机</li>
<li>整个设计可以集中化，因此多处理器系统的实现比较容易。但是，它需要一个单一的运行队列即系统中所有进程的列表，表中的进程是非阻塞的并处于就绪状态，运行队列是共享存储器中的一个数据结构
<ul>
<li>如果所有的CPU都在等待I/O而空闲，此时有某个进程就绪，那么应该将该进程分配给它最近使用的那个CPU(假设其它进程一直没有使用过这个CPU)。这样分配可以提高一部分性能（复用Cache）</li>
<li>如果在一个多处理器上的进程由于I/O而阻塞,那么,操作系统或者把它挂起或者让它等待。如果这个I/O可以在小于一个进程切换时间内完成，那么,让进程等待是比较合适的</li>
</ul>
</li>
</ul>
<p><img src="image-20220606151315634.png" alt="image-20220606151315634" style="zoom: 80%;" /></p>
<h3 id="18-分布式系统的设计问题">1.8. 分布式系统的设计问题</h3>
<h4 id="181-透明性">1.8.1. 透明性</h4>
<ul>
<li>透明性可以在两个不同层次上实现：
<ul>
<li>高层次：对用户透明，例如：make分布式编译</li>
<li>低层次：对程序员透明</li>
</ul>
</li>
<li>透明性的表现：
<ul>
<li>位置透明</li>
<li>迁移透明</li>
<li>复制透明</li>
<li>并发透明</li>
<li>并行透明
<ul>
<li>最复杂，解决方法是通过编译器、运行系统和操作系统来合理地利用多个计算机的并行性而不是让用户自已来安排</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="182-灵活性">1.8.2. 灵活性</h4>
<p><img src="image-20220606160842873.png" alt="image-20220606160842873" style="zoom:80%;" /></p>
<ul>
<li>大内核：每台机器应运行一个传统的内核,由内核提供大多数的服务
<ul>
<li>优点
<ul>
<li>性能好</li>
</ul>
</li>
</ul>
</li>
<li>微内核：内核所提供的服务应尽可能的少，大量操作系统服务可从用户级服务器上获得
<ul>
<li>基本服务
<ol>
<li>进程间通信机制</li>
<li>存储管理</li>
<li>底层进程管理及调度</li>
<li>底层输入输出</li>
</ol>
</li>
<li>优点
<ul>
<li>模块化</li>
<li>容易安装及调试新服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="184-可靠性">1.8.4. 可靠性</h4>
<ul>
<li>可用性
<ul>
<li>改善方法：冗余</li>
</ul>
</li>
<li>安全性</li>
<li>容错</li>
</ul>
<h4 id="185-性能">1.8.5. 性能</h4>
<ul>
<li>
<p>度量方法</p>
<ul>
<li>
<p>响应时间</p>
</li>
<li>
<p>吞吐率</p>
</li>
<li>
<p>利用率</p>
</li>
<li>
<p>网络容量消耗</p>
</li>
</ul>
</li>
<li>
<p>提高方法</p>
<ul>
<li>减少通信量</li>
<li>考虑计算粒度</li>
</ul>
</li>
</ul>
<h4 id="186-可缩放性">1.8.6. 可缩放性</h4>
<ul>
<li>一个分布式算法的效率$E$，当$n$数目到达顶点$M$后，随着$n$数目的增加，比较平稳缓慢下降，则我们称该分布式算法的可缩放性好</li>
</ul>
<h2 id="2-分布式系统同步">2. 分布式系统同步</h2>
<h3 id="21-分布式系统时钟同步">2.1. 分布式系统时钟同步</h3>
<p>分布式算法应具有以下特征：</p>
<ol>
<li>相关的信息是分布在多个机器上</li>
<li>进程根据局部信息来作出决定</li>
<li>对系统中任一机器的失败应能容错</li>
<li>不存在公共时钟或其他全局时间源</li>
</ol>
<p>在分布式系统中，时钟同步是非常重要的，也是必不可少的</p>
<h4 id="211-逻辑时钟同步算法">2.1.1. 逻辑时钟同步算法</h4>
<ul>
<li>
<p>时钟：计算机上用于记录时间的电路，实际上是一个定时器，一个以某个频率进行震荡的石英晶体</p>
<ul>
<li>与定时器相关的两个寄存器分别称为计数器和保持寄存器，晶体每震荡一次，计数器减一，当计数器变为0时，一个中断产生并将保持寄存器的值重新装入到计数器中</li>
<li>单机系统：所有进程共有时钟，每一个进程得到的时钟值在本机内一致</li>
<li>分布式系统：无法保证不同机器上晶体震荡频率的一致性，因此需要同步方法</li>
</ul>
</li>
<li>
<p>Lamport时钟同步算法</p>
<ul>
<li>
<p>时钟的同步不是绝对的，如果两个进程并不交互,则它们的时钟就无须同步</p>
</li>
<li>
<p>系统中的进程不需要在事件发生的确切时间上达成一致而只需要在事件发生的先后顺序上达成一致即可</p>
</li>
<li>
<p>这种并不一定是真正时间但所有机器都一致认可的时钟称之为逻辑时钟</p>
</li>
<li>
<p>定义“在之前发生”的关系$a\rightarrow b$，存在于两种情况：</p>
<ol>
<li>如果$a$和$b$都是同一个进程中的两个事件且$a$在$b$之前发生，则$a\rightarrow b$为真</li>
<li>如果$a$是一个进程发送一个消息的事件且$b$是另一个进程接收该消息的事件，则$a\rightarrow b$为真</li>
</ol>
<p>否则称为并发事件</p>
</li>
<li>
<p>度量时间的方法：对于每个事件$a$，分配一个所有进程都认可的时间值$C(a)$，具有特性：如果$a\rightarrow b$，则$C(a)&lt;C(b)$。时钟时间$C$是一直增加的不会减少</p>
<p><img src="image-20220606215842002.png" alt="image-20220606215842002" style="zoom:80%;" /></p>
</li>
<li>
<p>Lamport算法：每一个消息都含有一个发送者时钟的发送时间，当消息到达时,接收者将自己时钟的接收时间与发送时间相比较。如果接收时间小于等于发送时间,则接收者的时钟被修改成发送时间加1。如果接收时间大于发送时间，则不改变接收者的时钟</p>
<ul>
<li>需要满足的要求：任意两个事件的时间之差至少为1。如果一个进程连续发送或接收两个消息,则这两个消息的时间之差也至少为1</li>
<li>事件发生的时间值与该事件所属进程的进程号连接起来,中间用‘.’加以分隔。例如，进程1和进程2中两个事件。
<ul>
<li>例如,进程1和进程2中两个事件恰好同时在时间为40时发生。进程1中的事件发生时间为40.1而进程2中的事件发生时间为40.2</li>
</ul>
</li>
<li>系统中所有事件的赋值方法：
<ol>
<li>在同一进程中，若事件$a$在事件$b$之前发生，则$C(a)&lt;C(b)$</li>
<li>如果$a$和$b$分别是一个消息的发送和接收事件，则$C(a)&lt;C(b)$</li>
<li>对所有事件$a$和$b$，$C(a)\neq C(b)$</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="212-物理时钟同步算法">2.1.2. 物理时钟同步算法</h4>
<ul>
<li>所有的时钟不仅一致而且与实际时间之间的误差不超过某个值称为物理时钟</li>
<li>当UTC（标准时间源）时间为$t$，则机器$p$上时钟值为$C_p(t)$。在理想情况下，对于所有的$p$和$t$，$C_p(t)=t$，即$\mathrm dC/\mathrm dt=1$</li>
<li>如果存在某个常数$\rho$使得：$1-\rho\leq \mathrm dC/\mathrm dt\leq 1+\rho$，则该定时器的误差在允许的范围之内，常数$\rho$称为最大漂移率。当$\mathrm dC/\mathrm dt&gt;1$时，时钟太快；当$\mathrm dC/\mathrm dt&lt;1$时，时钟太慢</li>
<li>如果两个时钟朝着UTC两个相反的方向漂移，则在它们同步后的$\Delta t$时刻，它们之间的相差为$2\rho\Delta t$。如果操作系统的设计者要保证任意两个时钟相差不超过$\delta$，则时钟必须每$\delta/2\rho$秒同步一次</li>
<li>Cristian算法
<ul>
<li>假定：有一台机器拥有一个WWW接收器，称这台机器为时间服务器</li>
<li>算法：每一台机器周期地（周期低于$\delta/2\rho$秒）向时间服务器发送一个消息请求获得当前标准时间。时间服务器尽可能快地将一个含有当前时间$C_{UTC}$的消息回送给发送请求的机器。发送机器收到回答消息后，就将自己的时钟调到$C_{UTC}$</li>
<li>大问题：由于发送机器的时间不得向后调,所以,当发送机器的时间比标准时间$C_{UTC}$快,则将产生严重问题
<ul>
<li>解决方法：假定定时器每秒钟中断100次，则每一次中断将引起时间增加10ms。当时间快时,则每一次中断时间将增加9ms。同样,当时间慢时,则每一次中断时间将增加11ms。这个过程一直持续到时间正确为止</li>
</ul>
</li>
<li>小问题：服务器的回答消息在路途上花费了一定的延迟。这个延迟将随着网络负载的变化而变化
<ul>
<li>解决方法：发送机器精确地记录从发送请求到收到回答这段时间，开始发送时间$T_0$和收到回答时间$T_1$（均用发送机器的时钟来度量），假定时间服务器处理请求消息和中断所花费的时间为$I$。那么回答消息的延迟为$(T_1-T_0-I)/2$，如果请求消息和回答消息所走的路径不同，则回答消息的延迟将不能除以2。此外，当网络拥挤或不可靠时，$T_1-T_0$将异常的大，所以，当$T_1-T_0$超过某个阈值，则将其丢弃</li>
</ul>
</li>
</ul>
</li>
<li>Berkeley算法
<ul>
<li>在Cristian算法中,时间服务器是被动的而且需要一个WWW接收器。而在Berkeley算法中,时间服务器是主动的且无须一个WWW接收器</li>
<li>算法：时间服务器周期地轮询每一个机器当前的时间。收到所有机器当前时间后，计算其平均值。然后,将该平均值发送给每一个机器。每一个机器都将自己的时钟调到这个平均值。但是时间服务器的时钟必须由操作员周期地手工调整。更为精确的做法是每一个机器还将这个平均值+服务器到每一个机器的延迟</li>
</ul>
</li>
<li>平均算法
<ul>
<li>Cristian算法和Berkeley算法都是集中式物理时钟同步算法</li>
<li>基本思想：将时间划分为固定长度的再同步间隔。$i^{th}$间隔从$T_0+iR$时刻开始到$T_0+(i+1)R$时刻结束，其中，$T_0$是过去认可的一个时刻，$R$是一个系统参数。在每一个间隔的开始，每一个机器都广播自己时钟当前的时间值，由于不同机器上时钟的速度不相同，所以，这些广播不会恰好同时进行。每一个机器广播自己的时间后，它就启动自己的定时器来收集在第$S$间隔内其他机器发来的时间值。当所有机器含有时间值的广播到达后，它计算所有时间值的平均值并将自己的时钟调整到这个平均值</li>
<li>改进方法：去掉$m$个最大值和$m$个最小值，计算剩余时间的平均值。以消除某些机器时钟的损坏所造成的时钟值过大和过小的异常情况，提高时间值的正确性。该算法还可以考虑每一个广播消息的延迟。消息延迟可以通过已知网络拓扑或者探察消息返回的时间来获得</li>
</ul>
</li>
</ul>
<h3 id="22-分布式互斥">2.2. 分布式互斥</h3>
<ul>
<li>在具有多个进程的系统中，当一个进程要读或者修改某个共享数据结构时，它就必须首先进入一个临界区取得互斥权来确保其它进程不能同时使用该共享数据结构</li>
<li>在单机系统中，临界区是采用信号灯和管程来保护共享数据结构</li>
</ul>
<h4 id="221-集中式互斥算法">2.2.1. 集中式互斥算法</h4>
<p><img src="image-20220607143703292.png" alt="image-20220607143703292" style="zoom:80%;" /></p>
<ul>
<li>选择一个进程作为协调器。</li>
<li>当进程1要进入临界区时，它发送一个请求消息给协调器，告诉协调器它要进入那个临界区并申请访问权。如果当前没有一个进程在所申请的临界区内,则协调器回送一个允许访问的回答消息给申请进程，当回答消息到达时,申请进程进入临界区。</li>
<li>假定此时进程2也要求进入同一个临界区。由于进程1已在临界区内，所以，协调器不回送回答消息给等待回答消息的进程2。然后，暂时将进程2的申请进行排队，进程2阻塞。当进程1退出临界区时，它就发送一个释放互斥访问的消息给协调器。协调器从请求队列中取出第一个申请,然后,回送一个允许访问的回答消息给发送该申请的进程(即进程2)。解除该申请进程的阻塞并进入临界区</li>
</ul>
<h4 id="222-分布式互斥算法">2.2.2. 分布式互斥算法</h4>
<p><img src="image-20220607150446200.png" alt="image-20220607150446200" style="zoom:80%;" /></p>
<ul>
<li>
<p>Ricart和Agrawala算法的要求：系统中的所有事件都是顺序的，即任意两个事件发生的顺序是明确的，Lamport的逻辑时钟为分布式互斥提供了邮戳</p>
</li>
<li>
<p>Ricart和Agrawala算法：当一个进程要进入一个临界区时，它就建立一个消息。该消息含有要进入的临界区名字、自己的进程号以及当前时间。然后，将该消息发送给所有其它进程。假定消息的发送是可靠的。这里，我们也可以使用可靠的组通信来广播该消息。当一个进程收到另一个进程发来的一个请求消息时，它根据消息中指定临界区的状态采取相应的措施。我们将其分成下列三种情况：</p>
<ol>
<li>如果接收者不在指定的临界区内且又不想进入该临界区，则它回送一个OK消息给发送者</li>
<li>如果接收者已在指定的临界区内，则不回答而将请求排队</li>
<li>如果接收者要进入指定临界区但还未进入，则它接收的请求消息中邮戳和它发送的请求消息中的邮戳进行比较。若前者的邮戳比后者的邮戳小，则接收者回送一个OK消息给发送者。若后者的邮戳比前者的邮戳小，则接收者将收到的请求排队。</li>
</ol>
<p>一个进程在发送完请求消息后就一直等待所有进程回送的OK消息。只要所有的OK消息都到达，则它就可以进入指定的临界区。当该进程离开临界区时，它就发送一个OK消息给所有在本进程内排队要进入同一个临界区的进程并将这些进程的请求从队列中移去</p>
</li>
<li>
<p>Ricart和Agrawala算法存在的问题：既无死锁又无饿死也无单点失败。每次进入临界区要求发送$2(n-1)$个消息，其中，$n$为系统中进程总数，但是，一个进程崩溃将不响应所有的请求</p>
<ul>
<li>解决方法：当一个请求到达时，接收者或者回送一个允许访问消息或者回送一个不允许访问消息。每当一个请求或回答丢失时，发送者超时表明目前进程已崩溃。一个请求被拒绝后，发送者应该阻塞，等待以后发来的OK消息</li>
<li>与集中式算法相比：速度慢，复杂以及代价高</li>
</ul>
</li>
</ul>
<h4 id="223-令牌环算法">2.2.3. 令牌环算法</h4>
<p><img src="image-20220607170646928.png" alt="image-20220607170646928" style="zoom:80%;" /></p>
<ul>
<li>一个总线网络中的进程没有任何顺序，在总线上构造一个逻辑环，在这个环中，每一个进程按顺序分配一个号</li>
<li>令牌环算法：当初始化环时,进程0获得令牌。该令牌绕环循环即令牌以点到点消息传递的方式从进程$k$传递到进程$k+1$（按环大小取模），当一个进程从它的邻域那里收到了令牌，检查自己是否需要进入临界区，若要，则进入临界区、使用临界区、离开临界区。在离开临界区后，将令牌传递给下一个邻居。若进程从邻居处收到令牌且不需要进入临界区，则将令牌传给下一个邻居。若不存在进程需要进入临界区，则令牌绕环告诉循环</li>
<li>令牌环算法的正确性：
<ul>
<li>由于在任何时刻只有一个进程拥有令牌，所以，只有一个进程在临界区中</li>
<li>令牌是按顺序绕环传递的，因而不会出现饿死现象</li>
</ul>
</li>
<li>存在的问题：
<ul>
<li>如果令牌丢失，则必须重新生成令牌，而检测令牌的丢失是相当困难的</li>
<li>检测崩溃：要求收到令牌的进程给其上一个邻居回送一个应答即可，当一个进程检测到它的下一个进程崩溃时,它就将崩溃进程从环中移去并将令牌发送给崩溃进程的下一个邻居。这也要求每一个进程必须维护当前环的结构</li>
</ul>
</li>
</ul>
<h4 id="224-三种互斥算法的比较">2.2.4. 三种互斥算法的比较</h4>
<ul>
<li>
<p>消息数</p>
<ul>
<li>
<p>集中式：3</p>
</li>
<li>
<p>分布式：$2(n-1)$</p>
</li>
<li>
<p>令牌环：至少为1</p>
</li>
</ul>
</li>
<li>
<p>延迟（用传输消息数进行计算）</p>
<ul>
<li>集中式：2</li>
<li>分布式：$2(n-1)$</li>
<li>令牌环：0到$n-1$</li>
</ul>
</li>
<li>
<p>遇到的问题</p>
<ul>
<li>集中式：协调器的崩溃</li>
<li>分布式：任一进程的崩溃</li>
<li>令牌环：令牌丢失与任一进程崩溃</li>
</ul>
</li>
</ul>
<h3 id="23分布式选举算法">2.3.分布式选举算法</h3>
<ul>
<li>假设每个进程都有一个特殊的号，通常选举算法总是找拥有最大号的进程，将它指定为协调者，不同的选举算法在选举时采用不同的方法</li>
<li>假设每个进程都知道所有其他进程的进程号，但不知道目前哪些进程在工作，哪些进程不在工作；选举算法的目的是在选举开始后，确保在所有进程都同意的基础上选出协调者</li>
</ul>
<h4 id="231-欺负算法">2.3.1. 欺负算法</h4>
<ul>
<li>
<p>当一个进程P发现协调者不再响应请求时，它就发起选举。进程P负责选举算法如下：</p>
<ol>
<li>P向所有进程号比它大的进程发送选举（ELECTION）消息</li>
<li>若无人响应，P获胜成为协调者</li>
<li>若有进程号比它大的进程响应，响应者接管，P的工作完成</li>
</ol>
</li>
<li>
<p>由于总是进程号最大的进程获胜，故该算法命名为欺负算法</p>
<ul>
<li>在某一时刻，一个进程只能从进程号比它小的进程那里得到一个选举（ELECTION）消息，当它到达时，接收者就发送回OK消息，表明它的存在并接管，然后接收者主持选举（除非它正在主持别的选举）。</li>
<li>除了一个进程外即进程号最大的进程，其余进程都会放弃选举，这个进程就是新的协调者，它将选举获胜的消息发送给所有进程，告之自己是新的协调者</li>
<li>若一个进程刚刚崩溃过，但又很快恢复，它主持选举，若它刚好是当前运行进程中号最大的，它就会获得选举的胜利，从而接管协调者的工作</li>
</ul>
</li>
<li>
<p>举例</p>
<p><img src="image-20220607195052652.png" alt="image-20220607195052652" style="zoom:50%;" /></p>
<ul>
<li>
<p>一组由0~7号共8个进程组成，开始7号进程是协调者，但是它突然发生了故障，进程4第一个注意到这一点，所以它向所有比它进程号大的进程，即进程5、6、7发送选举消息</p>
<p><img src="image-20220607195145545.png" alt="image-20220607195145545" style="zoom: 50%;" /></p>
</li>
<li>
<p>进程5和6接收消息后，均回送一个OK。进程4接收到第一个应答时就知道自己的选举已经结束了，因为已经有比它进程号大的进程即将接管它的选举工作，它就等待着看谁将在选举中获胜</p>
<p><img src="image-20220607195204765.png" alt="image-20220607195204765" style="zoom:50%;" /></p>
</li>
<li>
<p>进程5和6都主持选举，每个进程仅把消息发送给比自己进程号大的进程</p>
<p><img src="image-20220607195222240.png" alt="image-20220607195222240" style="zoom:50%;" /></p>
</li>
<li>
<p>进程6向进程5发OK消息，进程5收到OK消息后停止选举，而这个时候进程6知道进程7已经死了，所以，它将是获胜者</p>
<p><img src="image-20220607195245579.png" alt="image-20220607195245579" style="zoom:50%;" /></p>
</li>
<li>
<p>进程6接管，向所有运行的进程发送COORDINATOR协调者消息</p>
</li>
<li>
<p>进程4收到消息，发现进程7已死，进程6是新协调者，进程4就可继续工作</p>
</li>
</ul>
</li>
</ul>
<h4 id="232-环算法基于没有令牌的环">2.3.2. 环算法（基于没有令牌的环）</h4>
<ul>
<li>
<p>假设所有的进程是按物理或逻辑环排序的，每个进程都知道谁是它的下邻居</p>
<ul>
<li>当一个进程发现协调者不再起作用时，它就创建一个包含它自身进程号的选举消息发送给它的下邻居</li>
<li>如果下邻居失效，消息将绕过它到达它的下邻居，或者再下一个，直到找到一个运行进程</li>
</ul>
</li>
<li>
<p>每一个发送者都将自己的进程号加入到消息表中。最后，消息到达了始发者手中，始发者接收到包括自己进程号的消息后，将消息的类型转化为协调者消息，该消息将再一次绕环运行，向所有的进程通知谁是协调者（在成员表中进程号最大的那个）。当消息循环一周后，被销毁，每个进程都恢复工作</p>
</li>
<li>
<p>举例</p>
<p><img src="image-20220607195536946.png" alt="image-20220607195536946" style="zoom: 80%;" /></p>
<ul>
<li>进程2、5同时发现前任协调者进程7失效，它们各自建立一个选举消息沿环发送</li>
<li>两条消息都将沿环运动，进程2和5分别将它们转化成协调者消息，消息中有完全一样的成员，相互顺序也相同，当两条消息再绕环一周后，均被销毁</li>
</ul>
</li>
</ul>
<h3 id="24-原子事务">2.4. 原子事务</h3>
<h4 id="241-事务模型">2.4.1. 事务模型</h4>
<ul>
<li>
<p>事务的属性和模型</p>
<ul>
<li>假设1：系统由一些相互独立的进程组成，每个进程都会随机出错</li>
<li>假设2：通信错误已经被底层软件透明地处理。尽管通信一般来说是不太可靠的，消息会丢失，但是底层可以采用超时重发协议恢复丢失的消息</li>
<li>假设3：稳定存储器。存储器有三种分类。第一种是普通的RAM存储器，当电源出错或机器崩溃时会丢失信息。第二种是磁盘存储器，它不受CPU错的影响，但磁头错会导致信息丢失。最后一种是稳定存储器,它不受其他任何错误的影响</li>
</ul>
</li>
<li>
<p>事务原语</p>
<ul>
<li><code>BEGIN_TRANSACTION</code>：标记一个事务的开始</li>
<li><code>END_TRANSACTION</code>：结束事务并设法提交</li>
<li><code>ABORT_TRANSACTION</code>：取消事务；恢复旧值</li>
<li><code>READ</code>：从一个文件（或其他对象）读取数据</li>
<li><code>WRITE</code>：将数据写入一个文件（或其他对象）</li>
</ul>
<p>事务原语取决于事务中正在使用的对象类型</p>
</li>
<li>
<p>事务体</p>
<ul>
<li><code>BEGIN_TRANSACTION</code>和<code>END_TRANSACTION</code>限定事务的范围。它们之间的操作构成了事务体</li>
<li>事务体中的操作要么全部执行，要么一个也不执行</li>
<li>这些事务体中的操作可以是系统调用，库过程，或者是某种语言中用括号括起来的语句，这取决于应用的需要</li>
</ul>
</li>
<li>
<p>事务的特性ACID</p>
<ul>
<li>原子性Atomic：对外部世界来说，事务的发生是不可分割的。确保了每个事务要么全部发生，要么全部不发生</li>
<li>一致性Consistent：事务不会破坏系统的恒定，系统拥有某种必须保持的不变性</li>
<li>孤立性Isolated：并发的事务不会互相干扰，如果两个或两个以上的事务在同时运行，那么对它们自己和其他进程来说，最终结果看起来就像是所有的事务是按某种次序（依赖于系统）顺序运行的</li>
<li>持久性Durable：一旦一个事务提交，改变就是永远存在的</li>
</ul>
</li>
<li>
<p>嵌套事务</p>
<ul>
<li>事务可以包含子事务，这通常称作嵌套事务
<ul>
<li>顶层事务可以在不同的处理机上创建并运行子事务，以提高性能简化编程</li>
<li>子事务中的任何一个都可以执行一个或多个子事务，或者创建自己的子事务</li>
<li>子事务会引起持久性问题，持久性只是对顶层事务而言</li>
</ul>
</li>
</ul>
</li>
<li>
<p>事务提交</p>
<ul>
<li>事务提交操作必须是原子的，即瞬时的和不可再分的</li>
<li>在分布式系统中，提交操作可能需要不同机器上的多个进程的协作，这些进程中的每一个都有一些被事务改动过的变量、文件、数据库或者其他对象</li>
<li>两阶段提交协议
<ul>
<li>基本思想：系统中有一个进程作为协调者。一般来说这个进程就是执行事务的进程。提交协议开始时协调者先写入一条日志条目以表明它要开始执行提交协议，然后，它给每个相关进程（下属）发送一条消息通知它们为提交作好准备。当一个下属收到消息后，它先进行检查以确认是否为提交作好了准备，然后，将它是否准备提交的决定发回给协调者。当协调者收到了所有的响应后，它就知道是否可以提交或中止。如果所有的进程都准备提交，那么事务就可以提交了。如果一个或几个进程不能提交（或没有响应），那么事务就得终止。无论是提交还是终止，协调者都要写一条日志记录并给每个下属发送一条消息以便将决定通知它们。正是因为写入的日志才使得事务能真正被提交</li>
<li>崩溃和回复
<ul>
<li>如果协调者在写入了初始化日志后崩溃，那么在恢复时只需要从停止的地方开始继续工作就可以了</li>
<li>如果在响应第一条消息之前某个下属崩溃了，那么协调者将会给它不断地发送消息</li>
<li>如果协调者以后崩溃了，那么它就可以从日志中看出自己所处的位置，并能决定该作些什么</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="242-并发控制">2.4.2. 并发控制</h4>
<ul>
<li>当多个事务在不同的进程（在不同的处理机上）中同时执行时，需要一些机制以保证它们互不干扰，这种机制称为并发控制算法，主要有：
<ol>
<li>加锁法</li>
<li>乐观并发控制</li>
<li>时间戳</li>
</ol>
</li>
</ul>
<p><strong>加锁法</strong></p>
<ul>
<li>
<p>作为一个事务的一部分，当一个进程需要读或写一个文件（或其他对象）时，它首先将这个文件加锁。由于正常的进程在一个文件被加锁前不会试图去存取它，因此对文件加锁可以防止其他进程对文件的访问，这就保证了一个事务的生存期内文件不会被改变。锁一般由事务系统请求和释放，不需要编程人员的操作</p>
</li>
<li>
<p>加锁法实现：可以使用一个集中式加锁管理程序来实现，也可以在每台机器上有一个本地加锁管理程序来管理本地文件</p>
<ul>
<li>两种情况下加锁管理程序都拥有一个锁定的文件列表，所有对已加锁文件进行的加锁尝试都将被拒绝</li>
</ul>
</li>
<li>
<p>读锁和写锁</p>
<ul>
<li>如果在一个文件上设置了读锁，那么在它上面设置其他的读锁也是允许的，写锁是禁止的</li>
<li>读锁用来确保文件不会被改写（也即排斥所有的写入者），但不禁止其他读取文件的事务</li>
<li>当一个文件被设置写锁时，其他任何类型的锁都被禁止，即读锁是可以共享的，而写锁必须是互斥的</li>
</ul>
</li>
<li>
<p>锁的粒度</p>
<ul>
<li>一个加锁单位究竟取多大的问题称为锁的粒度</li>
<li>粒度越细，加锁就可以越精确，也就能实现更大的并发度</li>
<li>锁分得越细致，也就越需要更多的锁，这样的开销也就越大，也就更容易导致死锁</li>
</ul>
</li>
<li>
<p>两阶段加锁法</p>
<p><img src="image-20220607210332371.png" alt="image-20220607210332371" style="zoom:50%;" /></p>
<ul>
<li>事务开始前，进程尝试对所有此事务需要的行进行加锁，按顺序一次锁一行，查询就加共享锁，修改就加互斥锁</li>
<li>执行更新然后释放所有锁。若在第一阶段某个进程加锁时发生冲突，则该进程释放它所有加锁的行，然后重试第一阶段</li>
</ul>
</li>
<li>
<p>死锁</p>
<ul>
<li>若两个进程都试图以相反的顺序请求同一对锁，那么，就会发生死锁</li>
<li>解决方法：
<ol>
<li>采用以某种顺序请求所有锁的方法来防止保持-等待循环的出现</li>
<li>通过对一张描述哪个进程可以拥有哪个锁，它还想请求哪个锁的图进行死锁扫描，以便检查是否有环路出现，以防止死锁</li>
<li>如果事先知道一个锁的拥有时间不会超过$T$秒，也可以采用一个超时方案：如果某个拥有者连续拥有同一个锁超过了$T$秒，那么一定是出现了死锁</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>乐观并发控制</strong></p>
<ul>
<li>思想：尽管放心去做你想做的，不用在意其他人正在做什么。如果有问题出现，那么以后再考虑吧</li>
<li>冲突处理：记录下有哪些文件曾经被读写过，在提交时刻，检测其他的事务以判断在本事务开始后它的文件是否被其他事务修改过。如果被修改过，那么，本事务将被中止。如果没有修改过，那么本事务就可以提交了</li>
<li>适合于基于私有工作空间的情况。每个事务都独立地修改各自的文件，不会涉及其他事务。在结束的时候，新的文件要么被提交要么被释放</li>
<li>优点
<ul>
<li>避免了死锁，而且允许最大限度的并行度（进程不需要去等待一个锁）</li>
</ul>
</li>
<li>缺点
<ul>
<li>有时可能会失效，这时，所有事务都必须退回重新运行</li>
<li>在重负载的情况下，算法失效的可能性将会直线上升</li>
</ul>
</li>
</ul>
<p><strong>时间戳</strong></p>
<ul>
<li>在一个事务开始做<code>BEGIN_TRANSACTION</code>的时候给它分配一个时间戳，通过Lamport的算法，我们可以确保时间戳是唯一的。系统中，每个文件都拥有一个读取时间戳和写入时间戳，以判断哪个已提交的进程最近一次读取或写入过该文件。
<ul>
<li>若事务都很短小且在时间间隔上比较大，那么一般来说当一个进程试图访问某个文件时，该文件的读写时间戳将早于当前事务的时间戳，意味着事务正在以正确的顺序进行处理</li>
<li>当次序不正确的时候，就表明一个晚于当前事务开始的事务试图插入、访问文件并提交。这种情况意味着晚事务开始得过早了，因此需要中止</li>
</ul>
</li>
<li>时间戳方法不会出现死锁</li>
<li>当一个事务碰到了更晚的时间戳时，就要中止（加锁法则是等待或立即执行）</li>
</ul>
<h3 id="25-分布式系统死锁">2.5. 分布式系统死锁</h3>
<ul>
<li>死锁的分类
<ul>
<li>通信死锁：进程A试图发送消息给进程B，进程B给进程C发送消息，而C又试图给A发送消息</li>
<li>资源死锁：当多个进程为了互斥访问IO设备、文件、锁或其他资源时就会发生资源死锁</li>
</ul>
</li>
<li>处理策略分类
<ul>
<li>鸵鸟算法：忽略问题</li>
<li>检测：允许死锁发生，在检测到后想办法消除</li>
<li>预防：静态的使死锁在结构上是不可能发生的</li>
<li>避免：通过仔细的分配资源以避免死锁（在分布式系统中从来都不采用）</li>
</ul>
</li>
</ul>
<h4 id="251-分布式死锁检测">2.5.1. 分布式死锁检测</h4>
<p><strong>集中式死锁检测</strong></p>
<ul>
<li>
<p>每一台机器都有一个资源图以描述自己所拥有的进程和资源</p>
<ul>
<li>一台中心机器即协调者拥有整个系统（所有资源图的集合）的资源图</li>
<li>当协调者检测到了环路时它就中止一个进程以解决死锁</li>
</ul>
</li>
<li>
<p>全局资源图的维护方法</p>
<ol>
<li>每当资源图中加入或删除一条弧时，相应的消息就发送给协调者以便更新</li>
<li>每个进程周期性的把从上次更新后新添加的和删除的弧的列表发送给协调者（发送消息数少于方法1）</li>
<li>协调者在需要的时候主动去请求信息</li>
</ol>
</li>
<li>
<p>假死锁问题</p>
<p><img src="image-20220607213515182.png" alt="image-20220607213515182" style="zoom:80%;" /></p>
<ul>
<li>
<p>假设有系统：</p>
<ul>
<li>A和B运行在机器0上，C运行在机器1上</li>
<li>共有三种资源S，R和T</li>
<li>一开始A拥有S并想请求R，但B正在使用R；C拥有T并想请求S</li>
</ul>
</li>
<li>
<p>此时协调者看到的情况如下图所示</p>
<p><img src="image-20220607213629705.png" alt="image-20220607213629705" style="zoom:50%;" /></p>
<ul>
<li>不会产生死锁</li>
</ul>
</li>
<li>
<p>过一段时间后，B释放R并请求T，这是一个完全合法的安全操作</p>
<ul>
<li>机器0向协调者发送一条消息声明它释放R</li>
<li>机器1向协调者发送了一条消息声明进程B正在等待它的资源T</li>
</ul>
</li>
<li>
<p>若机器1的消息首先到达，则协调者生成的资源图如下所示：</p>
<p><img src="image-20220607213735670.png" alt="image-20220607213735670" style="zoom:50%;" /></p>
</li>
<li>
<p>协调者将错误的得出死锁存在的结论，并中止某个进程，称为假死锁</p>
</li>
</ul>
</li>
<li>
<p>解决假死锁问题</p>
<ul>
<li>使用lamport算法以提供全局时间</li>
</ul>
</li>
</ul>
<p><strong>分布式死锁检测</strong></p>
<ul>
<li>
<p>Chandy-Misra-Haas算法允许进程一次请求多个资源（如锁）而不是一次一个。通过允许同时进行多个请求使得事务的增长阶段可以加速。但使得一个进程可以同时等待两个或多个进程</p>
</li>
<li>
<p>资源图</p>
<p><img src="image-20220607215032962.png" alt="image-20220607215032962" style="zoom:50%;" /></p>
<ul>
<li>机器1上的进程3正在等待两个资源，其中一个由进程4占有，而另一个由进程5占有。一些进程正在等待本地资源，例如进程1。一些进程，如进程2在等待其他机器上的资源</li>
</ul>
</li>
<li>
<p>Chandy-Misra-Haas算法</p>
<p><img src="image-20220607215422598.png" alt="image-20220607215422598" style="zoom:50%;" /></p>
<ul>
<li>当某个进程等待资源时，例如P0等待P1，将调用Chandy-Misra-Haas算法</li>
<li>等待者进程生成一个探测消息并发送给占用资源的进程</li>
<li>消息由三元组构成：被阻塞的进程，发送消息的进程，接受消息的进程。由P0到P1的初始消息包含三元组(0, 0, 1)</li>
<li>消息到达后，接收者检查以确认它自己是否也在等待其他进程
<ul>
<li>若是，更新消息，字段1保持不变，字段2改成当前发送消息的进程号，字段3改为占有被等待资源的进程号</li>
</ul>
</li>
<li>然后，该消息发送到占有该等待资源的进程。若存在多个等待进程，就要发送多个不同的消息</li>
<li>不论资源在本地还是在远程，该算法都要继续下去
<ul>
<li>图中(0, 2, 3)，(0, 4, 6)，(0, 5, 7)和(0, 8, 0)都是远程消息</li>
</ul>
</li>
<li>若消息转了一圈后又回到最初的发送者，即字段1对应的进程，就说明存在一个有死锁的环路系统</li>
</ul>
</li>
</ul>
<p><strong>处理死锁的方法</strong></p>
<ul>
<li>使最初发送探测消息的进程自杀
<ul>
<li>若有多个进程同时调用了此算法，就会出现问题：例如，在上例中假设进程0~6同时阻塞，而且都初始化了探测消息。那么每个进程最终都会发现死锁，并且因此而自杀，然而这是不必要的。中止掉一个进程就足够了</li>
</ul>
</li>
<li>将每个进程号添加到探测消息的末尾，这样当它返回到最初的发送者时完整的环路就可以列出来了
<ul>
<li>于是发送者就能看出哪个进程编号最大，可以将它中止或者发送一个消息给它请求其自杀。这样使得多个进程能够同时发现了同一个环路，选择同一个牺牲者即可</li>
</ul>
</li>
</ul>
<h4 id="252-分布式死锁预防">2.5.2. 分布式死锁预防</h4>
<ul>
<li>死锁预防是仔细地设计使得死锁在结构上不可能的
<ul>
<li>在某一时刻只允许进程占有一个资源</li>
<li>要求进程在初始阶段请求所有的资源</li>
<li>当进程请求新资源时必须释放所有资源</li>
<li>要求进程必须预定资源，并以严格增序请求资源，即一个进程不可能既占有了一个高序资源又去请求一个低序资源，这就使得环路不可能出现了</li>
</ul>
</li>
<li>基于时间戳的算法
<ul>
<li>基于在一个事务开始时给它分配一个全局时间戳的思想，保证不会有两个事务分配了完全相同的时间戳。使用Lamport的算法有效地保证了时间戳的唯一性（通过使用进程号）</li>
<li>基本思想：当一个进程因等待一个正被其他进程占用的资源而要被阻塞时，比较哪个进程的时间戳更大（更晚）。只有当等待进程的时间戳小于（早于）被等待进程的时间戳，才允许等待发生（只允许老进程等待），沿着等待进程链，时间戳递增，不可能发生环路。或只有当等待进程拥有大于（晚于）被等待进程的时间戳时，才允许等待发生（只允许新进程等待），沿着等待进程链，时间戳递减
<ul>
<li>给予老的进程以优先权可能更好一点。由于老进程已经运行了较长时间，系统对他们的投入会更大一些，他们占有的资源也就更多一些。同时这种选择消除了饿死现象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>等待-死亡算法</strong></p>
<ul>
<li>
<p>由于使用了时间戳，当请求被占用的资源时只可能有两种情况：</p>
<ol>
<li>老进程请求被新进程占用的资源：允许进程等待</li>
<li>新进程请求被老进程占用的资源：终止进程</li>
</ol>
<p><img src="image-20220607221009112.png" alt="image-20220607221009112" style="zoom:50%;" /></p>
</li>
<li>
<p>假设标记图a为中止、图b为等待。那就会使得老进程中止，但这样的效率较低（老进程只会变得更老）</p>
</li>
<li>
<p>在这种情况下，箭头总是指向事务编号增长的方向，使得环路不可能出现</p>
</li>
</ul>
<p><strong>受伤-等待算法</strong></p>
<p><img src="image-20220607221108261.png" alt="image-20220607221108261" style="zoom:50%;" /></p>
<ul>
<li>受伤-等待算法允许抢占：假设只允许老进程抢占新进程所占资源，那么，图a被标记为抢先，图b为等待</li>
<li>被抢占资源的进程中一个事务可能会受到伤害（实际是被中止）而等待进程中的事务必须等待</li>
<li>等待-死亡算法中，若一个老事务想得到一个正被新事务占用的资源，那么他会很礼貌的等待。 反之，若一个新事务想得到一个被老事务占用的资源，它将被中止。尽管它还会重新开始，但很可能又会立即被中止。在老事务释放资源之前，这个循环可能要重复多次</li>
<li>受伤-等待算法没有这么差的特性</li>
</ul>
<h2 id="3-分布式路由算法">3. 分布式路由算法</h2>
<h3 id="31-分布式路由算法导论">3.1. 分布式路由算法导论</h3>
<ul>
<li>
<p>分布式系统中的通信延迟依赖因素：</p>
<ul>
<li>
<p>拓扑：处理单元（PE）的连接方式</p>
<ul>
<li>一般类型</li>
<li>特殊类型</li>
</ul>
<p><img src="image-20220608094653102.png" alt="image-20220608094653102" style="zoom:50%;" /></p>
</li>
<li>
<p>交换</p>
<ul>
<li>存储-转发（对路由路径长度敏感）
<ul>
<li>分组转发：被分割成分组，整个分组被转发</li>
<li>性能评估标准：时间步数，通信步数</li>
</ul>
</li>
<li>分割-通过（目标：减少阻塞）
<ul>
<li>电路交换：传输之前建立一个物理电路</li>
<li>虚拟分割-通过：只有信道忙时才将分组存储于中间节点</li>
<li>虫孔路由
<ul>
<li>分组进一步被分成许多片</li>
<li>信道忙时，通过流量控制将后续片阻塞，使后续片沿建立好的路由留在片缓冲区中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>流量控制</p>
</li>
<li>
<p>路由</p>
</li>
</ul>
</li>
<li>
<p>通信类型</p>
<ul>
<li>一对一：单播</li>
<li>一对多：多播（组播）</li>
<li>一对所有：广播</li>
</ul>
</li>
<li>
<p>路由算法类型</p>
<ul>
<li>特殊 vs. 一般</li>
<li>最短 vs. 非最短</li>
<li>确定型 vs. 适应型</li>
<li>源路由 vs. 目标路由</li>
<li>容错型 vs. 非容错型</li>
<li>冗余型 vs. 非冗余型</li>
<li>死锁避免型 vs. 非死锁避免型</li>
</ul>
</li>
<li>
<p>路由函数：给定输入和信息，决定路径（输出）</p>
<ul>
<li>依赖于目标的：当前和目标节点</li>
<li>依赖于输入的：当前和目标节点、邻近的链接</li>
<li>依赖于源的：源节点、当前节点、目标节点</li>
<li>依赖于路径的：目标节点、从源节点到达当前节点的路径</li>
</ul>
</li>
</ul>
<h3 id="32-一般类型网络的最短路径路由算法">3.2. 一般类型网络的最短路径路由算法</h3>
<ul>
<li>
<p>分布式系统图示</p>
<p><img src="image-20220608104428975.png" alt="image-20220608104428975" style="zoom:50%;" /></p>
<ul>
<li>节点：PE</li>
<li>边：通信链接</li>
<li>边上数字：链接代价</li>
</ul>
</li>
</ul>
<h4 id="321-dijkstra集中式算法">3.2.1. Dijkstra集中式算法</h4>
<ul>
<li>
<p>发现一个源节点到其他所有节点的最短路径</p>
</li>
<li>
<p>需要全局拓扑信息</p>
<ul>
<li>网络中所有其他节点的列表</li>
<li>节点之间的所有链接</li>
<li>每个链接的代价</li>
</ul>
</li>
<li>
<p>$D(v)$是从源$s$到节点$v$的距离（沿给定路径的链接的代价的和）</p>
</li>
<li>
<p>$l(v,w)$是节点$v$和$w$之间的代价</p>
</li>
<li>
<p>算法描述：</p>
<ol>
<li>
<p>设$N={s}$，对不在$N$中的每一个节点$v$，令$D(v)=l(s,v)$，对那些没有连接到$s$的节点赋值为$\infin$</p>
</li>
<li>
<p>找到不在$N$中的节点$w$，使$D(w)$最小并将$w$加入$N$，然后对所有不在$N$中的其他节点计算并更新$D(v)$:<br />
$$<br />
D(v):=\min[D(v),D(w)+l(w,v)]<br />
$$<br />
重复步骤2，知道所有节点都在$N$中</p>
</li>
</ol>
</li>
<li>
<p>示例</p>
<p><img src="image-20220608105135126.png" alt="image-20220608105135126" style="zoom: 33%;" /></p>
<p><img src="image-20220608105434611.png" alt="image-20220608105434611" style="zoom:50%;" /></p>
</li>
</ul>
<h4 id="322-ford分布式算法">3.2.2. Ford分布式算法</h4>
<ul>
<li>
<p>每个节点通过交互：和其邻节点交换代价和路由信息，知道这些节点的路由由表到达最短路径的要求为止</p>
</li>
<li>
<p>每个节点$v$，都有$(n,D(v))$的标记</p>
<ul>
<li>$D(v)$代表该节点到目标节点的最短距离的当前值</li>
<li>$n$是截至目前得到的最短路径的下一个节点</li>
</ul>
</li>
<li>
<p>算法描述：</p>
<ol>
<li>
<p>初始化：设$d$是目标节点，令$D(d)=0$，将所有其他节点标记为$(\cdot, \infin)$</p>
</li>
<li>
<p>对所有节点的最短路径做标记：</p>
<p>对每个节点$v\neq d$：</p>
<ul>
<li>
<p>使用$v$的每个邻节点$w$的当前$D(w)$</p>
</li>
<li>
<p>计算$D(w)+l(w,v)$，使得<br />
$$<br />
D(v):=\min{D(v),D(w)+l(w,v)}<br />
$$<br />
更新$v$的标记：用上述表达式取值最小的邻接节点代替$n$，并用新值代替$D(v)$</p>
</li>
</ul>
</li>
<li>
<p>对每个节点重复上述操作直到不再改变</p>
</li>
</ol>
</li>
<li>
<p>示例</p>
<p><img src="image-20220608110533786.png" alt="image-20220608110533786" style="zoom: 33%;" /></p>
<p><img src="image-20220608110556526.png" alt="image-20220608110556526" style="zoom:50%;" /></p>
</li>
<li>
<p>Ford算法也适用于异步系统</p>
<ul>
<li>每个节点以随机的速率更新其$D(v)$值</li>
</ul>
</li>
</ul>
<h4 id="323-arpanet路由算法">3.2.3. ARPAnet路由算法</h4>
<ul>
<li>
<p>ARPAnet路由算法是一个可靠、实用的分布式路由算法</p>
</li>
<li>
<p>与Ford算法比较相似，不同点如下：</p>
<ul>
<li>算法中的节点都维护一个一般化的路由表
<ul>
<li>这个路由表包含从这个节点到所有其他节点的最优路径的延迟</li>
</ul>
</li>
<li>每隔固定的时间间隔，路由表就被传送到它的所有邻接节点，直到最小延迟表在某一点达到稳定为止</li>
</ul>
</li>
<li>
<p>示例</p>
<p><img src="image-20220608113719212.png" alt="image-20220608113719212" style="zoom:25%;" /></p>
<ul>
<li>
<p>在时刻0时，已经达到稳定点</p>
</li>
<li>
<p>每个表格表示：通过邻居到达$P_5$的最短距离</p>
</li>
<li>
<p>假设在时刻0，$P_4$和$P_5$之间的链接失效，如下图所示</p>
<p><img src="image-20220608113932994.png" alt="image-20220608113932994" style="zoom:25%;" /></p>
<p>则更新它的路由延迟表，并传输给$P_4$的所有相邻节点，从而使那些节点的路由延迟表发生变化，直到产生一个新的稳定点</p>
<p><img src="image-20220608114131656.png" alt="image-20220608114131656" style="zoom: 25%;" /></p>
</li>
<li>
<p>$P_5$为目标点，应用ARPAnet算法</p>
<ul>
<li>上述过程持续至一个新的稳定点，$P_1$，$P_2$，$P_3$，$P_4$分别用了20，19，17，20个时间间隔</li>
</ul>
</li>
</ul>
</li>
<li>
<p>存在的问题：每个节点对所有邻居都发送相同消息， 对接收节点不做任何标识</p>
<ul>
<li>
<p>某些节点会接收无用消息</p>
</li>
<li>
<p>链接节点失效时，这些消息将导致不期望的循环</p>
</li>
<li>
<p>示例</p>
<ul>
<li>如前所述，当$P_4\rightarrow P_5$失效时</li>
<li>当前时刻$P_2$的消息尚未更新</li>
<li>则$P_4$通过如下路由发送消息：$P_4\rightarrow P_2\rightarrow P_4\rightarrow P_5$</li>
</ul>
</li>
<li>
<p>解决方法</p>
<ul>
<li>路由消息中包含路径中所有节点（而不仅是下跳节点）
<ul>
<li>开销过大</li>
</ul>
</li>
<li>路由消息中包含路径的最近$l$个节点
<ul>
<li>$l$与相应网络中循环的最大长度有关</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="33-特殊类型网络的单播算法">3.3. 特殊类型网络的单播算法</h3>
<ul>
<li>一般类型网络的路由算法适用于所有拓扑类型的网络，但存在以下问题：
<ul>
<li>每个节点需要维持路由延迟表</li>
<li>不适用于特殊类型网络，因为效率低下</li>
</ul>
</li>
<li>特殊网络由于特殊的拓扑特性，可以不使用路由延迟表而构造最短路径路由算法</li>
</ul>
<h4 id="331-双向环k元1维">3.3.1. 双向环（$k$元1维）</h4>
<ul>
<li>在双向环上进行决定型单播路由的方法：
<ul>
<li>消息沿着一个方向被转发：顺时针或逆时针</li>
<li>由于消息可沿两个方向发送，因此由源节点根据目标节点的位置决定发送方向：
<ul>
<li>如果目标离顺时针方向近，则用顺时针方向</li>
<li>否则选择逆时针方向</li>
</ul>
</li>
<li>一个消息通过几个中间节点按照顺时针或逆时针方向传递，直到到达目标节点</li>
</ul>
</li>
</ul>
<p><img src="image-20220608155753674.png" alt="image-20220608155753674" style="zoom:50%;" /></p>
<h4 id="332-网格和圆环k元2维">3.3.2. 网格和圆环（$k$元2维）</h4>
<ul>
<li>2维网络
<ul>
<li>每个节点沿着两个维度（如X轴和Y轴）有邻居节点</li>
<li>如：2维网格和2维圆环</li>
</ul>
</li>
<li>网格和圆环的区别
<ul>
<li>圆环：有周边邻接</li>
<li>网格：没有周边邻接</li>
</ul>
</li>
<li>3维网格和圆环是$k$元3维立方</li>
</ul>
<p><strong>XY路由</strong></p>
<p><img src="image-20220608145618591.png" alt="image-20220608145618591" style="zoom:33%;" /></p>
<ul>
<li>每个节点的地址为$(x,y)$</li>
<li>消息首先沿着$X$维度转发，然后沿着$Y$维度路由</li>
<li>特别地，若源和目标分别为$(sx,sy)$和$(dx,dy)$，则路由消息将在$X$维度上走$|dx-sx|$步，然后在$Y$维度上走$|dy-sy|$步</li>
</ul>
<p><strong>最短且完全适应路由</strong></p>
<p><img src="image-20220608145810356.png" alt="image-20220608145810356" style="zoom:33%;" /></p>
<ul>
<li>每个中间节点都要充分利用所有可行的最短路径
<ul>
<li>只要$dx-sx\neq 0$且$dy-sy\neq 0$，每个节点在选择邻居时总有两个选择</li>
</ul>
</li>
<li>一个好的适应性路由算法应该能选择任意一个邻居并能尽可能地保持$dx-sx\neq 0$且$dy-sy\neq 0$的情况</li>
</ul>
<p><strong>折线路由</strong></p>
<p><img src="image-20220608150216896.png" alt="image-20220608150216896" style="zoom:33%;" /></p>
<ul>
<li>从$d$引出一条45°线$L$</li>
<li>总是选择距离$L$最近的一个邻居进行路由，即
<ul>
<li>先沿$y=sy$前进</li>
<li>然后沿45°线折线前进</li>
</ul>
</li>
</ul>
<p><strong>最大最短路径路由</strong></p>
<p><img src="image-20220608150332958.png" alt="image-20220608150332958" style="zoom:33%;" /></p>
<ul>
<li>折线路由对二维圆环可能不是最优的：
<ul>
<li>对$n\times n$圆环（$n$为偶数），存在一个具有四个合格邻居的节点</li>
<li>需要设定其它的最优判定条件</li>
</ul>
</li>
<li>邻居节点的选择
<ul>
<li>与目标节点存在最大个数的最短路径的邻居</li>
</ul>
</li>
</ul>
<p><img src="image-20220608152346625.png" alt="image-20220608152346625" style="zoom:33%;" /></p>
<ul>
<li>点（边）分离路径
<ul>
<li>对从源点$s$到终点$d$的多条路径$l_1,l_2,\cdots,l_n$，若$l_1,l_2,\cdots,l_n$无公共点（边），$(s,d)$除外，则$l_1,l_2,\cdots,l_n$是点（边）分离路径</li>
<li>如上图所示，源和目标都有四个邻居，因此可建立四个点（边）分离路径</li>
</ul>
</li>
</ul>
<h4 id="333-超立方2元n维">3.3.3. 超立方（2元$n$维）</h4>
<ul>
<li>
<p>超立方的数学定义</p>
<ul>
<li>$Q_0$：一个只有一个节点的退化图</li>
<li>$Q_n=K_2\times Q_{n-1}$，这里：
<ul>
<li>$K_2$是具有两个节点的完全图</li>
<li>$\times$是两个图的笛卡尔乘积</li>
</ul>
</li>
<li>$Q_n$中的一个节点的地址可表示为</li>
</ul>
<p>$$<br />
u=u_nu_{n-1}\cdots u_1(u_i=0或1,1\leq i\leq n)<br />
$$</p>
<ul>
<li>两个节点$u$，$w$的最短路径长度（海明距离）$H(u,w)$：</li>
</ul>
<p>$$<br />
H(u,w)=\sum_{i=1}^nh(u_i,w_i)<br />
$$</p>
<p>​	其中$h(u_i,w_i)=\begin{cases}1&amp;\mathrm{if}\ u_i\neq w_i\\0&amp;\mathrm{if}\ u_i=w_i\end{cases}$</p>
<ul>
<li>两个节点$u$，$w$的异或操作$u\oplus w=r$</li>
<li>$u^{(i)}$表示：改变$u$的第$i$维，如：$1101^{(3)}=1001$</li>
</ul>
</li>
<li>
<p>算法描述</p>
<ul>
<li>输入：当前节点$u$，目标节点$w$</li>
<li>过程：
<ul>
<li>初始节点计算，求$u\oplus w=r$</li>
<li>每轮由一个路由节点执行，$\exist i,r_i=1$，循环计算
<ul>
<li>沿$i$维路由</li>
<li>$r_i=0$</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="image-20220608155853349.png" alt="image-20220608155853349" /></p>
</li>
<li>
<p>示例：三维立方体</p>
<p><img src="image-20220608160452416.png" alt="image-20220608160452416" style="zoom: 33%;" /></p>
<ul>
<li>$s=000$，$d=110$
<ul>
<li>$r=s\oplus d=110$</li>
<li>路径1：$000\rightarrow 100\rightarrow110$</li>
<li>路径2：$000\rightarrow010\rightarrow110$</li>
<li>路由算法会生成路径1或路径2</li>
</ul>
</li>
<li>点分离路径
<ul>
<li>路径3：$000\rightarrow001\rightarrow011\rightarrow111\rightarrow110$</li>
<li>一种点分离路径：路径1、路径2、路径3</li>
</ul>
</li>
</ul>
</li>
<li>
<p>多路径路由的性质</p>
<ul>
<li>若两个节点$u$和$w$在$n$维立方中的海明距离为$k$，则：
<ul>
<li>在$u$和$w$之间就有$n$个点分离路径</li>
<li>在这$n$条路径中
<ul>
<li>有$k$个路径长度为$k$</li>
<li>其余$n-k$个路径长度为$k+2$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="34-特殊类型网络中的多播算法">3.4. 特殊类型网络中的多播算法</h3>
<ul>
<li>多播的定义：指从一个源向任意多个目标节点传送同样的消息
<ul>
<li>单播、广播是多播的特例</li>
</ul>
</li>
<li>多播的应用：数据并行编程操作
<ul>
<li>复制，障碍同步</li>
<li>对共享存储器失效及分布式共享内存系统更新的支持等</li>
</ul>
</li>
<li>性能评估指标：通信量和时间
<ul>
<li>通信量：消息发送到所有的目标所需的通信链接的数目</li>
<li>时间：消息传送的时间</li>
</ul>
</li>
</ul>
<h4 id="341-一般方法">3.4.1. 一般方法</h4>
<ul>
<li>多播问题可转换为以下问题：
<ul>
<li>多播路径优化问题：求包含所有目标的最短路径</li>
<li>多播回路优化问题：求包含所有目标的最短回路</li>
<li>Steiner树优化问题
<ul>
<li>Steiner树：一个包含所有目标节点的给定拓扑的一个子树</li>
<li>求最小总长度的steiner树</li>
</ul>
</li>
<li>组播树问题：求包含所有目标的给定拓扑的子树，其中，树中每个通向目标的路径的长度对于给定的拓扑是最小的</li>
</ul>
</li>
<li>挑战：对网格和超立方的优化问题都是NP问题
<ul>
<li>一般使用启发式组播算法，如：基于路径的、基于树的</li>
</ul>
</li>
</ul>
<h4 id="342-基于路径的方法">3.4.2. 基于路径的方法</h4>
<ul>
<li>
<p>基本思路</p>
<ol>
<li>首先建立一个哈密尔顿回路（即回路的路径上每个节点均经过一次）</li>
<li>然后根据这个回路把多播集合转发出去</li>
<li>如果有一个邻居位于下个目标前面，但距离目标更近，那么可以抄近路</li>
</ol>
</li>
<li>
<p>进一步，若使用双向链接，则只需一个哈密尔顿路径（而非哈密尔顿回路）即可</p>
<ul>
<li>
<p>利用哈密尔顿路径，为系统中所有节点定义一个顺序，如在二维网格中，设：<br />
$$<br />
r(u)=r(x,y)=\begin{cases}yn+x&amp;如果y是偶数\\yn+n-x-1&amp;如果y是奇数\end{cases}<br />
$$<br />
两个节点$u$，$v$在路径中相邻当且仅当$|r(v)-r(u)|=1$</p>
</li>
<li>
<p>示例：一个$4\times 4$的网格上每个节点具有的$r$值如下所示</p>
<p><img src="image-20220608193255932.png" alt="image-20220608193255932" style="zoom:33%;" /></p>
<ul>
<li>
<p>$n=4$</p>
</li>
<li>
<p>若$y$是偶数，$r$值沿$X$方向递增<br />
$$<br />
r(x,y)=yn+x<br />
$$</p>
</li>
<li>
<p>若$y$是奇数，$r$值沿$X$方向递减<br />
$$<br />
r(x,y)=yn+n-x-1<br />
$$</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>使用顺序定义，整个网络可以分为两个子网：</p>
<ul>
<li>高信道网络：一个包括从低序节点到高序节点的链接</li>
<li>低信道网络：一个包括从高序节点到低序节点的链接</li>
</ul>
<p><img src="image-20220608193448973.png" alt="image-20220608193448973" /></p>
</li>
<li>
<p>假定使用高信道网格</p>
<ul>
<li>
<p>$v$和$d$（$r(v)&lt;r(d)$）分别是中间节点和目标节点</p>
</li>
<li>
<p>若$d$是$v$的一个邻居，那么消息将直接转发到$d$</p>
</li>
<li>
<p>若$d$不是$v$的邻居，选择一个满足下式的$v$的邻居$u$<br />
$$<br />
r(u)=\max{r(w)|r(w)&lt;r(d),w是v的一个邻居}<br />
$$</p>
</li>
</ul>
<p>低信道网络同理</p>
</li>
<li>
<p>示例</p>
<p><img src="image-20220608193925695.png" alt="image-20220608193925695" style="zoom: 33%;" /></p>
<ul>
<li>假定节点6（地址为(1, 1)）为源节点，目标节点为0、2、10、13和14</li>
<li>转发消息到0和2时，应使用低信道网络$6\rightarrow 5\rightarrow2\rightarrow1\rightarrow0$</li>
<li>转发消息到10，13和14时，应使用高信道网络$6\rightarrow 9\rightarrow10\rightarrow13\rightarrow14$</li>
</ul>
<p><img src="image-20220608194253098.png" alt="image-20220608194253098" style="zoom:33%;" /></p>
</li>
</ul>
<h4 id="343-基于树的方法">3.4.3. 基于树的方法</h4>
<p><strong>Lan贪婪组播算法（适用于超立方）</strong></p>
<ul>
<li>
<p>对每个结点（包括源节点）</p>
<ul>
<li>输入：收到包含目标节点地址列表的消息</li>
<li>处理：
<ul>
<li>若自己的地址在列表中，保存该消息</li>
<li>若列表非空，当前节点将决定把目标列表中的地址转发到哪些邻居</li>
</ul>
</li>
<li>邻居的选择：由目标节点的相对二进制地址来决定
<ul>
<li>$n$位地址的每一位都有一个计数器
<ul>
<li>计数器的内容代表相应维度的信息</li>
</ul>
</li>
<li>具有最大计数值的那一维将被选中
<ul>
<li>所有在这一位为1的目标将被转发到这一维上的那个邻居</li>
<li>在剩余的目标中，将利用下一个被选中的维度重复上述步骤</li>
<li>当剩余的多播集合为空时，这一过程将结束</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>示例：节点0010打算向{0000, 0001, 1001, 1100, 1110}中的每个节点发送消息</p>
<ul>
<li>所有目标节点的实际地址和源节点0010的实际地址做异或操作，得到多播集合的相对地址{0010, 0011, 1011, 1110, 1100}</li>
<li>每一列的1的数目组成了一个称为列总和的向量(3, 2, 4, 2)</li>
<li>选择第二维方向的邻居，即0000为下一个邻居，通过0000发送消息给0001，1001，1100，通过0010直接发消息给1110</li>
<li>重复上述过程</li>
</ul>
<p><img src="image-20220608195223478.png" alt="image-20220608195223478" style="zoom: 33%;" /></p>
</li>
</ul>
<p><strong>U-网格算法</strong></p>
<ul>
<li>
<p>定义字典序$&lt;_t$</p>
<ul>
<li>若$x_1&lt;_tx_2$或者（$x_1=x_2\and y_1&lt;_t y_2$），则有$(x_1,y_1)&lt;_t(x_2,y_2)$</li>
</ul>
</li>
<li>
<p>边分离性质</p>
<ul>
<li>假定$P(n_1,n_2)$是$n_1$和$n_2$间的最短路径，则若$n_1&lt;_tn_2&lt;_tn_3&lt;_tn_4$，则$P(n_1,n_2)$和$P(n_3,n_4)$边分离</li>
</ul>
</li>
<li>
<p>假定源节点为$(0,0)$</p>
<ul>
<li>按照字典顺序重新排列目标节点，并将源节点放在前面</li>
<li>将列表分为两个相等的子列表，源节点将多播消息发往第二个子列表的第一个节点</li>
<li>重复上述分割直到每个子列表中只有一个节点</li>
</ul>
</li>
<li>
<p>若源节点不是$(0,0)$，可重新定义排列顺序以便源节点成为第一个节点</p>
</li>
<li>
<p>算法描述</p>
<p><img src="image-20220608200439998.png" alt="image-20220608200439998" style="zoom:50%;" /></p>
<ul>
<li>
<p>考虑一个$4\times 4$的网格，$(0,0)$是源节点，$(1,0)$，$(1,1)$，$(1,2)$，$(1,3)$，$(2,0)$，$(2,1)$和$(3,2)$是目标节点</p>
<ol>
<li>
<p>源节点和目标节点的字典顺序是<br />
$$<br />
(0,0),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(3,2)<br />
$$</p>
</li>
<li>
<p>列表被分为两个子列表<br />
$$<br />
(0,0),(1,0),(1,1),(1,2)<br />
$$</p>
<p>$$<br />
(1,3),(2,0),(2,1),(3,2)<br />
$$</p>
</li>
<li>
<p>$(0,0)\rightarrow(1,3)$</p>
</li>
<li>
<p>$(0,0)\rightarrow(1,1)$，$(1,3)\rightarrow(2,1)$</p>
<p><img src="image-20220608201011685.png" alt="image-20220608201011685" style="zoom:50%;" /></p>
</li>
<li>
<p>$(0,0)\rightarrow(1,0)$，$(1,1)\rightarrow(1,2)$，$(1,3)\rightarrow(2,0)$，$(2,1)\rightarrow(3,2)$</p>
<p><img src="image-20220608201133606.png" alt="image-20220608201133606" style="zoom:50%;" /></p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="35-虚信道和虚网络">3.5. 虚信道和虚网络</h3>
<ul>
<li>
<p>通过网络分区可以避免死锁</p>
<ul>
<li>给定的网络可以分为几个子网</li>
<li>根据源和目标的位置，消息被路由到不同的子网</li>
</ul>
</li>
<li>
<p>资源的申请与分配问题</p>
<ul>
<li>在存储转发交换中，资源是缓冲区</li>
<li>在虫孔路由中，资源是信道</li>
<li>目标：无死锁、自适应、容错</li>
<li>方法：
<ul>
<li>使用多个虚信道对一个物理信道进行复用</li>
<li>将一个物理网络分成多个虚网络</li>
</ul>
</li>
</ul>
</li>
<li>
<p>示例：考虑有四个节点的单向环，多个进程启动时，可能发生死锁</p>
<p><img src="image-20220608203332549.png" alt="image-20220608203332549" /></p>
<ul>
<li>解决方法：将每个信道分为高信道Ch和低信道CI
<ul>
<li>若源地址大于目标地址，可以从任何一个信道开始</li>
<li>若源地址小于目标地址，首先使用高信道，经过节点P3后，高虚信道切换为低虚信道</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="36-完全自适应和无死锁路由算法">3.6. 完全自适应和无死锁路由算法</h3>
<ul>
<li>在不引发死锁的前提下增加适应性
<ul>
<li>虚信道类算法
<ul>
<li>引入足够多的虚信道</li>
</ul>
</li>
<li>逃逸信道算法
<ul>
<li>同时使用两种路由算法
<ul>
<li>使用标记为非等待的虚信道的完全适应性路由</li>
<li>限制性但无死锁路由，使用标记为等待（或逃逸）的虚信道</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="361-虚信道类">3.6.1. 虚信道类</h4>
<ul>
<li>思路：引入足够多的虚信道</li>
<li>新问题：虚信道数量太多导致影响效率</li>
<li>可选方案：将网络分为多个子集，每个子集都不包含相邻节点，例如：
<ul>
<li>考虑二维棋盘格，黑色节点属于一个子集，白色节点属于一个子集</li>
<li>当一个消息从一个白色节点移动到黑色节点时，虚信道的标记加一</li>
<li>如果从黑色节点向白色节点移动，虚信道标记保持不变</li>
<li>在二维网格中，节点标记的改变次数最多为路由步数的一半，虚信道的总数就减少一半</li>
</ul>
</li>
<li>一般化算法
<ul>
<li>将给定网络分为$k$个子集$S_1,S_2,\cdots,S_k$，每个子集都不包含相邻节点</li>
<li>当一个消息从子集$S_i$中的一个节点移动到子集$S_j$中的一个节点$(i&lt;j)$时，成为正移动，否则为负移动
<ul>
<li>发生负移动，虚信道标记加一</li>
<li>假定信道标记从1开始，从而所需信道的个数就是一个路由路径中负移动的个数</li>
</ul>
</li>
<li>目标：选择合适的$k$和合适的划分，使得路由过程中的负移动个数最小</li>
</ul>
</li>
</ul>
<h4 id="362-逃逸信道">3.6.2. 逃逸信道</h4>
<ul>
<li>同时使用两种路由算法
<ul>
<li>完全适应性路由
<ul>
<li>使用标记为非等待的虚信道</li>
</ul>
</li>
<li>限制性但无死锁路由
<ul>
<li>使用标记为等待（或逃逸）的虚信道</li>
</ul>
</li>
</ul>
</li>
<li>基础方案
<ul>
<li>开始时，使用完全适应路由，直到阻塞为止</li>
<li>然后切换到限制性路由</li>
</ul>
</li>
<li>关键问题：如何合理分配等待和非等待信道
<ul>
<li>当消息发现等待信道被占用时，可以使用非等待信道
<ul>
<li>优点：增加了灵活性、引入新的信道依赖性</li>
<li>问题：难以得到死锁的充分条件，使得算法判断过严</li>
</ul>
</li>
<li>对于不同的目标，使用不同的等待信道
<ul>
<li>优点：可以得到一个无死锁的充分必要条件</li>
<li>问题：需要考虑不同目标的信道间的相互依赖（算法复杂）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="37-部分自适应和无死锁路由算法">3.7. 部分自适应和无死锁路由算法</h3>
<ul>
<li>部分适应性：路由适应性仅对一小部分虚信道有效
<ul>
<li>转弯模型</li>
<li>平面自适应模型等</li>
</ul>
</li>
</ul>
<h4 id="371-转弯模型二维网格">3.7.1. 转弯模型（二维网格）</h4>
<p><img src="image-20220608205132001.png" alt="image-20220608205132001" style="zoom:33%;" /></p>
<ul>
<li>
<p>部分自适应：源和目标的相对位置不同</p>
<ul>
<li>导致可能是适应性，可能只能决定性，例如对于正向优先路由：</li>
</ul>
<p><img src="image-20220608205329126.png" alt="image-20220608205329126" style="zoom:33%;" /></p>
</li>
</ul>
<h4 id="372-平面自适应模型k元n维">3.7.2. 平面自适应模型（$k$元$n$维）</h4>
<ul>
<li>
<p>基本思想：</p>
<ul>
<li>
<p>在某一时刻将路由的自由度限制到几个维度，以降低对硬件（虚信道）的要求</p>
</li>
<li>
<p>示例：</p>
<p><img src="image-20220608210909214.png" alt="image-20220608210909214" style="zoom:33%;" /></p>
<ul>
<li>若每次只选两个维度，就有$A_0,A_1,\cdots,A_n$这些平面，其中$A_i$在维度$d_i$和$d_{i+1}$方向扩展</li>
<li>每个信道$d_i$最多划分为三个虚信道：$d_{i,0},d_{i,1},d_{i,2}$</li>
<li>对每个$A_i$，引入三个虚信道，一个沿着第$i$维，两个沿着第$i+1$维，即$d_{i,2},d_{i+1,0},d_{i+1,1}$</li>
<li>设$d_{i,j}$可分为两个单向信道：$d_{i,j+}$，$d_{i,j-}$</li>
<li>类似于虚网络，$A_i$可划分为正向子网和负向子网，路由时根据源地址和目标地址在相应维度的大小选择子网来路由</li>
</ul>
</li>
<li>
<p>牺牲了全适应性，但降低了虚信道数目</p>
</li>
</ul>
</li>
</ul>
<h3 id="38-容错单播">3.8. 容错单播</h3>
<ul>
<li>在设计路由算法之前，需要确定：
<ul>
<li>最短路径或非最短路径</li>
<li>错误类型：链接错误，节点错误，或者链接错误和节点错误</li>
<li>出错的组件的个数是有限的还是无限的</li>
<li>对错误分布的了解：局部、全局和有限的全局</li>
<li>冗余或非冗余</li>
<li>回退或前进</li>
</ul>
</li>
</ul>
<h4 id="381-二维网格和圆环">3.8.1. 二维网格和圆环</h4>
<ul>
<li>算法类型（根据使用的错误信息类型）
<ul>
<li>基于局部信息</li>
<li>基于有限全局信息</li>
<li>基于其他故障模型</li>
</ul>
</li>
</ul>
<p><strong>基于局部信息</strong></p>
<ul>
<li>
<p>局部信息：仅仅局部了解的错误的分布</p>
</li>
<li>
<p>性质：错误区域</p>
<ul>
<li>如错误区域是一个凸形，就有可能设计一个简单的容错和无死锁路由</li>
<li>如错误区域是一个凹形，可以在区域中加入一些非错误节点，从而将其转变为凸形</li>
</ul>
</li>
<li>
<p>安全/非安全节点</p>
<ul>
<li>初始化：
<ul>
<li>所有错误节点都是不安全的</li>
<li>所有非错误节点开始时都是安全的</li>
</ul>
</li>
<li>迭代：
<ul>
<li>如果一个非错误节点有两个或两个以上的非安全邻居，那么它的状态就变为非安全的</li>
<li>扩展定义：若一个非出错节点在两个维度上都有错误的或不安全的邻居，它的状态就变为非安全的</li>
</ul>
</li>
</ul>
</li>
<li>
<p>算法：对二维网格或圆环的路由可进行如下扩展：</p>
<ul>
<li>若没有因错误阻塞，就按无错的情况路由</li>
<li>若在X维（或Y维）阻塞，就在Y维（或X维）路由</li>
<li>若因错误在X维受到阻塞，而Y维度的距离已接近零，就有必要进行曲折路由
<ul>
<li>任选一Y方向开始曲折路由，首先试着从X维度到达目标，继续沿着X方向直到Y方向正确为止，即沿着出错块的边缘路由</li>
<li>Y维度出错同理</li>
</ul>
</li>
</ul>
</li>
<li>
<p>示例：</p>
<p><img src="image-20220608214246327.png" alt="image-20220608214246327" style="zoom:33%;" /></p>
</li>
</ul>
<p><strong>基于有限全局信息</strong></p>
<ul>
<li>
<p>有限全局信息的例子：所有错误区域的位置</p>
</li>
<li>
<p>最优容错路由算法</p>
<ul>
<li>设节点$(0,0)$是源节点，节点$(i,j)$是目标节点，若没有出错块通过$X$和$Y$轴，至少存在一个始于$(0,0)$的最优路径，长度为$|i|+|j|$</li>
<li>上述结果对任意位置的目标节点和任何数目和分布的出错块都成立，相应的源叫做安全的</li>
<li>扩展定义：允许X和Y轴有出错块，只要它们到源的距离分别大于$|i|$和$|j|$，这样的源节点叫做扩展安全的</li>
</ul>
</li>
<li>
<p>假定：</p>
<ul>
<li>源节点是$(0,0)$</li>
<li>目标节点是$(i,j)$，且$i,j\geq 0$</li>
<li>路由永远向东北方向</li>
</ul>
</li>
<li>
<p>满足适应性的方法：</p>
<ul>
<li>
<p>面向目标路由</p>
<p><img src="image-20220608215059776.png" alt="image-20220608215059776" style="zoom:33%;" /></p>
<ul>
<li>思路：建立最短路径区域RMP
<ul>
<li>建立一条从目标节点$(i,j)$开始到Y轴结束的线
<ul>
<li>遇到出错块时，先向南绕过出错块，如何继续向西</li>
</ul>
</li>
<li>类似地，建立一条从目标节点$(i,j)$开始到X轴结束的线
<ul>
<li>遇到出错块时，先向西绕过出错块，如何继续向南</li>
</ul>
</li>
<li>由向西和向南的线以及XY轴围起来的区域为RMP</li>
</ul>
</li>
<li>算法描述
<ol>
<li>源通过最优路径向目标发送初始信号</li>
<li>目标接到信号后，向西、南分别发送信号，建立路径A和B</li>
<li>源收到两个信号后，建立RMP</li>
<li>源在RMP内自适应路由</li>
</ol>
</li>
</ul>
</li>
<li>
<p>面向源路由</p>
<p><img src="image-20220608215349966.png" alt="image-20220608215349966" style="zoom: 33%;" /></p>
<ul>
<li>思路：把出错块的信息分布到系统中的特定节点上</li>
<li>示例
<ul>
<li>$L_1,L_2,L_3,L_4$将网格分为8个子区域：$R_1\sim R_8$</li>
<li>任意算法可达：$R_1,R_2,R_3,R_7,R_8$</li>
<li>XY路由可达：$R_6,R_5$</li>
<li>YX路由可达：$R_4,R_5$</li>
</ul>
</li>
<li>算法描述
<ol>
<li>构建路径A，路径B</li>
<li>目标位于路径A的南侧或东侧的路由消息不能通过路径A</li>
<li>目标位于路径B的北侧或西侧的路由消息不能通过路径B</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>基于其他故障类型</strong></p>
<ul>
<li>
<p>基于局部信息和基于有限全局信息的方法存在的问题：虽然矩形出错块很简单，但它引入了很多被禁止的非出错节点，即它们将不会在路由过程中起作用</p>
</li>
<li>
<p>解决方法：非矩形凸形出错块</p>
</li>
<li>
<p>原理：将出错块中的非出错节点移除，并保持凸形</p>
</li>
<li>
<p>活跃/不活跃节点</p>
<ul>
<li>初始化：
<ul>
<li>所有出错节点都是非活跃的，所有安全节点都是活跃的</li>
<li>一个非安全节点开始的时候是非活跃的</li>
</ul>
</li>
<li>迭代
<ul>
<li>如果一个非安全节点有两个或两个以上的活跃邻居，那么它就可以称为活跃的</li>
</ul>
</li>
</ul>
</li>
<li>
<p>示例</p>
<ul>
<li>
<p>基本安全/不安全规则下的活跃节点</p>
<p><img src="image-20220608220455342.png" alt="image-20220608220455342" style="zoom:33%;" /></p>
</li>
<li>
<p>扩展安全/不安全规则下的活跃节点</p>
<p><img src="image-20220608220659598.png" alt="image-20220608220659598" style="zoom:33%;" /></p>
</li>
</ul>
</li>
</ul>
<h4 id="382-超立方体">3.8.2. 超立方体</h4>
<p><strong>基于局部信息</strong></p>
<ul>
<li>
<p>算法可达的四种情况</p>
<ol>
<li>出错组件小于$n-1$，不确保有最优路径</li>
<li>出错组件小于$n-1$，确保有最优路径</li>
<li>出错组件无限制，不确保有最优路径</li>
<li>出错组件无限制，确保有最优路径</li>
</ol>
</li>
<li>
<p>定义等位序列$[d_1,d_2,\cdots,d_k]$</p>
<ul>
<li>当前节点和目标节点不同的所有维度</li>
<li>例如：当前节点0010，目标节点0111，则等位序列为$[1,3]$</li>
</ul>
</li>
<li>
<p>定义消息格式：$(k,[d_1,d_2,\cdots,d_k],消息,标记)$</p>
<ul>
<li>$k$为剩余路径的长度</li>
<li>标记：要绕道时的首选维度</li>
</ul>
</li>
<li>
<p>算法思路：在等位序列中选择一个维度，按这个维度路由</p>
</li>
<li>
<p>示例：源$u=0110$，目标$w=1001$</p>
<ul>
<li>
<p>错误链接：$1101-1001,1000-1001,0101-0001$</p>
<p><img src="image-20220608223232475.png" alt="image-20220608223232475" style="zoom: 33%;" /></p>
</li>
<li>
<p>$(4,[1,2,3,4],m,0000)\rightarrow(3,[2,3,4],m,0000)\rightarrow(2,[3,4],m,0000)$</p>
<p><img src="image-20220608230420318.png" alt="image-20220608230420318" style="zoom:33%;" /></p>
</li>
<li>
<p>第三维邻居链接出错，选择走第四维</p>
<p>$(2,[3,4],m,0000)\rightarrow(1,[3],m,0000)$</p>
<p><img src="image-20220608230524546.png" alt="image-20220608230524546" style="zoom: 33%;" /></p>
</li>
<li>
<p>第三维链接出错，$0000\rightarrow0100$，选择第一维转发，$0100\rightarrow 0101$</p>
<p>$(1,[3],m,0000)\rightarrow(2,[3,1],m,0101)$</p>
<p><img src="image-20220608230809979.png" alt="image-20220608230809979" style="zoom:33%;" /></p>
</li>
<li>
<p>$(2,[3,1],m,0101)\rightarrow(1,[1],m,0101)$</p>
<p><img src="image-20220608230851092.png" alt="image-20220608230851092" style="zoom:33%;" /></p>
</li>
<li>
<p>第一维链接出错，$(1,[1],m,0101)\rightarrow(2,[1,2],m,0111)\rightarrow(1,[2],m,0111)\rightarrow(0,[],m,0111)$</p>
<p><img src="image-20220608231359854.png" alt="image-20220608231359854" style="zoom:33%;" /></p>
</li>
</ul>
</li>
</ul>
<p><strong>基于有限全局信息</strong></p>
<ul>
<li>
<p>安全等级定义：每个节点周围邻居中失效节点的大致数目</p>
<ul>
<li>$S(a)=k$是节点$a$的安全等级，简称$a$是$k$-安全的</li>
<li>一个失效节点是0-安全的，即最低的安全等级</li>
<li>一个$n$-安全的节点（安全节点），安全级别最高</li>
<li>若$k\neq n$，那么一个$k-$安全的节点就是不安全的</li>
</ul>
</li>
<li>
<p>安全等级的计算</p>
<ul>
<li>节点$a$采集周围节点的$S$，并按升序排列，设为$(S_0,S_1,\cdots,S_{n-1})$</li>
<li>若$\forall 0\leq i\leq n-1$，$S_i\geq i$，则$S(a)=n$</li>
<li>若$\forall 0\leq i\leq k-1$，$S_i\geq i\and S_k&lt;k$，则$S(a)=k$</li>
</ul>
</li>
<li>
<p>安全等级的计算方法</p>
<ul>
<li>初始化：所有非出错节点都是$n$-安全的</li>
<li>迭代：需要重复$n-1$次达到稳定状态</li>
</ul>
</li>
<li>
<p>安全等级计算示例：</p>
<p><img src="image-20220608231808675.png" alt="image-20220608231808675" style="zoom: 33%;" /></p>
</li>
<li>
<p>安全等级的性质</p>
<ul>
<li>如果一个节点的安全等级是$k(0&lt;k\leq n)$，那么在$k$海明距离内，至少存在一个从该节点到任意节点的海明距离路径</li>
<li>当源的安全等级不小于源和目标之间的距离的时候，就可以保证最优路由
<ul>
<li>可以在每一步通过选择具有最高安全等级的邻居来产生最优路径</li>
</ul>
</li>
</ul>
</li>
<li>
<p>最优路由示例：$s=1110$，$d=0001$</p>
<ul>
<li>
<p>$s\oplus d=1111$，$1111$、$1101$、$1010$都为4-安全 ，任取一个作为邻居，如$1111$</p>
<p><img src="image-20220609084000882.png" alt="image-20220609084000882" style="zoom:33%;" /></p>
</li>
<li>
<p>$1111\oplus0001=1110$，$S(0111)=1$，$S(1011)=1$，$S(1101)=4$，因此下一跳选择$1101$</p>
<p><img src="image-20220609084107030.png" alt="image-20220609084107030" style="zoom:33%;" /></p>
</li>
<li>
<p>$1101\oplus0001=1100$，$S(0101)=1$，$S(1001)=0$，下一跳选择$0101$</p>
<p><img src="image-20220609084239619.png" alt="image-20220609084239619" style="zoom:33%;" /></p>
</li>
<li>
<p>$0101\oplus0001=0100$，下一跳选择$0001$</p>
<p><img src="image-20220609084327551.png" alt="image-20220609084327551" style="zoom:33%;" /></p>
</li>
</ul>
</li>
<li>
<p>讨论</p>
<ul>
<li>只要存在一个安全等级不小于$|s\oplus d|-1$的邻居，仍可以通过将信息转发到这个节点来实现最优路由</li>
<li>否则，如果存在一个安全等级不小于$|s\oplus d|+1$的空闲邻居节点，也可通过将消息转发到这个节点实现次优路由，路径长度为$|s\oplus d|+2$</li>
</ul>
</li>
</ul>
<h3 id="39-容错组播">3.9. 容错组播</h3>
<ul>
<li>
<p>问题定义：中间节点$u$（包括源节点$s$）向它的合适的邻居节点发送一个目标节点集合${u_1,u_2,\cdots,u_m}$</p>
</li>
<li>
<p>符号定义</p>
<ul>
<li>
<p>相对地址：$r_i=u\oplus u_i$</p>
</li>
<li>
<p>$|r_i|=r_i$中1的个数</p>
</li>
<li>
<p>地址总和：$as=\sum_{r_i\in R}r_i$，如<br />
$$<br />
R={r_1,r_2,r_3}={1111，01111，1010}，as=2232<br />
$$</p>
</li>
</ul>
</li>
<li>
<p>简单策略：</p>
<ul>
<li>对其中一个目标节点$u_i$（$u_i$关于$u$的相对地址$r_i$）
<ul>
<li>当$r_i$的第$d$位为1，则$u$发送$r_i^{(d)}$给$u^{(d)}$</li>
<li>当$r_i$有多个位（维度）为1，则任取其中一个位，进行发送
<ul>
<li>顺序优先级的设置：
<ul>
<li>优先级顺序的定义应能够实现对路径的最大限度的共享从而使流量最小，即使用$as$</li>
<li>为避免因到达出错邻居而回退或绕道，使用安全等级</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>基于安全等级的组播算法</p>
<ul>
<li>基于安全等级的组播（SLBM）</li>
<li>修正的基于安全等级的组播（MSLBM）</li>
</ul>
</li>
<li>
<p>SLBM的优先级顺序</p>
<ul>
<li>
<p>沿着一个维度的邻居的安全等级越高，这个维度的优先级顺序就越高</p>
</li>
<li>
<p>当有两个或两个以上的维度上的邻居具有相同的最高安全等级时，随机决定它们的优先顺序</p>
</li>
<li>
<p>示例：</p>
<p><img src="image-20220609092218997.png" alt="image-20220609092218997" style="zoom:33%;" /></p>
<ul>
<li>1000的4-安全邻居：1010，1001。2-安全邻居：0000
<ul>
<li>1010、1001的优先级顺序为随机</li>
</ul>
</li>
<li>对于目标0111
<ul>
<li>$1000\oplus 0111=1111$</li>
<li>可选的下一跳有0000，1100，1010，1001</li>
<li>按顺序优先级选择1010为下一跳</li>
</ul>
</li>
<li>对于目标0101
<ul>
<li>$1000\oplus 0101=1101$</li>
<li>可选的下一跳有0000，1100，1001</li>
<li>按优先级顺序，选择1001为下一跳</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>MSLBM中的优先级顺序</p>
<ul>
<li>
<p>沿着一个维度的邻居的安全等级越高，这个维度的优先级顺序就越高</p>
</li>
<li>
<p>当有两个或两个以上的维度上的邻居具有相同的最高安全等级时，维度优先顺序根据相应位在所有目标的地址总和中的值决定，即若在维度$d$，$as(d)$的值最大，则$d$有最高优先级</p>
</li>
<li>
<p>示例：</p>
<p><img src="image-20220609093401832.png" alt="image-20220609093401832" style="zoom:33%;" /></p>
<ul>
<li>1000的4-安全邻居：1010，1001。2-安全邻居：0000</li>
<li>$as=1000\oplus0100+1000\oplus0000+1000\oplus0010+1000\oplus1001+1000\oplus0101+1000\oplus0111=5323$</li>
<li>因此$1001$优先级&gt;$1010$优先级</li>
<li>对于目标$0111$
<ul>
<li>$1000\oplus0111=1111$</li>
<li>可选的下一跳为：$0000,1100,1010,1001$</li>
<li>按优先级循序，选择$1001$为下一跳</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SLBM vs. MSLBM</p>
<ul>
<li>均为路径最优</li>
<li>通信量：SLBM-10，MSLBM-9</li>
</ul>
<p><img src="image-20220609095646473.png" alt="image-20220609095646473" style="zoom:33%;" /></p>
</li>
</ul>
<h2 id="4-分布式进程和处理机管理">4. 分布式进程和处理机管理</h2>
<h3 id="41-分布式系统模型">4.1. 分布式系统模型</h3>
<ul>
<li>模型的作用：精确地定义要建立或分析的系统的属性和特征并提供检验这些属性的基础。不同的模型用于说明不同的属性</li>
<li>常用的代表性模型：
<ul>
<li>数学函数型：由一个输入域，一个输出域和一个把输入转换为输出的规则组成，可以用逻辑和底层函数的结合加以说明，构成分层结构
<ul>
<li>分层的好处：能够组织大量的数据并检查顶层函数和它分解的许多底层互连函数间的输入和输出的一致性</li>
<li>分层的缺点：给定一个输入就产生一个输出，但不保存数据</li>
</ul>
</li>
<li>有限状态自动机FSM：FSM是一系列输入、一系列输出、一系列状态、一个初始状态和一对函数，这对函数用于指定作为给定输入结果的输出和状态转换
<ul>
<li>限制：FSM固有地串行化了所有并发；模型明确假设一个输入的所有处理在下一个输入到达之前完成</li>
</ul>
</li>
<li>图模型：是一个由顶点（或节点）和边（弧或连接）组成的有向图，用于说明控制流和数据流
<ul>
<li>局限性：没有体现“状态”的概念，“状态”是从对一个输入数据集的处理中保存下来的，用于处理后来的输入数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="411-工作站模型">4.1.1. 工作站模型</h4>
<p><img src="image-20220609101104447.png" alt="image-20220609101104447" style="zoom:33%;" /></p>
<ul>
<li>在任何时刻，一个工作站或者是因一个用户登录而繁忙（可能是暂时的）或者是空闲的</li>
<li>工作站模型的优点：清晰。系统拥有固定数量专门用于计算的处理机资源，用户响应时间能得到保证，每个用户都有很大的自主权</li>
</ul>
<h4 id="412-空闲工作站的利用">4.1.2. 空闲工作站的利用</h4>
<ul>
<li>
<p>工作站处于空闲状态的主要原因是很多单位都有大量的工作站，并且其中某些工作站常常是处于空闲状态</p>
</li>
<li>
<p>利用伯克利UNIX中的rsh程序寻找空闲工作站</p>
<pre><code>rsh machine command
</code></pre><p>第一个参数指定要使用的工作站，第二个参数表示在指定工作站上运行的命令。Rsh程序的功能就是在指定机器上运行指定的命令</p>
<p>存在的问题：</p>
<ul>
<li>用户指定要使用的机器，这样，必须由用户来寻找一台空闲的机器</li>
<li>程序有可能是在一个通常与本地运行环境完全不同的远程机器环境中运行</li>
<li>如果用户登录到一台正在运行其它程序的远程机器上，那么，他或者忍受较低的速度，或者重新寻找一台空闲的机器</li>
</ul>
</li>
<li>
<p>利用空闲工作站需要解决的问题：</p>
<ul>
<li>找到一个空闲工作站</li>
<li>透明地运行一个远程进程</li>
<li>处理空闲工作站的主人回来重新使用它的情况</li>
</ul>
</li>
<li>
<p>寻找空闲工作站的算法</p>
<ul>
<li>服务器端驱动的算法
<ul>
<li>当一个工作站处于空闲状态并可以提供一定计算能力的时候，它就通过将自己的名字、网址、属性输入到一个注册文件（或数据库）中来宣布自己已变成了一个服务器</li>
<li>当一个用户需要在一台空闲工作站上运行一个命令时，他就可以输入<code>remote command</code>，remote程序查看注册表并从中寻找一台合适的空闲工作站</li>
<li>另一个工作站宣布自己处于空闲状态的方法是当工作站处于空闲状态时，它就向整个网络发一条广播消息。然后，所有的工作站都保存这个消息，即每一台机器都维护一个私有的注册拷贝</li>
<li>优点：寻找空闲工作站的开销更少，冗余度更高</li>
<li>缺点：所有的机器都需要维护一个私有的注册文件。无论是维护一个注册文件还是多个注册文件都会产生一些潜在的冲突</li>
</ul>
</li>
<li>客户端驱动的算法
<ul>
<li>当remote程序启动运行时，它就发出一个广播，声明它需要运行哪个程序，需要多少内存，是否需要浮点运算等等
<ul>
<li>如果所有工作站都是同构的，那么，这些信息就不需要了</li>
</ul>
</li>
<li>当收到应答后，remote就从中挑选一个，并启动命令在选中的空闲工作站上运行</li>
<li>一个好的处理方法：让空闲机器稍微延迟它们的应答，并让应答的延迟与自己当前负载成正比，这样，负载最轻机器的应答一定最先到达，并被选中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>命令程序在空闲工作站上的运行：如何设置远程运行环境</p>
<ul>
<li>空闲工作站必须具有一个与本地工作站相同的文件系统以及相同的工作目录和相同的环境变量</li>
</ul>
</li>
<li>
<p>处理机器的主人回来了的情况</p>
<ul>
<li>什么都不做，如果其他人在你的机器上运行程序，那么，你的机器应当保证对你的响应时间</li>
<li>强行取消正在运行的非本地进程</li>
<li>把远程命令进程迁移到另一台工作站上去运行，要么迁移到原先本地工作站上，要么迁移到另外一台空闲工作站上</li>
</ul>
</li>
</ul>
<h4 id="413-处理机池模型">4.1.3. 处理机池模型</h4>
<p><img src="image-20220609105043615.png" alt="image-20220609105043615" style="zoom:33%;" /></p>
<ul>
<li>
<p>处理机池模型是无盘工作站模型的进一步发展</p>
</li>
<li>
<p>用排队论来描述和分析处理机池模型的性能</p>
<p><img src="image-20220609105125283.png" alt="image-20220609105125283" style="zoom:33%;" /></p>
<ul>
<li>
<p>假设$\lambda $是每秒用户产生服务请求的数目，服务器每秒能够处理$\mu$个请求，对于一个稳定的排队系统，必须有$\mu&gt;\lambda$，由排队论理论可知：一个用户的请求从到达、排队，一直到服务完毕的平均响应时间$T$与$\lambda$和$\mu$有关系：<br />
$$<br />
T=\frac{1}{\mu-\lambda}<br />
$$<br />
响应时间=等待+执行时间</p>
</li>
<li>
<p>用一个小排队系统$n$倍所形成的大排队系统来代替$n$个独立的小排队系统其平均响应时间可以降低$n$倍</p>
</li>
</ul>
</li>
</ul>
<h4 id="414-混合模型">4.1.4. 混合模型</h4>
<ul>
<li>给每一个用户分配一个工作站，并提供一个处理机池
<ul>
<li>所有交互工作可放在工作站上进行，以保证响应时间</li>
<li>所有非交互工作可以分配给处理机池中多个处理机上运行</li>
</ul>
</li>
<li>交互响应时间短、资源利用率高以及系统设计简单等</li>
</ul>
<h3 id="42-分布式处理机分配算法">4.2. 分布式处理机分配算法</h3>
<ul>
<li>
<p>算法目的</p>
<ul>
<li>分布式系统包括多个处理机，具有较大的分布处理能力</li>
<li>一个作业将产生多个任务或进程，它们需要分配在多个处理机上并行执行，以充分利用分布式系统提供的巨大处理能力</li>
</ul>
</li>
<li>
<p>基本假定</p>
<ul>
<li>处理器
<ul>
<li>假定所有的机器都是相同的，至少是代码兼容的，不同的只是运行速度</li>
<li>有些还假定系统具有多个互不相关的处理机池，每一个处理机池都是相同的</li>
</ul>
</li>
<li>互连拓扑
<ul>
<li>假定系统是完全互连的，即每一个处理机都可以与其它任意一个处理机通信
<ul>
<li>并不表示每一个机器与其它任意一台机器之间都有线路直接连接，这个假定只是意味着每一对机器都可以互相通信</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>新进程的产生</p>
<ul>
<li>在有些情况下，创建进程是由系统的命令解释程序（即shell）来完成的。它是用户执行其指定的命令所对应的程序</li>
<li>在另一些情况下，用户进程本身也可以创建一个或者多个子进程，以获得较高的系统性能</li>
</ul>
</li>
<li>
<p>处理机分配策略</p>
<ul>
<li>非迁移的
<ul>
<li>在非迁移策略中，当创建一个进程时，系统就决定它被分配到哪台处理机上。一旦一个进程被分配到一台机器上，那么，它就在那台机器上运行，一直到终止，不管这台处理机的负载是多么的重，而别的处理机是多么的空闲，它都不能迁移到别的处理机上运行</li>
</ul>
</li>
<li>可迁移的
<ul>
<li>一个进程即使已经被分配到一台处理机上并已经运行了一段时间，如果其负载变重了,它也可以动态地迁移到其它轻负载的处理机上继续运行</li>
<li>实现复杂</li>
</ul>
</li>
</ul>
</li>
<li>
<p>优化目标</p>
<ol>
<li>
<p>尽量提高处理机的利用率</p>
<p><img src="image-20220609110501120.png" alt="image-20220609110501120" style="zoom: 67%;" /></p>
<ul>
<li>让处理机在每个小时内执行用户工作的周期数尽可能地多</li>
<li>尽量减少空闲处理机周期数</li>
</ul>
</li>
<li>
<p>使平均响应时间最小化</p>
<p><img src="image-20220609113509870.png" alt="image-20220609113509870" style="zoom:50%;" /></p>
<p><img src="image-20220609113520102.png" alt="image-20220609113520102" style="zoom:50%;" /></p>
</li>
</ol>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<p>假设有两个处理机</p>
<ul>
<li>处理机1以10MIPS的速度运行</li>
<li>处理机2以100MIPS的速度运行，其中等待队列中的进程需要5秒才能完成</li>
</ul>
</li>
<li>
<p>有两个进程</p>
<ul>
<li>进程A有1亿条指令，执行时间分别为10秒（在处理机1上）和1秒（在处理机2上）</li>
<li>进程B有3亿条指令，执行时间分别为30秒和3秒</li>
</ul>
</li>
<li>
<p>这两个进程在每一个处理机上的响应时间（包括等待时间）如图所示</p>
<p><img src="image-20220609113946514.png" alt="image-20220609113946514" style="zoom: 33%;" /></p>
</li>
<li>
<p>平均响应时间：</p>
<ul>
<li>如果把进程A和B分别分配给处理机1和2，那么平均响应时间是(10+8)/2=9秒</li>
<li>若反向分配，那么平均响应时间就是(30+6)/2=18秒</li>
</ul>
</li>
</ul>
</li>
<li>
<p>响应率：定义为在一台机器上运行一个进程所需的时间除以该进程在无负载的标准处理机上运行所需的时间</p>
<p><img src="image-20220609114112257.png" alt="image-20220609114112257" style="zoom:50%;" /></p>
<ul>
<li>意义：对于大多数用户来说，响应率比响应时间更重要。 其原因是考虑了大任务要比小任务花费更多时间这一情况</li>
<li>示例：一个1秒的任务花了5秒，而一个1分钟的任务花了70秒，从响应时间上看，前者好，但从响应率上看，后者更好，因为5/1&raquo;70/60</li>
</ul>
</li>
<li>
<p>负载分配算法的分类</p>
<p><img src="image-20220609114251662.png" alt="image-20220609114251662" style="zoom:50%;" /></p>
<ul>
<li>局部和全局
<ul>
<li>局部负载分配处理单个处理器上的进程对时间片（单元）的分配</li>
<li>全局负载分配首先进行进程对处理器的分配，然后完成每个处理器内这些进程的局部调度</li>
</ul>
</li>
<li>静态和动态（在全局类中）
<ul>
<li>静态负载分配中，进程对处理器的分配是在进程执行以前的编译阶段完成的（确定性调度）</li>
<li>动态负载分配要到进程在系统中执行时才做出分配（负载平衡）</li>
</ul>
</li>
<li>最优和次优（在静态和动态两种类型中）
<ul>
<li>如果根据某种标准（例如，最小执行时间和最大系统输出）可以取得最优分配，那么就可以认为这种负载分配方法是最优的</li>
<li>某些情况下，次优方案（神经网络方法）也是可以接受的</li>
<li>常用方法
<ol>
<li>解空间枚举搜索</li>
<li>图模型</li>
<li>数学编程（例如0/1规划）</li>
<li>队列模型</li>
</ol>
</li>
</ul>
</li>
<li>近似和启发式（在次优类型中）
<ul>
<li>在近似方法中，负载分配算法仅搜索一个解空间的子集，当寻找到一个好的解时，终止执行</li>
<li>在启发式方法中，调度算法使用某些特殊参数，能够近似地对真实系统建模</li>
</ul>
</li>
<li>集中控制的和分散控制的（在动态类型中）
<ul>
<li>在分散控制中，分配决策工作被分配给不同的处理器</li>
<li>在集中控制中，分配决策工作由一个处理器完成</li>
</ul>
</li>
<li>协作的和非协作的（对分散控制）
<ul>
<li>协作的：分布式对象间有协同操作</li>
<li>非协作的：处理器独立做出决策</li>
</ul>
</li>
</ul>
</li>
<li>
<p>其他负载分配算法的分类方法：</p>
<ul>
<li>单个和多个应用程序
<ul>
<li>多应用程序情况可以转换成单个应用程序情况</li>
<li>多应用程序情况下用平均子图完成时间作为衡量指标</li>
<li>单个应用程序情况下用最小完成时间作为衡量指标</li>
</ul>
</li>
<li>非抢占式的和抢占式的
<ul>
<li>非抢占式：一个任务（进程）开始执行后就不能中断</li>
<li>抢占式：进程可以中断，并从处理器上移走，以后继续执行</li>
</ul>
</li>
<li>非自适应的和自适应的
<ul>
<li>非自适应：不会依据系统反馈而改变白己的行为</li>
<li>自适应：能够根据系统反馈调整分配算法</li>
<li>典型地，一个自适应负载分配算法是许多负载分配算法的集合，依据系统的各种参数来选择一个合适的算法</li>
</ul>
</li>
</ul>
</li>
<li>
<p>算法设计时需要考虑：</p>
<ul>
<li>
<p>算法是确定式还是启发式的</p>
<ul>
<li>确定式算法需要预先知道进程的所有信息</li>
<li>在可预测系统中，可以通过合理的近似来事先得到所有进程的信息</li>
<li>不可预测系统中，需要使用一种称之为启发式的算法</li>
</ul>
</li>
<li>
<p>算法是集中式的还是分布式的</p>
<ul>
<li>集中式算法需要将系统中所有的信息都收集到某个机器上，这会造成系统不够鲁棒，并且该机器负载过于沉重</li>
<li>一般都采用分布式算法来实现处理机分配</li>
</ul>
</li>
<li>
<p>算法是最优的还是次优的</p>
<ul>
<li>一般来说，采用集中式和分布式算法都能够得到最优解，但得到最优解所花费的代价要比得到次优解复杂得多</li>
<li>最优解需要收集更多的信息以及进行全面复杂的处理</li>
<li>对于大多数分布式系统来说，只要有一个启发、分布、次优的处理机分配算法就可以了</li>
</ul>
</li>
<li>
<p>算法是局部的还是全局的</p>
<ul>
<li>与迁移策略有关</li>
<li>当一个新进程被创建时，系统需要决定它是否在创建它的机器上运行。若该机器繁忙，那这个新进程就必须迁移到其它机器上去运行
<ul>
<li>简单的局部算法：若机器的负载低于某个阀值，那新进程就在本地机器上运行；否则，就不允许该进程在本地上运行</li>
<li>在决定新进程是否在本地机器上执行之前，先收集其它一些机器上的负载信息</li>
</ul>
</li>
<li>局部算法简单，但远远达不到最优</li>
<li>全局算法需要付出巨大的代价来换取一个性能稍微好一点的结果</li>
</ul>
</li>
<li>
<p>算法是过载者启动的还是欠载者启动的</p>
<p><img src="image-20220609143031181.png" alt="image-20220609143031181" style="zoom:33%;" /></p>
<ul>
<li>与迁移的目的机器有关</li>
<li>一旦决定不允许一个进程在本地机器上运行，那么，迁移算法就必须决定将该进程应该迁移到一台目的机器上。显然，迁移算法不能是本地的。它需要通过获得其它机器上的负载信息来决定迁移的目的机器</li>
<li>过载者启动：由过载者来寻找迁移的目的机器</li>
<li>欠载者启动：由空闲机器发起可用消息寻找过载者</li>
</ul>
</li>
</ul>
</li>
<li>
<p>负载度量方法</p>
<ol>
<li>
<p>以机器上的进程数量作为机器的负载</p>
<ul>
<li>优点：简单
<ul>
<li>只需要计算机器上的进程数量</li>
</ul>
</li>
<li>缺点：用进程数量的多少来表示机器的负载是不确切的
<ul>
<li>即使在一台空闲机器上，仍然会有一些后台监视进程在运行</li>
</ul>
</li>
<li>改进：只计算正在运行或已经就绪进程的数量
<ul>
<li>每一个正在运行或处于就绪状态的进程都会给系统增加一定的负载，即便它是一个后台进程</li>
</ul>
</li>
<li>存在的问题：许多后台守护进程只是定时被唤醒，检查所感兴趣的事件是否发生，如果没有，则重新进入睡眠状态。因此，这类进程只给系统带来很小的负载</li>
</ul>
</li>
<li>
<p>直接使用处理机利用率</p>
<ul>
<li>
<p>处理机繁忙时间在全部时间中（繁忙时间+空闲时间）所占的比例</p>
<p><img src="image-20220609143345458.png" alt="image-20220609143345458" style="zoom: 50%;" /></p>
</li>
<li>
<p>优点：比较合理</p>
<ul>
<li>兼顾了用户进程和守护进程</li>
</ul>
</li>
<li>
<p>利用率的测量：设置一个定时器，它周期地中断处理机，每次都检查处理机的状态。并按照上述公式计算处理机利用率</p>
</li>
<li>
<p>存在的问题：当处理机内核正在执行原语时，它屏蔽了包括定时器中断在内的所有中断。如果该原语正阻塞前一个活动进程，那么，计算出的处理机利用率就会比实际情况要低得多</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Eager的三个处理机分配算法</p>
<ol>
<li>
<p>随机选择</p>
<ul>
<li>随机地选择一台机器，并把新创建的进程传送到该机器上</li>
<li>如果该接收机器本身也超载，它也同样随机地选择一台机器并把该进程传送过去</li>
<li>这个过程一直持续到有一台欠载的机器接收它为止，或者指定计数器溢出停止该进程的传送</li>
</ul>
</li>
<li>
<p>提前询问超载/欠载</p>
<ul>
<li>随机地选择一台机器，然后发送一个信息给该机器询问该机器是超载还是欠载</li>
<li>如果该机器欠载，它就接收新创建的进程；否则，新进程的创建机器继续随机地选择一台机器并向其发送一个询问消息</li>
<li>这个过程一直持续到找到一台欠载机器为止，或超过了一定的询问次数，如果找不到欠载机器，该新创建的进程就只好留在本地机器上运行</li>
</ul>
</li>
<li>
<p>提前询问$k$台机器</p>
<ul>
<li>给$k$台机器发送询问消息，接收这$k$台回送的负载消息</li>
<li>这个新进程将发送给负载最小的机器，并在它上面运行</li>
</ul>
</li>
</ol>
<p>比较：算法3的性能只比算法2的性能稍好一点，但其复杂性以及额外开销却比算法2要大的多</p>
</li>
<li>
<p>静态分配算法的设计与目标</p>
<ul>
<li>运行时负载不能够重新分配</li>
<li>算法目标：调度一个任务集合，使它们在各个目标PE上有最小的执行时间</li>
<li>设计算法的三个主要因素：
<ul>
<li>处理器互连</li>
<li>任务划分（粒度决策）</li>
<li>任务分配</li>
</ul>
</li>
<li>即便在简单地对计算开销和通信开销做某种假设以后，依然是一个NP完全问题
<ul>
<li>可以利用数学工具如图、启发式规则来得到次优的解</li>
</ul>
</li>
</ul>
</li>
<li>
<p>任务优先图</p>
<p><img src="image-20220609150835808.png" alt="image-20220609150835808" style="zoom:33%;" /></p>
<ul>
<li>又称为有向无环图（DAG）</li>
<li>每个链接：定义任务间的优先关系</li>
<li>节点上的标记：表示任务执行时间</li>
<li>链接上的标记：表示任务完成后启动后续任务所需的时间间隔</li>
</ul>
</li>
<li>
<p>任务交互作用图</p>
<p><img src="image-20220609151048511.png" alt="image-20220609151048511" style="zoom: 50%;" /></p>
<ul>
<li>链接：定义两个任务间的相互关系</li>
<li>每个链接赋予一对数：表示这两个任务在同一个PE 上时的通信开销和在不同PE上时的通信开销</li>
</ul>
</li>
<li>
<p>任务划分的粒度</p>
<ul>
<li>一个给定任务划分的粒度定义是任务分解中影响通信开销的所有单元的平均尺度</li>
<li>根据数据单元的大小，算法可以分成：
<ul>
<li>细粒度：数据单元小</li>
<li>粗粒度：数据单元大</li>
<li>中粒度：介于上述两者之间</li>
</ul>
</li>
<li>粒度的大小
<ul>
<li>若太大，会降低并行度，因为潜在的并行任务可能被划分进同一个任务而分配给一个处理器</li>
<li>若太小，进程切换和通信的开销就会增加</li>
</ul>
</li>
<li>主要目标：尽可能消除处理器间通信引起的开销
<ol>
<li>水平或者垂直划分
<ul>
<li>主要思想是在给定的任务优先图中垂直或者水平划分</li>
<li>关键路径（最长路径）的概念常常在垂直划分中使用</li>
<li>水平划分把给定的任务分成若干层，任务的优先级由它们所在的层次决定</li>
</ul>
</li>
<li>通信延迟最小划分
<ul>
<li>主要思想是把通信频繁的节点归成一类</li>
<li>需要通信的任务分配在一个处理器上会丧失任务间的并发性</li>
</ul>
</li>
<li>任务复制
<ul>
<li>主要思想是通过在PE上复制任务来降低通信开销</li>
<li>保留了任务原有的并行性</li>
<li>存储空间要求和同步开销增加了</li>
<li>可以利用任务复制来达到容错性，可以实现无错调度以保证处理器出现错误时最后计算结果正确</li>
</ul>
</li>
</ol>
</li>
<li>任务分配就是在给定了互连网络的并行系统或者分布式系统中分配颗粒（颗粒是任务划分的结果）
<ul>
<li>若任务图和处理器图的节点数目都是$n$ ，那么就有$n!$种不同的分配方法把任务图$G_t$里的节点分配到处理器图$G_p$的节点上
<ul>
<li>通常把每种方法称做$G_t$到$G_p$的一个映射</li>
</ul>
</li>
<li>关于$G_p$的典型假设
<ul>
<li>存储器容量无限</li>
<li>每个PE 有相同的处理能力</li>
<li>忽略网络拥塞，虽然通信进程间的距离是影响通信延迟的因素</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>基于任务优先图的任务调度</strong></p>
<ul>
<li>
<p>假定一个进程集合$P={P_1,P_2,P_3,\cdots,P_n}$，在一系列同样的处理器上执行</p>
</li>
<li>
<p>任务优先图：定义$P$上的偏序$&lt;$关系，构成$(P,&lt;)$关系集，并用$G=(V,A)$描述，其中</p>
<ul>
<li>$V$是顶点的集合，表示进程集</li>
<li>$A$是弧集合，表示进程间的优先关系</li>
<li>$A$中的一个链接表示$(u,v)$，$u$和$v$是$V$中的两个连接进程（节点）</li>
</ul>
</li>
<li>
<p>对每个节点和链接都定义有代价函数$w$</p>
<ul>
<li>$w(u)\in(0,\infin)$是节点$u$的代价，$u\in V$</li>
<li>$w(u,v)=(l,l')$是链接$(u,v)$的代价，其中：
<ul>
<li>$l'$：同一处理器内的通信代价（若$u$和$v$被分配在同一个处理器上）</li>
<li>$l$：处理器间的通信代价（若$u$和$v$被分配在不同处理器上）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>任务优先关系图模型中不考虑处理器互连：</p>
<ul>
<li>假设每对处理器间的通信延迟是一个固定数值</li>
<li>处理器通信延迟在$l$中得到了体现</li>
<li>处理器内部通信代价$l'$相对于处理器间通信代价$l$要小。因此可以忽略，<br />
记做$w(u, v)=l$</li>
</ul>
</li>
<li>
<p>甘特图：能够最有效描述进程对处理器的分配情况</p>
<ul>
<li>以处理器为纵坐标，时间为横坐标</li>
<li>每个方块表示进程在某个系统中的开始时间，持续时间和结束时间</li>
</ul>
</li>
<li>
<p>示例：</p>
<p><img src="image-20220609155301112.png" alt="image-20220609155301112" style="zoom: 50%;" /></p>
<ul>
<li>上图表示一个实例的任务优先图</li>
<li>圆圈中的数对应任务的执行时间</li>
<li>与每个链接相关的数对应于处理器间的通信时间（延迟）。两个连接任务分配在不同的处理器上时就会发生通信延迟</li>
</ul>
<p><img src="image-20220609155635569.png" alt="image-20220609155635569" style="zoom:50%;" /></p>
<ul>
<li>上图是对处理器$P1$, $P2$的一个调度结果</li>
<li>两个处理器间的通信发生在有1个单位通信延迟的$T2\rightarrow T4$和有2 个单位通信延迟的$T4\rightarrow T5$。总的执行时间是12</li>
</ul>
</li>
<li>
<p>通信延迟的影响</p>
<p><img src="image-20220609160119893.png" alt="image-20220609160119893" style="zoom: 50%;" /></p>
<ul>
<li>对于c和d，若通信延迟d大于$T2$的执行时间，图c的调度就比图d要好</li>
<li>若通信延迟太大的话，所有任务分配在一个处理器上是比较合适的</li>
<li>通常总是尝试尽量增加并行度，同时尽可能降低通信延迟。多数时间这两个目标是互相矛盾的。因此需要某种程度折衷</li>
<li>有时可以使用任务复制的方法减少通信需求
<ul>
<li>通过任务复制而避免了处理器间的通信，图b的结果是最好的</li>
</ul>
</li>
</ul>
</li>
<li>
<p>线性与非线性调度</p>
<p><img src="image-20220609160641447.png" alt="image-20220609160641447" style="zoom: 50%;" /></p>
<ul>
<li>若至少有一个类中包含两个独立的任务，则分类是非线性的；否则，分类就是线性的</li>
</ul>
</li>
<li>
<p>粒度的定义</p>
<p><img src="image-20220609160715538.png" alt="image-20220609160715538" style="zoom: 50%;" /></p>
<ul>
<li>
<p>一个任务优先图可以认为是许多分叉和合并操作的集合</p>
</li>
<li>
<p>为了判别好的分类算法，引入了对每个分叉或者合并的粒度的概念：</p>
<ul>
<li>
<p>如上图，分叉（合并）的粒度为：<br />
$$<br />
g(x)=\min_{1\leq k\leq n}{c_k}/\max_{1\leq k\leq n}{l_k}<br />
$$<br />
即最小的进程代价/最大的连接代价</p>
</li>
<li>
<p>给定任务优先图$G$的粒度为：<br />
$$<br />
g(G)=\min_{\forall x\in G}{g(x)}<br />
$$</p>
</li>
<li>
<p>若$g(x)&gt;1$，或$g(G)&gt;1$，则分叉（合并）为粗粒度的，否则为细粒度的</p>
</li>
</ul>
</li>
<li>
<p>连接代价大时，更倾向于粗划分（非线性划分）</p>
</li>
</ul>
</li>
<li>
<p>算法实例：两种最优调度算法</p>
<ol>
<li>
<p>优先图是一棵树</p>
<p><img src="image-20220609161857422.png" alt="image-20220609161857422" style="zoom:50%;" /></p>
<ul>
<li>
<p>优先级定义：</p>
<ul>
<li>节点$u$的等级是它到根节点的距离加1</li>
<li>节点的等级越高，它的优先级就越高</li>
<li>当若干个节点有相同的等级时，所有先导节点都已执行的节点被第一个选中；如果还有若干个节点符合上述条件，则做随机选择</li>
</ul>
</li>
<li>
<p>任务分配举例：</p>
<p><img src="image-20220609162015430.png" alt="image-20220609162015430" style="zoom:50%;" /></p>
<ul>
<li>从第一个时间槽开始根据优先级进行分配</li>
<li>有先后关系的任务不能分配在同一个时问槽中</li>
</ul>
</li>
<li>
<p>分配算法的实现：就绪队列定义</p>
<ul>
<li>就绪队列被用来高效的实现上述调度算法</li>
<li>就绪队列包括所有节点，它们的先导节点都已经执行完毕</li>
<li>根据优先级从就绪队列中选择后续节点执行</li>
<li>一个节点被调度时，就绪队列就必须更新</li>
<li>计算过程：
<ol>
<li>初始就绪队列为${T1,T2,T3,T4,T5,T7,T9,T10,T12}$，队列前三个任务分配在第一个时间槽</li>
<li>就绪队列变成${T4,T5,T7,T9,T10,T12}$，$T_4$，$T_5$，$T_7$分配在时间槽2</li>
<li>$T6$加入就绪队列${T6,T9,T10,T12} $再将队列中前三个任务分配给下一个时间槽</li>
<li>$T8$加入就绪队列${T8,T12}$。$ T8$和$T12$都分配在时间槽4 ，</li>
<li>$T11$加入就绪队列。$ T11$分配在时间槽5</li>
<li>$T13$加入就绪队列， 并在时间槽6执行</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>只有两个处理器可用</p>
<ul>
<li>假定有两个处理器。优先图中不同节点的等级不相同</li>
<li>生成优先图：
<ul>
<li>假定有$k$个终止节点（无后续节点），从1到$k$依次标记这些节点</li>
<li>令$S$是没有被分配（未被标记）的节点的集合，并且其中每个节点的后续节点都已被标记，从中选一个标记成$i$。令$lex(u)$是$u$的所有直接后续节点的标记的升序排列。若对$S$中所有$u’(u’≠u)$, $lex(u)&lt;lex(u’)$ （字典序），那么$u$可以赋予$i$</li>
</ul>
</li>
</ul>
<p><img src="image-20220609163514564.png" alt="image-20220609163514564" style="zoom:50%;" /></p>
<ul>
<li>
<p>任务按照优先级升序排序为：$ T1,T2,T3,T4,T5,T6,T11, T8,T7, T10,T9 $</p>
</li>
<li>
<p>注意终止任务$T1,T2,T3$的顺序是随机选 择的，例中它们的优先级分别是1,2,3，T4的直接后续节点是T1和T2，因此$lex(T4)=(1, 2)$。显然$lex(T4)&lt; Iex(T5)$，因此$T4$的标记是4，$T5$的标记是5</p>
</li>
<li>
<p>最优调度如下图所示：</p>
<p><img src="image-20220609163717175.png" alt="image-20220609163717175" style="zoom:50%;" /></p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>基于任务相互关系图的任务调度</strong></p>
<ul>
<li>
<p>任务图定义：与任务优先图模型不同的是处理器间通信在任务相互关系图调度模型中有重要作用</p>
<ul>
<li>处理器图由$G_p(V_p,E_p)$表示
<ul>
<li>顶点集$V_p$中每个元素是一个处理器</li>
<li>边集$E_p$中每个元素是一个通信信道</li>
</ul>
</li>
<li>一般来说，$|V_t|&lt;=|V_p|$，因此可以假设任务划分已经完成。然后，进行分配$M:V_t\rightarrow V_p$以及执行时间的估计。注意，$w(u)$和$w(u, v)$分别表示节点$u$和链接$(u, v)$的代价</li>
</ul>
</li>
<li>
<p>负载定义</p>
<ul>
<li>
<p>处理器$p$的计算负载，$p\in V_p$：<br />
$$<br />
Comp(p)=\sum_{u\in V_t}w(u)|M(u)=p<br />
$$<br />
表示任务$u$分给了$p$，计算负载即$p$上所有任务计算代价之和</p>
</li>
<li>
<p>通信负载<br />
$$<br />
Commp(p)=\sum_{(u,v)\in E_t}w(u,v)|M(u)=p\neq M(v)<br />
$$<br />
表示任务$u$分给了$p$，但$v$计算负载即$p$上所有任务计算代价之和</p>
</li>
<li>
<p>在一个应用程序中总的计算和通信量是<br />
$$<br />
\begin{aligned}<br />
Comp&amp;=\sum_{p\in V_p}Comp(p)=\sum_{p\in V_p}\sum_{u\in V_t}w(u)|M(u)=p\\<br />
Comm&amp;=\frac{1}{2}\sum_{p\in V_p}Comm(p)=\frac{1}{2}\sum_{p\in V_p}\sum_{(u,v)\in E_t}w(u,v)|M(u)=p\neq M(v)<br />
\end{aligned}<br />
$$</p>
</li>
<li>
<p>程序总的执行时间大概为：<br />
$$<br />
T=\max{\alpha Comp(p)+\beta Comm(p)},p\in V_p<br />
$$</p>
<ul>
<li>其中，$\alpha$依据每个PE的执行速度，$\beta$依据每个通信信道的通信速度和通信进程间的距离</li>
<li>如果两个进程$u$和$v$在$G_t$邻接，它们在$G_p$的映像（$M $的映像结果）可能邻接也可能不邻接</li>
<li>理想的情况下，所有通信进程被分配在邻接的处理器上，以此减少处理器间通信</li>
</ul>
</li>
</ul>
</li>
<li>
<p>映射的势</p>
<ul>
<li>
<p>通常两个进程不应该映射在一个处理器上</p>
<ul>
<li>任务分类时这两个进程应当分类进同一个类</li>
</ul>
</li>
<li>
<p>评估映射质量的一个指标是映射的势，即任务图$G_t$中的边映射到处理器图$G_p$的边的数目。也是$G_t$中映射到$G_p$中邻接处理器的通信进程对的数目</p>
<ul>
<li>映射的势不能超过$G_t$中的链接数</li>
<li>如果一个映射的势最大，它就是一个理想映射</li>
</ul>
</li>
<li>
<p>示例</p>
<p><img src="image-20220609171415049.png" alt="image-20220609171415049" style="zoom: 50%;" /></p>
<ul>
<li>左边是一个任务相互关系图，右边是一个具有9个处理器的处理器图</li>
<li>右图显示了任务与处理器的映射关系，该映射的势是8（13条边，8=13-5）</li>
</ul>
</li>
<li>
<p>有时映射的势可能不能准确地反映映射的质量，例如无法区分以下两种情况：</p>
<ol>
<li>两个通信进程被映射到两个处理器上，这两个处理器在处理器图中的距离是$k$，且$k&gt;2$</li>
<li>两个通信进程被映射到两个处理器上，这两个处理器在处理器图中的距离是2</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>基于图论的确定性分配算法</strong></p>
<ul>
<li>
<p>假定每个进程都知道：</p>
<ul>
<li>所需的处理机</li>
<li>所要求的内存</li>
<li>知道系统中任意一对进程间的平均通信量</li>
</ul>
<p>若系统中处理机的数目$k$比进程数少，那系统中的一些处理机就必须被分配多个进程</p>
</li>
<li>
<p>系统的带权图表示</p>
<ul>
<li>
<p>系统可以表示为图$G(V,E)$</p>
<p>$V$中的每个节点表示一个进程</p>
<p>$E$中的每条边表示两个进程需要通信，边上面的数字表示两个进程之间的通信量</p>
</li>
<li>
<p>数学简化：在一定的约束条件下将图分割成$k$个不相连的子图。目标就是在满足所有限制条件下，找到一个分割方法，使得分割后各子图之间的通信量之和最小</p>
</li>
</ul>
</li>
<li>
<p>示例：</p>
<p><img src="image-20220609193113473.png" alt="image-20220609193113473" style="zoom:33%;" /></p>
<ul>
<li>$a$中系统图被分割为：A、E、G在处理机1上，B、F、H在处理机2上，C，D，I在处理机3上。网络通信量=被虚线分割开的边上的权值之和=30</li>
<li>$b$中通信量之和为28</li>
</ul>
</li>
</ul>
<p><strong>集中式分配算法：up-down</strong></p>
<ul>
<li>
<p>图论算法的局限性：需要预先知道所有信息，这在一般情况下是办不到的</p>
</li>
<li>
<p>上升-下降算法的基本思想</p>
<ol>
<li>由一个协调器来维护一张使用情况表
<ul>
<li>每个工作站在表中都对应着一项（初始值为零）</li>
<li>当发生一个重要事件时，就给协调器发送一个消息来更新使用情况表</li>
</ul>
</li>
<li>协调器根据使用情况表来分配处理机
<ul>
<li>分配时机：调度事件发生时</li>
<li>典型的调度事件：
<ul>
<li>申请处理机</li>
<li>处理机进入空闲状态</li>
<li>发生时钟中断</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>集中式分配算法的目标：让每个工作站公平地使用系统处理机的计算能力,而不是尽可能地提高处理机的利用率</p>
<ul>
<li>其它算法有可能在给一个用户分配处理机时，为了让每一台处理机都繁忙起来而将所有处理机都分配给该用户</li>
</ul>
</li>
<li>
<p>处理新进程：</p>
<ul>
<li>当创建一个进程时，如果创建该进程的机器认为该进程应该在其它机器上运行，它就向协调器申请分配处理机</li>
<li>如果有可分配的处理机时，协调器就分配一个处理机，否则，协调器就暂时拒绝该处理机的申请，并记录这个请求</li>
</ul>
</li>
<li>
<p>罚分的情况</p>
<ul>
<li>
<p>增加：当一个工作站上的进程正在其它机器上运行时，它的罚分每秒钟增加一个固定值。这个罚分将加在使用情况表中该工作站所对应的项上</p>
</li>
<li>
<p>减少</p>
<ol>
<li>每当工作站上的进程需要在其它机器上运行的请求被拒绝时，该工作站在使用情况表中所对应项上的罚分就会减少一个固定值</li>
<li>当没有等待的处理机分配请求，并且处理机也未被使用时，使用情况表中该处理机所对应项上的罚分就会每秒钟减去一个值，直到为0</li>
</ol>
</li>
<li>
<p>取值</p>
<p><img src="image-20220609195243555.png" alt="image-20220609195243555" style="zoom: 50%;" /></p>
<ul>
<li>如图，由于罚分一会儿上升，一会儿下降，因此称为上升下降算法</li>
<li>使用情况表中的罚分可以为正数、零和负数
<ul>
<li>正数表示对应工作站上的用户是在使用系统资源</li>
<li>负数表示该工作站需要系统资源</li>
<li>零表示介于两者之间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>集中式分配算法的启发性：</p>
<ul>
<li>当一个处理机变成空闲状态时，首先分配给罚分最低正在等待处理机的申请。因此，等待时间最长，没有使用处理机的请求将优先得到响应</li>
<li>若一个用户已使用了一段时间的系统资源，另一个用户刚开始申请一个进程的运行，那负载较轻的后者要比负载较重的前者要优先得到资源</li>
</ul>
</li>
</ul>
<p><strong>层次分配算法</strong></p>
<ul>
<li>
<p>上升-下降算法作为一个集中式算法无法适用于大型分布式系统</p>
<ul>
<li>原因：协调器将成为整个系统的瓶颈，协调器崩溃将造成整个系统无法进行处理机分配</li>
</ul>
</li>
<li>
<p>层次分配算法将所有处理机以一种与物理拓扑结构无关的方式组织成一个逻辑分层结构</p>
<ul>
<li>由于每一个处理机只需要与一个上级和若干个下属进行通信，所以就可以对系统的信息流进行管理</li>
</ul>
</li>
<li>
<p>处理器预定</p>
<ul>
<li>一个处理机只能分配一个进程</li>
<li>若一个作业产生$S$个进程，系统必须为它分配$S$个处理机。作业可以在层次树上的任何一层次上创建。每一个管理者跟踪并记录它辖区内有多少个处理机可用</li>
<li>如果有足够的处理机可供使用，那它将预定$R$个处理机，但$R\geq S$必须成立，因为这种估计不一定准确，有些机器可能已经关机</li>
<li>如果没有足够的处理机可供分配，那就把这个申请请求（逐级）向上传递，直到到达某个能够满足该请求的层次。在这一层次上，管理者把这个请求分解成多个申请并向下传递给下级的管理者，一直传递到树的底层。在最低层，被分配的处理机被标为“繁忙”，并把实际分配到的处理机数沿着树向上逐级报告</li>
</ul>
</li>
<li>
<p>$R$的取值</p>
<ol>
<li>$R$必须足够的大以便确保有足够数量的处理机可供分配。否则，请求将沿着树向上传递。这样将会浪费了大量的时间</li>
<li>如果$R$太大，那么将有过多的处理机被标为“繁忙”，这将浪费一些计算能力，直到分配消息返回底层，这些处理机才会被释放</li>
</ol>
</li>
</ul>
<p><strong>超载者启动的分布式启发算法</strong></p>
<ul>
<li>
<p>算法描述</p>
<ul>
<li>
<p>当一个进程创建时，若创建该进程的机器发现自己超载，那就将询问消息发送给一个随机选择的机器，询问该机器的负载是否低于一个阀值</p>
<ol>
<li>如果是，那么该进程就被传送到该机器上去运行</li>
<li>否则，就再随机地选择一台机器进行询问</li>
</ol>
<p>这个过程最多执行$N$次，若仍然找不到一台合适的机器，那么算法将终止，新创建的进程就在创建它的机器上运行</p>
</li>
</ul>
</li>
<li>
<p>算法分析</p>
<ul>
<li>每一个机器都不断地向其他机器发送询问消息以便找到一台机器愿意接收外来的工作</li>
<li>在这种情况下，所有机器的负载都很重，没有一台机器能够接收其它机器的工作，此时，大量的询问消息不仅毫无意义，而且还给系统增添了巨大的额外开销</li>
</ul>
</li>
</ul>
<p><strong>欠载者启动的分布式启发算法</strong></p>
<ul>
<li>算法描述
<ul>
<li>当一个进程结束时，系统就检查自己是否欠载</li>
<li>如果是，它就随机地向一台机器发送询问消息</li>
<li>如果被询问的机器也欠载，则再随机地向第二台、第三台机器发送询问消息</li>
<li>如果连续$N$个询问之后仍然没有找到超载的机器，就暂时停止询问的发送，开始处理本地进程就绪队列中的一个等待进程，处理完毕后，再开始新一轮的询问</li>
<li>如果既没有本地工作也没有外来的工作，这台机器就进入空闲状态</li>
<li>在一定的时间间隔以后，它又开始随机地询问远程机器</li>
</ul>
</li>
<li>与超载者启动的分布式启发式算法相比
<ul>
<li>欠载者启动的算法不会在系统非常繁忙时给系统增加额外的负载</li>
<li>超载者启动的算法中，一台机器却在系统非常繁忙时发送大量的毫无意义的询问</li>
</ul>
</li>
<li>算法分析
<ul>
<li>当系统繁忙时，一台机器欠载的可能性很小。即使有机器欠载，它也能很快地找到外来的工作</li>
<li>在系统几乎无事可做时，算法会让每一台空闲机器都不间断地发送询问消息去寻找其它超载机器上的工作，造成大量的系统额外开销</li>
<li>在系统欠载时产生大量额外开销要比在系统过载时产生大量额外开销好得多</li>
</ul>
</li>
</ul>
<p><strong>超/欠载者启动的结合</strong></p>
<ul>
<li>让超载机器清除一些工作，而让欠载机器去寻找一些工作</li>
<li>系统中的机器可以通过保留以前的询问以及进行随机地询问来判断是否机器一直过载或欠载，这样可以提高系统性能</li>
</ul>
<p><strong>拍卖算法</strong></p>
<ul>
<li>
<p>进程为了完成自己的任务必须购买处理机时间，而处理机将它的处理机时间拍卖给出价最高的进程</p>
<ul>
<li>每一个处理机将自己估计的价格写入一个公共可读的文件中以此来进行拍卖</li>
<li>根据处理机的运算速度、内存大小、浮点运算能力以及其它一些特性来确定每一个处理机的价格</li>
<li>处理器提供的服务（例如，预计的响应时间）也要公布出来</li>
</ul>
</li>
<li>
<p>当一个进程要启动一个子进程时</p>
<ol>
<li>查询公共可读文件看有谁能够提供它所需要的服务</li>
<li>确定一个它可以付得起钱的处理机集合。通过计算从这个集合中选出一个最好的处理机。最好的标准是最便宜、速度最快或者性能价格比最高</li>
<li>给第一个选中的处理机发送一个出价信息，这个出价有可能高于或低于处理机公布的价格</li>
</ol>
</li>
<li>
<p>处理机</p>
<ol>
<li>收集所有发送给它的出价信息</li>
<li>选择一个出价最高的进程并将通知发送给选中的进程和未选中的进程</li>
<li>开始执行被选中的进程</li>
</ol>
<p>公共可读文件中该处理机的价格将被更新以便反映处理机当前最新的价格</p>
</li>
</ul>
<h3 id="43-分布式进程调度">4.3. 分布式进程调度</h3>
<ul>
<li>
<p>假定：进程都是成组创建的，并且组内进程之间的通信要比组间进程之间的通信多得多，系统有足够多的处理机来处理最大的一组进程，并且每一个处理机都是具有$N$个时间片的多进程处理机</p>
</li>
<li>
<p>Ousterhout基于协同调度概念的算法</p>
<ul>
<li>考虑了进程间的通信以此来保证同一组中的所有进程都在同一个时间片不同处理机上同时运行</li>
<li>使用了一个概念上的矩阵，每一列表示一个处理机上的进程表</li>
</ul>
<p><img src="image-20220609204203695.png" alt="image-20220609204203695" style="zoom: 67%;" /></p>
<ul>
<li>算法基本思想：每一台处理机都使用循环调度算法
<ul>
<li>如果处理机0启动在时间片3内运行的进程，那么，所有的处理机也必须启动时间片3内运行的进程（如果有的话）</li>
</ul>
</li>
<li>主要目的：所有的处理机都首先运行在时间片0内运行的进程，然后，同时运行在时间片1内运行的进程，依此一直运行下去。
<ul>
<li>用一个广播消息来通知所有处理机在何时进行进程切换，以便保证时间片的同步</li>
<li>将同一组内所有进程都放在不同处理机上同一个时间片内并保证同一组内的所有进程同时被调度运行，以获得最大并行度和通信吞吐率</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="44-分布式系统容错">4.4. 分布式系统容错</h3>
<ul>
<li>当一个系统没有完成它应该完成的任务，将其称之为失败或者失效</li>
</ul>
<h4 id="441-部件错误">4.4.1. 部件错误</h4>
<ul>
<li>
<p>错误一般分为三类：</p>
<ul>
<li>偶发性错误：偶尔发生一次，然后再也不会发生的错误。再重复操作一次，错误就会消失</li>
<li>间歇性错误：一会儿发生一会儿消失，反复不断（如网线接触不良）</li>
<li>永久性错误：当错误出现时，它是不会自动消失的，必须将发生错误的部件修复后，错误才能消失（如芯片烧坏）</li>
</ul>
</li>
<li>
<p>设计和制造容错系统的目的：保证即使存在一些错误，整个系统仍然能够正常地工作</p>
</li>
<li>
<p>如果一个部件在一秒钟时间内发生错误的概率为$p$，那么，它连续$k$秒正常工作后发生错误的概率是$p(1-p)^k$，失败发生的均值由下面的公式给出：<br />
$$<br />
发生错误的平均时间=\sum_{k=1}^\infin kp(1-p)^{k-1}=\frac{1}{p}<br />
$$</p>
</li>
</ul>
<h4 id="442-系统错误">4.4.2. 系统错误</h4>
<ul>
<li>处理机错误可被分为两类：
<ul>
<li>Fail-silent错误：出错的处理机仅仅是停止运行，并对接下来的输入既不响应也不产生输出，从而表示它停止工作了，它也称为fail-stop错误</li>
<li>Byzantine错误：出错的处理机仍然继续工作，但对输入产生错误的响应，甚至与其它出错的处理机一起产生更严重的错误，它们的特征是看起来好像都在正常工作</li>
</ul>
</li>
</ul>
<h4 id="443-同步和异步系统容错">4.4.3. 同步和异步系统容错</h4>
<ul>
<li>第三类错误：假定系统中一个处理机给另一个处理机发送一个消息，那么，必须在给定的时间$T$内得到一个回答，如果没有得到一个回答，则发送处理机就认为接收处理机已经崩溃。时间$T$必须包含处理消息丢失重发的时间</li>
<li>同步系统的性质：系统总能在一个确定的时间内对一个消息做出响应。不具有这个性质的系统就成之为异步的</li>
<li>异步系统比同步系统更难进行容错处理</li>
</ul>
<h4 id="444-采用冗余容错">4.4.4. 采用冗余容错</h4>
<ul>
<li>
<p>三种冗余：</p>
<ol>
<li>
<p>信息冗余：信息冗余就是给数据添加一些额外的信息位，以便检查数据出错时可以迅速将其纠正过来（如海明码校正传输线噪声错误）</p>
</li>
<li>
<p>时间冗余：在一个事务执行之后，如果需要，可以再次被执行一次。时间冗余特别适用于解决偶发性错误或间歇性错误</p>
</li>
<li>
<p>物理冗余：增加额外的物理设备使系统能够允许一些部件的出错或失效（例如：系统冗余处理机）</p>
<ul>
<li>主动复制：多个处理机完全并行地同时工作，其中一部分处理机失效后，其它处理机继续工作</li>
<li>主备份：一个处理机作为服务器，只有当它失效后，才用另一个备份处理机去代替它</li>
</ul>
<p>需要考虑的问题：</p>
<ul>
<li>复制的程度</li>
<li>出错和不出错时，平均情况和最坏情况下的性能</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="445-主动复制方法的容错">4.4.5. 主动复制方法的容错</h4>
<ul>
<li>主动复制是一种使用物理冗余来提供容错的技术</li>
<li>主动复制中所有服务器可以看作为一个大的有限状态机：
<ul>
<li>它们接收请求并给出应答。读请求并不改变服务器的状态，但写请求会改变服务器的状态</li>
<li>如果每一个客户请求都被发送给所有的服务器，那么，这些服务器接收这个请求并以同样的方式来处理它，处理完毕之后，无错误的服务器都处于相同的状态，并给出相同的结果。</li>
<li>客户端中的表决器可以综合这些结果，将错误的结果屏蔽掉</li>
</ul>
</li>
<li>如果在最多$k$个部件同时出错时系统仍然能够正常工作，那么，这个系统就称之为$k$容错的
<ul>
<li>对于Fail-silent类型的错误，系统只要拥有$k+1$个部件就可以满足$k$容错的要求</li>
<li>对于Byzantine类型的错误，出错的处理机一直处于运行状态并给出错误的结果，这时至少需要$2k+1$个处理机才能获得$k$容错。在最坏情况下，$k$个出错处理机碰巧给出同样的结果。然而，剩下的$k+1$个未出错的处理机仍然给出相同的正确结果，于是，客户端的表决器仍然可以从大多数结果中获得正确的结果</li>
</ul>
</li>
<li>原子广播问题：有限状态机模型的一个前提就是所有请求到达服务器的顺序都相同
<ul>
<li>读操作不会产生原子广播问题而写操作则会，因此可以适当放松条件</li>
<li>解决方法：
<ul>
<li>给所有的请求进行全局顺序编号。所有请求都首先发送到一个全局顺序编号服务器上，由该服务器分配一个全局顺序编号，但必须考虑这个服务器，如果它坏了，我们可以采用内部容错的方法来加以解决</li>
<li>使用Lamport逻辑时钟。如果每一个发送到服务器上的请求消息都含有一个邮戳，而所有的服务器都根据请求消息中的邮戳顺序来处理消息。这样，所有的服务器都可以以相同的顺序来处理请求消息
<ul>
<li>存在的问题：当一个服务器收到一个请求消息的时候，它并不知道是否有邮戳更小的请求消息还未到达</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="446-主备份的容错">4.4.6. 主备份的容错</h4>
<ul>
<li>
<p>基本思想：在任何时候，一个服务器作为主服务器，它承担所有的工作。如果这个主服务器崩溃了，那么就会有一个备份服务器来取而代之</p>
</li>
<li>
<p>与主动复制容错方法比较：</p>
<ul>
<li>优点
<ul>
<li>在通常情况下，请求消息只发往一台主/备份服务器而不是一组服务器，所以，比较简单易行，并且不存在消息顺序问题</li>
<li>在实际应用中，主备份容错方法需要的机器非常少，因为在任何时候它只需要一台主服务器和一台备份服务器</li>
</ul>
</li>
<li>缺点
<ul>
<li>当出现byzantine错误时，出错的服务器却认为自己的工作正常有效，造成了一种假象</li>
<li>恢复一个崩溃主服务器是非常复杂和耗时的</li>
</ul>
</li>
</ul>
</li>
<li>
<p>举例：简单写操作协议</p>
<p><img src="image-20220609213548167.png" alt="image-20220609213548167" style="zoom:67%;" /></p>
<ul>
<li>客户端给主服务器发送一个请求消息，主服务器在处理完该请求消息后给备份服务器发送一个更新消息</li>
<li>当备份服务器收到更新消息后，它就进行处理，然后，给主服务器发送一个确认消息</li>
<li>当确认消息到达主服务器后，主服务器才给客户端发送应答</li>
<li>如果主服务器在处理请求消息之前（即第2步）崩溃，那么，不会产生什么不良的影响。客户端只是在超时之后，再次重新发送请求消息，直到发送一定次数后，或者因得不到响应而停止发送请求消息，或者重发后它的请求分别得到主服务器和备份服务器的处理，并且只执行一次</li>
<li>如果主服务器在处理完请求消息之后并将更新消息发送给备份服务器之前崩溃了，那么，在备份服务器取代主服务器之后，这个请求消息就会再次从客户端传到主服务器，于是，该请求消息就会被备份服务器处理两次</li>
<li>主服务器在第4步之后第6步之前崩溃的话，那么，这个请求消息都要被执行三次：第2步主服务器执行一次；第4步备份服务器执行一次；在备份服务器取代主服务器之后又执行一次
<ul>
<li>如果每一个请求消息都带有标志信息，那么，请求消息只被执行两次</li>
</ul>
</li>
</ul>
</li>
<li>
<p>在主服务器崩溃后，只正确执行一次请求消息的处理是非常困难的</p>
</li>
<li>
<p>必须保证的是在备份服务器取代主服务器后，主服务器必须停止工作</p>
<ul>
<li>理想情况下，在主服务器和备份服务器之间应有一个协议来处理这个问题</li>
<li>最好的解决方案就是采用一种硬件技术强制备份服务器取代主服务器工作或重新启动主服务器
<ul>
<li>由主服务器和备份服务器共享的双向端口磁盘
<ul>
<li>当主服务器收到一个请求消息后，它首先把这个请求写入磁盘</li>
<li>然后，它也把结果写到这个磁盘上</li>
<li>主服务器就不需要与备份服务器进行通信了</li>
<li>如果主服务器崩溃了，那么，备份服务器就可以简单地从磁盘中读取信息以得知主服务器崩溃的情况</li>
<li>存在的问题：如果这个唯一的磁盘坏了，那么，所有信息都将丢失</li>
<li>解决方法：通过使用多个相同的共享磁盘来提高系统的容错能力。所有的写操作都可以在多个磁盘上同时进行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="447-容错系统中的协作一致性">4.4.7. 容错系统中的协作一致性</h4>
<ul>
<li>
<p>分布式协作一致性算法：让所有未出错的处理机能够对某些问题达成一致性意见，并在有限步数内完成协作操作</p>
</li>
<li>
<p>对于无故障的处理机来说，在通信不可靠的情况下，两个进程要达到协作一致是完全不可能的</p>
</li>
<li>
<p>Lamport解决Byzantine将军问题的递归算法</p>
<p><img src="image-20220609214635467.png" alt="image-20220609214635467" style="zoom:80%;" /></p>
<ol>
<li>每一个将军发送一个可靠的消息给所有其他的将军，声明自己的军队人数
<ul>
<li>忠诚将军说出的是真实数字</li>
<li>叛徒告诉每一个将军的数字都各不相同</li>
</ul>
</li>
<li>将收集的军队人数的结果组成向量</li>
<li>每一个将军把自己得到的向量传给其他每一个将军，叛徒继续撒谎，得到12个不同的新值</li>
<li>每个将军检查所有新收到向量的第$i$个元素，若有某个数值占多数，则这个值被存入结果向量；若没有一个数值占多数，则相应元素标记为unknown</li>
</ol>
<p>Lamport等证明：在一个有$m$个坏处理机的系统中，仅当系统中还有$2m+1$个好处理机在正常工作（即系统中共有$3m+1$个处理机），系统才能达到协作一致</p>
<ul>
<li>要使系统能够达到协作一致，那么至少要有超过三分之二的处理机处于正常工作的状态</li>
</ul>
</li>
<li>
<p>Fischer等证明：对于一个异步的且无传输延迟限制的分布式系统，只要有一个处理机崩溃（即使是Fail-silent错误），那么，系统都不可能达到协作一致</p>
<ul>
<li>异步系统对运行慢的处理机和崩溃的处理机无法区别</li>
</ul>
</li>
</ul>
<h3 id="45-实时分布式系统">4.5. 实时分布式系统</h3>
<h4 id="451-实时分布式系统的定义">4.5.1. 实时分布式系统的定义</h4>
<p><img src="image-20220609220325623.png" alt="image-20220609220325623" style="zoom:50%;" /></p>
<ul>
<li>根据实时性的限制和后果，实时系统通常可以分为两类：
<ul>
<li>软实时系统：系统对激励的响应可以偶尔超过时间限制</li>
<li>硬实时系统：不允许任何一次响应超过时间的限制，因为它有可能造成死亡或巨大的灾难</li>
</ul>
</li>
<li>常见误区：
<ul>
<li>实时系统是用汇编语言编写的驱动程序</li>
<li>实时计算是快速计算</li>
<li>高速计算机取代了实时系统</li>
</ul>
</li>
</ul>
<h4 id="452-设计问题">4.5.2. 设计问题</h4>
<ul>
<li>
<p>时钟同步问题：在多个处理机情况下，每一个处理机都有它自己本地的时钟，保持所有时钟的同步便成为一个非常重要的设计问题</p>
</li>
<li>
<p>事件触发和时间触发：在一个事件触发的实时系统中，当一个重要的外部事件发生时，它就被传感器接收到，然后，传感器就给与之相连的处理机发一个中断请求信号</p>
<ul>
<li>事件触发系统实际上是由中断来驱动的</li>
<li>大多数实时系统都是由中断驱动的事件触发系统</li>
</ul>
<p>主要问题：当许多事件同时发生时，中断重载会产生失败</p>
<ul>
<li>解决方法：设计一个时间触发的实时系统。在这种系统中，每隔$\Delta T$毫秒时间就会产生一个时钟中断。每一次时钟中断时，都对传感器进行采样，并驱动相应的执行机构。中断只是在若干时钟滴答时发生
<ul>
<li>$\Delta T$太小，则系统就会产生很多的时钟中断，浪费了大量时间来响应中断</li>
<li>$\Delta T$太大，一些严重问题可能在发现的时候已经太迟了</li>
</ul>
</li>
</ul>
<p>有一些事件的持续时间可能比时钟中断间隔要短，必须将这些事件保存起来，以防止他们被忽略</p>
<ul>
<li>存储在锁存器中或外部设备的微处理机中</li>
</ul>
<p>事件触发系统在负载较低的时候能够响应较快，但在负载较大的时候会出现失败。时间触发系统则刚好相反，它比较适应于相对静态环境</p>
</li>
<li>
<p>预知性</p>
<ul>
<li>实时系统的一个最重要特性就是系统中的事件是可预见的</li>
<li>在理想情况下，设计时就应该保证系统能够满足所有事件的时间限制，包括最大负载时的时间限制</li>
</ul>
</li>
<li>
<p>容错性</p>
<ul>
<li>一般采用主动复制方法来容错
<ul>
<li>只适用于采用非扩展协议的实时系统</li>
<li>非扩展协议能够使所有的进程在任何时刻任何事件上达成协作一致</li>
</ul>
</li>
<li>主备份方法很少使用
<ul>
<li>主服务器崩溃后，在主服务器和备份服务器的切换期间可能会超过实时系统中的时间限制</li>
</ul>
</li>
<li>容错实时系统必须能够同时处理最多设备出现失败以及负载达到最大的情况</li>
</ul>
</li>
<li>
<p>语言支持</p>
<ul>
<li>专用实时系统编程语言应该能够在编译的时候，计算出每一个任务的最大执行时间</li>
<li>不支持通常的while循环语句，必须使用常量参数限制的for循环语句，且不允许递归使用for循环</li>
<li>实时系统的编程语言应拥有表示最小和最大延迟的方法</li>
<li>必须有一个方法来说明当预期的事件未发生时系统应该如何处理</li>
</ul>
</li>
</ul>
<h4 id="453-实时通讯">4.5.3. 实时通讯</h4>
<ul>
<li>
<p>预知性和确定性是实时系统中最为重要的特性</p>
<ul>
<li>预知性意味着处理机之间的通信是可预知的（以太网随机协议无法预先得到数据包传输时间的上界）
<ul>
<li>令牌环局域网
<ul>
<li>每当一个处理机有一个数据包要发送，它就等待循环的令牌传到自己这儿，得到令牌后，发送数据包，然后，将令牌沿环发送给下一个邻居</li>
<li>假设，令牌环网上有$k$台机器，每一台机器在得到令牌时最多只发送$n$个字节的数据包。这就能保证一个数据包能在$kn$个字节的传输时间内到达任意一台机器。这就是实时系统所需要的传输时间上界</li>
</ul>
</li>
<li>时分多路访问TDMA
<ul>
<li>通信是以固定长度的时间帧来组织的，每一个帧具有$n$个时间片</li>
<li>每一个时间片都分配给一个处理机。只有处理机对应的时间片到来时它才能传送自己的数据包</li>
<li>可以避免冲突，延迟也是有限</li>
<li>每一个处理机在每个帧中都被分配了一定数目的时间片，因而，通讯具有固定的带宽</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>丢包率问题</p>
<ul>
<li>一般处理方法：在发送一个数据包后启动一个定时器。如果定时器在收到确认消息之前超时，那么，这个数据包将被重新发送一次
<ul>
<li>实时系统无法接受较大的传输延迟</li>
</ul>
</li>
<li>简单解决方法：每个数据包至少被发送两次或多次
<ul>
<li>浪费了至少一半的带宽</li>
<li>若丢失率为十万个数据包中只有一个数据包丢失，那么，采用每一个数据包被传输二次,就使得每10^10^个数据包中只丢失两个数据包</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间触发协议TTP</p>
<ul>
<li>
<p>MARS实时系统</p>
<ul>
<li>一个节点至少包含一个处理机，但通常有二、三个处理机同时工作，对外表现为一个能够处理Fail-silent错误的节点</li>
<li>所有节点都是通过两个可靠且独立的TDMA广播网络连接在一起的</li>
<li>所有的数据包都并行地在这两个网络中传送</li>
<li>数据包的丢失率是每三千万年丢失一个数据包</li>
<li>MARS时间触发系统
<ul>
<li>假定所有的时钟脉冲总是能够在数十微秒的数量级上保持精确同步。协议本身能够提供一个连续的时钟同步，并且其硬件实现精度极高</li>
</ul>
</li>
<li>所有节点都知道其它节点上正在运行的程序并且任意节点都知道其它节点在什么时候发送一个数据包</li>
<li>每一个节点都保留了系统的全局状态。这些状态在任何地方都是完全相同的。如果某一个节点与其它节点步调不一致，那么，这将产生一个严重的可检测错误。全局状态包括三个域：
<ul>
<li>当前模式：由应用程序定义的，并与系统所处的阶段相关。每一个模式都有它自己的一组进程和这组进程的运行顺序、参加运行的节点列表、TDMA时间片分配、消息名称和格式以及合法的后继模式</li>
<li>全局时间：由应用程序定义的，但在任何情况下，都必须足够的大以便所有节点都能达成一致</li>
<li>当前系统成员的位图：记录节点的动态增删</li>
</ul>
</li>
</ul>
</li>
<li>
<p>TTP协议包括单独的一个层来处理点对点的数据传输、时钟同步以及成员管理</p>
</li>
<li>
<p>TTP数据包格式</p>
<p><img src="image-20220610091944045.png" alt="image-20220610091944045" style="zoom:50%;" /></p>
<ul>
<li>包括了一个头域、一个控制域、一个数据域、以及一个CRC校验域</li>
<li>控制域：初始化位、存放当前模式的域、对前一节点发送数据包的确认域
<ul>
<li>让前一节点知道自己在正常工作，并且它的数据包已发送到网上了</li>
<li>如果没有进行一个预期的确认，那么，所有的节点都将应发确认数据包的节点标成崩溃，并把它从当前成员位图中删去。被删去的节点将无条件地从系统中消失了</li>
</ul>
</li>
<li>数据域：所需的数据</li>
<li>CRC校验域：提供了一个既包括整个数据包的校验和，又包括了全局状态的校验和
<ul>
<li>如果发送者的全局状态不正确，那么，它发送的所有数据包中的CRC校验值都与数据接收者根据自己全局状态计算出的值不一样，接收者将不会给出确认应答，这样，包括出错节点在内的所有节点都会在系统成员位图中将这个出错节点标为失败</li>
</ul>
</li>
</ul>
</li>
<li>
<p>周期性的广播将只发送含有初始化位的数据包</p>
<ul>
<li>这个数据包包含当前的全局状态</li>
<li>任何一个已被标为非成员的节点通过广播后可以作为被动成员加入到系统</li>
<li>如果一个节点已被认为是一个成员，那么，它就会被分配一个TDMA时间片，因而它就可以用自己的TDMA时间片来响应其它节点发给自己的数据包</li>
<li>一旦它的数据包被确认，所有其它节点又会把它标为一个活动节点</li>
</ul>
</li>
<li>
<p>TDMA协议处理时钟同步的方法比较简单</p>
<ul>
<li>每一个节点都知道TDMA帧何时启动以及它的时间片在帧内的位置</li>
<li>能够准确地知道何时能够发送一个数据包，避免冲突</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="454-实时调度算法">4.5.4. 实时调度算法</h4>
<ul>
<li>
<p>实时调度算法涉及的问题：</p>
<ul>
<li>硬实时还是软实时
<ul>
<li>硬实时算法必须保证所有的时间限制都必须满足</li>
<li>软实时算法允许偶尔超过时间限制但不会产生一些致命的后果</li>
</ul>
</li>
<li>抢占式还是非抢占式
<ul>
<li>抢占式：允许当一个具有更高优先级的任务到来时暂时挂起当前正在运行的低优先级任务，直到没有更高优先级任务执行的时候，才重新执行它</li>
<li>非抢占式：将每一个任务一直执行到结束</li>
</ul>
</li>
<li>动态还是静态
<ul>
<li>动态：在执行期间进行调度
<ul>
<li>动态抢占式：当检测到一个事件时，立即决定是执行与这个事件相关的任务还是继续执行当前的任务</li>
<li>动态非抢占式：知道又增加了一个任务要执行。只有等当前任务完成后，算法才在就绪任务中选择一个来运行</li>
</ul>
</li>
<li>静态：不管是否是抢占式的，任务调度都是在执行之前事先定好的。当一个事件发生时，任务调度程序只是到一个表中查看应该执行什么任务并执行该任务</li>
</ul>
</li>
<li>集中式还是非集中式</li>
</ul>
</li>
<li>
<p>调度问题建模</p>
<p>假设，一个周期性实时分布式系统有$m$个任务运行在$N$个处理机上。令$C_i$是任务$i$需要的处理机时间，$P_i$是它的周期，即连续两个中断之间的时间间隔。显然，系统的利用率$\mu$与$N$有如下的关系：<br />
$$<br />
\mu=\sum_{i=1}^m\frac{C_i}{P_i}\leq N<br />
$$</p>
<ul>
<li>举例：如果一个任务每20毫秒执行一次，每次运行10毫秒，那么，它就占用了0.5个处理机。5个这样的任务就需要3个处理机来承担</li>
<li>一组能够满足上述要求的任务我们称其是可调度的</li>
</ul>
</li>
<li>
<p>动态调度</p>
<ul>
<li>
<p>比率单调算法（Liu，Layland）</p>
<ul>
<li>
<p>为抢占式调度在处理机上没有顺序关系和互斥限制的周期性任务而设计的</p>
</li>
<li>
<p>算法过程：事先给每一个任务分配一个与其执行频率相等的优先级（例如每20ms执行一次的任务优先级为50，每100ms执行一次的优先级为10），调度程序总是选择优先级最高的任务运行，如果需要的话，也可以暂时停止当前任务的运行</p>
</li>
<li>
<p>已证明该算法是最优的，且对于任何一组任务，只要满足下面利用率的条件：<br />
$$<br />
\mu=\sum_{i=1}^m\frac{C_i}{P_i}\leq m(2^{1/m}-1)<br />
$$<br />
它们可用比率单调算法进行调度</p>
</li>
</ul>
</li>
<li>
<p>最早时限优先算法</p>
<ul>
<li>也是一种抢占式动态调度算法</li>
<li>算法过程：每当检测到一个事件时，调度程序就把它加在等待队列上。这个队列是按照任务时限到期的早迟来排序，时限最先到期的任务排在最前面</li>
<li>这个调度程序总是从队列中选择第一个任务来执行</li>
<li>产生结果是最佳的</li>
</ul>
</li>
<li>
<p>松弛度算法</p>
<ul>
<li>也是一种抢占式动态调度算法</li>
<li>计算每一个任务已完成的时间量，称之为松弛度（如对于一个200ms内完成的任务，若还需运行150ms，则松弛度为50ms）。算法只选择松弛度最小的任务来运行，也就是选择最不能拖延的任务来运行</li>
</ul>
</li>
</ul>
<p>上述算法没有一个在分布式系统中是最优的，但它们在分布式系统中可作为启发式算法。同时，没有一个算法考虑了任务的顺序关系和互斥限制，即使在单一处理机上也没有考虑任务顺序关系和互斥限制，只在理论上有效</p>
</li>
<li>
<p>静态调度</p>
<ul>
<li>
<p>算法输入：所有任务的列表和每一个任务运行需要的时间</p>
</li>
<li>
<p>算法目的：将任务分配到各个处理机上，并为每一个处理机给出任务的执行顺序</p>
</li>
<li>
<p>理论上能够穷举所有调度方案得到最优解，穷举时间与任务个数成指数增长，因此一般只使用启发式静态调度算法</p>
</li>
<li>
<p>算法过程：</p>
<p><img src="image-20220610101614352.png" alt="image-20220610101614352" style="zoom:50%;" /></p>
<ul>
<li>
<p>假设每当检测到一个特殊事件时，任务1就在处理机A上启动。这个任务又依次在本地和处理机B上启动其它任务。假定任务分配给处理机由外部来完成，所有的任务都只需要一个处理机时间单位</p>
</li>
<li>
<p>两个可能的调度方法如下图所示</p>
<p><img src="image-20220610101814475.png" alt="image-20220610101814475" style="zoom:50%;" /></p>
</li>
<li>
<p>对于静态调度，调度程序在系统开始运行前就必须决定使用的调度策略，一旦一个调度策略被确定下来之后，所有的调度信息存入表中，当系统运行时，使用一个简单的分配器就能够进行调度，并且开销较小</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>动态调度 vs. 静态调度</p>
<ul>
<li>静态调度比较适合于时间触发的系统；而动态调度比较适合于事件触发的系统</li>
<li>静态调度必须事先认真仔细设计，并需要花费较大的精力来选择各种各样的参数；而动态调度则不需要事先做这么多工作，因为它是在运行期间动态地进行选择</li>
<li>动态调度比静态调度更能充分地利用资源；对于静态调度，系统在设计中必须考虑各种各样的情况，并且还必须考虑最坏情况，因而，浪费了大量的资源</li>
<li>如果具有足够的计算能力，那么，静态系统可以事先得到一个最优或者次优的调度策略；一个动态系统要在运行期间花费大量的时间来进行调度计算几乎是不可能的</li>
</ul>
</li>
</ul>
<h2 id="5-分布式资源管理">5. 分布式资源管理</h2>
<h3 id="51-资源管理的基本概念">5.1. 资源管理的基本概念</h3>
<p><img src="image-20220610103501548.png" alt="image-20220610103501548" style="zoom:50%;" /></p>
<ul>
<li>
<p>单机OS的资源管理</p>
<ul>
<li>采用一类资源由一个资源管理者来管的集中式管理方式</li>
</ul>
</li>
<li>
<p>分布式OS的资源管理</p>
<ul>
<li>采用一类资源多个管理者的方式</li>
</ul>
</li>
<li>
<p>两种分布式资源管理方式</p>
<ol>
<li>集中分布管理：一类资源由多个管理者管理，但每个具体资源只存在唯一的一个管理者对其负责</li>
<li>完全分布式管理：一类资源由多个管理者管理，但一个资源由多个管理者共同管理</li>
</ol>
</li>
<li>
<p>分布式管理 vs. 集中式管理：对同类资源采用多个管理者还是一个管理者</p>
</li>
<li>
<p>集中分布式管理 vs. 完全分布式管理：前者对所管资源拥有完全控制权，后者对所管资源仅有部分控制权</p>
</li>
<li>
<p>从两种管理方式的角度划分系统资源：</p>
<ol>
<li>和处理机紧密相连的资源：如存储单元、显示器、硬盘以及与计算机连接的打印机等。通常采用集中分布管理方式，资源的管理者就放在被管理资源所连的那台处理机上</li>
<li>和处理机关系不甚紧密的资源：如多副本文件。与多台处理机相连的打印机等。往往采用完全分布管理方式</li>
</ol>
</li>
<li>
<p>集中和分布式资源申请过程的区别：</p>
<ul>
<li>集中资源申请：资源的申请者总是向唯一的一个资源管理者提出申请
<ul>
<li>申请者可以按一个确定的次序排队等候</li>
<li>只要不发生死锁，并且任何资源占有者都能在有限长的时间内释放所占用的资源</li>
<li>任何申请者必定能在有限长的时间内获得资源</li>
</ul>
</li>
<li>集中分布资源申请：一个申请者先向某个管理者提出申请
<ul>
<li>当申请者得知暂时不能获得所需资源后，应向另一个管理者提出申请</li>
<li>会产生饿死现象：申请者A向资源管理者R1申请资源，R1的资源不空，A转向资源管理者R2，此时，R1的资源刚被释放，且正逢另一个申请者B向R1申请，因而，B获得资源。A向R2申请资源又被拒绝，而当A第二次向R1申请资源时，R2资源恰好空了，但又被另一个申请者C占用了，R1仍不能满足A的申请，因为它的资源已被B占用；如此下去，B和C不断地从R1和R2处获得资源、使用资源、归还资源，而A交替地向R1和R2提出申请却永远得不到资源。（死锁：资源被无限期地占用而得不到释放。而饿死的本质是每个资源占有者都在有限长的时间内释放它所占有的资源，但仍然存在着申请者得不到资源）</li>
</ul>
</li>
</ul>
<p>分配资源算法应能满足条件：任何资源的占用者总能在有限长的时间内释放所占用的资源，并且任何资源申请者总能在有限长的时间内获得资源</p>
</li>
</ul>
<h3 id="52-集中分布资源管理">5.2. 集中分布资源管理</h3>
<ul>
<li>
<p>资源搜索算法</p>
<ul>
<li>目的：使得资源管理者按此算法帮助用户找到所需资源</li>
<li>满足条件：
<ul>
<li>避免饿死</li>
<li>高效地利用资源</li>
<li>资源使用均衡</li>
<li>算法开销小</li>
<li>鲁棒性</li>
</ul>
</li>
<li>基本假设：
<ul>
<li>先发先到</li>
<li>节点未失效时，消息一定能无误地被接收，失效的节点不再被外界感知</li>
</ul>
</li>
</ul>
</li>
<li>
<p>投标算法</p>
<ol>
<li>
<p>资源管理者欲向它机资源管理者申请资源时，首先广播招标消息，向网络中位于其它结点的每个资源管理者发招标消息</p>
</li>
<li>
<p>当一个资源管理者接到招标消息时，如果该结点上有所需资源，则根据一定的策略计算出”标数”，然后发一个投标消息给申请者，否则回一个拒绝消息</p>
<ul>
<li>
<p>标数规定：$b=w_1a+w_2d$</p>
<p>其中，$a$为等待申请者的个数，$d$为投标者与招标者间的距离，$w_1$和$w_2$为两个常数</p>
</li>
</ul>
</li>
<li>
<p>当申请者收到所有回答消息后，根据一定策略选出一个投标者，并向它发一个申请消息</p>
</li>
<li>
<p>接到申请消息后，将申请者的名字登记入册，并在可以分配资源时发消息通知申请者</p>
</li>
<li>
<p>当资源使用完毕后，向分配资源的资源管理者归还资源</p>
</li>
</ol>
<p>投标策略考虑了资源使用的均衡性又兼顾了资源使用的有效性，且不会出现饿死现象</p>
<p>在没有节点失效时，从广播招标信息到接到获得资源通知，一共发了$M$条信息：$M=2(n-1)+2=2n$，其中$n$为网络中的节点总数</p>
</li>
<li>
<p>投标算法的环形结构改进</p>
<ol>
<li>需要资源者向其邻居节点发一封招标信</li>
<li>接到招标信后，若本节点上无此类资源，则将招标信沿环传向下一邻居节点，否则
<ul>
<li>若信中未附投标，则将本节点的投标附上，将信传给下一邻点</li>
<li>若信中已附有投标，则将本节点的投标和它比较，优选一个附在信中传向下一个邻点</li>
</ul>
</li>
<li>接到自己发出的招标信后，从信中所附投标可知中标的资源管理者是谁</li>
<li>向中标的资源管理者发一封申请信</li>
<li>中标者接到申请信后将申请者排入申请队列，并在可以使用资源时向它发出通知</li>
<li>使用资源完毕后，通知分配资源者收回资源</li>
</ol>
</li>
<li>
<p>回声算法</p>
<ul>
<li>
<p>回声算法是用来获得全局知识的一种算法，也可用于资源搜索</p>
</li>
<li>
<p>用于搜索资源的回声算法由以下规则来定义：</p>
<ol>
<li>
<p>资源申请者向它的每一个邻结点发探查消息，消息中附上对资源的需求</p>
</li>
<li>
<p>若接探查消息的结点是第一次接到这样的探查消息，它就把传来探查消息的邻结点定义为它的对该探查而言的上邻结点，而把其余的邻结点定义为它的下邻结点。若接探查消息的结点不是第一次接到这样的探查消息，它就向传来探查消息的邻结点发一回声消息，消息中参数值为0</p>
</li>
<li>
<p>接上邻结点传来的探查消息后，若有下邻结点，则将探查消息复制后分发给各下邻结点，否则向上邻结点发一回声消息，消息中参数$S$（称资源参数）取值如下：</p>
<p>当结点不具备所需资源时，$S=0$</p>
<p>当有$a$个申请者在等待资源时，$S=w*a+1$</p>
<p>式中$w$为常数</p>
</li>
<li>
<p>当一个结点接到它的所有下邻结点发来的回声消息后，它就向它的上邻结点发一回声消息，消息中附上参数$S$及与之对应的结点编号。参数$S$的取值如下：</p>
<p>若$S_r=0$且所有回声消息中所附参数均为0，$S=0$</p>
<p>否则，$S=\min(S_{r1}+1,\cdots,S_{re}+1,S_r)$</p>
<p>其中，$S_r$为本结点的资源参数；$S_{r1,},\cdots,S_{re}$为所有回声中所附的非零资源参数</p>
<p>若$S$值被选为$S_{re}+1$，则回声消息中所附结点编号就是附有资源参数$S_{re}$的回声中所附的结点编号</p>
<p>若$S$值被选为$S_r$，则回声消息中所附节点编号为本结点编号</p>
</li>
<li>
<p>申请者获得所有邻结点发来的回声消息后，将按上一条规则选定$S$的方法选中一个资源提供者，然后，向它发申请消息</p>
</li>
<li>
<p>当一个结点接到申请消息后，就把申请消息登记下，并在可能时将资源分配给它</p>
</li>
<li>
<p>使用完毕后通知资源分配者释放</p>
</li>
<li>
<p>如果某个下邻节点很久没有回声，则发信询问，如果得到肯定回答，则继续等待；否则，就假定它的回声信已经收到，信中资源参数为0</p>
</li>
<li>
<p>如果发出申请信后很久未得到资源，则询问资源提供者，如果得到肯定回答，则继续等待；否则，重发探查信</p>
</li>
</ol>
</li>
<li>
<p>回声算法搜索资源不会产生饿死现象，但通信量比投标算法要高</p>
</li>
<li>
<p>对于一个节点很多的系统往往没有必要去搜索所有的节点，只要找到满意的资源就停止搜索</p>
</li>
</ul>
</li>
<li>
<p>改进的回声算法</p>
<ol>
<li>资源申请者向它的每一个邻结点发探查消息，消息中附上对资源的需求</li>
<li>若接探查信的节点不具有所需的资源并且没有收到过同样的探查信，则将探查信转发给它的所有的下邻节点</li>
<li>若接探查信的节点未收到过同样的探查信，并且它具有所需资源，则向来信者发一封回信</li>
<li>当一个节点接到满意的回声信或所有下邻节点的回声信后，即向上邻节点发回声信。信中所附的资源参数仍按原规则确定</li>
<li>当申请者收到满意的回声信或全部邻点的回声信后，就选择一个资源提供者，向它申请资源</li>
<li>当一个结点接到申请消息后，就把申请消息登记下，并在可能时将资源分配给它</li>
<li>使用完毕后通知资源分配者释放</li>
</ol>
</li>
<li>
<p>由近及远算法</p>
<ul>
<li>
<p>该算法让资源申请者由近及远地搜索，直到搜索到具有所要资源的结点为止</p>
</li>
<li>
<p>算法描述：</p>
<ol>
<li>资源申请者向它的某个邻结点发一个搜索消息，信中附上对资源的需求及参数$P$，其值为申请者编号</li>
<li>接搜索消息后，将发来消息的结点编号（定义为它的上邻结点）和信中参数$P$（定义为它的前结点）登记下来。如果接搜索消息的结点具有消息中所要求的资源，那么，它就向它的上邻结点发一个成功消息，并将自己的编号附上；否则它先发一个消息给它的前结点告知自己是它的后结点。然后，发消息给上邻结点，请继续搜索，消息中带上参数$P$，其值为自己的编号</li>
<li>接继续搜索消息后，如果还有未被搜索的下邻结点，那么，就发搜索消息给它，消息中附上的参数$P$是从继续搜索消息中取得的。如果所有下邻结点都已搜索过，但它有后结点，则把继续搜索消息转给它的后结点。如果既没有未被搜索的下邻结点，又没有后结点，则说明全部结点己被搜索过，这时它将向上邻结点发一个失败消息</li>
<li>接成功消息或失败消息后，若接消息者非申请者，则将消息转发给它的上邻结点，否则搜索到此结束。申请者或获得最近能提供所要资源的结点地址或被告之系统中没有这样的资源</li>
<li>如果一个己被搜索过的结点又收到搜索消息，则将原消息退回，发搜索消息的结点就认为该下邻结点不存在</li>
</ol>
</li>
<li>
<p>示例：假定节点$A$是申请者，只有节点$F$有节点$A$要的资源，按由近及远算法，搜索过程如下：</p>
<p><img src="image-20220610164039455.png" alt="image-20220610164039455" style="zoom:50%;" /></p>
<ol>
<li>A向B发搜索信</li>
<li>B向A发信告知A的后节点是B</li>
<li>B向A发信请继续搜索</li>
<li>A向C发搜索信</li>
<li>C向B发信告知B的后节点是C</li>
<li>C向A发信请继续搜索</li>
<li>A将继续搜索信转给它的后节点B</li>
<li>B向D发搜索信</li>
<li>D向C发信告知C的后节点是D</li>
<li>D向B发信请继续搜索</li>
<li>B向E发搜索信</li>
<li>E向D发信告知D的后节点是E</li>
<li>E向B发信请继续搜索</li>
<li>B将继续搜索信转给它的后节点C</li>
<li>C向E发搜索信</li>
<li>E将搜索信退还C</li>
<li>C将继续搜索信转给它的后节点D</li>
<li>D将继续搜索信转给它的后节点E</li>
<li>E向F发搜索信</li>
<li>F向E发成功信</li>
<li>E向B转发成功信</li>
<li>B向A转发成功信</li>
<li>A收到来自F的成功信</li>
</ol>
<p>如果F也没有A所要的资源，则19步以后的过程为：</p>
<ol start="20">
<li>F向E发信告知E的后节点F</li>
<li>F向E发信请继续搜索</li>
<li>E将继续搜索信转给它的后节点F</li>
<li>F即无资源又无后节点，因此,F发失败信息给它的上邻节点E</li>
<li>E向B转发失败信</li>
<li>B向A转发失败信</li>
<li>A收到失败信，搜索失败</li>
</ol>
</li>
<li>
<p>采用由近及远算法搜索资源不会产生饿死现象，比投标算法和回声算法通信量大得多，但当系统中有较多的节点拥有资源时，采用这种算法很快就能获得资源</p>
</li>
</ul>
</li>
</ul>
<h3 id="53-完全分布资源管理">5.3. 完全分布资源管理</h3>
<ul>
<li>
<p>完全分布资源管理的性质</p>
<ul>
<li>每个资源由位于不同节点上的资源管理共同来管</li>
<li>每个资源管理在决定分配它所管理的资源前，必须和其他资源管理者协商</li>
</ul>
</li>
<li>
<p>完全分布资源管理算法应满足的条件</p>
<ol>
<li>按算法协商的资源分配，应保证每个资源在任何时刻最多被一个进程所占有，即保证资源分配的互斥性</li>
<li>按算法协商资源的分配，不应产生饿死现象</li>
</ol>
</li>
<li>
<p>里卡特算法</p>
<ul>
<li>
<p>改进的时间戳算法</p>
</li>
<li>
<p>算法描述：</p>
<ol>
<li>
<p>申请资源者向网络中所有进程广播申请信，信上加盖申请时刻的时间戳，一旦收到所有进程的回答，就可以获取资源</p>
</li>
<li>
<p>进程$P_r$接到一封来自进程$P_s$的申请信时，设信上的时间戳为$T_s$，如果$P_r$既不是资源的申请者又不是资源的占用者，则立即给$P_s$以回答；否则，仅当$P_r$不是资源的占有者（它必定是资源的申请者），并且满足条件:<br />
$$<br />
T_s&lt;T_r或T_s=T_r且s&lt;r<br />
$$<br />
时才予以回答。上述条件中，$T_r$为$P_r$申请信中的时间戳，$s$和$r$分别为进程$P_s$和$P_r$的编号</p>
</li>
<li>
<p>占用资源的进程在释放资源时，对那些曾经接到过它们的申请信但未予回答的进程，补送回答</p>
</li>
<li>
<p>各进程都定义了一个逻辑时钟，每当发生一个诸如发信、收信等事件时，它的值将按逻辑时钟的定义增大</p>
</li>
<li>
<p>发出申请信后，如果某进程久未回答，就向他发一封探查信。如果发探查信后仍不见回答，那么这个被探查的节点必定已经失败，因此就不再等它的回答了</p>
</li>
<li>
<p>若接到探查信，立即发一封确认信给探查者，以确认自己在正常工作</p>
</li>
</ol>
</li>
<li>
<p>算法保证资源的互斥分配，并且不会产生饿死现象</p>
</li>
</ul>
</li>
<li>
<p>令牌算法</p>
<ul>
<li>令牌算法是一种通信量更小基于分布式同步的算法</li>
<li>算法描述：
<ol>
<li>每个进程有一张记录各进程申请资源状态的表格
<ul>
<li>当它发申请信时，或者接到其它进程发来的申请信时，就记录下该进程已经处于申请资源状态，并将信中所附的时间戳记录下来</li>
<li>接到某个进程发来的第二封申请信时，第一封信的时间戳就不再保留了</li>
</ul>
</li>
<li>初始化时，有且只有一个进程持有令牌</li>
<li>只有令牌持有者才能获得资源</li>
<li>申请资源时，如果该进程不持有令牌，则向其它进程广播申请信，信中附上当时的时间戳（其值大于表中所记录的所有其它进程发来申请信中的时间戳的值）</li>
<li>如果令牌持有者不是申请者并且它不在使用资源，则当表中记录有申请者时，就选择一个具有最小时间戳的申请者，将令牌传给它，并附上自己表中保存的所有进程使用资源的状况（是否在申请，以及最大的时间戳）</li>
<li>收到令牌的进程，根据令牌中附有的各进程状况，对自己表中各个进程的状况，以时间戳最大的值为标准进行修改，从而成为令牌持有者</li>
<li>每次使用互斥资源后，将增加表中自己所对应栏的时间戳的值并将自己的状态改为非申请资源状态，然后转规则5</li>
<li>当申请信发出后很久未获得令牌时，向其它各进程广播探查信。如果其它各进程没有回信反对，那它就成为令牌持有者。否则继续等待</li>
<li>接探查信后，如果接信者是令牌持有者，或者是申请者，并且自己申请时的时间戳小于发探查信者的时间戳（相等时，则比较进程编号），则立即发一封反对信</li>
<li>令牌持有者传送令牌时，如果发现接收者失效，则重新选择申请者，以传送令牌</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="6-分布式程序设计">6. 分布式程序设计</h2>
<h3 id="61-分布式程序设计的特点">6.1. 分布式程序设计的特点</h3>
<ul>
<li>分布式程序设计的特点
<ul>
<li>分布性</li>
<li>通信性</li>
<li>鲁棒性</li>
</ul>
</li>
<li>分布式功能
<ul>
<li>可使程序分为若干个可独⽴立执行的程序模块
<ul>
<li>这些程序模块可以在程序开始执行前就按要求分布于各台计算机上</li>
<li>可以在程序执行过程中逐个产生出来</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="62-分布式进程">6.2. 分布式进程</h3>
<ul>
<li>
<p>分布式进程</p>
<ul>
<li>分布式进程是分布于系统的若干台计算机上的进程，它们之间没有公用变量</li>
<li>一个程序是由数量固定的若干分布式进程组成，它们同时被启动，并行地在各台计算机上执行</li>
</ul>
</li>
<li>
<p>一个过程定义了它的输入输出参数、局部变量和语句序列</p>
<p><img src="image-20220610201624820.png" alt="image-20220610201624820" style="zoom:50%;" /></p>
</li>
<li>
<p>一个进程可⽤用call语句句来调⽤用另一个进程所定义的公共过程, 如</p>
<p><img src="image-20220610201711995.png" alt="image-20220610201711995" style="zoom: 50%;" /></p>
</li>
<li>
<p>卫式命令</p>
<ol>
<li>
<p>if语句</p>
<p><img src="image-20220610201751943.png" alt="image-20220610201751943" style="zoom:50%;" /></p>
<p>选择某个相应的语句执行之，否则停止执行程序</p>
</li>
<li>
<p>do语句</p>
<p><img src="image-20220610201834369.png" alt="image-20220610201834369" style="zoom:50%;" /></p>
<p>只要B1，B2，……中某个条件为真，就选择某个相应的语句执行之，直到所有条件均为假时这个语句才执行完毕</p>
</li>
<li>
<p>When语句</p>
<p><img src="image-20220610201938319.png" alt="image-20220610201938319" style="zoom:50%;" /></p>
<p>等到B1，B2，……中某个条件为真时，就执行某个相应的语句</p>
<p>如果多个条件为真，则选择某个相应的条件来执行</p>
</li>
<li>
<p>cycle语句</p>
<p><img src="image-20220610202254513.png" alt="image-20220610202254513" style="zoom:50%;" /></p>
<p>不断重复执行语句，等价于</p>
<p><img src="image-20220610202324268.png" alt="image-20220610202324268" style="zoom:50%;" /></p>
</li>
<li>
<p>for语句</p>
<p><img src="image-20220610202352672.png" alt="image-20220610202352672" style="zoom:50%;" /></p>
<p>对数组或集合$y$中每个元素$x$执行语句$S$</p>
</li>
<li>
<p>Skip语句</p>
<p>什么都不做的空操作</p>
</li>
</ol>
</li>
<li>
<p>示例：</p>
<ol>
<li>
<p>信件缓冲</p>
<p><img src="image-20220610202457955.png" alt="image-20220610202457955" style="zoom:50%;" /></p>
</li>
<li>
<p>字符串传送</p>
<p><img src="image-20220610202525772.png" alt="image-20220610202525772" style="zoom:50%;" /></p>
</li>
<li>
<p>文件读写</p>
<ul>
<li>一个称为Resource的进程管理理一个共享⽂文件</li>
<li>当一个进程要读（写）这个文件时
<ul>
<li>先调用过程Startread（Startwrite）取得读（写）的权力</li>
<li>然后就可以不断地调用过程Read（Write）来读（写）文件</li>
<li>当读写完毕后，调用过程Endread（Endwrite）以归还读（写）权</li>
</ul>
</li>
</ul>
<p><img src="image-20220610202559458.png" alt="image-20220610202559458" style="zoom:50%;" /></p>
<p><img src="image-20220610202845423.png" alt="image-20220610202845423" style="zoom:50%;" /></p>
<ul>
<li>其中，变量$S$的值表示文件所处的状态：
<ul>
<li>$S=0$，有一个写文件的进程占用文件</li>
<li>$S=1$，没有进程占用文件</li>
<li>$S=k,(k\geq 2)$，有$k-1$个读文件的进程占用文件</li>
</ul>
</li>
<li>文件在Resource的控制下可以同时为几个读文件的进程占用，而最多只可能为一个写文件的进程占用</li>
<li>上述程序无法避免饿死，为避免饿死应作如下修改：</li>
</ul>
<p><img src="image-20220610203323439.png" alt="image-20220610203323439" style="zoom:50%;" /></p>
</li>
<li>
<p>哲学家用餐问题</p>
<ul>
<li>解决5个哲学家⽤用餐问题的程序由6个进程组成
<ul>
<li>一个哲学家的活动由一个进程来描述</li>
<li>叉子由一个称为Table的进程来管理</li>
</ul>
</li>
</ul>
<p><img src="image-20220610204301977.png" alt="image-20220610204301977" style="zoom:50%;" /></p>
<p><img src="image-20220610204322538.png" alt="image-20220610204322538" style="zoom:50%;" /></p>
<p><img src="image-20220610204336124.png" alt="image-20220610204336124" style="zoom:50%;" /></p>
<ul>
<li>
<p>程序中函数left和right定义如下：</p>
<p><img src="image-20220610204408018.png" alt="image-20220610204408018" style="zoom:50%;" /></p>
</li>
<li>
<p>上述解法不不会产⽣生死锁，但是可能出现饿死现象</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="63-分布式进程迁移">6.3. 分布式进程迁移</h3>
<ul>
<li>分类
<ul>
<li>数据迁移</li>
<li>计算迁移</li>
<li>进程迁移</li>
</ul>
</li>
<li>引入进程迁移的理由
<ul>
<li>负载均衡</li>
<li>通信性能</li>
<li>加速计算</li>
<li>特殊功能和资源的使用</li>
</ul>
</li>
<li>IBM的AIX是一种分布式UNIX操作系统，它提供了了一种实⽤用的进程迁移机制。进程迁移的步骤如下：
<ol>
<li>当进程决定迁移⾃自身时，它先选择一个⽬目标机，发送一个远程执行任务的消息，该消息运载了进程映象及打开文件的部分信息</li>
<li>在接收端，内核服务进程生成一个子进程，将这些信息交给它</li>
<li>这个新进程收集完成其操作所需的环境、数据、变量和栈信息。如果它是“脏”的就复制程序文件；如果是“干净”的，则请求从全局文件系统中调页</li>
<li>迁移完成后发消息通知源进程，源进程发一个最后完成的消息给新进程，然后删去自己</li>
</ol>
</li>
</ul>
<h3 id="64-分布式语言">6.4. 分布式语言</h3>
<p><img src="image-20220610204839955.png" alt="image-20220610204839955" style="zoom:50%;" /></p>
<ul>
<li>
<p>Erlang</p>
<ul>
<li>
<p>一种通用的面向并发的编程语言</p>
</li>
<li>
<p>创造一种可以应对大规模并发活动的编程语言和运行环境</p>
</li>
<li>
<p>分布式机制是透明的</p>
</li>
<li>
<p>甚至允许代码在不被中断的情况下更新</p>
</li>
<li>
<p>多重范式编程语言</p>
<ul>
<li>涵盖函数式、并发式及分布式</li>
</ul>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<p>函数式编程</p>
<p><img src="image-20220610205050638.png" alt="image-20220610205050638" style="zoom:50%;" /></p>
</li>
<li>
<p>并发式编程</p>
<p><img src="image-20220610205112408.png" alt="image-20220610205112408" style="zoom:50%;" /></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>GoLang</p>
<ul>
<li>
<p>并行与分布式支持</p>
</li>
<li>
<p>软件工程支持</p>
</li>
<li>
<p>编程哲学的重塑</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<p>并发编程</p>
<p><img src="image-20220610205205886.png" alt="image-20220610205205886" style="zoom:50%;" /></p>
<p><img src="image-20220610205221554.png" alt="image-20220610205221554" style="zoom:50%;" /></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-移动计算">7. 移动计算</h2>
<h3 id="71-移动计算的类型">7.1. 移动计算的类型</h3>
<h4 id="711-移动计算的分类">7.1.1. 移动计算的分类</h4>
<ul>
<li>Mobile Computation：代码移动，它包括移动代理（Mob ile Agent）和主动网络（Actve Network）</li>
<li>Mobile Computing：设备移动，它包括有基站无线网络的设备移动和无基站无线网络（又称移动自组网络，俗称Ad-Hoc网络）的设备移动</li>
</ul>
<h4 id="712-mobile-computing的通信基础">7.1.2. Mobile Computing的通信基础</h4>
<ul>
<li>有基站无线网络：采用Mobile IP技术来支持设备的移动和通信</li>
<li>无基站无线网络：采用动态路由协议来支持设备的移动和通信</li>
</ul>
<h3 id="72-移动代理简介">7.2. 移动代理简介</h3>
<h4 id="721-moblie-agent的定义">7.2.1. Moblie Agent的定义</h4>
<ul>
<li>被抽象为能够自动完成用户任务的程序，可以不固定于开始运行的系统，能够自主地从网络中的一个节点移动到另一个节点并继续运行，必要时可以进行自我复制以及生成子移动代理。每一个节点上的Mobile Agent都可以直接同服务资源进行交互，待任务完成后再将结果集传送回源节点</li>
</ul>
<h4 id="722-mobile-agent研究内容">7.2.2. Mobile Agent研究内容</h4>
<ul>
<li>技术研究：技术研究主要涉及Mobile Agent的体系结构与模式、安全性、智能性、鲁棒性、搜索与定位、管理与控制以及Mobile Agent之间的协作等</li>
<li>应用研究：目前主要集中于Mobile Agent在网络管理、数据库、电子商务、多媒体信息获取等方面的应用</li>
</ul>
<h4 id="723-mobile-agent的体系结构">7.2.3. Mobile Agent的体系结构</h4>
<p><img src="image-20220610213123550.png" alt="image-20220610213123550" style="zoom:80%;" /></p>
<ul>
<li>
<p>一个Mobile Agent系统含有Mobile Agent 以及Mobile Agent服务设施</p>
<ul>
<li>Mobile Agent服务设施为每个Mobile Agent建立运行环境、提供服务接口，并利用Mobile Agent传输协议(ATP)实现Mobile Agent在网络节点间移动</li>
<li>Mobile Agent在服务设施中执行，通过Mobile Agent通信语言（ACL）访问服务设施提供的服务</li>
</ul>
</li>
<li>
<p>Mobile Agent的组成</p>
<p><img src="image-20220610213256011.png" alt="image-20220610213256011" style="zoom:80%;" /></p>
<ul>
<li>
<p>安全代理：Mobile Agent与外界通信的中介，执行Mobile Agent的安全策略，阻止外界环境对Mobile Agent的非法访问</p>
</li>
<li>
<p>环境交互模块：感知外部环境并作用于外部环境，实现MACL的语义，保证使用相同MACL的Mobile Agent和服务设施之间的正确通信和协商，而通信内容的语义与MACL无关</p>
</li>
<li>
<p>任务求解模块</p>
<ul>
<li>初始化：在初始化或移动到另一节点后启动事件处理程序</li>
<li>事件处理程序：持续自主运行，感知外部环境的请求，并依据内部的规则和状态产生动作</li>
</ul>
<p>可以设计为任务独立的模块，任务相关性由不同的推理规则集实现</p>
</li>
<li>
<p>知识库：Mobile Agent所感知的世界和模型，包含任务求解的结果和在移动过程中获取的知识</p>
</li>
<li>
<p>内部状态集：Mobile Agent执行过程中的当前状态，它影响Mobile Agent的任务求解过程，同时Mobile Agent的任务求解又作用于内部状态</p>
</li>
<li>
<p>约束条件：Mobile Agent的创建者为保证Mobile Agent的行为和性能而作出的约束，如返回时间、站点停留时间及任务完成程度等，一般只有创建者拥有对约束条件的修改权限</p>
</li>
<li>
<p>路由策略：决定Mobile Agent的移动路径。可以是静态路由也可以是动态路由</p>
</li>
</ul>
</li>
<li>
<p>Mobile Agent服务设施</p>
<p><img src="image-20220610213657287.png" alt="image-20220610213657287" style="zoom:80%;" /></p>
<ul>
<li>
<p>事件处理系统：包括初始化程序和事件处理模块，控制服务设施中其他模块，根据外部环境和Mobile Agent执行环境中的不同服务请求，协调相关组件提供所要求的服务</p>
</li>
<li>
<p>环境接口服务：包括Mobile Agent传输控制模块和通信模块，它们分别负责处理不同的外部请求</p>
<ul>
<li>传输控制模块：采用MATP协议，具体实现Mobile Agent的移动</li>
<li>通信控制模块：采用MACL完成Mobile Agent传输之外的其它通信任务</li>
</ul>
</li>
<li>
<p>执行环境：负责激活和执行Mobile Agent，同时实施服务设施安全策略保护节点不受攻击。两种执行环境分配策略：</p>
<ol>
<li>为每一个Mobile Agent分配单独执行环境（需要更多资源但安全性更强）</li>
<li>为所有的Mobile Agent分配同一个执行环境</li>
</ol>
<p>异构系统中，Mobile Agent往往被分配不同的执行环境</p>
</li>
<li>
<p>服务设施基本服务：为Mobile Agent提供基本服务，包括Mobile Agent的生命周期服务、事件服务以及目录服务等</p>
<ul>
<li>生命周期服务：包括与Mobile Agent整个生命周期的各个阶段相关的子服务，分别实现Mobile Agent的创建、移动、存储和执行环境分配</li>
<li>事件服务：包括对Mobile Agent传输协议和通信协议的支持，实现Mobile Agent在服务设施间的移动及与服务设施和其它Mobile Agent之间的事件传递</li>
<li>目录服务：向Mobile Agent提供一定范围内服务设施的描述信息的列表，并与Mobile Agent协商形成路由选择</li>
</ul>
</li>
<li>
<p>定制服务：为Mobile Agent提供领域相关的任务求解服务</p>
</li>
<li>
<p>本地访问代理：提供服务设施与本地应用的接口，应用程序通过它创建、发送、接收自己的Mobile Agent。Mobile Agent或服务设施需要访问访问设施所在主机的本地应用程序，本地访问代理集中对这些访问进行管理和安全性控制，代表服务设施访问本地应用，然后返回结果</p>
</li>
</ul>
</li>
</ul>
<h4 id="724-mobile-agent基本技术">7.2.4. Mobile Agent基本技术</h4>
<ul>
<li>
<p>构建一个Mobile Agent的基本运行框架，需要下列技术是：</p>
<ul>
<li>
<p>Mobile Agent 通信语言（ACL）：ACL定义了Mobile Agent以及服务设施间协商过程的语法和语义,是实现异质系统集成的基础。开放的Mobile Agent系统ACL应该具有以下特征：</p>
<ol>
<li>应用的普遍性</li>
<li>简捷、一致的语法和语义</li>
<li>通信内容的独立性等</li>
</ol>
<p>KQML和HTTP是两种具有发展潜力的通信语言，其中KQML主要应用于知识处理领域，在Internet/Intranet环境中具有很好的普遍性和支持能力</p>
</li>
<li>
<p>Mobile Agent传输协议(ATP)：ATP定义了Mobile Agent之间传输的语法和语义，具体实现Mobile Agent在服务设施间的移动机制</p>
</li>
<li>
<p>Mobile Agent实现语言：Mobile Agent的跨平台执行需要实现语言具有</p>
<ol>
<li>简洁性，以便使服务设施以最小的代价提供语言的执行环境</li>
<li>移动性语义，方便Mobile Agent的移动</li>
<li>平台独立，具有跨平台一致的语义</li>
<li>安全性，实现语言级的安全性以提供增强的安全性</li>
</ol>
<p>较为成功的实现语言主要有Java,Telescript等解释型或中间代码语言</p>
</li>
<li>
<p>Mobile Agent知识表示语言：Mobile Agent知识表示语言对系统的应用领域具有强的依赖性</p>
</li>
</ul>
</li>
</ul>
<h4 id="725-mobile-agent的特点">7.2.5. Mobile Agent的特点</h4>
<ul>
<li>可移动性：Mobile Agent在运行过程中，为了完成特定的任务往往需要从网络中的一个节点迁移到网络中的另一个节点运行</li>
<li>分布并行性：在支持Mobile Agent的系统中，可以将一个大的任务分解为若干个子任务，然后，将每一个子任务分配一个Mobile Agent 去完成，而每一个Mobile Agent则可以根据不同任务的具体情况迁移到适当的网络节点上并行运行，共同完成同一个任务。在运行过程中，各个Mobile Agent之间可能是对等的，每个Mobile Agent作为一个自治系统，相互协作，因此，这些运行的Mobile Agent就构成了一个分布式系统</li>
<li>异步性：Mobile Agent提供不同时间和空间范围内的互操作机制
<ul>
<li>传统的分布式计算一般基于同步方式，只有少数应用程序支持有限的异步交互</li>
<li>Mobile Agent引入了完整的异步计算环境，用户创建的Mobile Agent可以异步地与处于其它时间和空间范围的主机交互，任务完成后将运算结果返回给创建者</li>
</ul>
</li>
<li>资源优化：Mobile Agent能够优化网络通信和计算资源，实现负载平衡</li>
</ul>
<h4 id="726-mobile-agent的应用">7.2.6. Mobile Agent的应用</h4>
<ul>
<li>Mobile Agent在网络服务中的应用</li>
<li>Mobile Agent在TINA中的应用</li>
<li>网络管理</li>
<li>数据库访问</li>
</ul>
<h4 id="727-尚待研究的其他技术">7.2.7. 尚待研究的其他技术</h4>
<ul>
<li>安全性
<ul>
<li>防止MA对主机系统的资源进行非法操作，如存取系统敏感信息，例如，用户口令文件；非法访问系统文件；占用大量系统资源，使系统陷入瘫痪</li>
<li>对MA保护，如在主机上，对MA的运行代码、数据进行攻击；在网络传输过程中，其它恶意主机对MA的代码以及数据进行攻击；其他程序对于MA的攻击</li>
</ul>
</li>
<li>Mobile Agent的管理与控制</li>
<li>Mobile Agent的搜索和定位</li>
<li>Mobile Agent的协作</li>
<li>Mobile Agent容错与可靠性</li>
<li>开放性与标准化</li>
</ul>
<h4 id="727-mobile-agent的发展趋势">7.2.7. Mobile Agent的发展趋势</h4>
<ul>
<li>标准化</li>
<li>安全性问题</li>
<li>智能高效</li>
</ul>
<h3 id="73-主动网络">7.3. 主动网络</h3>
<h4 id="731-主动网络的起源">7.3.1. 主动网络的起源</h4>
<ul>
<li>主动网络的特点
<ol>
<li>可编程性</li>
<li>移动性</li>
<li>可扩展性</li>
<li>可互操作性</li>
<li>安全保密性</li>
</ol>
</li>
</ul>
<h4 id="732-主动网络的概念">7.3.2. 主动网络的概念</h4>
<ul>
<li>
<p>主动网络的定义：主动网络由一组称为主动结点的网络结点构成。每个主动结点可以是路由器或交换器,这些主动结点共同构成了主动网络的执行环境</p>
</li>
<li>
<p>主动节点的组成</p>
<ol>
<li>网络传输层</li>
<li>主动消息的瞬时执行环境</li>
<li>构件存储器</li>
</ol>
<p>每个主动消息均包含指令“原语”，即消息对象的方法，同时也可调用执行环境提供的外部方法</p>
<p>当主动消息中的小程序执行后，改变了主动消息报文内容或修改了临时执行环境的状态，处理后的主动消息传给下一个主动结点处理</p>
</li>
<li>
<p>主动网络的体系结构：</p>
<ul>
<li>基于编程语言的方法，如SwitchWare，NetScript</li>
<li>扩展传统网络IP协议选项的方法，如Active IP</li>
</ul>
<p>共同特点：</p>
<ol>
<li>主动网络可根据用户和应用的需要动态扩展功能</li>
<li>主动网络提供可编程的互操作性</li>
<li>网络计算可移动性</li>
<li>主动网络与用户之间的接口是一种编程语言</li>
<li>网络服务可以分解在服务构件中。主动结点提供服务，作为主动报文的外部方法</li>
</ol>
<p><img src="image-20220610221432534.png" alt="image-20220610221432534" style="zoom:50%;" /></p>
</li>
<li>
<p>主动网络的实现方法</p>
<ol>
<li>离散型实现方法：
<ul>
<li>也叫可编程的交换结点(switch node)方法</li>
<li>对主动消息的处理和代码分发是两种独立的机制，网络端与主动结点间有两个通道交互</li>
<li>一个传送数据，另一个传送管理，用户预先将定制好的程序通过管理通道插入到所需的主动路由器中，以后的消息经过这些主动路由器时，检查报文头，决定调用相应的处理程序</li>
<li>为使主动路由器具有可扩展性，管理人员可以动态地加载代码到主动路由器中</li>
</ul>
</li>
<li>集成型实现方法
<ul>
<li>又称封装方法</li>
<li>每一个主动报文都有一段程序与数据组成封装体</li>
<li>当该封装体到达主动结点后，主动结点提供一种执行报文中程序的机制，存取执行环境的信息；若该封装体中的程序需要调用的外部方法不在该主动结点时，通过请求(on demand)下载该方法，其概念如Postscript代码</li>
</ul>
</li>
</ol>
</li>
<li>
<p>主动网络运行支持和执行环境</p>
<ul>
<li>主动网络必须在OS的支持下有效地处理主动消息</li>
<li>包括操作系统和编译技术的支持,还包括主动结点的安全设施、代码Cache及分发机制</li>
</ul>
</li>
<li>
<p>主动网络的安全性</p>
<ul>
<li>正确地执行、安全地传输及如何安全地控制主动报文存取主动结点的资源,是主动网络安全性的要求</li>
</ul>
</li>
<li>
<p>主动网络的控制和算法</p>
<ul>
<li>需要解决配置管理、流量控制、拥塞控制及消息调度等问题</li>
</ul>
</li>
<li>
<p>主动网络的典型实例</p>
<ul>
<li>MIT开发的用于实现端系统间移动代码技术的主动网络工具ANTS</li>
<li>宾夕法尼亚大学开发的主动网络系统SwitchWare</li>
<li>哥伦比亚大学研发的主动网络NetScript</li>
</ul>
</li>
</ul>
<h2 id="8-云计算大数据人工智能杂项">8. 云计算&amp;大数据&amp;人工智能杂项</h2>
<h3 id="81-云计算">8.1. 云计算</h3>
<ul>
<li>
<p>云计算优势</p>
<ul>
<li>按需服务</li>
<li>快速服务</li>
<li>通用性</li>
<li>高可靠性</li>
<li>极其廉价</li>
<li>超大规模</li>
<li>虚拟化</li>
<li>高扩展性</li>
</ul>
</li>
<li>
<p>云计算模式</p>
<p><img src="image-20220610222734125.png" alt="image-20220610222734125" style="zoom:50%;" /></p>
<ul>
<li>软件即服务SaaS：服务租赁化
<ul>
<li>提供给客户的服务是服务商运行在云计算基础设施上的应用程序，可以在各种客户端设备上通过瘦客户端界面访问</li>
</ul>
</li>
<li>平台即服务Paas：平台可伸缩化
<ul>
<li>提供给客户的是将客户用供应商提供的开发语言和工具（例如Java，python,.Net）创建的应用程序部署到云计算基础设施上去</li>
</ul>
</li>
<li>基础设施即服务Iaas：资源虚拟化
<ul>
<li>提供给客户的是出租处理能力、存储、网络和其它基本的计算资源，用户能够部署和运行任意软件，包括操作系统和应用程序</li>
</ul>
</li>
</ul>
</li>
<li>
<p>下一代IT架构</p>
<p><img src="image-20220610223032725.png" alt="image-20220610223032725" style="zoom:50%;" /></p>
<ul>
<li>强化：减少费用、提高质量</li>
<li>虚拟化：简单接入，提高终端用户管理&amp;使用最大化</li>
<li>自动化：提高速度和预言性&amp;减少劳动力</li>
</ul>
</li>
<li>
<p>云计算关键技术</p>
<p><img src="image-20220610223133109.png" alt="image-20220610223133109" style="zoom:50%;" /></p>
<ul>
<li>虚拟化技术</li>
<li>分布式技术</li>
<li>数据中心构建技术</li>
<li>云计算安全技术</li>
<li>云计算编程模型</li>
</ul>
</li>
<li>
<p>IaaS层关键技术</p>
<ul>
<li>如何建设低成本、高效能的数据中心</li>
<li>如何拓展虚拟化技术，实现弹性、可靠的基础设施服务
<ul>
<li>软件虚拟化</li>
<li>硬件辅助虚拟化</li>
<li>操作系统级虚拟化</li>
</ul>
</li>
</ul>
</li>
<li>
<p>PaaS层关键技术</p>
<ul>
<li>海量数据存储与处理技术</li>
<li>资源管理与调度技术</li>
</ul>
</li>
<li>
<p>服务管理层技术</p>
<ul>
<li>QoS保证机制</li>
<li>安全与隐私保护技术</li>
<li>资源监控技术</li>
<li>服务计费模型</li>
</ul>
</li>
<li>
<p>云计算应用</p>
<ul>
<li>云安全</li>
<li>云存储</li>
<li>云物联</li>
<li>云政务</li>
</ul>
</li>
</ul>
<h3 id="82-大数据发展趋势及其关键技术">8.2. 大数据发展趋势及其关键技术</h3>
<ul>
<li>
<p>大数据关键技术体系</p>
<ol>
<li>
<p>采集、预处理</p>
<ul>
<li>结构化日志采集、非结构化数据采集、其他数据采集</li>
<li>数据抽取（将这些复杂的数据转化为单一的或者便于处理的构型）、数据清洗（清洗无用数据）</li>
</ul>
</li>
<li>
<p>存储管理</p>
<ul>
<li>挑战：规模巨大、管理复杂、上层需求</li>
<li>分布式文件存储系统代表技术：Google的GFS和Hadoop的HDFS，HDFS是GFS的开源实现</li>
<li>分布式数据库代表技术：Google的Big Table和Hadoop的Hbase,前者基于GFS，后者基于HDFS。主要特征：
<ul>
<li>非关系数据模型，比如键值存储等</li>
<li>对简单操作如键值查询的水平可扩展</li>
<li>在多个节点中分割和复制数据的能力</li>
<li>弱并发一致性语义（比如最终一致性）</li>
<li>充分利用分布式索引和内存</li>
</ul>
</li>
</ul>
</li>
<li>
<p>计算模式</p>
<ul>
<li>查询分析计算：HBase，Hive，Cassandra，Impala，Shark，Hana等</li>
<li>批处理计算：Hadoop MapReduce，Spark等</li>
<li>流式计算：Scribe，Flume，Storm，S4，Spark Steaming等</li>
<li>迭代计算：HaLoop，iMapReduce，Twister，Spark等</li>
<li>图计算：Pregel，Giraph，Trinity，PowerGraph，GraphX等</li>
<li>内存计算：Dremel，Hana，Spark等</li>
</ul>
<p>MapReduce计算模式：先分后合。把海量数据分割成若干部分，分给多台处理器并行处理。把各台处理器处理后的结果进行汇总操作以得到最终结果</p>
</li>
<li>
<p>分析挖掘</p>
</li>
<li>
<p>可视化</p>
</li>
<li>
<p>隐私和安全</p>
</li>
</ol>
</li>
</ul>
<h3 id="83-人工智能的三次浪潮">8.3. 人工智能的三次浪潮</h3>
<ul>
<li>第一次：在1956年达特茅斯会议上，定义了人工智能，即人工智能需要经过特征提取、模型训练和数据预测三个阶段</li>
<li>第二次：1982年，美国加州工学院物理学家Hopfield提出了一个Hopfield神经网络模型</li>
<li>第三次：Hinton提出了深度学习技术、谷歌机器人AlphaGO四比一战胜了围棋世界冠军李世石</li>
</ul>

    </article>
    
    
<script defer src="/js/clipboard.min.c168d3a04c45a631be76437054619a4a3b30107960cb9730be96012fef5762b0.js"></script>

<script defer src="/js/helper/prev.min.js"></script>

<script defer src="/js/helper/prop.min.js"></script>
<script>
  'use strict';
  document.addEventListener('DOMContentLoaded', function () {
    
    var clipInit = false;
    var preChromaElem = document.querySelectorAll('pre.chroma');
    var langCodeElem = document.querySelectorAll('.language-code');
    var dollarCodeElem = document.querySelectorAll('div.language-\\$');
    var gtCodeElem = document.querySelectorAll('div.language-\\>');

    var makeClipboard = function(elem) {
      var code = elem,
          text = elem.textContent;
        
      if (text.length > 15) {
        if (!clipInit) {
          var text, clip = new ClipboardJS('.copy-to-clipboard', {
            text: function (trigger) {
              var codeElem = prev(trigger).querySelectorAll('code');
              if (codeElem.length > 1) {
                text = prev(trigger).querySelector('code[class^="language-"]').textContent;
              } else {
                text = prev(trigger).querySelector('code').textContent;
              }

              return text.replace(/^\$\s/gm, '');
            }
          });

          var inPre;
          clip.on('success', function (e) {
            e.clearSelection();
            inPre = prop(e.trigger.parentNode, 'tagName') == 'PRE';
            e.trigger.setAttribute('aria-label', 'Copied to clipboard!');
            e.trigger.classList.add('tooltipped');
            e.trigger.classList.add('tooltipped-w');
          });

          clip.on('error', function (e) {
            inPre = prop(e.trigger.parentNode, 'tagName') == 'PRE';
            e.trigger.setAttribute('aria-label', e.action.toString());
            e.trigger.classList.add('tooltipped');
            e.trigger.classList.add('tooltipped-w');
          });

          clipInit = true;
        }

        var notAllowedClass = ['language-mermaid', 'language-viz', 'language-wave', 'language-chart', 'language-msc', 'language-flowchart'];
        var isNotAllowedIncluded = false;
        var curClassName = code.getAttribute('class');

        for (var i = 0; i < notAllowedClass.length; i++) {
          if (curClassName && curClassName.startsWith(notAllowedClass[i])) {
            isNotAllowedIncluded = true;
            break;
          }
        }

        if (!isNotAllowedIncluded) {
          if (curClassName) {
            var newClipboardElem = document.createElement('span');
            newClipboardElem.setAttribute('class', 'copy-to-clipboard');
            newClipboardElem.setAttribute('title', 'Copy to clipboard');
            elem.parentNode.parentNode.insertBefore(newClipboardElem, elem.parentNode.nextElementSibling);
          }
        }
      }
    }

    var makeSymbolClipboard = function(elem) {
      var clipboardSpan = document.createElement('span');
      clipboardSpan.setAttribute('class', 'copy-to-clipboard');
      clipboardSpan.setAttribute('title', 'Copy to clipboard');
      elem.parentNode.parentNode.insertBefore(clipboardSpan, elem.parentNode.nextElementSibling);
    }

    preChromaElem ? 
    preChromaElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function(codeElem) {
        makeClipboard(codeElem);
      });
    }) : null;
    
    langCodeElem ? 
    langCodeElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function (codeElem) {
        makeClipboard(codeElem);
      });
    }) : null;

    dollarCodeElem ? 
    dollarCodeElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function (codeElem) {
        makeSymbolClipboard(codeElem);
      });
    }) : null;

    gtCodeElem ?
    gtCodeElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function (codeElem) {
        makeSymbolClipboard(codeElem);
      });
    }) : null;
    
  });
</script>
    <script>
  'use strict';
  
  function wrap(el, wrapper) {
    el.parentNode.insertBefore(wrapper, el);
    wrapper.appendChild(el);
  }

  (function () {
    var singleContentsElem = document.querySelector('.single__contents');
    singleContentsElem ? 
    singleContentsElem.querySelectorAll('pre > code').forEach(function(elem) {
      var dataLang = elem.getAttribute('data-lang');
      var dataLangWrapper = document.createElement('div');
      var code = null;
      var codeTitle = null;

      if (dataLang && dataLang.includes(':')) {
        code = dataLang.split(':')[0];
        codeTitle = dataLang.split(':')[1];

        dataLangWrapper.className = 'language-' + code;
        dataLangWrapper.setAttribute('data-lang', codeTitle);

        elem.className = 'language-' + code;
        elem.setAttribute('data-lang', codeTitle);
        elem.setAttribute('id', codeTitle);
      } else if (!dataLang) {
        dataLangWrapper.setAttribute('data-lang', 'Code');
        dataLangWrapper.className = 'language-code';
      }

      if (!dataLang || codeTitle) {
        wrap(elem.parentNode, dataLangWrapper);
      }

    }) : null;
  })();

  var langCodeElem = document.querySelectorAll('.language-code');
  langCodeElem ? langCodeElem.forEach(function (elem) {
    var newElem = document.createElement('span');
    newElem.className = 'copy-to-clipboard';
    newElem.setAttribute('title', 'Copy to clipboard');
    elem.append(newElem);
  }) : null;
  

  

  
  var dollarCodeElem = document.querySelectorAll('div.language-\\$');
  var gtCodeElem = document.querySelectorAll('div.language-\\>');

  dollarCodeElem ?
  dollarCodeElem.forEach(function(elem) {
    var lnts = elem.parentNode.parentNode ? elem.parentNode.parentNode.querySelectorAll('.lnt') : null;
    lnts ? 
    lnts.forEach(function(lnt) {
      lnt.innerHTML = '$<br/>';
    }) : null;
  }) : null;

  gtCodeElem ?
  gtCodeElem.forEach(function(elem) {
    var lnts = elem.parentNode.parentNode ? elem.parentNode.parentNode.querySelectorAll('.lnt') : null;
    lnts ? 
    lnts.forEach(function(lnt) {
      lnt.innerHTML = '><br/>';
    }) : null;
  }) : null;
  
</script>
    
<div class="donation">
  <div class="donation__message">
    分享
  </div>
  <div class="donation__icons">
    
    
    
      
        <a href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fchaphlagical.github.io%2fzh%2fposts%2fcomputer%2fos%2f" title="Facebook" aria-label="Facebook Share Button" class="donation__item" target="_blank" rel="noreferrer" data-type="share">
          <svg data-name="facebook" enable-background="new 0 0 24 24" viewBox="0 0 24 24" width="35" height="35" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="m15.997 3.985h2.191v-3.816c-.378-.052-1.678-.169-3.192-.169-3.159 0-5.323 1.987-5.323 5.639v3.361h-3.486v4.266h3.486v10.734h4.274v-10.733h3.345l.531-4.266h-3.877v-2.939c.001-1.233.333-2.077 2.051-2.077z"/></svg>
        </a>
      
    
      
        <a href="javascript:void(function(){var d=document,e=encodeURIComponent,s1=window.getSelection,s2=d.getSelection,s3=d.selection,s=s1?s1():s2?s2():s3?s3.createRange().text:'',r='https://www.douban.com/recommend/?url='+e(d.location.href)+'&title='+e(d.title)+'&sel='+e(s)+'&v=1',w=450,h=330,x=function(){if(!window.open(r,'douban','toolbar=0,resizable=1,scrollbars=yes,status=1,width='+w+',height='+h+',left='+(screen.width-w)/2+',top='+(screen.height-h)/2))location.href=r+'&r=1'};if(/Firefox/.test(navigator.userAgent)){setTimeout(x,0)}else{x()}})()" class="donation__item" target="_blank" rel="noreferrer" title="Douban" aria-label="Douban Share Button" data-type="share">
          <svg data-name="douban" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="35" height="35"><path fill="currentColor" d="M 4 4 A 1.0001 1.0001 0 1 0 4 6 L 20 6 A 1.0001 1.0001 0 1 0 20 4 L 4 4 z M 7 8 C 5.9069372 8 5 8.9069372 5 10 L 5 13 C 5 14.093063 5.9069372 15 7 15 L 7.2792969 15 L 8.6113281 19 L 4 19 A 1.0001 1.0001 0 1 0 4 21 L 20 21 A 1.0001 1.0001 0 1 0 20 19 L 15.388672 19 L 16.720703 15 L 17 15 C 18.093063 15 19 14.093063 19 13 L 19 10 C 19 8.9069372 18.093063 8 17 8 L 7 8 z M 7 10 L 17 10 L 17 13 L 7 13 L 7 10 z M 9.3886719 15 L 14.611328 15 L 13.279297 19 L 10.720703 19 L 9.3886719 15 z"/></svg>
        </a>
      
    
  </div>
</div>


    
    
<div class="whoami__gutter"></div>
<hr class="hr-slash whoami-hr"/>
<section class="whoami">
  <div class="whoami__image-wrapper">
    
    
      
        <img data-src="/images/whoami/avatar.png" src="data:image/svg+xml,%0A%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath fill='none' d='M0 0h24v24H0V0z'/%3E%3Cpath fill='%23aaa' d='M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-1 16H6c-.55 0-1-.45-1-1V6c0-.55.45-1 1-1h12c.55 0 1 .45 1 1v12c0 .55-.45 1-1 1zm-4.44-6.19l-2.35 3.02-1.56-1.88c-.2-.25-.58-.24-.78.01l-1.74 2.23c-.26.33-.02.81.39.81h8.98c.41 0 .65-.47.4-.8l-2.55-3.39c-.19-.26-.59-.26-.79 0z'/%3E%3C/svg%3E" alt="Wenbo Chen" class="lazyload whoami__image"/>
      
    
  </div>
  <div class="whoami__contents">
    <div class="whoami__written-by">
      作者
    </div>
    <div class="whoami__title">
      
        Wenbo Chen
      
    </div>
    <div class="whoami__desc">
      
        CG Student
      
    </div>
    <div class="whoami__social">
      
      
      <a href="https://blog.csdn.net/Chaphlagical" title="csdn" aria-label="csdn">
        <svg fill="#000000" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="25" height="25"><path fill="currentColor" d="M11.705 9.681l-.03.247c-.035.288-.3.484-.585.439-.47-.081-1.135-.151-1.64-.151-.765 0-1.16.267-1.19.56-.035.368.365.389 1.355.681 1.345.378 1.935.913 1.855 1.741C11.38 14.172 10.31 15 8.165 15c-.655 0-1.24-.096-1.675-.222-.24-.066-.395-.293-.37-.545l.035-.288c.045-.232.25-.404.49-.404.035 0 .065.005.095.01.01 0 1.057.237 1.61.202.808-.051 1.26-.247 1.3-.636.03-.353-.3-.404-1.22-.646-1.265-.343-2.075-.878-1.995-1.731C6.53 9.752 7.72 9 9.555 9 10.2 9 10.83 9.035 11.3 9.121 11.56 9.167 11.74 9.414 11.705 9.681zM18.79 9.814c.019-.223.184-.409.404-.45 4.533-.849 4.929.926 4.782 2.502l-.241 2.54c-.024.257-.24.453-.498.453h-.546c-.295 0-.526-.254-.498-.547l.207-2.182c.056-.601.405-1.776-1.281-1.732-.186.005-.343.017-.469.032-.235.027-.414.218-.433.455-.021.255-.05.595-.083.88l-.251 2.642c-.024.257-.24.453-.498.453h-.514c-.296 0-.527-.255-.498-.549l.247-2.501L18.79 9.814zM17.115 9.846c-.615-.5-1.611-.696-2.84-.735-.531-.017-1.087.024-1.265.05-.192.029-.345.19-.385.38-.01.035-.015.07-.015.11l-.43 4.635c-.03.275.17.52.44.545.425.045.91.065 1.41.065 1.205 0 2.005-.18 2.64-.59.695-.44 1.17-1.15 1.265-2.16C18.035 11.056 17.665 10.306 17.115 9.846zM16.435 12.106c-.085.935-.955 1.605-2.185 1.605-.305 0-.46-.025-.58-.05l.3-3.355c.125-.025.36-.025.525-.025C15.795 10.271 16.565 10.746 16.435 12.106zM5.367 14.461c-.021.227-.19.41-.415.448C4.623 14.966 4.163 15 3.595 15c-2.427 0-3.737-1.254-3.583-2.913C.198 10.112 2.139 9 4.264 9c.559 0 .961.034 1.304.093.259.045.437.286.408.547L5.941 9.965c-.031.283-.292.487-.573.439-.326-.055-.724-.093-1.071-.093-1.25 0-2.312.41-2.434 1.707-.109 1.16.637 1.714 2.044 1.714.271 0 .614-.024.922-.064.318-.041.592.222.562.541L5.367 14.461z"/></svg>
      </a>
      
      
      
      
      
      <a href="https://www.douban.com/people/Chaphlagical/" title="douban" aria-label="douban">
        <svg fill="#000000" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="25" height="25"><path fill="currentColor" d="M 5 4 A 1.0001 1.0001 0 1 0 5 6 L 19 6 A 1.0001 1.0001 0 1 0 19 4 L 5 4 z M 7 8 C 5.9069372 8 5 8.9069372 5 10 L 5 13 C 5 14.093063 5.9069372 15 7 15 L 7.3242188 15 L 8.5234375 18 L 5 18 A 1.0001 1.0001 0 1 0 5 20 L 19 20 A 1.0001 1.0001 0 1 0 19 18 L 15.476562 18 L 16.675781 15 L 17 15 C 18.093063 15 19 14.093063 19 13 L 19 10 C 19 8.9069372 18.093063 8 17 8 L 7 8 z M 7 10 L 17 10 L 17 13 L 7 13 L 7 10 z M 9.4765625 15 L 14.523438 15 L 13.324219 18 L 10.675781 18 L 9.4765625 15 z"/></svg>
      </a>
      
      
      
      <a href="mailto:chaf@mail.ustc.edu.cn" title="email" aria-label="email">
        <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-.4 4.25l-7.07 4.42c-.32.2-.74.2-1.06 0L4.4 8.25c-.25-.16-.4-.43-.4-.72 0-.67.73-1.07 1.3-.72L12 11l6.7-4.19c.57-.35 1.3.05 1.3.72 0 .29-.15.56-.4.72z"/></svg>
      </a>
      
      
      
      <a href="https://www.facebook.com/chaf.chen.3" title="facebook" aria-label="facebook">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewBox="0 0 24 24" version="1.1">
<g id="surface2747">
<path fill="currentColor" d="M 11.664062 2.003906 C 6.621094 2.171875 2.375 6.25 2.023438 11.289062 C 1.65625 16.617188 5.46875 21.121094 10.507812 21.878906 L 10.507812 14.648438 L 8.890625 14.648438 C 8.164062 14.648438 7.578125 14.0625 7.578125 13.335938 C 7.578125 12.609375 8.164062 12.023438 8.890625 12.023438 L 10.503906 12.023438 L 10.503906 10.273438 C 10.503906 7.378906 11.914062 6.105469 14.324219 6.105469 C 14.679688 6.105469 14.984375 6.113281 15.242188 6.128906 C 15.878906 6.15625 16.371094 6.6875 16.371094 7.324219 C 16.371094 7.988281 15.835938 8.523438 15.171875 8.523438 L 14.730469 8.523438 C 13.710938 8.523438 13.351562 9.492188 13.351562 10.585938 L 13.351562 12.023438 L 15.222656 12.023438 C 15.8125 12.023438 16.265625 12.550781 16.175781 13.132812 L 16.066406 13.835938 C 15.992188 14.304688 15.589844 14.652344 15.113281 14.652344 L 13.351562 14.652344 L 13.351562 21.898438 C 18.234375 21.234375 22 17.0625 22 12 C 22 6.367188 17.339844 1.820312 11.664062 2.003906 Z M 11.664062 2.003906 "/>
</g>
</svg>

      </a>
      
      
      
      
      
      <a href="https://github.com/Chaphlagical" title="github" aria-label="github">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewBox="0 0 24 24" version="1.1">
<g id="surface3680">
<path fill="currentColor" d="M 10.898438 2.101562 C 6.300781 2.601562 2.601562 6.300781 2.101562 10.800781 C 1.601562 15.5 4.300781 19.699219 8.398438 21.300781 C 8.699219 21.398438 9 21.199219 9 20.800781 L 9 19.199219 C 9 19.199219 8.601562 19.300781 8.101562 19.300781 C 6.699219 19.300781 6.101562 18.101562 6 17.398438 C 5.898438 17 5.699219 16.699219 5.398438 16.398438 C 5.101562 16.300781 5 16.300781 5 16.199219 C 5 16 5.300781 16 5.398438 16 C 6 16 6.5 16.699219 6.699219 17 C 7.199219 17.800781 7.800781 18 8.101562 18 C 8.5 18 8.800781 17.898438 9 17.800781 C 9.101562 17.101562 9.398438 16.398438 10 16 C 7.699219 15.5 6 14.199219 6 12 C 6 10.898438 6.5 9.800781 7.199219 9 C 7.101562 8.800781 7 8.300781 7 7.601562 C 7 7.199219 7 6.601562 7.300781 6 C 7.300781 6 8.699219 6 10.101562 7.300781 C 10.601562 7.101562 11.300781 7 12 7 C 12.699219 7 13.398438 7.101562 14 7.300781 C 15.300781 6 16.800781 6 16.800781 6 C 17 6.601562 17 7.199219 17 7.601562 C 17 8.398438 16.898438 8.800781 16.800781 9 C 17.5 9.800781 18 10.800781 18 12 C 18 14.199219 16.300781 15.5 14 16 C 14.601562 16.5 15 17.398438 15 18.300781 L 15 20.898438 C 15 21.199219 15.300781 21.5 15.699219 21.398438 C 19.398438 19.898438 22 16.300781 22 12.101562 C 22 6.101562 16.898438 1.398438 10.898438 2.101562 Z M 10.898438 2.101562 "/>
</g>
</svg>

      </a>
      
      
      
      
      
      
      
      <a href="https://scholar.google.com/citations?user=lD3dpIQAAAAJ&amp;hl=en" title="google-scholar" aria-label="google-scholar">
        <svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="25" height="25"><path d="M 25 2 C 12.309534 2 2 12.309534 2 25 C 2 37.690466 12.309534 48 25 48 C 37.690466 48 48 37.690466 48 25 C 48 12.309534 37.690466 2 25 2 z M 25 4 C 36.609534 4 46 13.390466 46 25 C 46 36.609534 36.609534 46 25 46 C 13.390466 46 4 36.609534 4 25 C 4 13.390466 13.390466 4 25 4 z M 21 11 L 11 20 L 17.78125 20 C 17.80125 22.847 19.967531 25.730469 23.769531 25.730469 C 24.129531 25.730469 24.529688 25.690391 24.929688 25.650391 C 24.749688 26.100391 24.560547 26.470078 24.560547 27.080078 C 24.560547 28.230078 25.140391 28.920078 25.650391 29.580078 C 24.020391 29.690078 20.989766 29.879531 18.759766 31.269531 C 16.629766 32.559531 15.980469 34.43 15.980469 35.75 C 15.980469 38.47 18.500469 41 23.730469 41 C 29.930469 41 33.220703 37.510547 33.220703 34.060547 C 33.220703 31.530547 31.779453 30.279922 30.189453 28.919922 L 28.900391 27.890625 C 28.500391 27.570625 27.949219 27.120312 27.949219 26.320312 C 27.949219 25.510313 28.500703 24.989766 28.970703 24.509766 C 30.480703 23.309766 32 21.960234 32 19.240234 C 32 18.197234 31.756203 17.348391 31.408203 16.650391 L 35 13.570312 L 35 17.277344 C 34.405 17.623344 34 18.261 34 19 L 34 25 C 34 26.104 34.896 27 36 27 C 37.104 27 38 26.104 38 25 L 38 19 C 38 18.262 37.595 17.624344 37 17.277344 L 37 12 C 37 11.957 36.980609 11.920906 36.974609 11.878906 L 38 11 L 21 11 z M 24.269531 14.240234 C 27.269531 14.240234 28.820312 18.35 28.820312 21 C 28.820312 21.65 28.739922 22.819922 27.919922 23.669922 C 27.339922 24.259922 26.370938 24.699219 25.460938 24.699219 C 22.370938 24.699219 20.949219 20.620156 20.949219 18.160156 C 20.949219 17.210156 21.14 16.220938 21.75 15.460938 C 22.33 14.710938 23.339531 14.240234 24.269531 14.240234 z M 26.039062 30.609375 C 26.409063 30.609375 26.590859 30.610391 26.880859 30.650391 C 29.620859 32.630391 30.800781 33.620234 30.800781 35.490234 C 30.800781 37.760234 28.97 39.460938 25.5 39.460938 C 21.64 39.460938 19.160156 37.590469 19.160156 34.980469 C 19.160156 32.370469 21.459766 31.499219 22.259766 31.199219 C 23.769766 30.679219 25.719062 30.609375 26.039062 30.609375 z"/></svg>
      </a>
      
      
      
      <a href="https://www.instagram.com/chaphlagical/" title="instagram" aria-label="instagram">
        <svg fill="#000000" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="25" height="25"><path fill="currentColor" d="M 11.46875 5 C 7.917969 5 5 7.914063 5 11.46875 L 5 20.53125 C 5 24.082031 7.914063 27 11.46875 27 L 20.53125 27 C 24.082031 27 27 24.085938 27 20.53125 L 27 11.46875 C 27 7.917969 24.085938 5 20.53125 5 Z M 11.46875 7 L 20.53125 7 C 23.003906 7 25 8.996094 25 11.46875 L 25 20.53125 C 25 23.003906 23.003906 25 20.53125 25 L 11.46875 25 C 8.996094 25 7 23.003906 7 20.53125 L 7 11.46875 C 7 8.996094 8.996094 7 11.46875 7 Z M 21.90625 9.1875 C 21.402344 9.1875 21 9.589844 21 10.09375 C 21 10.597656 21.402344 11 21.90625 11 C 22.410156 11 22.8125 10.597656 22.8125 10.09375 C 22.8125 9.589844 22.410156 9.1875 21.90625 9.1875 Z M 16 10 C 12.699219 10 10 12.699219 10 16 C 10 19.300781 12.699219 22 16 22 C 19.300781 22 22 19.300781 22 16 C 22 12.699219 19.300781 10 16 10 Z M 16 12 C 18.222656 12 20 13.777344 20 16 C 20 18.222656 18.222656 20 16 20 C 13.777344 20 12 18.222656 12 16 C 12 13.777344 13.777344 12 16 12 Z"/></svg>
      </a>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="https://steamcommunity.com/profiles/76561198855701848/" title="steam" aria-label="steam">
        <svg fill="#000000" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="25" height="25"><path fill="currentColor" d="M 25 3 C 13.59 3 4.209375 11.680781 3.109375 22.800781 L 14.300781 28.529297 C 15.430781 27.579297 16.9 27 18.5 27 L 18.550781 27 C 18.940781 26.4 19.389375 25.649141 19.859375 24.869141 C 20.839375 23.259141 21.939531 21.439062 23.019531 20.039062 C 23.259531 15.569063 26.97 12 31.5 12 C 36.19 12 40 15.81 40 20.5 C 40 25.03 36.430937 28.740469 31.960938 28.980469 C 30.560938 30.060469 28.750859 31.160859 27.130859 32.130859 C 26.350859 32.610859 25.6 33.059219 25 33.449219 L 25 33.5 C 25 37.09 22.09 40 18.5 40 C 14.91 40 12 37.09 12 33.5 C 12 33.33 12.009531 33.17 12.019531 33 L 3.2792969 28.519531 C 4.9692969 38.999531 14.05 47 25 47 C 37.15 47 47 37.15 47 25 C 47 12.85 37.15 3 25 3 z M 31.5 14 C 27.92 14 25 16.92 25 20.5 C 25 24.08 27.92 27 31.5 27 C 35.08 27 38 24.08 38 20.5 C 38 16.92 35.08 14 31.5 14 z M 31.5 16 C 33.99 16 36 18.01 36 20.5 C 36 22.99 33.99 25 31.5 25 C 29.01 25 27 22.99 27 20.5 C 27 18.01 29.01 16 31.5 16 z M 18.5 29 C 17.71 29 16.960313 29.200312 16.320312 29.570312 L 19.640625 31.269531 C 20.870625 31.899531 21.350469 33.410625 20.730469 34.640625 C 20.280469 35.500625 19.41 36 18.5 36 C 18.11 36 17.729375 35.910469 17.359375 35.730469 L 14.029297 34.019531 C 14.289297 36.259531 16.19 38 18.5 38 C 20.99 38 23 35.99 23 33.5 C 23 31.01 20.99 29 18.5 29 z"/></svg>
      </a>
      
      
      
      
      
      
      
      <a href="https://twitter.com/chen_418199378" title="twitter" aria-label="twitter">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewBox="0 0 32 32" version="1.1">
<g id="surface676">
<path fill="currentColor" d="M 28 8.558594 C 27.117188 8.949219 26.167969 9.214844 25.171875 9.332031 C 26.1875 8.722656 26.96875 7.757812 27.335938 6.609375 C 26.386719 7.171875 25.332031 7.582031 24.210938 7.804688 C 23.3125 6.847656 22.03125 6.246094 20.617188 6.246094 C 17.898438 6.246094 15.691406 8.453125 15.691406 11.171875 C 15.691406 11.558594 15.734375 11.933594 15.820312 12.292969 C 11.726562 12.089844 8.097656 10.128906 5.671875 7.148438 C 5.246094 7.875 5.003906 8.722656 5.003906 9.625 C 5.003906 11.332031 5.871094 12.839844 7.195312 13.722656 C 6.386719 13.695312 5.628906 13.476562 4.964844 13.105469 C 4.964844 13.128906 4.964844 13.148438 4.964844 13.167969 C 4.964844 15.554688 6.660156 17.546875 8.914062 17.996094 C 8.5 18.109375 8.066406 18.171875 7.617188 18.171875 C 7.300781 18.171875 6.988281 18.140625 6.691406 18.082031 C 7.316406 20.039062 9.136719 21.460938 11.289062 21.503906 C 9.605469 22.824219 7.480469 23.609375 5.175781 23.609375 C 4.777344 23.609375 4.386719 23.585938 4 23.539062 C 6.179688 24.9375 8.765625 25.753906 11.546875 25.753906 C 20.605469 25.753906 25.558594 18.25 25.558594 11.742188 C 25.558594 11.53125 25.550781 11.316406 25.542969 11.105469 C 26.503906 10.410156 27.339844 9.542969 28 8.558594 Z M 28 8.558594 "/>
</g>
</svg>

      </a>
      
      
      
      
      
      
      
      
      
      <a href="https://www.youtube.com/channel/UC6izbcXMuip_qYlw50QZvmA" title="youtube" aria-label="youtube">
        <svg xmlns="http://www.w3.org/2000/svg" fill="#000000" viewBox="0 0 30 30" width="25" height="25">    <path fill="currentColor" d="M 7.4140625 3 L 9.1894531 9.4121094 L 9.1894531 12.488281 L 10.726562 12.488281 L 10.726562 9.4121094 L 12.525391 3 L 10.976562 3 L 10.332031 5.9179688 C 10.151031 6.7699687 10.035422 7.3753281 9.9824219 7.7363281 L 9.9355469 7.7363281 C 9.8605469 7.2313281 9.7439375 6.62125 9.5859375 5.90625 L 8.9648438 3 L 7.4140625 3 z M 14.318359 5.4199219 C 13.797359 5.4199219 13.376641 5.5224687 13.056641 5.7304688 C 12.735641 5.9374688 12.500609 6.2687031 12.349609 6.7207031 C 12.199609 7.1737031 12.123047 7.7715781 12.123047 8.5175781 L 12.123047 9.5234375 C 12.123047 10.261437 12.190266 10.853828 12.322266 11.298828 C 12.454266 11.743828 12.675281 12.072203 12.988281 12.283203 C 13.301281 12.494203 13.733203 12.600562 14.283203 12.601562 C 14.818203 12.601562 15.244641 12.497063 15.556641 12.289062 C 15.868641 12.081063 16.095375 11.755641 16.234375 11.306641 C 16.373375 10.857641 16.443359 10.264391 16.443359 9.5253906 L 16.443359 8.5175781 C 16.443359 7.7715781 16.371516 7.1755625 16.228516 6.7265625 C 16.085516 6.2785625 15.860781 5.9473281 15.550781 5.7363281 C 15.241781 5.5253281 14.830359 5.4199219 14.318359 5.4199219 z M 17.251953 5.5566406 L 17.251953 10.734375 C 17.251953 11.375375 17.362078 11.847437 17.580078 12.148438 C 17.799078 12.449437 18.137656 12.599609 18.597656 12.599609 C 19.260656 12.599609 19.758844 12.279672 20.089844 11.638672 L 20.123047 11.638672 L 20.259766 12.486328 L 21.480469 12.486328 L 21.480469 5.5566406 L 19.921875 5.5566406 L 19.921875 11.060547 C 19.861875 11.189547 19.769531 11.295906 19.644531 11.378906 C 19.519531 11.462906 19.389906 11.503906 19.253906 11.503906 C 19.094906 11.503906 18.982063 11.436687 18.914062 11.304688 C 18.846063 11.172688 18.8125 10.954531 18.8125 10.644531 L 18.8125 5.5566406 L 17.251953 5.5566406 z M 14.283203 6.4941406 C 14.501203 6.4941406 14.656187 6.6098437 14.742188 6.8398438 C 14.829188 7.0688437 14.871094 7.4316875 14.871094 7.9296875 L 14.871094 10.089844 C 14.871094 10.602844 14.828188 10.971266 14.742188 11.197266 C 14.656188 11.423266 14.502156 11.536109 14.285156 11.537109 C 14.067156 11.537109 13.915031 11.423266 13.832031 11.197266 C 13.748031 10.971266 13.707031 10.601844 13.707031 10.089844 L 13.707031 7.9296875 C 13.707031 7.4326875 13.751891 7.0698438 13.837891 6.8398438 C 13.923891 6.6108438 14.072203 6.4941406 14.283203 6.4941406 z M 6.5 13.900391 C 5.119 13.900391 4 15.019391 4 16.400391 L 4 24.400391 C 4 25.781391 5.119 26.900391 6.5 26.900391 L 23.5 26.900391 C 24.881 26.900391 26 25.781391 26 24.400391 L 26 16.400391 C 26 15.019391 24.881 13.900391 23.5 13.900391 L 6.5 13.900391 z M 15.058594 16.199219 L 16.328125 16.199219 L 16.328125 19.283203 L 16.337891 19.283203 C 16.451891 19.060203 16.614219 18.881141 16.824219 18.744141 C 17.034219 18.607141 17.261906 18.539062 17.503906 18.539062 C 17.815906 18.539062 18.059328 18.622109 18.236328 18.787109 C 18.413328 18.952109 18.544047 19.220844 18.623047 19.589844 C 18.702047 19.959844 18.742188 20.471953 18.742188 21.126953 L 18.742188 22.050781 C 18.742188 22.922781 18.637734 23.563609 18.427734 23.974609 C 18.217734 24.385609 17.888359 24.591797 17.443359 24.591797 C 17.195359 24.591797 16.969625 24.533922 16.765625 24.419922 C 16.561625 24.305922 16.410594 24.149172 16.308594 23.951172 L 16.279297 23.951172 L 16.146484 24.503906 L 15.058594 24.503906 L 15.058594 16.199219 z M 7.1835938 16.496094 L 11.087891 16.496094 L 11.087891 17.556641 L 9.7792969 17.556641 L 9.7792969 24.503906 L 8.4902344 24.503906 L 8.4902344 17.556641 L 7.1835938 17.556641 L 7.1835938 16.496094 z M 21.117188 18.542969 C 21.568188 18.542969 21.916203 18.624062 22.158203 18.789062 C 22.399203 18.955063 22.570922 19.2135 22.669922 19.5625 C 22.767922 19.9125 22.816406 20.396672 22.816406 21.013672 L 22.816406 22.017578 L 20.613281 22.017578 L 20.613281 22.314453 C 20.613281 22.690453 20.623484 22.971203 20.646484 23.158203 C 20.669484 23.345203 20.715156 23.483359 20.785156 23.568359 C 20.855156 23.654359 20.963375 23.697266 21.109375 23.697266 C 21.306375 23.697266 21.441625 23.62075 21.515625 23.46875 C 21.588625 23.31675 21.628766 23.061078 21.634766 22.705078 L 22.769531 22.771484 C 22.775531 22.821484 22.779297 22.893422 22.779297 22.982422 C 22.779297 23.523422 22.631937 23.927359 22.335938 24.193359 C 22.039938 24.461359 21.621078 24.595703 21.080078 24.595703 C 20.431078 24.595703 19.976844 24.391375 19.714844 23.984375 C 19.452844 23.577375 19.324219 22.94675 19.324219 22.09375 L 19.324219 21.072266 C 19.324219 20.194266 19.460469 19.553438 19.730469 19.148438 C 20.000469 18.743437 20.462188 18.542969 21.117188 18.542969 z M 12.949219 18.650391 L 14.267578 18.650391 L 14.267578 24.501953 L 14.263672 24.501953 L 14.263672 24.503906 L 13.232422 24.503906 L 13.119141 23.787109 L 13.089844 23.787109 C 12.809844 24.329109 12.390078 24.599609 11.830078 24.599609 C 11.441078 24.599609 11.155703 24.47375 10.970703 24.21875 C 10.785703 23.96475 10.693359 23.565391 10.693359 23.025391 L 10.693359 18.652344 L 12.013672 18.652344 L 12.013672 22.949219 C 12.013672 23.209219 12.042609 23.397813 12.099609 23.507812 C 12.157609 23.619812 12.251719 23.673828 12.386719 23.673828 C 12.500719 23.673828 12.609844 23.639359 12.714844 23.568359 C 12.820844 23.498359 12.897219 23.408781 12.949219 23.300781 L 12.949219 18.650391 z M 21.089844 19.431641 C 20.949844 19.431641 20.844344 19.472687 20.777344 19.554688 C 20.710344 19.637687 20.665531 19.772938 20.644531 19.960938 C 20.621531 20.147938 20.611328 20.433453 20.611328 20.814453 L 20.611328 21.234375 L 21.574219 21.234375 L 21.574219 20.814453 C 21.574219 20.438453 21.562109 20.154937 21.537109 19.960938 C 21.512109 19.765937 21.467391 19.630781 21.400391 19.550781 C 21.333391 19.471781 21.230844 19.431641 21.089844 19.431641 z M 16.910156 19.474609 C 16.783156 19.474609 16.664641 19.524953 16.556641 19.626953 C 16.448641 19.728953 16.372125 19.859578 16.328125 20.017578 L 16.328125 23.339844 C 16.386125 23.441844 16.460734 23.517359 16.552734 23.568359 C 16.644734 23.618359 16.744516 23.646484 16.853516 23.646484 C 16.993516 23.646484 17.1045 23.596141 17.1875 23.494141 C 17.2705 23.392141 17.329281 23.220516 17.363281 22.978516 C 17.398281 22.737516 17.416016 22.402562 17.416016 21.976562 L 17.416016 21.222656 C 17.416016 20.764656 17.402047 20.411109 17.373047 20.162109 C 17.345047 19.914109 17.292703 19.736812 17.220703 19.632812 C 17.147703 19.528813 17.045156 19.474609 16.910156 19.474609 z"/></svg>

      </a>
      
      
      
      <a href="https://www.zhihu.com/people/chaf-86" title="zhihu" aria-label="zhihu">
        <svg fill="#000000" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="25" height="25"><path fill="currentColor" d="M 5.921875 2.9511719 C 5.5336094 2.9815469 5.1832344 3.2390625 5.0527344 3.6328125 L 3.6835938 7.7363281 C 3.5085938 8.2593281 3.7924062 8.825 4.3164062 9 C 4.8404063 9.175 5.4050781 8.8911875 5.5800781 8.3671875 L 6.0351562 7 L 6.9941406 7 L 6.9941406 10.222656 C 6.9941406 10.845846 6.9644144 11.431442 6.9199219 12 L 5 12 A 1.0001 1.0001 0 1 0 5 14 L 6.6367188 14 C 6.1575971 16.260332 5.1601574 17.989071 3.4179688 19.189453 C 2.9979688 19.479453 2.8798125 20.049188 3.1328125 20.492188 C 3.4258125 21.004188 4.0960781 21.153359 4.5800781 20.818359 C 6.0994455 19.769009 7.1700075 18.397613 7.8808594 16.720703 A 1.0001 1.0001 0 0 0 8.0449219 17.601562 L 9.5117188 19.59375 A 1.0002375 1.0002375 0 1 0 11.123047 18.408203 L 9.65625 16.416016 A 1.0001 1.0001 0 0 0 8.7929688 15.998047 A 1.0001 1.0001 0 0 0 7.9921875 16.472656 C 8.2917972 15.713486 8.5082238 14.883111 8.6699219 14 L 10 14 A 1.0001 1.0001 0 1 0 10 12 L 8.9316406 12 C 8.9726972 11.4285 8.9941406 10.836947 8.9941406 10.222656 L 8.9941406 7 L 10 7 A 1.0001 1.0001 0 1 0 10 5 L 6.7011719 5 L 6.9472656 4.2636719 C 7.1222656 3.7406719 6.8404063 3.175 6.3164062 3 C 6.1856563 2.95625 6.0512969 2.9410469 5.921875 2.9511719 z M 14 5 A 1.0001 1.0001 0 0 0 13 6 L 13 17 A 1.0001 1.0001 0 0 0 14 18 L 15 18 L 15 20 A 1.0001 1.0001 0 0 0 16.707031 20.707031 L 19.414062 18 L 21 18 A 1.0001 1.0001 0 0 0 22 17 L 22 6 A 1.0001 1.0001 0 0 0 21 5 L 14 5 z M 15 7 L 20 7 L 20 16 L 19 16 A 1.0001 1.0001 0 0 0 18.292969 16.292969 L 17 17.585938 L 17 17 A 1.0001 1.0001 0 0 0 16 16 L 15 16 L 15 7 z"/></svg>
      </a>
      
      
    </div>
  </div>
</section>
<hr class="hr-slash whoami-hr" />


    <section class="related">
    
    
  </section>
    <div class="grow"></div>
<nav class="pagination-single">
  
    
      <a href="https://chaphlagical.github.io/zh/posts/rendering/sampling/" class="pagination-single__left">
        <div class="pagination-single__icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M19 11H7.83l4.88-4.88c.39-.39.39-1.03 0-1.42-.39-.39-1.02-.39-1.41 0l-6.59 6.59c-.39.39-.39 1.02 0 1.41l6.59 6.59c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L7.83 13H19c.55 0 1-.45 1-1s-.45-1-1-1z"/></svg>
        </div>
        <div class="pagination-single__left-title">采样与低差异序列</div>      
      </a>
    
    <div class="grow"></div>
    
  
</nav>
    
  
    <div id="disqus_thread"></div>
<script>
  let disqus_config = function () {
    
    
    
  };
  (function () {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
      return;
    }
    var d = document, s = d.createElement('script'); s.async = true;
    s.src = 'https://' + 'chaphlagical-github-io' + '.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  }) ();
</script>
  

    <div class="modal micromodal-slide" id="modal" aria-hidden="true">
  <div class="modal__overlay" tabindex="-1" data-micromodal-close>
    <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="modal-title">
      
      <div class="modal__content" id="modal-content">
        <div id="mySwipe" class="swipe">
          <div class="swipe-wrap">
          </div>
        </div>
      </div>

      <span class="modal__items">
        
        <span class="modal__header">
          <div class="modal__paging" title="Page Info" aria-label="Current Page">
          </div>
          <div class="modal__icon modal__toolbar modal__toolbar--close" title="Close" aria-label="Close Button" data-micromodal-close>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" width="25" height="25"><path fill="currentColor" d="M 21.734375 19.640625 L 19.636719 21.734375 C 19.253906 22.121094 18.628906 22.121094 18.242188 21.734375 L 13 16.496094 L 7.761719 21.734375 C 7.375 22.121094 6.746094 22.121094 6.363281 21.734375 L 4.265625 19.640625 C 3.878906 19.253906 3.878906 18.628906 4.265625 18.242188 L 9.503906 13 L 4.265625 7.761719 C 3.882813 7.371094 3.882813 6.742188 4.265625 6.363281 L 6.363281 4.265625 C 6.746094 3.878906 7.375 3.878906 7.761719 4.265625 L 13 9.507813 L 18.242188 4.265625 C 18.628906 3.878906 19.257813 3.878906 19.636719 4.265625 L 21.734375 6.359375 C 22.121094 6.746094 22.121094 7.375 21.738281 7.761719 L 16.496094 13 L 21.734375 18.242188 C 22.121094 18.628906 22.121094 19.253906 21.734375 19.640625 Z"/></svg>
          </div>
          <div class="modal__icon modal__toolbar modal__toolbar--full" title="Full Screen" aria-label="Full Screen Button">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="25" height="25"><path fill="currentColor" d="M 5 3 C 3.9069372 3 3 3.9069372 3 5 L 3 8 A 1.0001 1.0001 0 1 0 5 8 L 5 5 L 8 5 A 1.0001 1.0001 0 1 0 8 3 L 5 3 z M 16 3 A 1.0001 1.0001 0 1 0 16 5 L 19 5 L 19 8 A 1.0001 1.0001 0 1 0 21 8 L 21 5 C 21 3.9069372 20.093063 3 19 3 L 16 3 z M 3.984375 14.986328 A 1.0001 1.0001 0 0 0 3 16 L 3 19 C 3 20.093063 3.9069372 21 5 21 L 8 21 A 1.0001 1.0001 0 1 0 8 19 L 5 19 L 5 16 A 1.0001 1.0001 0 0 0 3.984375 14.986328 z M 19.984375 14.986328 A 1.0001 1.0001 0 0 0 19 16 L 19 19 L 16 19 A 1.0001 1.0001 0 1 0 16 21 L 19 21 C 20.093063 21 21 20.093063 21 19 L 21 16 A 1.0001 1.0001 0 0 0 19.984375 14.986328 z"/></svg>
          </div>
          <div class="modal__icon modal__toolbar modal__toolbar--normal" title="Normal Screen" aria-label="Normal Screen Button">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="25" height="25"><path fill="currentColor" d="M 16.96875 4.972656 C 15.867188 4.988281 14.984375 5.894531 15 7 L 15 15 L 7 15 C 6.277344 14.988281 5.609375 15.367188 5.246094 15.992188 C 4.878906 16.613281 4.878906 17.386719 5.246094 18.007813 C 5.609375 18.632813 6.277344 19.011719 7 19 L 19 19 L 19 7 C 19.007813 6.460938 18.796875 5.941406 18.414063 5.558594 C 18.03125 5.175781 17.511719 4.964844 16.96875 4.972656 Z M 32.96875 4.972656 C 31.921875 4.988281 31.0625 5.8125 31.003906 6.859375 C 31 6.90625 31 6.953125 31 7 L 31 19 L 43 19 C 43.066406 19 43.132813 19 43.199219 18.992188 C 44.269531 18.894531 45.070313 17.972656 45.015625 16.902344 C 44.964844 15.828125 44.074219 14.988281 43 15 L 35 15 L 35 7 C 35.007813 6.460938 34.796875 5.941406 34.414063 5.558594 C 34.03125 5.175781 33.511719 4.964844 32.96875 4.972656 Z M 7 31 C 6.277344 30.988281 5.609375 31.367188 5.246094 31.992188 C 4.878906 32.613281 4.878906 33.386719 5.246094 34.007813 C 5.609375 34.632813 6.277344 35.011719 7 35 L 15 35 L 15 43 C 14.988281 43.722656 15.367188 44.390625 15.992188 44.753906 C 16.613281 45.121094 17.386719 45.121094 18.007813 44.753906 C 18.632813 44.390625 19.011719 43.722656 19 43 L 19 31 Z M 31 31 L 31 43 C 30.988281 43.722656 31.367188 44.390625 31.992188 44.753906 C 32.613281 45.121094 33.386719 45.121094 34.007813 44.753906 C 34.632813 44.390625 35.011719 43.722656 35 43 L 35 35 L 43 35 C 43.722656 35.011719 44.390625 34.632813 44.753906 34.007813 C 45.121094 33.386719 45.121094 32.613281 44.753906 31.992188 C 44.390625 31.367188 43.722656 30.988281 43 31 Z"/></svg>
          </div>
        </span>
        
        <div class="modal__icon modal__arrow modal__arrow--left" title="Arrow Left" aria-label="Arrow Left Button">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" width="28" height="28"><path fill="currentColor" d="M 23.28125 11 L 10 10 L 10 6.851563 C 10 6.523438 9.839844 6.277344 9.519531 6.03125 C 9.199219 5.949219 8.878906 5.949219 8.640625 6.113281 C 5.359375 8.410156 2.238281 12.257813 2.160156 12.421875 C 2.082031 12.578125 2.007813 12.8125 2.003906 12.976563 C 2.003906 12.980469 2 12.988281 2 12.992188 C 2 13.15625 2.078125 13.402344 2.160156 13.484375 C 2.238281 13.648438 5.28125 17.507813 8.640625 19.804688 C 8.960938 19.96875 9.28125 20.050781 9.519531 19.886719 C 9.839844 19.722656 10 19.476563 10 19.148438 L 10 16 L 23.28125 15 C 23.679688 14.679688 24 13.875 24 12.992188 C 24 12.195313 23.761719 11.320313 23.28125 11 Z"/></svg>
        </div>
        
        <div class="modal__icon modal__arrow modal__arrow--right" title="Arrow Right" aria-label="Arrow Right Button">

          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" width="28" height="28"><path fill="currentColor" d="M 2.71875 11.023438 L 16 10.023438 L 16 6.875 C 16 6.546875 16.160156 6.300781 16.480469 6.054688 C 16.800781 5.972656 17.121094 5.972656 17.359375 6.136719 C 20.640625 8.433594 23.761719 12.28125 23.839844 12.445313 C 23.917969 12.601563 23.992188 12.835938 23.996094 13 C 23.996094 13.003906 24 13.011719 24 13.015625 C 24 13.179688 23.921875 13.425781 23.839844 13.507813 C 23.761719 13.671875 20.71875 17.53125 17.359375 19.828125 C 17.039063 19.992188 16.71875 20.074219 16.480469 19.910156 C 16.160156 19.746094 16 19.5 16 19.171875 L 16 16.023438 L 2.71875 15.023438 C 2.320313 14.703125 2 13.898438 2 13.015625 C 2 12.21875 2.238281 11.34375 2.71875 11.023438 Z"/></svg>
        </div>

        <div class="modal__caption">
          <div class="modal__caption--text">
          </div>
        </div>

      </span>
    </div>
  </div>
</div>


<script defer src="/js/swipe.min.d2e020e2d405fafaa45c0a10d2af949627bf554a9366c31a905af38f8cc30c30.js"></script>

<script defer src="/js/micromodal.min.de01b44b2f383056bbcaf6ee921fd385d79108ec1129afd0eb2f3f5a07e11f45.js"></script>

<script defer src="/js/helper/fadeinout.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function () {
  
   
  var docElem = document.documentElement;

   
  function openFullscreen() {
    if (docElem.requestFullscreen) {
      docElem.requestFullscreen();
    } else if (docElem.mozRequestFullScreen) {  
      docElem.mozRequestFullScreen();
    } else if (docElem.webkitRequestFullscreen) {  
      docElem.webkitRequestFullscreen();
    } else if (docElem.msRequestFullscreen) {  
      docElem.msRequestFullscreen();
    }
  }

   
  function closeFullscreen() {
    if (document.fullscreenElement ||
      document.webkitFullscreenElement ||
      document.mozFullScreenElement) {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {  
        document.mozCancelFullScreen();
      } else if (document.webkitExitFullscreen) {  
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {  
        document.msExitFullscreen();
      }
    }
  }

  var modal = document.getElementById('modal');
  var galleryContainerElem = document.querySelector('.gallery__container');
  var swipeWrapElem = document.querySelector('.swipe-wrap');
  var mySwipeElem = document.getElementById('mySwipe');
  var arrowLeftElem = document.querySelector('.modal__arrow--left');
  var arrowRightElem = document.querySelector('.modal__arrow--right');
  var closeElem = document.querySelector('.modal__toolbar--close');
  var fullElem = document.querySelector('.modal__toolbar--full');
  var normalElem = document.querySelector('.modal__toolbar--normal');
  var captionElem = document.querySelector('.modal__caption');
  var pagingElem = document.querySelector('.modal__paging');
  var itemsElem = document.querySelector('.modal__items');
  var imgTotalNum = null;
  var myFadeTimeout = null;
  var mySwipe = null;
  var keydownFunction = function (e) {
    if (e.key === 'ArrowRight') {
      if (modal && modal.classList.contains('is-open')) {
        mySwipe.next();
      }
    } else if (e.key === 'ArrowLeft') {
      if (modal && modal.classList.contains('is-open')) {
        mySwipe.prev();
      }
    }
  }

  if (galleryContainerElem) {
    imgTotalNum = galleryContainerElem.querySelectorAll('img').length;
  } else {
    galleryContainerElem = document.querySelector('.single__contents');
    imgTotalNum = galleryContainerElem.querySelectorAll('img').length;
  }

  MicroModal.init({
    onClose: function () {
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
        closeFullscreen();
      }
      window.removeEventListener('keydown', keydownFunction);
    },
    disableScroll: true,
    disableFocus: true,
    awaitOpenAnimation: false,
    awaitCloseAnimation: false,
    debugMode: false,
  });

  var imageLoad = function(src) {
    return new Promise(function(resolve, reject) {
      var newImg = new Image;
      newImg.onload = function() {
        resolve(newImg);
      }
      newImg.onerror = reject;
      newImg.src = src;
    });
  }

  galleryContainerElem.querySelectorAll('img').forEach(function (elem, idx) {
    elem.style.cursor = 'pointer';

    var clonedElem = elem.cloneNode(true);
    clonedElem.style.maxHeight = '100%';
    clonedElem.style.maxWidth = '100%';
    clonedElem.onclick = function (e) {
      e.stopPropagation();
    }

    var wrapper = document.createElement('div');
    wrapper.style.width = '100%';
    wrapper.style.height = '100vh';
    wrapper.setAttribute('data-micromodal-close', '');
    wrapper.onclick = function () {
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
      }
    }
    wrapper.onmouseenter = function () {
      clearTimeout(myFadeTimeout);
      fadeIn(itemsElem, 200);
    };
    wrapper.onmouseleave = function () {
      myFadeTimeout = setTimeout(function () {
        fadeOut(itemsElem, 200);
      }, 2500);
    }
    wrapper.ontouchstart = function() {
      fadeIn(itemsElem, 200);
    }
    wrapper.append(clonedElem);
    swipeWrapElem.append(wrapper);

    elem.addEventListener('click', async function (e) {
      MicroModal.show('modal');
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
      }

      var imgSrc = e.target.getAttribute('data-src') || e.target.getAttribute('src');
      var img = await imageLoad(imgSrc);
      clonedElem.style.width = img.width + 'px';
      clonedElem.style.height = img.height + 'px';
      
      
      mySwipe = new Swipe(mySwipeElem, {
        startSlide: idx,
        draggable: true,
        autoRestart: false,
        continuous: false,
        disableScroll: true,
        stopPropagation: true,
        callback: async function (index, element) {
          
          var imgElem = element.querySelector('img');
          var imgSrc = imgElem.getAttribute('data-src') || imgElem.getAttribute('src');
          var img = await imageLoad(imgSrc);
          imgElem.style.width = img.width + 'px';
          imgElem.style.height = img.height + 'px';

          
          if (captionElem && imgElem) {
            var caption = null;
            if (imgElem.getAttribute('data-caption')) {
              caption = imgElem.getAttribute('data-caption');
            } else if (imgElem.getAttribute('title')) {
              caption = imgElem.getAttribute('title');
            } else if (imgElem.getAttribute('alt')) {
              caption = imgElem.getAttribute('alt');
            } else {
              caption = imgElem.getAttribute('src');
            }

            captionElem.querySelector('.modal__caption--text').innerText = caption;
            pagingElem.innerText = (index + 1) + ' / ' + imgTotalNum;

            clearTimeout(myFadeTimeout);
            fadeIn(itemsElem, 200);
          }
        },
      });

      fadeIn(itemsElem);

      
      if (captionElem) {
        var caption = null;
        if (e.target.getAttribute('data-caption')) {
          caption = e.target.getAttribute('data-caption');
        } else if (e.target.getAttribute('title')) {
          caption = e.target.getAttribute('title');
        } else if (e.target.getAttribute('alt')) {
          caption = e.target.getAttribute('alt');
        } else {
          caption = e.target.getAttribute('src');
        }

        captionElem.querySelector('.modal__caption--text').innerText = caption;
        pagingElem.innerText = (idx + 1) + ' / ' + imgTotalNum;
      }

      if (normalElem && fullElem) {
        normalElem.style.zIndex = -1;
        normalElem.style.opacity = 0;
        fullElem.style.zIndex = 25;
        fullElem.style.opacity = 1;
      }
    });

    window.addEventListener('keydown', keydownFunction);
  });

  arrowLeftElem ?
    arrowLeftElem.addEventListener('click', function (e) {
      if (mySwipe) {
        mySwipe.prev();
      }
    }) : null;
  arrowRightElem ?
    arrowRightElem.addEventListener('click', function (e) {
      if (mySwipe) {
        mySwipe.next();
      }
    }) : null;

  closeElem ?
    closeElem.addEventListener('click', function () {
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
      }
      closeFullscreen();
      MicroModal.close('modal');
    }) : null;

  fullElem ?
    fullElem.addEventListener('click', function (e) {
      openFullscreen();
      if (normalElem) {
        normalElem.style.zIndex = 25;
        normalElem.style.opacity = 1;
        fullElem.style.zIndex = -1;
        fullElem.style.opacity = 0;
      }
    }) : null;

  normalElem ?
    normalElem.addEventListener('click', function (e) {
      closeFullscreen();
      if (fullElem) {
        fullElem.style.zIndex = 25;
        fullElem.style.opacity = 1;
        normalElem.style.zIndex = -1;
        normalElem.style.opacity = 0;
      }
    }) : null;
  
});
</script>

    <div class="hide">
      

<div class="search">
  <span class="icon">
    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M15.5 14h-.79l-.28-.27c1.2-1.4 1.82-3.31 1.48-5.34-.47-2.78-2.79-5-5.59-5.34-4.23-.52-7.79 3.04-7.27 7.27.34 2.8 2.56 5.12 5.34 5.59 2.03.34 3.94-.28 5.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
  </span>
  <input id="search" aria-label="Site Search" class="input" type="text" placeholder="搜索" autocomplete="off">
  <div id="search-results" class="dropdown">
    <div id="search-menu" class="dropdown-menu" role="menu">
    </div>
  </div>
</div>


    </div>
  </div>
</main>


<script>
  
  
  

  var enableToc = JSON.parse("true");
  var toc = JSON.parse("null");
  var tocPosition = JSON.parse("\"outer\"");
  
  var singleMainElem = document.querySelector('.single__main');
  var singleSideElem = document.querySelector('.single__side');

  enquire.register("screen and (max-width: 769px)", {
    match: function () {
      if ((enableToc || toc) && tocPosition !== "outer") {
        if (singleMainElem && singleSideElem) {
          singleMainElem.classList.remove('main-main');
          singleMainElem.classList.add('main');
          singleSideElem.classList.remove('main-side');
          singleSideElem.classList.add('hide');
        }
      } else if (tocPosition === "outer") {
        if (singleMainElem && !singleMainElem.classList.contains('main-main')) {
          singleMainElem.classList.remove('main-main');
          singleMainElem.classList.add('main');
        }
        if (singleSideElem && !singleSideElem.classList.contains('hide')) {
          singleSideElem.classList.add('hide');
        }
      }
    },
    unmatch: function () {
      if ((enableToc || toc) && tocPosition !== "outer") {
        singleMainElem.classList.remove('main');
        singleMainElem.classList.add('main-main');
        singleSideElem.classList.remove('hide');
        singleSideElem.classList.add('main-side');
      } else if (tocPosition === "outer") {
        if (singleMainElem && !singleMainElem.classList.contains('main-main')) {
          singleMainElem.classList.remove('main-main');
          singleMainElem.classList.add('main');
        }
        if (singleSideElem && !singleSideElem.classList.contains('hide')) {
          singleSideElem.classList.add('hide');
        }
      }

      var navCollapseBtn = document.querySelector('.navbar__burger');
      var navCollapse = document.getElementsByClassName('navbarm__collapse')[0];
      if (navCollapse) {
        navCollapse.setAttribute('data-open', false);
        navCollapse.style.maxHeight = 0;
        navCollapseBtn.classList.remove('is-active');
      }
      document.getElementsByClassName('navbar__menu')[0].classList.remove('is-active');
      document.getElementsByClassName('mobile-search')[0].classList.add('hide');
    },
    setup: function () { },
    deferSetup: true,
    destroy: function () { },
  });
</script>





<script defer src="/js/helper/getParents.min.js"></script>

<script defer src="/js/helper/closest.min.js"></script>

<script defer src="/js/helper/prev.min.js"></script>

<script defer src="/js/helper/prop.min.js"></script>

<script defer src="/js/helper/fadeinout.min.js"></script>

<script defer src="/js/helper/throttle.min.js"></script>










































<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true,
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      ignoreHtmlClass: 'tex2jax_ignore',
      processHtmlClass: 'tex2jax_process'
    }
  };
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script"></script>










<script>
  'use strict';

  window.onload = function() {
    var navbar = document.querySelector('.navbar');
    var singleContentsElem = document.querySelector('.single__contents');

    
    
    
    var enableBusuanzi = JSON.parse("false");
    var busuanziPagePV = JSON.parse("true");
    
    if (enableBusuanzi && busuanziPagePV) {
      var pagePvElem = document.querySelector('#busuanzi_value_page_pv');
      pagePvElem.textContent = pagePvElem.textContent.replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
    }    
    



    
    
    
    
    
    
    var enableToc = JSON.parse("true");
    var toc = JSON.parse("null");
    var hideToc = JSON.parse("false");
    var tocFlexbox = document.querySelector('.toc__flexbox');
    var tocFlexboxOuter = document.querySelector('.toc__flexbox--outer');
    var tocFolding = JSON.parse("true");
    
    if ((enableToc || toc) && document.querySelector('.toc')) {
      var tableOfContentsElem = document.querySelector('.toc').querySelector('#TableOfContents');

      tableOfContentsElem.onmouseenter = function() {
        if (navbar.classList.contains('scrolling')) {
          navbar.classList.remove('scrolling');
        }
      }

      tableOfContentsElem.onmouseleave = function() {
        if (!navbar.classList.contains('scrolling')) {
          navbar.classList.add('scrolling');
        }
      }

      if (false === tocFolding) {

      } else {
        tableOfContentsElem.querySelectorAll('ul') ?
          tableOfContentsElem.querySelectorAll('ul').forEach(function (rootUl) {
            rootUl.querySelectorAll('li').forEach(function (liElem) {
              liElem.querySelectorAll('ul').forEach(function (ulElem) {
                ulElem.style.display = 'none';
              });
            });
          }) : null;
      }

      if (tableOfContentsElem) {
        if (tableOfContentsElem.querySelectorAll('a').length > 0) {
          tableOfContentsElem.querySelectorAll('a').forEach(function (elem) {
            elem.addEventListener('click', function () {
              var id = elem.getAttribute('id');

              if (!navbar.classList.contains('scrolling')) {
                navbar.classList.remove('navbar--show');
                navbar.classList.remove('navbar--hide');
                navbar.classList.add('navbar--hide');
              }
              
              document.querySelector('.toc').querySelectorAll('a').forEach(function (elem) {
                elem.classList.remove('active');
              });
              elem.classList.add('active');

              var curElem = tableOfContentsElem.querySelector('[href="#' + id + '"]');
              if (curElem && curElem.nextElementSibling) {
                curElem.nextElementSibling.style.display = 'block';
              }
              if (curElem) {
                getParents(curElem, 'ul') ?
                  getParents(curElem, 'ul').forEach(function (elem) {
                    elem.style.display = 'block';
                  }) : null;
              }
            });
          });
        } else {
          if (tocFlexbox) {
            tocFlexbox.setAttribute('data-position', '');
            if (!tocFlexbox.classList.contains('hide')) {
              tocFlexbox.classList.add('hide');
            }
          }
          if (tocFlexboxOuter) {
            tocFlexboxOuter.setAttribute('data-position', '');
            if (!tocFlexboxOuter.classList.contains('hide')) {
              tocFlexboxOuter.classList.add('hide');
            }
          }
        }
      }

      
      var toggleTocElem = document.getElementById("toggle-toc");
      var visibleTocElem = document.getElementById('visible-toc');
      var tocElem = document.querySelector('.toc');
      var mainElem = document.querySelector('main');
      var sideElem = document.querySelector('side');
      var tocFlexboxElem = document.querySelector('.toc__flexbox');

      toggleTocElem ? 
      toggleTocElem.addEventListener('change', function(e) {
        if (e.target.checked) {
          if (tocElem) {
            fadeIn(tocElem, 200);
          }
          if (tocFlexboxElem) {
            tocFlexboxElem.setAttribute('data-position', 'fixed');
          }

          if (mainElem) {
            mainElem.classList.remove('main-main');
            mainElem.classList.remove('main');
            mainElem.classList.add('main-main');
          }
          if (sideElem) {
            sideElem.classList.remove('main-side');
          }
        } else {
          if (tocElem) {
            fadeOut(tocElem, 200);
          }
          if (tocFlexboxElem) {
            tocFlexboxElem.setAttribute('data-position', 'absolute');
          }

          if (mainElem) {
            mainElem.classList.remove('main-main');
            mainElem.classList.remove('main');
            mainElem.classList.add('main');
          }
          if (sideElem) {
            sideElem.classList.remove('main-side');
          }
        }
      }) : null;

      visibleTocElem ?
      visibleTocElem.addEventListener('change', function(e) {
        if (e.target.checked) {
          if (tocElem) {
            fadeIn(tocElem, 200);
          }
        } else {
          if (tocElem) {
            fadeOut(tocElem, 200);
          }
        }
      }) : null;
    }
    
    
    
    
    
    var topOffset = 120;
    var botOffset = 70;
    var handleWindowResize = function () {
      if (tocElem) {
        tocElem.style.maxHeight = (window.innerHeight - topOffset - botOffset) + 'px';
      }
    }
    var throttledWindowResize = throttle(handleWindowResize, 300);
    throttledWindowResize()

    
    window.addEventListener('resize', throttledWindowResize);
    



    
    var text, clip = new ClipboardJS('.anchor');
    var headers = singleContentsElem.querySelectorAll("h1, h2, h3, h4");

    
    var languagedir = JSON.parse("\"ltr\"");

    headers ? 
    headers.forEach(function (elem) {
      var size = parseInt(elem.tagName.substr(1), 10) * 2;
      var url = encodeURI(document.location.origin + document.location.pathname);
      var link = url + "#" + elem.getAttribute('id');
      var newElemOuter = document.createElement('span');
      newElemOuter.classList.add('anchor');
      newElemOuter.classList.add('hide');
      newElemOuter.setAttribute('data-clipboard-text', decodeURI(link));
      newElemOuter.style.position = 'relative';

      var newElemInner = document.createElement('span');
      newElemInner.style.position = 'absolute';
      newElemInner.style.top = '50%';
      newElemInner.style.left = '0.75rem';
      newElemInner.style.transform = 'translateY(-50%)';
      newElemInner.innerHTML = `
<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="${32 - size}px" height="${32 - size}px"><path d="M 5.5625 0 C 4.136719 0 2.707031 0.542969 1.625 1.625 C -0.539063 3.789063 -0.539063 7.335938 1.625 9.5 L 5.28125 13.15625 C 5.667969 13.554688 6.304688 13.558594 6.703125 13.171875 C 7.101563 12.785156 7.105469 12.148438 6.71875 11.75 L 3.03125 8.0625 C 1.632813 6.664063 1.632813 4.429688 3.03125 3.03125 C 4.429688 1.632813 6.664063 1.632813 8.0625 3.03125 L 12.96875 7.9375 C 14.367188 9.335938 14.367188 11.570313 12.96875 12.96875 C 12.804688 13.132813 12.621094 13.25 12.4375 13.375 C 11.980469 13.6875 11.859375 14.308594 12.171875 14.765625 C 12.484375 15.222656 13.105469 15.34375 13.5625 15.03125 C 13.847656 14.835938 14.125 14.625 14.375 14.375 C 16.539063 12.210938 16.539063 8.664063 14.375 6.5 L 9.5 1.625 C 8.417969 0.542969 6.988281 0 5.5625 0 Z M 10.78125 8.875 C 10.738281 8.882813 10.695313 8.894531 10.65625 8.90625 C 10.507813 8.9375 10.371094 9 10.25 9.09375 C 10.039063 9.253906 9.820313 9.429688 9.625 9.625 C 7.460938 11.789063 7.460938 15.335938 9.625 17.5 L 14.5 22.375 C 16.664063 24.539063 20.210938 24.539063 22.375 22.375 C 24.539063 20.210938 24.539063 16.664063 22.375 14.5 L 18.71875 10.875 C 18.476563 10.578125 18.089844 10.441406 17.714844 10.527344 C 17.34375 10.613281 17.050781 10.90625 16.964844 11.277344 C 16.878906 11.652344 17.015625 12.039063 17.3125 12.28125 L 20.96875 15.9375 C 22.367188 17.335938 22.367188 19.570313 20.96875 20.96875 C 19.570313 22.367188 17.335938 22.367188 15.9375 20.96875 L 11.03125 16.0625 C 9.632813 14.664063 9.632813 12.429688 11.03125 11.03125 C 11.152344 10.90625 11.300781 10.820313 11.4375 10.71875 C 11.839844 10.472656 12.015625 9.976563 11.855469 9.53125 C 11.699219 9.085938 11.25 8.8125 10.78125 8.875 Z"/></svg>`;

      if (languagedir === "rtl") {
        newElemInner.style.left = '-2rem';
      } else {
        newElemInner.style.right = '-2rem';
      }

      newElemOuter.append(newElemInner);
      elem.append(newElemOuter);

      elem.addEventListener('mouseenter', function() {
        this.querySelector('.anchor').classList.remove('hide');
      });
      elem.addEventListener('mouseleave', function () {
        this.querySelector('.anchor').classList.add('hide');
      });
    }) : null;

    document.querySelectorAll('.anchor').forEach(function(elem) {
      elem.addEventListener('mouseleave', function() {
        elem.setAttribute('aria-label', null);
        elem.classList.remove('tooltipped');
        elem.classList.remove('tooltipped-s');
        elem.classList.remove('tooltipped-w');
      });
    });

    clip.on('success', function (e) {
      e.clearSelection();
      e.trigger.setAttribute('aria-label', 'Link copied to clipboard!');
      e.trigger.classList.add('tooltipped');
      e.trigger.classList.add('tooltipped-s');
    });
    // =================================================================



    
    
    var lib = JSON.parse("[\"mathjax\"]");

    if (lib && lib.includes('mermaid')) {
      
      var themeVariant = localStorage.getItem('theme') || JSON.parse("\"dark\"");

      if (themeVariant === "dark" || themeVariant === "hacker") {
        mermaid.initialize({ theme: 'dark' });
      } else {
        mermaid.initialize({ theme: 'default' });
      }
      
      var mermaids = [];
      [].push.apply(mermaids, document.getElementsByClassName('language-mermaid'));
      mermaids.forEach(function(elem) {
        var elemParentNode = elem.parentNode;

        if (elemParentNode !== document.body) {
          elemParentNode.parentNode.insertBefore(elem, elemParentNode);
          elemParentNode.parentNode.removeChild(elemParentNode);
        }

        var newElemWrapper = document.createElement('div');
        newElemWrapper.classList.add('mermaid');
        newElemWrapper.style.padding = '34px 4px 6px';
        newElemWrapper.innerHTML = elem.innerHTML;
        elem.replaceWith(newElemWrapper);
      });
    }
    

    

    
    if (lib && lib.includes('katex')) {
      var mathElements = document.getElementsByClassName('math');
      var options = {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "\\[", right: "\\]", display: true },
          { left: "$", right: "$", display: false },
          { left: "\\(", right: "\\)", display: false }
        ],
      };

      renderMathInElement(document.querySelector('.single__contents'), options);
    }
    



    
    if (lib && lib.includes('flowchartjs')) {
      
      var options = JSON.parse("{\"arrow-end\":\"block\",\"element-color\":\"black\",\"fill\":\"white\",\"flowstate\":{\"approved\":{\"fill\":\"#58C4A3\",\"font-size\":12,\"no-text\":\"n/a\",\"yes-text\":\"APPROVED\"},\"current\":{\"fill\":\"yellow\",\"font-color\":\"red\",\"font-weight\":\"bold\"},\"future\":{\"fill\":\"#FFFF99\"},\"invalid\":{\"fill\":\"#444444\"},\"past\":{\"fill\":\"#CCCCCC\",\"font-size\":12},\"rejected\":{\"fill\":\"#C45879\",\"font-size\":12,\"no-text\":\"REJECTED\",\"yes-text\":\"n/a\"},\"request\":{\"fill\":\"blue\"}},\"font-color\":\"black\",\"font-size\":14,\"line-color\":\"black\",\"line-length\":50,\"line-width\":3,\"no-text\":\"no\",\"scale\":1,\"symbols\":{\"end\":{\"class\":\"end-element\"},\"start\":{\"element-color\":\"green\",\"fill\":\"yellow\",\"font-color\":\"red\"}},\"text-margin\":10,\"x\":0,\"y\":0,\"yes-text\":\"yes\"}");
      var jsonContent = null;

      var flowchartPrefix = "language-flowchart";
      var index = 0;
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + flowchartPrefix + "]"), function(x){
          x.style.display = 'none'
          x.parentNode.style.backgroundColor = "transparent"
          jsonContent = x.innerText;

          var node0 = document.createElement('div');
          node0.id = 'flowchart' + index;
          x.parentNode.insertBefore(node0, x);

          var diagram = flowchart.parse(jsonContent);
          diagram.drawSVG("flowchart"+index, options);

          index +=1;
      });      
    }
    

    

    
    document.querySelectorAll("mjx-container").forEach(function (x) {
      x.parentElement.classList += 'has-jax'
    });
    



    
    if (lib && lib.includes('msc')) {
      
      var options = JSON.parse("{\"theme\":\"hand\"}");
      var jsonContent = null;

      var index = 0;
      var chartPrefix = "language-msc";
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + chartPrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        jsonContent = x.innerText;
        var node0 = document.createElement('div');
        node0.id = 'msc' + index;
        x.parentNode.insertBefore(node0, x);
        var diagram = Diagram.parse(jsonContent);
        diagram.drawSVG("msc" + index, options);
        index += 1;
      });
    }
    



    
    if (lib && lib.includes('chart')) {
      var borderColor = "#666";
      var bgColor = "#ddd";
      var borderWidth = 2;

      Chart.defaults.global.elements.rectangle.borderWidth = borderWidth;
      Chart.defaults.global.elements.rectangle.borderColor = borderColor;
      Chart.defaults.global.elements.rectangle.backgroundColor = bgColor;

      Chart.defaults.global.elements.line.borderWidth = borderWidth;
      Chart.defaults.global.elements.line.borderColor = borderColor;
      Chart.defaults.global.elements.line.backgroundColor = bgColor;

      Chart.defaults.global.elements.point.borderWidth = borderWidth;
      Chart.defaults.global.elements.point.borderColor = borderColor;
      Chart.defaults.global.elements.point.backgroundColor = bgColor;

      var chartPrefix = "language-chart";
      var index = 0;
      var jsonContent = null;

      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + chartPrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        jsonContent = x.innerText;
        var node0 = document.createElement('canvas');
        var source = null;
        node0.height = 200;
        node0.style.height = 200;
        node0.id = 'myChart' + index;
        source = JSON.parse(jsonContent);
        x.parentNode.insertBefore(node0, x);
        var ctx = document.getElementById('myChart' + index).getContext('2d');
        var myChart = new Chart(ctx, source);
        index += 1;
      });            
    }
    



    
    if (lib && lib.includes('wavedrom')) {
      var wavePrefix = "language-wave";
      var index = 0;
      var jsonContent = null;
      
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + wavePrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        jsonContent = x.innerText;
        var node0 = document.createElement('div');
        var source = null;
        node0.id = 'WaveDrom_Display_' + index;
        source = JSON.parse(jsonContent);
        x.parentNode.insertBefore(node0, x);
        WaveDrom.RenderWaveForm(index, source, "WaveDrom_Display_");
        index += 1;
      });
    }
    



    
    if (lib && lib.includes('viz')) {
      var vizPrefix = "language-viz-";
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + vizPrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        var engine;
        x.getAttribute("class").split(" ").forEach(function (cls) {
          if (cls.startsWith(vizPrefix)) {
            engine = cls.substr(vizPrefix.length);
          }
        });
        var viz = new Viz();
        viz.renderSVGElement(x.innerText, { engine: engine })
          .then(function (element) {
            element.style.width = "100%";
            x.parentNode.insertBefore(element, x);
          })
      });
    }
    
    
  }
</script>


            
            <footer class="footer">
    
<div class="dropdown">
  <button class="dropdown-trigger" aria-label="Select Language Button">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M12.65 15.67c.14-.36.05-.77-.23-1.05l-2.09-2.06.03-.03c1.74-1.94 2.98-4.17 3.71-6.53h1.94c.54 0 .99-.45.99-.99v-.02c0-.54-.45-.99-.99-.99H10V3c0-.55-.45-1-1-1s-1 .45-1 1v1H1.99c-.54 0-.99.45-.99.99 0 .55.45.99.99.99h10.18C11.5 7.92 10.44 9.75 9 11.35c-.81-.89-1.49-1.86-2.06-2.88-.16-.29-.45-.47-.78-.47-.69 0-1.13.75-.79 1.35.63 1.13 1.4 2.21 2.3 3.21L3.3 16.87c-.4.39-.4 1.03 0 1.42.39.39 1.02.39 1.42 0L9 14l2.02 2.02c.51.51 1.38.32 1.63-.35zM17.5 10c-.6 0-1.14.37-1.35.94l-3.67 9.8c-.24.61.22 1.26.87 1.26.39 0 .74-.24.88-.61l.89-2.39h4.75l.9 2.39c.14.36.49.61.88.61.65 0 1.11-.65.88-1.26l-3.67-9.8c-.22-.57-.76-.94-1.36-.94zm-1.62 7l1.62-4.33L19.12 17h-3.24z"/></svg>
  </button>
  <div class="dropdown-content">
    
    
    
      
      
        
      
        
        
          
            
              <a href="https://chaphlagical.github.io/zh/posts/computer/os/" data-lang="zh" class="dropdown-item is-active">简体中文</a>
            
          
        
      
    
  </div>
</div>

    
<div class="footer__social">
  <div class="social">
    
      
      <a href="https://blog.csdn.net/Chaphlagical" title="csdn" aria-label="csdn">
        <svg fill="#000000" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32"><path fill="currentColor" d="M11.705 9.681l-.03.247c-.035.288-.3.484-.585.439-.47-.081-1.135-.151-1.64-.151-.765 0-1.16.267-1.19.56-.035.368.365.389 1.355.681 1.345.378 1.935.913 1.855 1.741C11.38 14.172 10.31 15 8.165 15c-.655 0-1.24-.096-1.675-.222-.24-.066-.395-.293-.37-.545l.035-.288c.045-.232.25-.404.49-.404.035 0 .065.005.095.01.01 0 1.057.237 1.61.202.808-.051 1.26-.247 1.3-.636.03-.353-.3-.404-1.22-.646-1.265-.343-2.075-.878-1.995-1.731C6.53 9.752 7.72 9 9.555 9 10.2 9 10.83 9.035 11.3 9.121 11.56 9.167 11.74 9.414 11.705 9.681zM18.79 9.814c.019-.223.184-.409.404-.45 4.533-.849 4.929.926 4.782 2.502l-.241 2.54c-.024.257-.24.453-.498.453h-.546c-.295 0-.526-.254-.498-.547l.207-2.182c.056-.601.405-1.776-1.281-1.732-.186.005-.343.017-.469.032-.235.027-.414.218-.433.455-.021.255-.05.595-.083.88l-.251 2.642c-.024.257-.24.453-.498.453h-.514c-.296 0-.527-.255-.498-.549l.247-2.501L18.79 9.814zM17.115 9.846c-.615-.5-1.611-.696-2.84-.735-.531-.017-1.087.024-1.265.05-.192.029-.345.19-.385.38-.01.035-.015.07-.015.11l-.43 4.635c-.03.275.17.52.44.545.425.045.91.065 1.41.065 1.205 0 2.005-.18 2.64-.59.695-.44 1.17-1.15 1.265-2.16C18.035 11.056 17.665 10.306 17.115 9.846zM16.435 12.106c-.085.935-.955 1.605-2.185 1.605-.305 0-.46-.025-.58-.05l.3-3.355c.125-.025.36-.025.525-.025C15.795 10.271 16.565 10.746 16.435 12.106zM5.367 14.461c-.021.227-.19.41-.415.448C4.623 14.966 4.163 15 3.595 15c-2.427 0-3.737-1.254-3.583-2.913C.198 10.112 2.139 9 4.264 9c.559 0 .961.034 1.304.093.259.045.437.286.408.547L5.941 9.965c-.031.283-.292.487-.573.439-.326-.055-.724-.093-1.071-.093-1.25 0-2.312.41-2.434 1.707-.109 1.16.637 1.714 2.044 1.714.271 0 .614-.024.922-.064.318-.041.592.222.562.541L5.367 14.461z"/></svg>
      </a>
            
    
            
    
      
      <a href="https://www.douban.com/people/Chaphlagical/" title="douban" aria-label="douban">
        <svg fill="#000000" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32"><path fill="currentColor" d="M 5 4 A 1.0001 1.0001 0 1 0 5 6 L 19 6 A 1.0001 1.0001 0 1 0 19 4 L 5 4 z M 7 8 C 5.9069372 8 5 8.9069372 5 10 L 5 13 C 5 14.093063 5.9069372 15 7 15 L 7.3242188 15 L 8.5234375 18 L 5 18 A 1.0001 1.0001 0 1 0 5 20 L 19 20 A 1.0001 1.0001 0 1 0 19 18 L 15.476562 18 L 16.675781 15 L 17 15 C 18.093063 15 19 14.093063 19 13 L 19 10 C 19 8.9069372 18.093063 8 17 8 L 7 8 z M 7 10 L 17 10 L 17 13 L 7 13 L 7 10 z M 9.4765625 15 L 14.523438 15 L 13.324219 18 L 10.675781 18 L 9.4765625 15 z"/></svg>
      </a>
            
    
      
      <a href="mailto:chaf@mail.ustc.edu.cn" title="email" aria-label="email">
        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-.4 4.25l-7.07 4.42c-.32.2-.74.2-1.06 0L4.4 8.25c-.25-.16-.4-.43-.4-.72 0-.67.73-1.07 1.3-.72L12 11l6.7-4.19c.57-.35 1.3.05 1.3.72 0 .29-.15.56-.4.72z"/></svg>
      </a>
            
    
      
      <a href="https://www.facebook.com/chaf.chen.3" title="facebook" aria-label="facebook">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 24 24" version="1.1">
<g id="surface2747">
<path fill="currentColor" d="M 11.664062 2.003906 C 6.621094 2.171875 2.375 6.25 2.023438 11.289062 C 1.65625 16.617188 5.46875 21.121094 10.507812 21.878906 L 10.507812 14.648438 L 8.890625 14.648438 C 8.164062 14.648438 7.578125 14.0625 7.578125 13.335938 C 7.578125 12.609375 8.164062 12.023438 8.890625 12.023438 L 10.503906 12.023438 L 10.503906 10.273438 C 10.503906 7.378906 11.914062 6.105469 14.324219 6.105469 C 14.679688 6.105469 14.984375 6.113281 15.242188 6.128906 C 15.878906 6.15625 16.371094 6.6875 16.371094 7.324219 C 16.371094 7.988281 15.835938 8.523438 15.171875 8.523438 L 14.730469 8.523438 C 13.710938 8.523438 13.351562 9.492188 13.351562 10.585938 L 13.351562 12.023438 L 15.222656 12.023438 C 15.8125 12.023438 16.265625 12.550781 16.175781 13.132812 L 16.066406 13.835938 C 15.992188 14.304688 15.589844 14.652344 15.113281 14.652344 L 13.351562 14.652344 L 13.351562 21.898438 C 18.234375 21.234375 22 17.0625 22 12 C 22 6.367188 17.339844 1.820312 11.664062 2.003906 Z M 11.664062 2.003906 "/>
</g>
</svg>

      </a>
            
    
            
    
      
      <a href="https://github.com/Chaphlagical" title="github" aria-label="github">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 24 24" version="1.1">
<g id="surface3680">
<path fill="currentColor" d="M 10.898438 2.101562 C 6.300781 2.601562 2.601562 6.300781 2.101562 10.800781 C 1.601562 15.5 4.300781 19.699219 8.398438 21.300781 C 8.699219 21.398438 9 21.199219 9 20.800781 L 9 19.199219 C 9 19.199219 8.601562 19.300781 8.101562 19.300781 C 6.699219 19.300781 6.101562 18.101562 6 17.398438 C 5.898438 17 5.699219 16.699219 5.398438 16.398438 C 5.101562 16.300781 5 16.300781 5 16.199219 C 5 16 5.300781 16 5.398438 16 C 6 16 6.5 16.699219 6.699219 17 C 7.199219 17.800781 7.800781 18 8.101562 18 C 8.5 18 8.800781 17.898438 9 17.800781 C 9.101562 17.101562 9.398438 16.398438 10 16 C 7.699219 15.5 6 14.199219 6 12 C 6 10.898438 6.5 9.800781 7.199219 9 C 7.101562 8.800781 7 8.300781 7 7.601562 C 7 7.199219 7 6.601562 7.300781 6 C 7.300781 6 8.699219 6 10.101562 7.300781 C 10.601562 7.101562 11.300781 7 12 7 C 12.699219 7 13.398438 7.101562 14 7.300781 C 15.300781 6 16.800781 6 16.800781 6 C 17 6.601562 17 7.199219 17 7.601562 C 17 8.398438 16.898438 8.800781 16.800781 9 C 17.5 9.800781 18 10.800781 18 12 C 18 14.199219 16.300781 15.5 14 16 C 14.601562 16.5 15 17.398438 15 18.300781 L 15 20.898438 C 15 21.199219 15.300781 21.5 15.699219 21.398438 C 19.398438 19.898438 22 16.300781 22 12.101562 C 22 6.101562 16.898438 1.398438 10.898438 2.101562 Z M 10.898438 2.101562 "/>
</g>
</svg>

      </a>
            
    
            
    
            
    
      
      <a href="https://scholar.google.com/citations?user=lD3dpIQAAAAJ&amp;hl=en" title="google-scholar" aria-label="google-scholar">
        <svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="32" height="32"><path d="M 25 2 C 12.309534 2 2 12.309534 2 25 C 2 37.690466 12.309534 48 25 48 C 37.690466 48 48 37.690466 48 25 C 48 12.309534 37.690466 2 25 2 z M 25 4 C 36.609534 4 46 13.390466 46 25 C 46 36.609534 36.609534 46 25 46 C 13.390466 46 4 36.609534 4 25 C 4 13.390466 13.390466 4 25 4 z M 21 11 L 11 20 L 17.78125 20 C 17.80125 22.847 19.967531 25.730469 23.769531 25.730469 C 24.129531 25.730469 24.529688 25.690391 24.929688 25.650391 C 24.749688 26.100391 24.560547 26.470078 24.560547 27.080078 C 24.560547 28.230078 25.140391 28.920078 25.650391 29.580078 C 24.020391 29.690078 20.989766 29.879531 18.759766 31.269531 C 16.629766 32.559531 15.980469 34.43 15.980469 35.75 C 15.980469 38.47 18.500469 41 23.730469 41 C 29.930469 41 33.220703 37.510547 33.220703 34.060547 C 33.220703 31.530547 31.779453 30.279922 30.189453 28.919922 L 28.900391 27.890625 C 28.500391 27.570625 27.949219 27.120312 27.949219 26.320312 C 27.949219 25.510313 28.500703 24.989766 28.970703 24.509766 C 30.480703 23.309766 32 21.960234 32 19.240234 C 32 18.197234 31.756203 17.348391 31.408203 16.650391 L 35 13.570312 L 35 17.277344 C 34.405 17.623344 34 18.261 34 19 L 34 25 C 34 26.104 34.896 27 36 27 C 37.104 27 38 26.104 38 25 L 38 19 C 38 18.262 37.595 17.624344 37 17.277344 L 37 12 C 37 11.957 36.980609 11.920906 36.974609 11.878906 L 38 11 L 21 11 z M 24.269531 14.240234 C 27.269531 14.240234 28.820312 18.35 28.820312 21 C 28.820312 21.65 28.739922 22.819922 27.919922 23.669922 C 27.339922 24.259922 26.370938 24.699219 25.460938 24.699219 C 22.370938 24.699219 20.949219 20.620156 20.949219 18.160156 C 20.949219 17.210156 21.14 16.220938 21.75 15.460938 C 22.33 14.710938 23.339531 14.240234 24.269531 14.240234 z M 26.039062 30.609375 C 26.409063 30.609375 26.590859 30.610391 26.880859 30.650391 C 29.620859 32.630391 30.800781 33.620234 30.800781 35.490234 C 30.800781 37.760234 28.97 39.460938 25.5 39.460938 C 21.64 39.460938 19.160156 37.590469 19.160156 34.980469 C 19.160156 32.370469 21.459766 31.499219 22.259766 31.199219 C 23.769766 30.679219 25.719062 30.609375 26.039062 30.609375 z"/></svg>
      </a>
            
    
      
      <a href="https://www.instagram.com/chaphlagical/" title="instagram" aria-label="instagram">
        <svg fill="#000000" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="32" height="32"><path fill="currentColor" d="M 11.46875 5 C 7.917969 5 5 7.914063 5 11.46875 L 5 20.53125 C 5 24.082031 7.914063 27 11.46875 27 L 20.53125 27 C 24.082031 27 27 24.085938 27 20.53125 L 27 11.46875 C 27 7.917969 24.085938 5 20.53125 5 Z M 11.46875 7 L 20.53125 7 C 23.003906 7 25 8.996094 25 11.46875 L 25 20.53125 C 25 23.003906 23.003906 25 20.53125 25 L 11.46875 25 C 8.996094 25 7 23.003906 7 20.53125 L 7 11.46875 C 7 8.996094 8.996094 7 11.46875 7 Z M 21.90625 9.1875 C 21.402344 9.1875 21 9.589844 21 10.09375 C 21 10.597656 21.402344 11 21.90625 11 C 22.410156 11 22.8125 10.597656 22.8125 10.09375 C 22.8125 9.589844 22.410156 9.1875 21.90625 9.1875 Z M 16 10 C 12.699219 10 10 12.699219 10 16 C 10 19.300781 12.699219 22 16 22 C 19.300781 22 22 19.300781 22 16 C 22 12.699219 19.300781 10 16 10 Z M 16 12 C 18.222656 12 20 13.777344 20 16 C 20 18.222656 18.222656 20 16 20 C 13.777344 20 12 18.222656 12 16 C 12 13.777344 13.777344 12 16 12 Z"/></svg>
      </a>
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
      
      <a href="https://steamcommunity.com/profiles/76561198855701848/" title="steam" aria-label="steam">
        <svg fill="#000000" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="32" height="32"><path fill="currentColor" d="M 25 3 C 13.59 3 4.209375 11.680781 3.109375 22.800781 L 14.300781 28.529297 C 15.430781 27.579297 16.9 27 18.5 27 L 18.550781 27 C 18.940781 26.4 19.389375 25.649141 19.859375 24.869141 C 20.839375 23.259141 21.939531 21.439062 23.019531 20.039062 C 23.259531 15.569063 26.97 12 31.5 12 C 36.19 12 40 15.81 40 20.5 C 40 25.03 36.430937 28.740469 31.960938 28.980469 C 30.560938 30.060469 28.750859 31.160859 27.130859 32.130859 C 26.350859 32.610859 25.6 33.059219 25 33.449219 L 25 33.5 C 25 37.09 22.09 40 18.5 40 C 14.91 40 12 37.09 12 33.5 C 12 33.33 12.009531 33.17 12.019531 33 L 3.2792969 28.519531 C 4.9692969 38.999531 14.05 47 25 47 C 37.15 47 47 37.15 47 25 C 47 12.85 37.15 3 25 3 z M 31.5 14 C 27.92 14 25 16.92 25 20.5 C 25 24.08 27.92 27 31.5 27 C 35.08 27 38 24.08 38 20.5 C 38 16.92 35.08 14 31.5 14 z M 31.5 16 C 33.99 16 36 18.01 36 20.5 C 36 22.99 33.99 25 31.5 25 C 29.01 25 27 22.99 27 20.5 C 27 18.01 29.01 16 31.5 16 z M 18.5 29 C 17.71 29 16.960313 29.200312 16.320312 29.570312 L 19.640625 31.269531 C 20.870625 31.899531 21.350469 33.410625 20.730469 34.640625 C 20.280469 35.500625 19.41 36 18.5 36 C 18.11 36 17.729375 35.910469 17.359375 35.730469 L 14.029297 34.019531 C 14.289297 36.259531 16.19 38 18.5 38 C 20.99 38 23 35.99 23 33.5 C 23 31.01 20.99 29 18.5 29 z"/></svg>
      </a>
            
    
            
    
            
    
      
      <a href="https://twitter.com/chen_418199378" title="twitter" aria-label="twitter">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32" version="1.1">
<g id="surface676">
<path fill="currentColor" d="M 28 8.558594 C 27.117188 8.949219 26.167969 9.214844 25.171875 9.332031 C 26.1875 8.722656 26.96875 7.757812 27.335938 6.609375 C 26.386719 7.171875 25.332031 7.582031 24.210938 7.804688 C 23.3125 6.847656 22.03125 6.246094 20.617188 6.246094 C 17.898438 6.246094 15.691406 8.453125 15.691406 11.171875 C 15.691406 11.558594 15.734375 11.933594 15.820312 12.292969 C 11.726562 12.089844 8.097656 10.128906 5.671875 7.148438 C 5.246094 7.875 5.003906 8.722656 5.003906 9.625 C 5.003906 11.332031 5.871094 12.839844 7.195312 13.722656 C 6.386719 13.695312 5.628906 13.476562 4.964844 13.105469 C 4.964844 13.128906 4.964844 13.148438 4.964844 13.167969 C 4.964844 15.554688 6.660156 17.546875 8.914062 17.996094 C 8.5 18.109375 8.066406 18.171875 7.617188 18.171875 C 7.300781 18.171875 6.988281 18.140625 6.691406 18.082031 C 7.316406 20.039062 9.136719 21.460938 11.289062 21.503906 C 9.605469 22.824219 7.480469 23.609375 5.175781 23.609375 C 4.777344 23.609375 4.386719 23.585938 4 23.539062 C 6.179688 24.9375 8.765625 25.753906 11.546875 25.753906 C 20.605469 25.753906 25.558594 18.25 25.558594 11.742188 C 25.558594 11.53125 25.550781 11.316406 25.542969 11.105469 C 26.503906 10.410156 27.339844 9.542969 28 8.558594 Z M 28 8.558594 "/>
</g>
</svg>

      </a>
            
    
            
    
            
    
            
    
      
      <a href="https://www.youtube.com/channel/UC6izbcXMuip_qYlw50QZvmA" title="youtube" aria-label="youtube">
        <svg xmlns="http://www.w3.org/2000/svg" fill="#000000" viewBox="0 0 30 30" width="32" height="32">    <path fill="currentColor" d="M 7.4140625 3 L 9.1894531 9.4121094 L 9.1894531 12.488281 L 10.726562 12.488281 L 10.726562 9.4121094 L 12.525391 3 L 10.976562 3 L 10.332031 5.9179688 C 10.151031 6.7699687 10.035422 7.3753281 9.9824219 7.7363281 L 9.9355469 7.7363281 C 9.8605469 7.2313281 9.7439375 6.62125 9.5859375 5.90625 L 8.9648438 3 L 7.4140625 3 z M 14.318359 5.4199219 C 13.797359 5.4199219 13.376641 5.5224687 13.056641 5.7304688 C 12.735641 5.9374688 12.500609 6.2687031 12.349609 6.7207031 C 12.199609 7.1737031 12.123047 7.7715781 12.123047 8.5175781 L 12.123047 9.5234375 C 12.123047 10.261437 12.190266 10.853828 12.322266 11.298828 C 12.454266 11.743828 12.675281 12.072203 12.988281 12.283203 C 13.301281 12.494203 13.733203 12.600562 14.283203 12.601562 C 14.818203 12.601562 15.244641 12.497063 15.556641 12.289062 C 15.868641 12.081063 16.095375 11.755641 16.234375 11.306641 C 16.373375 10.857641 16.443359 10.264391 16.443359 9.5253906 L 16.443359 8.5175781 C 16.443359 7.7715781 16.371516 7.1755625 16.228516 6.7265625 C 16.085516 6.2785625 15.860781 5.9473281 15.550781 5.7363281 C 15.241781 5.5253281 14.830359 5.4199219 14.318359 5.4199219 z M 17.251953 5.5566406 L 17.251953 10.734375 C 17.251953 11.375375 17.362078 11.847437 17.580078 12.148438 C 17.799078 12.449437 18.137656 12.599609 18.597656 12.599609 C 19.260656 12.599609 19.758844 12.279672 20.089844 11.638672 L 20.123047 11.638672 L 20.259766 12.486328 L 21.480469 12.486328 L 21.480469 5.5566406 L 19.921875 5.5566406 L 19.921875 11.060547 C 19.861875 11.189547 19.769531 11.295906 19.644531 11.378906 C 19.519531 11.462906 19.389906 11.503906 19.253906 11.503906 C 19.094906 11.503906 18.982063 11.436687 18.914062 11.304688 C 18.846063 11.172688 18.8125 10.954531 18.8125 10.644531 L 18.8125 5.5566406 L 17.251953 5.5566406 z M 14.283203 6.4941406 C 14.501203 6.4941406 14.656187 6.6098437 14.742188 6.8398438 C 14.829188 7.0688437 14.871094 7.4316875 14.871094 7.9296875 L 14.871094 10.089844 C 14.871094 10.602844 14.828188 10.971266 14.742188 11.197266 C 14.656188 11.423266 14.502156 11.536109 14.285156 11.537109 C 14.067156 11.537109 13.915031 11.423266 13.832031 11.197266 C 13.748031 10.971266 13.707031 10.601844 13.707031 10.089844 L 13.707031 7.9296875 C 13.707031 7.4326875 13.751891 7.0698438 13.837891 6.8398438 C 13.923891 6.6108438 14.072203 6.4941406 14.283203 6.4941406 z M 6.5 13.900391 C 5.119 13.900391 4 15.019391 4 16.400391 L 4 24.400391 C 4 25.781391 5.119 26.900391 6.5 26.900391 L 23.5 26.900391 C 24.881 26.900391 26 25.781391 26 24.400391 L 26 16.400391 C 26 15.019391 24.881 13.900391 23.5 13.900391 L 6.5 13.900391 z M 15.058594 16.199219 L 16.328125 16.199219 L 16.328125 19.283203 L 16.337891 19.283203 C 16.451891 19.060203 16.614219 18.881141 16.824219 18.744141 C 17.034219 18.607141 17.261906 18.539062 17.503906 18.539062 C 17.815906 18.539062 18.059328 18.622109 18.236328 18.787109 C 18.413328 18.952109 18.544047 19.220844 18.623047 19.589844 C 18.702047 19.959844 18.742188 20.471953 18.742188 21.126953 L 18.742188 22.050781 C 18.742188 22.922781 18.637734 23.563609 18.427734 23.974609 C 18.217734 24.385609 17.888359 24.591797 17.443359 24.591797 C 17.195359 24.591797 16.969625 24.533922 16.765625 24.419922 C 16.561625 24.305922 16.410594 24.149172 16.308594 23.951172 L 16.279297 23.951172 L 16.146484 24.503906 L 15.058594 24.503906 L 15.058594 16.199219 z M 7.1835938 16.496094 L 11.087891 16.496094 L 11.087891 17.556641 L 9.7792969 17.556641 L 9.7792969 24.503906 L 8.4902344 24.503906 L 8.4902344 17.556641 L 7.1835938 17.556641 L 7.1835938 16.496094 z M 21.117188 18.542969 C 21.568188 18.542969 21.916203 18.624062 22.158203 18.789062 C 22.399203 18.955063 22.570922 19.2135 22.669922 19.5625 C 22.767922 19.9125 22.816406 20.396672 22.816406 21.013672 L 22.816406 22.017578 L 20.613281 22.017578 L 20.613281 22.314453 C 20.613281 22.690453 20.623484 22.971203 20.646484 23.158203 C 20.669484 23.345203 20.715156 23.483359 20.785156 23.568359 C 20.855156 23.654359 20.963375 23.697266 21.109375 23.697266 C 21.306375 23.697266 21.441625 23.62075 21.515625 23.46875 C 21.588625 23.31675 21.628766 23.061078 21.634766 22.705078 L 22.769531 22.771484 C 22.775531 22.821484 22.779297 22.893422 22.779297 22.982422 C 22.779297 23.523422 22.631937 23.927359 22.335938 24.193359 C 22.039938 24.461359 21.621078 24.595703 21.080078 24.595703 C 20.431078 24.595703 19.976844 24.391375 19.714844 23.984375 C 19.452844 23.577375 19.324219 22.94675 19.324219 22.09375 L 19.324219 21.072266 C 19.324219 20.194266 19.460469 19.553438 19.730469 19.148438 C 20.000469 18.743437 20.462188 18.542969 21.117188 18.542969 z M 12.949219 18.650391 L 14.267578 18.650391 L 14.267578 24.501953 L 14.263672 24.501953 L 14.263672 24.503906 L 13.232422 24.503906 L 13.119141 23.787109 L 13.089844 23.787109 C 12.809844 24.329109 12.390078 24.599609 11.830078 24.599609 C 11.441078 24.599609 11.155703 24.47375 10.970703 24.21875 C 10.785703 23.96475 10.693359 23.565391 10.693359 23.025391 L 10.693359 18.652344 L 12.013672 18.652344 L 12.013672 22.949219 C 12.013672 23.209219 12.042609 23.397813 12.099609 23.507812 C 12.157609 23.619812 12.251719 23.673828 12.386719 23.673828 C 12.500719 23.673828 12.609844 23.639359 12.714844 23.568359 C 12.820844 23.498359 12.897219 23.408781 12.949219 23.300781 L 12.949219 18.650391 z M 21.089844 19.431641 C 20.949844 19.431641 20.844344 19.472687 20.777344 19.554688 C 20.710344 19.637687 20.665531 19.772938 20.644531 19.960938 C 20.621531 20.147938 20.611328 20.433453 20.611328 20.814453 L 20.611328 21.234375 L 21.574219 21.234375 L 21.574219 20.814453 C 21.574219 20.438453 21.562109 20.154937 21.537109 19.960938 C 21.512109 19.765937 21.467391 19.630781 21.400391 19.550781 C 21.333391 19.471781 21.230844 19.431641 21.089844 19.431641 z M 16.910156 19.474609 C 16.783156 19.474609 16.664641 19.524953 16.556641 19.626953 C 16.448641 19.728953 16.372125 19.859578 16.328125 20.017578 L 16.328125 23.339844 C 16.386125 23.441844 16.460734 23.517359 16.552734 23.568359 C 16.644734 23.618359 16.744516 23.646484 16.853516 23.646484 C 16.993516 23.646484 17.1045 23.596141 17.1875 23.494141 C 17.2705 23.392141 17.329281 23.220516 17.363281 22.978516 C 17.398281 22.737516 17.416016 22.402562 17.416016 21.976562 L 17.416016 21.222656 C 17.416016 20.764656 17.402047 20.411109 17.373047 20.162109 C 17.345047 19.914109 17.292703 19.736812 17.220703 19.632812 C 17.147703 19.528813 17.045156 19.474609 16.910156 19.474609 z"/></svg>

      </a>
            
    
      
      <a href="https://www.zhihu.com/people/chaf-86" title="zhihu" aria-label="zhihu">
        <svg fill="#000000" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32"><path fill="currentColor" d="M 5.921875 2.9511719 C 5.5336094 2.9815469 5.1832344 3.2390625 5.0527344 3.6328125 L 3.6835938 7.7363281 C 3.5085938 8.2593281 3.7924062 8.825 4.3164062 9 C 4.8404063 9.175 5.4050781 8.8911875 5.5800781 8.3671875 L 6.0351562 7 L 6.9941406 7 L 6.9941406 10.222656 C 6.9941406 10.845846 6.9644144 11.431442 6.9199219 12 L 5 12 A 1.0001 1.0001 0 1 0 5 14 L 6.6367188 14 C 6.1575971 16.260332 5.1601574 17.989071 3.4179688 19.189453 C 2.9979688 19.479453 2.8798125 20.049188 3.1328125 20.492188 C 3.4258125 21.004188 4.0960781 21.153359 4.5800781 20.818359 C 6.0994455 19.769009 7.1700075 18.397613 7.8808594 16.720703 A 1.0001 1.0001 0 0 0 8.0449219 17.601562 L 9.5117188 19.59375 A 1.0002375 1.0002375 0 1 0 11.123047 18.408203 L 9.65625 16.416016 A 1.0001 1.0001 0 0 0 8.7929688 15.998047 A 1.0001 1.0001 0 0 0 7.9921875 16.472656 C 8.2917972 15.713486 8.5082238 14.883111 8.6699219 14 L 10 14 A 1.0001 1.0001 0 1 0 10 12 L 8.9316406 12 C 8.9726972 11.4285 8.9941406 10.836947 8.9941406 10.222656 L 8.9941406 7 L 10 7 A 1.0001 1.0001 0 1 0 10 5 L 6.7011719 5 L 6.9472656 4.2636719 C 7.1222656 3.7406719 6.8404063 3.175 6.3164062 3 C 6.1856563 2.95625 6.0512969 2.9410469 5.921875 2.9511719 z M 14 5 A 1.0001 1.0001 0 0 0 13 6 L 13 17 A 1.0001 1.0001 0 0 0 14 18 L 15 18 L 15 20 A 1.0001 1.0001 0 0 0 16.707031 20.707031 L 19.414062 18 L 21 18 A 1.0001 1.0001 0 0 0 22 17 L 22 6 A 1.0001 1.0001 0 0 0 21 5 L 14 5 z M 15 7 L 20 7 L 20 16 L 19 16 A 1.0001 1.0001 0 0 0 18.292969 16.292969 L 17 17.585938 L 17 17 A 1.0001 1.0001 0 0 0 16 16 L 15 16 L 15 7 z"/></svg>
      </a>
            
    
    
  
  
    
      <a href="https://chaphlagical.github.io/zh/posts/index.xml" type="application/rss+xml" title="RSS" aria-label="RSS Feed Link">
        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><circle fill="currentColor" cx="6.18" cy="17.82" r="2.18"/><path fill="currentColor" d="M5.59 10.23c-.84-.14-1.59.55-1.59 1.4 0 .71.53 1.28 1.23 1.4 2.92.51 5.22 2.82 5.74 5.74.12.7.69 1.23 1.4 1.23.85 0 1.54-.75 1.41-1.59-.68-4.2-3.99-7.51-8.19-8.18zm-.03-5.71C4.73 4.43 4 5.1 4 5.93c0 .73.55 1.33 1.27 1.4 6.01.6 10.79 5.38 11.39 11.39.07.73.67 1.28 1.4 1.28.84 0 1.5-.73 1.42-1.56-.73-7.34-6.57-13.19-13.92-13.92z"/></svg>
      </a>
    
  


  </div>
</div>

    
<div id="gtt">
  <div class="gtt">
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M8.12 14.71L12 10.83l3.88 3.88c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L12.7 8.71c-.39-.39-1.02-.39-1.41 0L6.7 13.3c-.39.39-.39 1.02 0 1.41.39.38 1.03.39 1.42 0z"/></svg>
  </div>
</div>

    <hr />

    <div class="basicflex flexwrap">
        
            
        
            
        
    </div>

    <div class="footer__poweredby">
        
                
            <p class="caption">
                
                    ©2022, All Rights Reserved
                
            </p>
        

        
            <p class="caption">Powered by <a href="https://gohugo.io/" target="_blank" rel="noreferrer">Hugo</a> and the <a href="https://github.com/zzossig/hugo-theme-zzo" target="_blank" rel="noreferrer">Zzo theme</a></p>
        
        
    </div> 
</footer>
        </div>
        





<div class="wrapper__right hide" data-pad="true" dir="ltr">
  <script>document.querySelector('.wrapper__right').classList.remove('hide')</script>
  
    
      
        <div class="toc__flexbox--outer" data-position="fixed" data-dir="ltr" data-ani="true">
          <h6 class="toc__title toc__title--outer" data-ani="true">目录</h6>
          
          <label class="switch" data-ani="true">
            <input id="visible-toc" aria-label="Visible TOC" type="checkbox" checked>
            <span class="slider round"></span>
          </label>
          
        </div>
        <div class="toc toc__outer " data-dir="ltr" data-folding="true" data-ani="true">
          <nav id="TableOfContents">
  <ul>
    <li><a href="#1-分布式系统简介">1. 分布式系统简介</a>
      <ul>
        <li><a href="#11-分布式系统的诞生和定义">1.1. 分布式系统的诞生和定义</a></li>
        <li><a href="#12-分布式系统发展的动力">1.2. 分布式系统发展的动力</a></li>
        <li><a href="#13-分布式系统的目标">1.3. 分布式系统的目标</a></li>
        <li><a href="#14-分布式系统的优缺点">1.4. 分布式系统的优缺点</a>
          <ul>
            <li><a href="#141-分布式系统同集中式系统相比之优点">1.4.1. 分布式系统同集中式系统相比之优点</a></li>
            <li><a href="#142-分布式系统与独立pc相比之优点">1.4.2. 分布式系统与独立PC相比之优点</a></li>
            <li><a href="#143-分布式系统的缺点">1.4.3. 分布式系统的缺点</a></li>
          </ul>
        </li>
        <li><a href="#15-计算机网络与分布式系统的关系">1.5. 计算机网络与分布式系统的关系</a></li>
        <li><a href="#16-分布式系统硬件">1.6. 分布式系统硬件</a>
          <ul>
            <li><a href="#161-分布式系统硬件分类">1.6.1. 分布式系统硬件分类</a></li>
            <li><a href="#162-基于总线的多处理器">1.6.2. 基于总线的多处理器</a></li>
            <li><a href="#163-基于开关的多处理器系统">1.6.3. 基于开关的多处理器系统</a></li>
            <li><a href="#164-基于总线的多计算机系统">1.6.4. 基于总线的多计算机系统</a></li>
            <li><a href="#165-基于开关的多计算机系统">1.6.5. 基于开关的多计算机系统</a></li>
          </ul>
        </li>
        <li><a href="#17-分布式系统软件">1.7. 分布式系统软件</a>
          <ul>
            <li><a href="#171-网络操作系统">1.7.1. 网络操作系统</a></li>
            <li><a href="#172-分布式操作系统">1.7.2. 分布式操作系统</a></li>
            <li><a href="#173-多处理器分时操作系统">1.7.3. 多处理器分时操作系统</a></li>
          </ul>
        </li>
        <li><a href="#18-分布式系统的设计问题">1.8. 分布式系统的设计问题</a>
          <ul>
            <li><a href="#181-透明性">1.8.1. 透明性</a></li>
            <li><a href="#182-灵活性">1.8.2. 灵活性</a></li>
            <li><a href="#184-可靠性">1.8.4. 可靠性</a></li>
            <li><a href="#185-性能">1.8.5. 性能</a></li>
            <li><a href="#186-可缩放性">1.8.6. 可缩放性</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#2-分布式系统同步">2. 分布式系统同步</a>
      <ul>
        <li><a href="#21-分布式系统时钟同步">2.1. 分布式系统时钟同步</a>
          <ul>
            <li><a href="#211-逻辑时钟同步算法">2.1.1. 逻辑时钟同步算法</a></li>
            <li><a href="#212-物理时钟同步算法">2.1.2. 物理时钟同步算法</a></li>
          </ul>
        </li>
        <li><a href="#22-分布式互斥">2.2. 分布式互斥</a>
          <ul>
            <li><a href="#221-集中式互斥算法">2.2.1. 集中式互斥算法</a></li>
            <li><a href="#222-分布式互斥算法">2.2.2. 分布式互斥算法</a></li>
            <li><a href="#223-令牌环算法">2.2.3. 令牌环算法</a></li>
            <li><a href="#224-三种互斥算法的比较">2.2.4. 三种互斥算法的比较</a></li>
          </ul>
        </li>
        <li><a href="#23分布式选举算法">2.3.分布式选举算法</a>
          <ul>
            <li><a href="#231-欺负算法">2.3.1. 欺负算法</a></li>
            <li><a href="#232-环算法基于没有令牌的环">2.3.2. 环算法（基于没有令牌的环）</a></li>
          </ul>
        </li>
        <li><a href="#24-原子事务">2.4. 原子事务</a>
          <ul>
            <li><a href="#241-事务模型">2.4.1. 事务模型</a></li>
            <li><a href="#242-并发控制">2.4.2. 并发控制</a></li>
          </ul>
        </li>
        <li><a href="#25-分布式系统死锁">2.5. 分布式系统死锁</a>
          <ul>
            <li><a href="#251-分布式死锁检测">2.5.1. 分布式死锁检测</a></li>
            <li><a href="#252-分布式死锁预防">2.5.2. 分布式死锁预防</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#3-分布式路由算法">3. 分布式路由算法</a>
      <ul>
        <li><a href="#31-分布式路由算法导论">3.1. 分布式路由算法导论</a></li>
        <li><a href="#32-一般类型网络的最短路径路由算法">3.2. 一般类型网络的最短路径路由算法</a>
          <ul>
            <li><a href="#321-dijkstra集中式算法">3.2.1. Dijkstra集中式算法</a></li>
            <li><a href="#322-ford分布式算法">3.2.2. Ford分布式算法</a></li>
            <li><a href="#323-arpanet路由算法">3.2.3. ARPAnet路由算法</a></li>
          </ul>
        </li>
        <li><a href="#33-特殊类型网络的单播算法">3.3. 特殊类型网络的单播算法</a>
          <ul>
            <li><a href="#331-双向环k元1维">3.3.1. 双向环（$k$元1维）</a></li>
            <li><a href="#332-网格和圆环k元2维">3.3.2. 网格和圆环（$k$元2维）</a></li>
            <li><a href="#333-超立方2元n维">3.3.3. 超立方（2元$n$维）</a></li>
          </ul>
        </li>
        <li><a href="#34-特殊类型网络中的多播算法">3.4. 特殊类型网络中的多播算法</a>
          <ul>
            <li><a href="#341-一般方法">3.4.1. 一般方法</a></li>
            <li><a href="#342-基于路径的方法">3.4.2. 基于路径的方法</a></li>
            <li><a href="#343-基于树的方法">3.4.3. 基于树的方法</a></li>
          </ul>
        </li>
        <li><a href="#35-虚信道和虚网络">3.5. 虚信道和虚网络</a></li>
        <li><a href="#36-完全自适应和无死锁路由算法">3.6. 完全自适应和无死锁路由算法</a>
          <ul>
            <li><a href="#361-虚信道类">3.6.1. 虚信道类</a></li>
            <li><a href="#362-逃逸信道">3.6.2. 逃逸信道</a></li>
          </ul>
        </li>
        <li><a href="#37-部分自适应和无死锁路由算法">3.7. 部分自适应和无死锁路由算法</a>
          <ul>
            <li><a href="#371-转弯模型二维网格">3.7.1. 转弯模型（二维网格）</a></li>
            <li><a href="#372-平面自适应模型k元n维">3.7.2. 平面自适应模型（$k$元$n$维）</a></li>
          </ul>
        </li>
        <li><a href="#38-容错单播">3.8. 容错单播</a>
          <ul>
            <li><a href="#381-二维网格和圆环">3.8.1. 二维网格和圆环</a></li>
            <li><a href="#382-超立方体">3.8.2. 超立方体</a></li>
          </ul>
        </li>
        <li><a href="#39-容错组播">3.9. 容错组播</a></li>
      </ul>
    </li>
    <li><a href="#4-分布式进程和处理机管理">4. 分布式进程和处理机管理</a>
      <ul>
        <li><a href="#41-分布式系统模型">4.1. 分布式系统模型</a>
          <ul>
            <li><a href="#411-工作站模型">4.1.1. 工作站模型</a></li>
            <li><a href="#412-空闲工作站的利用">4.1.2. 空闲工作站的利用</a></li>
            <li><a href="#413-处理机池模型">4.1.3. 处理机池模型</a></li>
            <li><a href="#414-混合模型">4.1.4. 混合模型</a></li>
          </ul>
        </li>
        <li><a href="#42-分布式处理机分配算法">4.2. 分布式处理机分配算法</a></li>
        <li><a href="#43-分布式进程调度">4.3. 分布式进程调度</a></li>
        <li><a href="#44-分布式系统容错">4.4. 分布式系统容错</a>
          <ul>
            <li><a href="#441-部件错误">4.4.1. 部件错误</a></li>
            <li><a href="#442-系统错误">4.4.2. 系统错误</a></li>
            <li><a href="#443-同步和异步系统容错">4.4.3. 同步和异步系统容错</a></li>
            <li><a href="#444-采用冗余容错">4.4.4. 采用冗余容错</a></li>
            <li><a href="#445-主动复制方法的容错">4.4.5. 主动复制方法的容错</a></li>
            <li><a href="#446-主备份的容错">4.4.6. 主备份的容错</a></li>
            <li><a href="#447-容错系统中的协作一致性">4.4.7. 容错系统中的协作一致性</a></li>
          </ul>
        </li>
        <li><a href="#45-实时分布式系统">4.5. 实时分布式系统</a>
          <ul>
            <li><a href="#451-实时分布式系统的定义">4.5.1. 实时分布式系统的定义</a></li>
            <li><a href="#452-设计问题">4.5.2. 设计问题</a></li>
            <li><a href="#453-实时通讯">4.5.3. 实时通讯</a></li>
            <li><a href="#454-实时调度算法">4.5.4. 实时调度算法</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#5-分布式资源管理">5. 分布式资源管理</a>
      <ul>
        <li><a href="#51-资源管理的基本概念">5.1. 资源管理的基本概念</a></li>
        <li><a href="#52-集中分布资源管理">5.2. 集中分布资源管理</a></li>
        <li><a href="#53-完全分布资源管理">5.3. 完全分布资源管理</a></li>
      </ul>
    </li>
    <li><a href="#6-分布式程序设计">6. 分布式程序设计</a>
      <ul>
        <li><a href="#61-分布式程序设计的特点">6.1. 分布式程序设计的特点</a></li>
        <li><a href="#62-分布式进程">6.2. 分布式进程</a></li>
        <li><a href="#63-分布式进程迁移">6.3. 分布式进程迁移</a></li>
        <li><a href="#64-分布式语言">6.4. 分布式语言</a></li>
      </ul>
    </li>
    <li><a href="#7-移动计算">7. 移动计算</a>
      <ul>
        <li><a href="#71-移动计算的类型">7.1. 移动计算的类型</a>
          <ul>
            <li><a href="#711-移动计算的分类">7.1.1. 移动计算的分类</a></li>
            <li><a href="#712-mobile-computing的通信基础">7.1.2. Mobile Computing的通信基础</a></li>
          </ul>
        </li>
        <li><a href="#72-移动代理简介">7.2. 移动代理简介</a>
          <ul>
            <li><a href="#721-moblie-agent的定义">7.2.1. Moblie Agent的定义</a></li>
            <li><a href="#722-mobile-agent研究内容">7.2.2. Mobile Agent研究内容</a></li>
            <li><a href="#723-mobile-agent的体系结构">7.2.3. Mobile Agent的体系结构</a></li>
            <li><a href="#724-mobile-agent基本技术">7.2.4. Mobile Agent基本技术</a></li>
            <li><a href="#725-mobile-agent的特点">7.2.5. Mobile Agent的特点</a></li>
            <li><a href="#726-mobile-agent的应用">7.2.6. Mobile Agent的应用</a></li>
            <li><a href="#727-尚待研究的其他技术">7.2.7. 尚待研究的其他技术</a></li>
            <li><a href="#727-mobile-agent的发展趋势">7.2.7. Mobile Agent的发展趋势</a></li>
          </ul>
        </li>
        <li><a href="#73-主动网络">7.3. 主动网络</a>
          <ul>
            <li><a href="#731-主动网络的起源">7.3.1. 主动网络的起源</a></li>
            <li><a href="#732-主动网络的概念">7.3.2. 主动网络的概念</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#8-云计算大数据人工智能杂项">8. 云计算&amp;大数据&amp;人工智能杂项</a>
      <ul>
        <li><a href="#81-云计算">8.1. 云计算</a></li>
        <li><a href="#82-大数据发展趋势及其关键技术">8.2. 大数据发展趋势及其关键技术</a></li>
        <li><a href="#83-人工智能的三次浪潮">8.3. 人工智能的三次浪潮</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
      
    
  
</div>

    </div>
</body>

</html>