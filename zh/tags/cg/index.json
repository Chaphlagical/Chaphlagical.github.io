[{"content":"核心思想 用概率表征粗糙网格，用联合密度来实现细分\nOverview 曲面表示定义流形网格$\\Pi=(\\mathcal V,\\mathcal \\varepsilon,\\mathcal F)$，并对顶点$\\mathcal V={\\Theta_i}$独立编码高斯函数$\\Theta_o=(\\mu_i,\\Sigma_i)$，并且用边$\\mathcal\\varepsilon$和面$\\mathcal F$定义拓扑连接性。网格利用协方差矩阵$\\Sigma_i$扩展了网格顶点存储的位置信息$\\mu_i$，称为协方差网格。此方案利用协方差信息，基于顶点高斯基进行细化，引入一系列非线性细分方案：\n 生成协方差网格的方法  通过推断协方差信息 从高斯混合体经过启发式三角剖分得到   应用  使用稀疏控制网格交互尖锐特征 从高斯混合进行高效表面重建    PROBABILISTIC SUBDIVISION SURFACES Probabilistic Refinement\n两个连接的高斯$\\Theta_i$和$\\Theta_j$，需要在它们之间生成光滑轮廓\n联合概率密度：\n$$\nf(\\pmb x|\\Theta_{ij})=\\omega^{-1}f(\\pmb x|\\Theta_i)f(\\pmb x|\\Theta_j)\n$$\n其中：\n$$\n\\omega=\\int_{\\mathbb R^d}f(\\pmb x|\\Theta_i)f(\\pmb x|\\Theta_j)\n$$\n新的细分点则为：\n$$\n\\mu_{ij}=E[\\pmb x|\\Theta_{ij}]\n$$\n进一步地，在$\\Theta_i$和$\\Theta_{ij}$之间细分，有\n$$\nf(\\pmb x|\\Theta_{iij})=\\omega^{-1}f(\\pmb x|\\Theta_{i})f(\\pmb x|\\Theta_{ij})=\\omega^{-1}f(\\pmb x|\\Theta_i)^2f(\\pmb x|\\Theta_j)\n$$\n以此类推：\n$$\nf(\\pmb x|\\Theta_{ij})=\\omega^{-1}f(\\pmb x|\\Theta_i)^{\\alpha_i}f(\\pmb x|\\Theta_j)^{\\alpha_j}\n$$\n概率密度函数的幂增加$\\alpha_i$倍，协方差矩阵$\\Sigma_i$减小$\\alpha_i$倍，对于权重$\\alpha_i$，\n$$\n\\mu_{ij}=(\\alpha_i\\Sigma_i^{-1}+\\alpha_j\\Sigma_j^{-1})^{-1}(\\alpha_i\\Sigma_i^{-1}\\mu_i+\\alpha_j\\Sigma_j^{-1}\\mu_j)\n$$\n对于$n\u0026gt;2$的拓扑连接，扩展到\n$$\nf(\\pmb x|\\Theta_J)=\\omega^{-1}\\prod_{i\\in J}f(\\pmb x|\\Theta_i)^{\\alpha_i}\n$$\n现需要确定权重$\\alpha_i$以保证细分结果为光滑曲面\nChoice of Weights\n重写高斯函数\n$$\nf(\\pmb x|\\Theta_i)=c\\cdot e^{-\\frac{1}{2}\\pmb b(\\pmb x)^Tq_i}\n$$\n$\\pmb b$是二次方多项式基函数，$q_i$为系数向量，代入前式：\n$$\nf(\\pmb x|\\Theta_J)=c\\cdot e^{-\\frac{1}{2}\\pmb b(\\pmb x)^T\\sum_i\\alpha_iq_i}=\nc\\cdot e^{-\\frac{1}{2}\\pmb b(\\pmb x)^TqJ}\n$$\n如果可以把协方差网格$\\Pi=({\\Theta_i,\\mathcal \\varepsilon, \\mathcal F})$映射到混合网格$\\mathcal M^*=({F(\\Theta_i),\\mathcal \\varepsilon, \\mathcal F})$ ，利用线性的方法获得权重\nMapping Function\n定义映射$F:(\\mu,\\Sigma)\\rightarrow q$满足$\\pmb b(\\pmb x)^Tq+c_q=(\\pmb x-\\mu)^T\\Sigma^{-1}(\\pmb x-\\mu)$\n为方便起见，定义：\n$$\n\\pmb b(\\pmb x)^T=(vech(2\\pmb {xx}^T-\\mathrm{diag}(\\pmb x)^2)^T,-2\\pmb x^T)\n$$\n$$\nq=(\\tilde q^T,\\overline q^T)=(vech(\\Sigma^{-1}),\\Sigma^{-1}\\mu)\n$$\n常数项没必要建模\n逆映射$F^{-1}:q\\rightarrow (\\mu,\\Sigma)$\n$$\n\\Sigma=F_\\Sigma^{-1}(q)=[\\tilde q]^{-1}\\\n\\mu=F_\\mu^{-1}(q)=\\Sigma \\overline q\n$$\n$[\\cdot]$为$vech$的逆运算\n结合前式可得\n$$\n\\Sigma_J=[\\tilde q_J]^{-1}\\Big[\\sum_j\\alpha_i\\tilde q_i\\Big]^{-1}=\\Big(\\sum_i\\alpha_i\\Sigma_i^{-1}\\Big)^{-1}\\\n\\mu_J=\\Sigma_J\\Big(\\sum_i\\alpha_i\\overline{q}_i \\Big)=\\Big(\\sum_i\\alpha_i\\Sigma_i^{-1} \\Big)^{-1}\\Big(\\sum_i\\alpha_i\\Sigma_i^{-1}\\mu_i \\Big)\n$$\nCOVMESH GENERATION Gaussian Inference 给定输入网格$\\Pi=(\\mathcal V,\\mathcal \\varepsilon,\\mathcal F)$\n采用顶点估计：\n$$\n\\Sigma_i^v=\\mathrm{cov}(v_i\\cup \\mathcal N(i))+\\sigma_0^2I\n$$\n采用面估计：\n$$\n\\Sigma_i^f=\\mathrm{cov}\\Big(\\prod_j f(\\pmb x|\\Theta_{\\Delta f})\\Big)=\\Big(\\sum_j\\Sigma_{\\Delta j}^{-1}\\Big)^{-1}\n$$\n$$\n\\Sigma_\\Delta j=\\mathrm{cov}(v\\in \\Delta _j)+\\sigma_0^2I\n$$\nTopological Inference Greedy triangulation\n从一个初始种子三角形开始，然后通过添加下一个连接的满足某种似然评估$P(\\Delta_{ijk})$的候选三角形$\\Delta_{ijk}$。\nProbabilistic plausibility grading\nBhattacharyya coefficient：\n$$\nBC_{ij}=\\int_{\\mathbb R^3}\\sqrt{f(\\pmb x|\\Theta_i)f(\\pmb x|\\Theta_j)}\\mathrm d\\pmb x\n$$\n对Gaussian有相似形式：\n$$\nBC_{ij}=|\\tilde \\Sigma|^{-\\frac{1}{2}}|\\Sigma_i\\Sigma_j|^{\\frac{1}{4}}e^{-\\frac{1}{8}(\\mu_i-\\mu_j)\\tilde\\Sigma^{-1}(\\mu_i-\\mu_j)}\n$$\n其中，$\\tilde\\Sigma=(\\Sigma_i+\\Sigma_j)/2$\n概率似然：\n$$\np_{prob}(\\Delta_{ijk})=BC_{ij}\\cdot BC_{jk}\\cdot BC_{ik}\n$$\n仅当其所有三个成对系数都超过最小阈值$BC_{min}$时，才认为候选三角形有效。 较高的$BC_{min}$值更具限制性，并且在其高斯分布的公共密度重叠非常低的区域中跳过三角形，这表明在表面上有实际孔的可能性较高\n基于$∆_{ijk}$及其相邻三角形之间的最小二面角$β_{ijk}$添加几何权重\n$$\np_\\beta(\\Delta_{ijk})=\\beta_{ijk}/\\pi\n$$\n$$\np(\\Delta_{ijk})=p_{prob}(\\Delta_{ijk})\\cdot p_\\beta(\\Delta_{ijk})\n$$\n","description":"","id":0,"section":"posts","tags":["CG","paper"],"title":"论文阅读《Gaussian Product Subdivision Surface》","uri":"https://chaphlagical.github.io/zh/posts/gaussian-product-subdivision-surfaces/"},{"content":"近日编写简易数学库时发现，自己写的向量类无法使用指针进行连续内存访问，而我的类存储数据底层为std::array，属于顺序存储容器，可以通过下述方式进行遍历：\n1 2 3 4  std::array\u0026lt;float, 3\u0026gt; x = { 1,2,3 }; float* p = static_cast\u0026lt;float*\u0026gt;(\u0026amp;x[0]); for (size_t i = 0; i \u0026lt; sizeof(x) / sizeof(float); i++) std::cout \u0026lt;\u0026lt; *(p++) \u0026lt;\u0026lt; std::endl; // 输出1,2,3   而我的向量类会出现乱码，只能说内存分布并不是我想的那样，用sizeof(v)/sizeof(float)测试后，发现该值比正常的直接使用array存储大了近一倍。于是针对类内的所有成员函数进行逐一排查，最后将其中的一个虚函数删去，发现内存回到我要的结果，原来是虚表指针的锅啊，虽然以前在书上看到过但真正实践起来却没能快速意识到。借此机会也温习一下虚函数在C++类的中的内存分布。\n1. Visual Studio查看C++类内存分布的方法 在项目的属性中找到C/C++→命令行，在其他选项中添加命令：\n/d1 reportSingleClassLayoutXXX\r其中XXX为你想显示的类名，或者直接显示所有类的内存分布：\n/d1 reportAllClassLayout\r2. 普通类的内存分布 使用测试代码：\n1 2 3 4 5 6 7 8  class Base { public: void test() {} private: int a; int b; };   这是一个极其简单的类，它的内存分布如下：\n其中，类实例化得到的对象所占用的存储空间只是该对象的数据部分（包括虚指针和虚基类指针，后面提到）所占用的存储空间，而不包括成员函数代码所占用的存储空间。这是由于各对象的函数占用相同空间：\n3. 带虚函数的类的内存分布 使用测试代码：\n1 2 3 4 5 6 7 8 9  class vBase { public: void test() {} virtual void vtest() {} private: int a; int b; };   可以看到其内存分布：\n多出一项虚表指针vfptr，指向虚函数表\n4. 类继承的内存分布 再来看看类继承的情况，普通类的派生类：\n1 2 3 4 5 6 7  class Derv : public Base { public: void test1() {} private: int c; };   内存分布：\n派生类中的内存数据包括基类部分和派生类自己的部分\n带虚函数的类的派生类：\n1 2 3 4 5 6 7  class vDerv : public vBase { public: void test1() {} private: int c; };   内存分布：\n虚表指针被继承了，且仍位于内存排布的起始处，而虚表只有一个，子类并没有重新生成虚表指针，这里不对父类虚函数进行重载，因此虚表中的vtest函数仍然是父类的vtest函数\n再来看看重载了父类虚函数的情况：\n1 2 3 4 5 6 7 8  class vDerv : public vBase { public: void test1() {} virtual void vtest()override {} private: int c; };   内存分布：\n可以看到虚表中的函数指向了子类的结果\n对于多重继承，若所有父类均不含虚成员函数，如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Base1 { public: void test1() {} private: int a; }; class Base2 { public: void test2() {} private: int b; }; class Derv : public Base1, public Base2 { public: void test() {} private: int c; };   内存分布：\n可见派生类依次继承了父类的数据部分\n带虚函数时\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class vBase1 { public: void test() {} virtual void vtest1() {} private: int a; int b; }; class vBase2 { public: void test() {} virtual void vtest2() {} private: int c; int d; }; class vDerv : public vBase1, public vBase2 { public: void test1() {} virtual void vtest1()override {} private: int c; };   内存分布：\n这里vDerv继承自Base1和Base2两个父类，重载了Base1中的vtest1方法，结果和之前讨论的类似\n需要特别注意的是：空基类的继承问题\n例如：\n1 2 3 4 5 6 7 8 9 10 11  class Empty { }; class Derv : public Empty { public: void test() {} private: int c; };   此时内存分布如下：\n发现空基类是不占用内存的，这似乎很符合常识，但直接计算空类的大小时可以发现，sizeof(Empty)的结果为1，也就是说虽然空类不存储任何数据，它仍需要占用一个字节的空间。而进行空基类继承时，会进行空基类优化（empty base class optimization, EBCO），节省空间占用。然而在Visual Studio中进行空基类多继承时又会有奇怪的现象发生：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Empty1 { }; class Empty2 { }; class Derv : public Empty1, public Empty2 { public: void test() {} private: int c; };   内存分布：\n发现多继承时MSVC并没有进行EBCO，查阅资料发现这竟然还是MSVC的一个bug，由于没有进行EBCO，多出来的几个字节由于对齐的原因还得浪费3个字节无用空间。于是为了使子类能够拥有两个基类的特性，不得不将多继承改为链式继承来解决这个问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Empty1 { }; class Empty2: public Empty1 { }; class Derv : public Empty2 { public: void test() {} private: int c; };   内存分布：\n此时可以成功对齐\n5. 复习：C++的内存格局  栈：系统自动分配的空间，只要不特殊声明，就定义在栈区，函数的区域也在栈上。栈是向下增长的。（const 在栈里） 堆：使用动态内存分配的方式可以申请堆空间，用完要手动释放。 全局区：全局变量、静态变量（static） 常量区：代码中的数字，字符等常量，例如’a’，—1.2等 代码区：存放可执行代码，避免频繁的读硬盘。   Data:数据段，要放在可执行文件中的数据，包括堆、栈、以初始化的全局变量 Bss: 未初始化的全局变量，不占用可执行文件的大小 Text: 只读区域，包括常量区和代码区  示例：\n6. 小结 回到最开始的问题，我希望能让我的类能够进行顺序存储访问，现在看来其实非常简单：\n 首先必须使用连续存储结构  成员变量本身必须顺序存储，如数组、顺序容器等 成员变量为单个变量个体（成员变量在类中顺序存储）   避免在类中使用虚函数  引入虚表指针污染内存分布   若使用MSVC，注意空基类多继承无EBCO的坑  ","description":"浅谈C++类的内存分布","id":2,"section":"posts","tags":["C++"],"title":"C++类的内存分布","uri":"https://chaphlagical.github.io/zh/posts/2020-11-15-c++%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"content":"我将在这里分享有趣的知识与技术\n","description":"My Blog","id":4,"section":"","tags":null,"title":"关于","uri":"https://chaphlagical.github.io/zh/about/"},{"content":"课内资料 电子设计实践：课程资料\n人工智能导论：课程资料\n线性电子线路：课程资料\n数字逻辑电路：课程资料\n模式识别导论：课程资料\n自动控制原理：课程资料\n执行器技术：课程资料\n运筹学基础：课程资料\n传感器原理与技术：课程资料\n计算机网络：课程资料 期末总复习\n现代控制理论：课程资料 期末总复习\n微机原理与嵌入式：课程资料 期末总复习\n理论力学：课程资料 期末总复习\n系统辨识：课程资料\n图像处理基础：课程资料\n多媒体系统概论：课程资料\n计算机图形学：课程资料 期末总复习\n数学学习资源 EE364a Convex Optimization：主页链接\n机器人学学习资源 轨迹优化：主页链接\n概率机器人：主页链接\n人工智能学习资源 CSE 599W: Systems for ML：主页链接\nCS231n Convolutional Neural Networks for Visual Recognition：主页链接\n计算机图形学 Ray Tracing系列：主页链接\nPBRB网页版：主页链接\nSPH教程：主页链接\nFluid Simulation for Computer Animation：主页链接\n常用的Github开源项目 Immediate Mode GUI Framework：Dear ImGui\nImGui的扩展：implot，ImGuiFileDialog，ImGuizmo，imgui-markdown\nImGui的Python版本：DearPyGui、pyimgui\n开源自制游戏引擎：octoon，Overload，Hazel，luna-Engine，LumixEngine\n物理引擎：box2d\n模型导入库：tinyobjloader，assimp\nLogging System：spdlog\n获取文件/路径信息：dirent\nEntity Component System：entt\ncmake资源：awesome-cmake\n","description":"本科课程资料（PPT、复习）以及一些本人感兴趣的学习资源","id":5,"section":"posts","tags":["Resource"],"title":"资源资料","uri":"https://chaphlagical.github.io/zh/posts/2020-09-25-resource/"}]