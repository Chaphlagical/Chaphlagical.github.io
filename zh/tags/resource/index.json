[{"content":"近日编写简易数学库时发现，自己写的向量类无法使用指针进行连续内存访问，而我的类存储数据底层为std::array，属于顺序存储容器，可以通过下述方式进行遍历：\n1 2 3 4  std::array\u0026lt;float, 3\u0026gt; x = { 1,2,3 }; float* p = static_cast\u0026lt;float*\u0026gt;(\u0026amp;x[0]); for (size_t i = 0; i \u0026lt; sizeof(x) / sizeof(float); i++) std::cout \u0026lt;\u0026lt; *(p++) \u0026lt;\u0026lt; std::endl; // 输出1,2,3   而我的向量类会出现乱码，只能说内存分布并不是我想的那样，用sizeof(v)/sizeof(float)测试后，发现该值比正常的直接使用array存储大了近一倍。于是针对类内的所有成员函数进行逐一排查，最后将其中的一个虚函数删去，发现内存回到我要的结果，原来是虚表指针的锅啊，虽然以前在书上看到过但真正实践起来却没能快速意识到。借此机会也温习一下虚函数在C++类的中的内存分布。\n1. Visual Studio查看C++类内存分布的方法 在项目的属性中找到C/C++→命令行，在其他选项中添加命令：\n/d1 reportSingleClassLayoutXXX\r其中XXX为你想显示的类名，或者直接显示所有类的内存分布：\n/d1 reportAllClassLayout\r2. 普通类的内存分布 使用测试代码：\n1 2 3 4 5 6 7 8  class Base { public: void test() {} private: int a; int b; };   这是一个极其简单的类，它的内存分布如下：\n其中，类实例化得到的对象所占用的存储空间只是该对象的数据部分（包括虚指针和虚基类指针，后面提到）所占用的存储空间，而不包括成员函数代码所占用的存储空间。这是由于各对象的函数占用相同空间：\n3. 带虚函数的类的内存分布 使用测试代码：\n1 2 3 4 5 6 7 8 9  class vBase { public: void test() {} virtual void vtest() {} private: int a; int b; };   可以看到其内存分布：\n多出一项虚表指针vfptr，指向虚函数表\n4. 类继承的内存分布 再来看看类继承的情况，普通类的派生类：\n1 2 3 4 5 6 7  class Derv : public Base { public: void test1() {} private: int c; };   内存分布：\n派生类中的内存数据包括基类部分和派生类自己的部分\n带虚函数的类的派生类：\n1 2 3 4 5 6 7  class vDerv : public vBase { public: void test1() {} private: int c; };   内存分布：\n虚表指针被继承了，且仍位于内存排布的起始处，而虚表只有一个，子类并没有重新生成虚表指针，这里不对父类虚函数进行重载，因此虚表中的vtest函数仍然是父类的vtest函数\n再来看看重载了父类虚函数的情况：\n1 2 3 4 5 6 7 8  class vDerv : public vBase { public: void test1() {} virtual void vtest()override {} private: int c; };   内存分布：\n可以看到虚表中的函数指向了子类的结果\n对于多重继承，若所有父类均不含虚成员函数，如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Base1 { public: void test1() {} private: int a; }; class Base2 { public: void test2() {} private: int b; }; class Derv : public Base1, public Base2 { public: void test() {} private: int c; };   内存分布：\n可见派生类依次继承了父类的数据部分\n带虚函数时\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class vBase1 { public: void test() {} virtual void vtest1() {} private: int a; int b; }; class vBase2 { public: void test() {} virtual void vtest2() {} private: int c; int d; }; class vDerv : public vBase1, public vBase2 { public: void test1() {} virtual void vtest1()override {} private: int c; };   内存分布：\n这里vDerv继承自Base1和Base2两个父类，重载了Base1中的vtest1方法，结果和之前讨论的类似\n需要特别注意的是：空基类的继承问题\n例如：\n1 2 3 4 5 6 7 8 9 10 11  class Empty { }; class Derv : public Empty { public: void test() {} private: int c; };   此时内存分布如下：\n发现空基类是不占用内存的，这似乎很符合常识，但直接计算空类的大小时可以发现，sizeof(Empty)的结果为1，也就是说虽然空类不存储任何数据，它仍需要占用一个字节的空间。而进行空基类继承时，会进行空基类优化（empty base class optimization, EBCO），节省空间占用。然而在Visual Studio中进行空基类多继承时又会有奇怪的现象发生：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Empty1 { }; class Empty2 { }; class Derv : public Empty1, public Empty2 { public: void test() {} private: int c; };   内存分布：\n发现多继承时MSVC并没有进行EBCO，查阅资料发现这竟然还是MSVC的一个bug，由于没有进行EBCO，多出来的几个字节由于对齐的原因还得浪费3个字节无用空间。于是为了使子类能够拥有两个基类的特性，不得不将多继承改为链式继承来解决这个问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Empty1 { }; class Empty2: public Empty1 { }; class Derv : public Empty2 { public: void test() {} private: int c; };   内存分布：\n此时可以成功对齐\n5. 复习：C++的内存格局  栈：系统自动分配的空间，只要不特殊声明，就定义在栈区，函数的区域也在栈上。栈是向下增长的。（const 在栈里） 堆：使用动态内存分配的方式可以申请堆空间，用完要手动释放。 全局区：全局变量、静态变量（static） 常量区：代码中的数字，字符等常量，例如’a’，—1.2等 代码区：存放可执行代码，避免频繁的读硬盘。   Data:数据段，要放在可执行文件中的数据，包括堆、栈、以初始化的全局变量 Bss: 未初始化的全局变量，不占用可执行文件的大小 Text: 只读区域，包括常量区和代码区  示例：\n6. 小结 回到最开始的问题，我希望能让我的类能够进行顺序存储访问，现在看来其实非常简单：\n 首先必须使用连续存储结构  成员变量本身必须顺序存储，如数组、顺序容器等 成员变量为单个变量个体（成员变量在类中顺序存储）   避免在类中使用虚函数  引入虚表指针污染内存分布   若使用MSVC，注意空基类多继承无EBCO的坑  ","description":"浅谈带虚函数的C++类的内存分布","id":0,"section":"posts","tags":["C++"],"title":"关于C++类的内存分布问题","uri":"https://chaphlagical.github.io/zh/posts/2020-11-16-%E5%85%B3%E4%BA%8Ec++%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E9%97%AE%E9%A2%98/"},{"content":"我将在这里分享有趣的知识与技术\n","description":"My Blog","id":2,"section":"","tags":null,"title":"关于","uri":"https://chaphlagical.github.io/zh/about/"},{"content":"Item 32: Make Sure public inheritance models \u0026ldquo;is-a\u0026rdquo;   public inheritance（公开继承）意味着“is-a”（是一种）的关系\n  如果令class D以public形式继承class B，便是告知C++编译器每个类型为D的对象同时也是一个类型为B的对象，反之不成立\n  考虑public继承\n  1 2  class Person{...}; class student: public Person{...};     每个学生都是人，但并非每个人都是学生\n  在C++中，任何函数如果期望获得一个类型为Person（或pointer-to-Person或reference-to-Person）的实参，也都愿意接受一个Student对象（或pointer-to-Student或reference-to-Student）\n  1 2 3 4 5 6 7 8  void eat(const Person\u0026amp; p);\t// all person will eat void study(const Student\u0026amp; s);\t// only students study Person p; Student s; eat(p);\t// √ eat(s);\t// √ study(p);\t// ×， person is not student study(s);\t// √    “is-a”并非唯一存在于classes之间的关系，另外两个常见的关系是“has-a”（有一个）和“is-implemented-in-terms-of”（根据某物实现出）  Item 33: Avoid hiding inherited names  遮掩名称：作用域相关  1 2 3 4 5 6  int x;\t// global variable void someFunc() { double x;\t// local variable  std::cin\u0026gt;\u0026gt;x; }    当编译器处于someFunc的作用域内并遭受名称x时，它在local作用域内查找是否有什么东西带着这个名称。如果找到了就不再找其他作用域  遮掩继承：derived class作用域被嵌套在base class作用域内\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Base{ private: int x; public: virtual void mf1() = 0; virtual void mf2(); void mf3(); ... }; class Derived: public Base{ public: virtual void mf1(); void mf4(); ... };    假设derived class内的mf4的实现如下：  1 2 3 4 5 6  void Derived::mf4() { ... mf2(); ... }     查找顺序：local作用域 → class Derived作用域 → base class作用域 → 含Base的namespace → global作用域\n  重载\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Base{ private: int x; public: virtual void mf1() = 0; virtual void mf1(int); virtual void mf2(); void mf3(); void mf3(double); ... }; class Derived: public Base{ public: virtual void mf1(); void mf3(); void mf4(); ... };    base class内所有名为mf1和mf3的函数都被derived class内的mf1和mf3函数遮掩掉。从名称查找观点看，Base::mf1和Base::mf3不再被Derived继承  1 2 3 4 5 6 7 8  Derived d; int x; ... d.mf1();\t// √ 调用Derived::mf1 d.mf1(x);\t// × Derived::mf1遮掩了Base::mf1 d.mf2();\t// √ 调用Base::mf2 d.mf3();\t// √ 调用Derived::mf3 d.mf3(x);\t// × Derived::mf3遮掩了Base::mf3     上述规则对base classes和derived classes内的函数有不同的参数类型也适用，而且无论函数是virtual还是non-virtual也适用\n  若继承base class并加上重载函数，有希望重新定义或覆写其中一部分，则必须为那些原本会被遮掩的每个名称引入一个using声明式，否则某些你希望继承的名称会被遮掩\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Base{ private: int x; public: virtual void mf1() = 0; virtual void mf1(int); virtual void mf2(); void mf3(); void mf3(double); ... }; class Derived: public Base{ public: using Base::mf1; using Base::mf3; virtual void mf1(); void mf3(); void mf4(); ... };     继承base classes的部分函数\n 在public继承下是不可能出现的，因为违反了“is-a”关系 在private继承下是有意义的，通过转交函数实现    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Base{ public: virtual void mf1() = 0; virtual void mf1(int); ... }; class Derived: private Base{ public: virtual void mf1() {Base::mf1();}\t// inline转交函数  ... }; ... Derived d; int x; d.mf1();\t// √ 调用Derived::mf1 d.mf1(x);\t// × Base::mf1被遮掩了   Item 34: Differentiate between inheritance of interface and inheritance of implementation   public继承：函数接口继承、函数实现继承\n  pure virtual函数的目的是为了让derived class只继承函数接口\n  non-virtual函数是为了令derived class继承函数扽接口以及一份强制性实现\n  impure virtual函数的目的是让derived class继承函数的接口和缺省实现\n impure virtual函数会让derived class在未声明二点情况下自动继承缺省实现 切断virtual函数接口和缺省实现的一个方法：  1 2 3 4 5 6 7 8 9 10 11  class Airplane{ public: virtual void fly(const Airport\u0026amp; destination) = 0; ... protected: void defaultFly(const Airport\u0026amp; destination); }; void Airplane::defaultFly(const Airport\u0026amp; destination) { // implementation }   使用缺省实现时，只需要：\n1 2 3 4 5 6 7 8 9 10 11 12  class ModelA: public Airplane{ public: virtual void fly(const Airport\u0026amp; destination) {defaultFly(destination);} ... }; class ModelB: public Airplane{ public: virtual void fly(const Airport\u0026amp; destination) {defaultFly(destination);} ... };   这种方法避免了意外继承的现象，下面是该方法的一种优化方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Airplane{ public: virtual void fly(const Airport\u0026amp; destination) = 0; ... }; void Airplane::fly(const Airport\u0026amp; destination) { // implementation } class ModelA: public Airplane{ public: virtual void fly(const Airport\u0026amp; destination) {Airplane::fly(destination);} ... }; class ModelB: public Airplane{ public: virtual void fly(const Airport\u0026amp; destination) {Airplane::fly(destination);} ... };     ","description":"《Effective C++学习笔记第六章》","id":3,"section":"note","tags":["Effective C++","C++"],"title":"Chapter 6: Inheritance and Object-Oriented Design","uri":"https://chaphlagical.github.io/zh/note/effectivecpp/ch6/"},{"content":"1. B样条基函数 1.1. De Boor递推 1.1.1. 单位情况 $k$阶（$k-1$度）单位B样条基函数表示为：\n$$\nN_i^1(t)=\\begin{cases}\n1,\u0026amp;i\\leq t\u0026lt;i+1\\\\0,\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n$$\n$$\n\\begin{align}\nN_i^k(t)\u0026amp;=\\dfrac{t-i}{(i+k-1)-i}N_i^{k-1}(t)+\\dfrac{(i+k)-t}{(i+k)-(i+1)}N_{i+1}^{k-1}(t)\\\\\n\u0026amp;=\\dfrac{t-i}{k-1}N_i^{k-1}(t)+\\dfrac{i+k-t}{k-1}N_{i+1}^{k-1}(t)\n\\end{align}\n$$\n1.1.2. 一般情况   给定：结序列$t_0\u0026lt;t_1\u0026lt;\\cdots\u0026lt;t_n\u0026lt;\\cdots\u0026lt;t_{n+k}$\n（$(t_0,t_1,\\cdots,t_{n+k})$称为结向量）\n  归一化的$k$阶（$k-1$度）单位B样条基函数$N_{i,k}$定义为：\n$$\n\\begin{align}\nN_i^1(t)\u0026amp;=\\begin{cases}\n1,\u0026amp;t_i\\leq t\u0026lt;t_{i+1}\\\\0,\u0026amp;\\mathrm{otherwise}\n\\end{cases}\\\\\nN_{i,k}(t)\u0026amp;=\\dfrac{t-t_i}{t_{i+k-1}-t_i}N_{i,k-1}(t)+\\dfrac{t_{i+k}-t}{t_{i+k}-t_{i+1}}N_{i+1,k-1}(t)\n\\end{align}\n$$\n其中，$k\u0026gt;1$且$i=0,\\cdots,n$\n  1.2. 核心思想  设计基函数$\\pmb b(t)$ 性质：  $\\pmb b(t)$为$C^2$连续 $\\pmb b(t)$是三次分段多项式 $\\pmb b(t)$具有局部控制性质 叠加位移的$\\pmb b(t+i)$组成一个整体的划分 对所有的$t$，有$\\pmb b(t)\\geq 0$   简而言之  基函数中具有所有所需的性质 基函数的线性组合也将有这些性质    1.3. 基函数性质   对$t_i\u0026lt;t\u0026lt;t_{i+k}$，有$N_{i,k}(t)\u0026gt;0$\n  对$t_0\u0026lt;t\u0026lt;t_i$或$t_{i+k}\u0026lt;t\u0026lt;t_{n+k}$，有$N_{i,k}(t)=0$\n  对$t_{k-1}\\leq t\\leq t_{n+1}$，有$\\sum_{i=1}^nN_{i,k}(t)=1$\n  对于$t_i\\leq t_j\\leq t_{i+k}$，基函数$N_{i,k}(t)$在结点$t_j$处有$C^{k-2}$连续性\n  区间$[t_i,t_{i+k}]$称为$N_{i,k}$的支撑（support）\n  2. B样条曲线 2.1. B样条曲线简介   给定$n+1$个控制点$\\pmb d_0,\\cdots,\\pmb d_n\\in \\mathbb R^3$，结向量$T=(t_0,\\cdots,t_n,\\cdots,t_{n+k})$\n  $k$阶B样条曲线$\\pmb x(t)$定义为：\n$$\n\\pmb x(t)=\\sum\\limits_{i=0}^nN_{i,k}(t)\\cdot\\pmb d_i\n$$\n  点$\\pmb d_i$称为de Boor points\n  2.1.1. 重复结向量   B样条曲线允许：$T=(t_0,\\cdots,t_n,\\cdots,t_{n+k})$，$t_0\\leq t_1\\leq \\cdots\\leq t_{n+k}$\n  只要不超过$k$个结重合，B样条函数$N_{i,k}(i=0,\\cdots,n)$的递归定义依然有效\n  多结重合的效果：\n 设：$t_0=t_1=\\cdots=t_{k-1}$ 且$t_{n+1}=t_{n+2}=\\cdots=t_{n+k}$  则将插值$\\pmb d_0$和$\\pmb d_n$\n  2.2. B样条的性质 2.2.1. B样条函数 vs Bernstein多项式 结向量$T=(t_0,t_1,\\cdots,t_{2k-1})=(\\underbrace{0,\\cdots,0}_k,\\underbrace{1,\\cdots,1}_k)$下的$k$阶B样条函数$N_{i,k}(i=0,\\cdots,k-1)$为$k-1$次Bernstein多项式$B_i^{k-1}$\n2.2.2. 基本性质   给定\n $T=(\\underbrace{t_0,\\cdots,t_0}_{k\\ \\mathrm{times}},t_k,\\cdots,t_n,\\underbrace{t_{n+1},\\cdots,t_{n+1}}_{k\\ \\mathrm{times}})$ de Boor多边形$\\pmb d_0,\\cdots,\\pmb d_n$    相应的B样条曲线$\\pmb x(t)$有以下性质：\n  $\\pmb x(t_0)=\\pmb d_0$，$\\pmb x(t_{n+1})=\\pmb d_n$（边界点插值）\n  $\\dot{\\pmb x}(t_0)=\\dfrac{k-1}{t_k-t_0}(\\pmb d_1-\\pmb d_0)$（$\\pmb d_0$处的切线方向与$\\pmb d_n$处相似）\n  $\\pmb x(t)$由$n-k+2$个$k-1$次多项式曲线段构成\n  多重内部结$\\Rightarrow$减小了$\\pmb x(t)$的连续阶数\n$l$重内部结$(1\\leq l\u0026lt;k)$意味着$C^{k-l-1}$阶连续\n  de Boor点的局部影响：移动$\\pmb d_i$只会改变曲线的$[t_i,t_{i+k}]$区间部分\n  插入新的de Boor点不会改变曲线段的多项式阶数\n    2.2.3. B样条曲线的局部性 2.2.4. B样条曲线的升阶   使用B样条函数\n  使用de Boor算法\n与Bezier曲线的de Casteljau算法类似，在Boor多边形上进行一系列的线性插值\n  2.3. de Boor算法   给定：\nde Boor点：$\\pmb d_0,\\cdots,\\pmb d_n$\n结向量：$(t_0,\\cdots,t_{k-1}=t_0,t_k,t_{k+1},\\cdots,t_n,t_{n+1},\\cdots,t_{n+k}=t_{n+1})$\n  目标：$k$结B样条曲线的曲线点$\\pmb x(t)$\n  算法流程：\n  中间系数$\\pmb d_i^j(t)$可以表示为一个下三角矩阵——de Boor图\n$$\n\\begin{matrix}\n\\pmb d_{r-k+1}=\\pmb d^0_{r-k+1}\\\\\n\\pmb d_{r-k+2}=\\pmb d^0_{r-k+2}\u0026amp;\\pmb d_{r-k+2}^1\\\\\n\\vdots\\\\\n\\pmb d_{r-1}=\\pmb d_{r-1}^0\u0026amp;\\pmb d_{r-1}^1\u0026amp;\\cdots\u0026amp;\\pmb d_{r-1}^{k-2}\\\\\n\\pmb d_r=\\pmb d_r^0\u0026amp;\\pmb d_r^1\u0026amp;\\cdots\u0026amp;\\pmb d_r^{k-2}\u0026amp;\\pmb d_r^{k-1}=\\pmb x(t)\n\\end{matrix}\n$$\n  2.4. B样条曲线插值   给定：$n+1$个控制点$\\pmb k_0,\\cdots,\\pmb k_n$，结序列$s_0,\\cdots,s_n$\n  目标：分段三次插值B样条曲线$\\pmb x$\n  方法：分段三次$\\Rightarrow k=4$\n $\\pmb x(t)$由$n$段组成$\\Rightarrow n+3$个de Boor点    实例：$n=3$\n  若选择结向量\n$$\n\\begin{align}\nT\u0026amp;=(t_0,t_1,t_2,t_3,t_4,\\cdots,t_{n+2},t_{n+3},t_{n+4},t_{n+5},t_{n+6})\\\\\n\u0026amp;=(s_0,s_0,s_0,s_0,s_1,\\cdots,s_{n-1},s_n,s_n,s_n,s_n)\n\\end{align}\n$$\n  插值条件：\n$$\n\\begin{align}\n\\pmb x(s_0)\u0026amp;=\\pmb k_0=\\pmb d_0\\\\\n\\pmb x(s_i)\u0026amp;=\\pmb k_i=N_{i,4}(s_i)\\pmb d_i+N_{i+1,4}(s_i)\\pmb d_{i+1}+N_{i+2,4}(s_i)\\pmb d_{i+2}\\\\\n\u0026amp;\\mathrm{for}\\ i=1,\\cdots,n-1\\\\\n\\pmb x(s_n)\u0026amp;=\\pmb k_n=\\pmb d_{n+2}\n\\end{align}\n$$\n  共计：$n+1$个条件解$n+3$个未知的de Boor点\n$\\Rightarrow$ 2个终值条件\n  natural end condition\n$$\n\\begin{align}\n\\ddot{\\pmb x}(s_0)\u0026amp;=0\\Leftrightarrow \\dfrac{\\pmb d_2-\\pmb d_1}{s_2-s_0}=\\dfrac{\\pmb d_1-\\pmb d_0}{s_1-s_0}\\\\\n\\ddot{\\pmb x}(s_n)\u0026amp;=0\\Leftrightarrow \\dfrac{\\pmb d_{n+2}-\\pmb d_{n+1}}{s_n-s_{n-1}}=\\dfrac{\\pmb d_{n+1}-\\pmb d_n}{s_n-s_{n-2}}\n\\end{align}\n$$\n  结果可以表示为求解对角系统方程：\n$$\n\\begin{pmatrix}\n1\\\\\n\\alpha_0\u0026amp;\\beta_0\u0026amp;\\gamma_0\\\\\n\u0026amp;\\alpha_1\u0026amp;\\beta_1\u0026amp;\\gamma_1\\\\\n\u0026amp;\u0026amp;\u0026amp;\\ddots\\\\\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\alpha_{n-1}\u0026amp;\\beta_{n-1}\u0026amp;\\gamma_{n-1}\\\\\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\alpha_n\u0026amp;\\beta_n\u0026amp;\\gamma_n\\\\\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;1\n\\end{pmatrix}\n\\begin{pmatrix}\n\\pmb d_0\\\\pmb d_1\\\\\\pmb d_2\\\\\\vdots\\\\\\pmb d_n\\\\\n\\pmb d_{n+1}\\\\\\pmb d_{n+2}\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\pmb k_0\\\\\\pmb 0\\\\\\pmb k_1\\\\\\vdots\\\\\\pmb k_{n-1}\\\\\n\\pmb 0\\\\\\pmb k_{n}\n\\end{pmatrix}\n$$\n其中，\n  $$\n\\begin{align}\n\\alpha_0\u0026amp;=s_2-s_0\\\\\n\\beta_0\u0026amp;=-(s_2-s_0)-(s_1-s_0)\\\\\n\\gamma_0\u0026amp;=s_1-s_0\\\\\n\\alpha_n\u0026amp;=s_n-s_{n-1}\\\\\n\\beta_n\u0026amp;=-(s_n-s_{n-1})-(s_n-s_{n-2})\\\\\n\\gamma_n\u0026amp;=s_n-s_{n-2}\\\\\n\\alpha_i\u0026amp;=N_{i,4}(s_i)\\\\\n\\beta_i\u0026amp;=N_{i+1,4}(s_i)\\\\\n\\gamma_i\u0026amp;=N_{i+2,4}(s_i)\\\\\n\\mathrm{for}\u0026amp;\\ i=1,\\cdots,n-1\n\\end{align}\n$$\n  解法\n 托马斯算法——解决对角系统方程 复杂度$O(n)$ 仅适用于对角占优矩阵  对于对角系统方程\n$$\n\\begin{pmatrix}\nb_1\u0026amp;c_1\u0026amp;\u0026amp;\u0026amp;0\\\\\na_2\u0026amp;b_2\u0026amp;c_2\\\\\n\u0026amp;a_3\u0026amp;b_3\u0026amp;\\cdot\u0026amp;\\\\\n\u0026amp;\u0026amp;\\cdot\u0026amp;\\cdot\u0026amp;c_{n-1}\\\\\n0\u0026amp;\u0026amp;\u0026amp;a_n\u0026amp;b_n\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1\\\\x_2\\\\\\vdots\\\\x_n\n\\end{pmatrix}=\n\\begin{pmatrix}\nd_1\\\\d_2\\\\\\vdots\\\\d_n\n\\end{pmatrix}\n$$\n求解流程：\n  前向消除阶段\n  后向替代阶段\n    2.5. Bezier曲线转B样条曲线   给定\n控制点：$\\pmb k_0,\\cdots,\\pmb k_n$\n结序列：$t_0,\\cdots,t_n$\n2个终值条件\n$\\pmb b_0,\\cdots,\\pmb b_{3n}$：用于$C^2$连续插值三次Bezier样条曲线的Bezier点\n  目标：一些B样条形式的曲线\n  结向量\n$$\nT=(t_0,t_0,t_0,t_0,t_1,\\cdots,t_{n-1},t_n,t_n,t_n,t_n)\n$$\n  $\\pmb d_0,\\cdots,\\pmb d_{n+2}$由下列式子决定：\n$$\n\\begin{align}\n\\pmb d_0\u0026amp;=\\pmb b_0\\\\\n\\pmb d_1\u0026amp;=\\pmb b_1\\\\\n\\pmb d_i\u0026amp;=\\pmb b_{3i-4}+\\frac{\\Delta_{i-1}}{\\Delta_{i-2}}(\\pmb b_{3i-4}-\\pmb b_{3i-5})\\ \\mathrm{for}\\ i=2,\\cdots,n\\\\\n\\pmb d_{n+1}\u0026amp;=\\pmb b_{3n-1}\\\\\n\\pmb d_{n+2}\u0026amp;=\\pmb b_{3n}\n\\end{align}\n$$\n其中，$\\Delta_i=t_{i+1}-t_i\\quad \\mathrm{for}\\quad i=0,\\cdots,n-1$\n  逆问题同样可解\n  3. Bezier和B样条曲线小结  由$n+1$个控制点$\\pmb b_0,\\cdots,b_n$决定的Bezier曲线  $n$次多项式曲线 由控制点唯一确定 边界点作插值，其他点作逼近 控制点的伪局部影响   由控制点$\\pmb k_0,\\cdots,\\pmb k_n$插值的三次Bezier样条曲线  由$n$个分段三次曲线段组成 控制点处有$C^2$连续性 由参数化（如结序列）和两个终值条件唯一确定 插值所有控制点 控制点的伪局部影响   由控制点$\\pmb d_0,\\cdots,\\pmb d_n$和结向量$T=(t_0,t_0,t_0,t_0,t_1,\\cdots,t_{n-1},t_n,t_n,t_n,t_n)$得到的分段三次B样条曲线  由在结点处具有$C^2$连续状态的$n-2$条分段三次曲线段组成 由$\\pmb d_i$和$T$唯一确定 边界点插值，其余点逼近 de Boor点局部影响   通过控制点$\\pmb k_0,\\cdots,k_n$插值三次B样条  对每个$x,y,z$分量，可以使用2个终值条件和求解一个对角线矩阵系统方程来实现类似3.的效果 与2. 的曲线相同    ","description":"B样条学习笔记","id":4,"section":"note","tags":["CAGD"],"title":"CAGD(5) | B样条","uri":"https://chaphlagical.github.io/zh/note/cagd/cagd5/"},{"content":"1. 参数与几何连续性 1.1. 参数连续性   连接曲线——连续性\n  给定两条曲线\n$$\n\\begin{align}\n\u0026amp;\\pmb x_1(t)\\ \\mathrm{over}\\ [t_0,t_1]\\\n\u0026amp;\\pmb x_2(t)\\ \\mathrm{over}\\ [t_1,t_2]\n\\end{align}\n$$\n  若$\\pmb x_1$和$\\pmb x_2$在$t_1$处的0阶到$r$阶导数向量均重合，则$\\pmb x_1$与$\\pmb x_2$在$t_1$处$C^r$连续\n    常见的参数连续性：\n $C^0$：位置变化连续（position varies continuously） $C^1$：一阶导数在交界处连续（First derivative is continuous across junction）  速度向量相同   $C^2$：二阶导数在交界处连续（Second derivative is continuous across junction）  加速度向量相同      1.2. 几何连续性   曲线的几何连续性\n  给定两条曲线\n$$\n\\begin{align}\n\u0026amp;\\pmb x_1(t)\\ \\mathrm{over}\\ [t_0,t_1]\\\n\u0026amp;\\pmb x_2(t)\\ \\mathrm{over}\\ [t_1,t_2]\n\\end{align}\n$$\n  若$\\pmb x_1$和$\\pmb x_2$能够以某种方式重新参数化使得在$t_1$处$C^r$连续，则$\\pmb x_1$和$\\pmb x_2$在$t_1$处$G^r$连续\n    常见的几何连续性\n $G^0=C^0$：位置变化连续性（连接性）（position varies continuously） $G^1$：切线方向变化连续性（相同切线）（ tangent direction varies continuously ）  正则化切线变化连续 等价于曲线能够重新参数化到$C^1$ 等价于单位速度参数化为$C^1$   $G^2$：曲率变化连续性（相同切线与曲率）（curvature varies continuously）  等价于曲线能够重新参数化到$C^2$ 等价于单位速度参数化为$C^2$      1.3. 参数连续性 vs 几何连续性    参数连续性$C^r$ 几何连续性$G^r$     $C^0,C^1,\\cdots$连续 曲线本身是否光滑   在该曲线上运动的粒子是否有光滑的轨迹？（位置、速度、加速度） 独立于参数化方式   取决于参数化方式 与建模更相关（曲线设计）   应用：动画（物体移动、摄像头轨迹）     2. Bezier样条参数化 2.1. Bezier样条曲线的局部和全局参数  给定  $\\pmb b_0,\\cdots,\\pmb b_n$ $\\pmb y(u)$：间隔$[0,1]$之间的Bezier曲线 $\\pmb x(t)$：间隔$[t_i,t_{i+1}]$之间的Bezier曲线   设置$u(t)=\\dfrac{t-t_i}{t_{i+1}-t_i}$ 结果：$\\pmb x(t)=\\pmb y(u(t))$  局部参数$u$从0变化到1，全局参数$t$从$t_i$变化到$t_{i+1}$\n2.2. Bezier样条曲线的导数 $$\n\\begin{align}\n\\dot{\\pmb x}(t)\u0026amp;=\\dot{\\pmb y}(u(t))\\cdot\\dot u(t)=\\dfrac{\\dot{\\pmb y}(u(t))}{t_{i+1}-t_i}\\\\\n\\ddot{\\pmb x}(t)\u0026amp;=\\ddot{\\pmb y}(u(t))\\cdot(\\dot u(t))^2+\\dot{\\pmb y}(u(t))\\cdot\\ddot u(t)=\\dfrac{\\ddot{\\pmb y}(u(t))}{(t_{i+1}-t_i)^2}\\\\\n\\cdots\\\\\n\\pmb x^{[n]}(t)\u0026amp;=\\dfrac{\\pmb y^{[n]}(u(t))}{(t_{i+1}-t_i)^n}\n\\end{align}\n$$\n2.3. Bezier曲线 $$\n\\pmb f(t)=\\sum_{i=0}^nB_i^n(t)\\pmb p_i\n$$\n  ${0,1}$之间的函数值\n$$\n\\begin{align}\n\\pmb f(0)\u0026amp;=\\pmb p_0\\\n\\pmb f(1)\u0026amp;=\\pmb p_1\\\n\\end{align}\n$$\n  ${0,1}$之间的一阶导数向量\n$$\n\\begin{align}\n\\pmb f'(0)\u0026amp;=n[\\pmb p_1-\\pmb p_0]\\\n\\pmb f'(1)\u0026amp;=n[\\pmb p_n-\\pmb p_{n-1}]\\\n\\end{align}\n$$\n  ${0,1}$之间的二阶导数向量\n$$\n\\begin{align}\n\\pmb f''(0)\u0026amp;=n(n-1)[\\pmb p_2-2\\pmb p_1+\\pmb p_0]\\\\\n\\pmb f''(1)\u0026amp;=n(n-1)[\\pmb p_n-2\\pmb p_{n-1}+\\pmb p_{n-2}]\\\n\\end{align}\n$$\n  2.4. Bezier样条曲线的特殊情况 $$\n\\begin{align}\n\\dot{\\pmb x}(t_i)\u0026amp;=\\dfrac{n(\\pmb b_1-\\pmb b_0)}{t_{i+1}-t_i}\\\\\n\\dot{\\pmb x}(t_{i+1})\u0026amp;=\\dfrac{n(\\pmb b_n-\\pmb b_{n-1})}{t_{i+1}-t_i}\\\\\n\\ddot{\\pmb x}(t_i)\u0026amp;=\\dfrac{n(n-1)(\\pmb b_2-2\\pmb b_1+\\pmb b_0)}{(t_{i+1}-t_i)^2}\\\\\n\\ddot{\\pmb x}(t_{i+1})\u0026amp;=\\dfrac{n(n-1)(\\pmb b_n-2\\pmb b_{n-1}+\\pmb b_{n-2})}{(t_{i+1}-t_i)^2}\\\\\n\\end{align}\n$$\n2.5. Bezier样条的一般情况   连接Beizer曲线\n  给定两条$n$阶Bezier曲线：\n$$\n\\begin{align}\n\\pmb k_{j-1}\u0026amp;=\\pmb b_0^-,\\pmb b_1^-,\\cdots,\\pmb b_n^-=\\pmb k_j\\\\\n\\pmb k_j\u0026amp;=\\pmb b_0^+,\\pmb b_1^+,\\cdots,\\pmb b_n^+=\\pmb k_{j+1}\n\\end{align}\n$$\n  要求：$\\pmb k_j$处$C^1$连续\n  $\\pmb b_{n-1}^-,\\pmb k_j,\\pmb b_1^+$不共线且\n$$\n\\dfrac{\\pmb b_n^\u0026ndash;\\pmb b_{n-1}^-}{t_j-t_{j-1}}=\\dfrac{\\pmb b_1^+-\\pmb b_0^+}{t_{j+1}-t_j}\n$$\n    4. Bezier样条阶数 4.1. 可选的方案  $d=0$，分段常数（piecewise constant）：不光滑 $d=1$，分段线性（piecewise linear）：不够光滑 $d=2$，分段二次（piecewise quadratic）：二阶导数为常数，不够灵活 $d=3$，分段三次（piecewise cubic）：计算机图形学应用中常用的阶数  4.2. 三次样条 4.2.1. 三次分段多项式   我们可以在不固定整个曲线的二阶导数的情况下获得$C^2$连续性（？）\n  $C^2$连续性在直觉上很重要\n  运动：连续的位移、速度和加速度\n非连续的加速度是可察觉的（物体、摄像机运动）\n  可以看到二阶阴影不连续（反射性的物体）\n    在所有点集内插得到的$C^2$曲线中（满足相同的始末状态），分段三次曲线拥有最小的积分加速度（即所能获得的最光滑的曲线）\n  4.2.3. 应用  三次Bezier曲线被广泛使用 更高阶的Bezier曲线较少使用（某些CAD/CAM应用） 典型的：\u0026ldquo;points\u0026amp;handles\u0026quot;接口 四种模式  不连续（两条曲线） $C^0$连续（两个点重合） $G^1$连续（切向连续）  处理点指向同一方向，但长度不同   $C^1$连续  处理点有对称向量     $C^2$的限制更大：通过$k_i$进行控制  5. Bezier样条的连续性 5.1. Bezier样条连续性规则 连接多条曲线段，需要确定使曲线有$C^{-1},C^0，C^1，C^2$连续性的控制点约束\n$C^0$连续性\n 每个样条线段内插第一个和最后一个控制点 相邻线段的点必须重合以获得$C^0$连续性  $C^1$连续性\n 切向量与向量差$\\pmb p_1-\\pmb p_0,\\pmb p_n-\\pmb p_{n-1}$成正比 这些向量应相同以满足$C^1$连续性  $C^2$连续性\n $\\mathrm d^2/\\mathrm dt^2$向量与$\\pmb p_2-2\\pmb p_1+\\pmb p_0$和$\\pmb p_n-2\\pmb p_{n-1}+\\pmb p_{n-2}$成正比 切线必须相同 下示阴影三角形必须相似  $G^1$连续性\n能够被参数化为$C^1$，只需按切线向量长度的比率增加第二个曲线段的速度\n6. Bezier样条曲线 6.1. 在某点处$C^2$连续 要求：在$\\pmb k_j$处$C^2$连续\n  $C^1$意味着\n$$\n\\dfrac{\\pmb b_n^\u0026ndash;\\pmb b_{n-1}^-}{t_j-t_{j-1}}=\\dfrac{\\pmb b_1^+-\\pmb b_0^+}{t_{j+1}-t_j}\n$$\n  $C^2$意味着\n$$\n\\dfrac{\\pmb b_n^\u0026ndash;2\\pmb b_{n-1}^-+\\pmb b_{n-2}^-}{(t_j-t_{j-1})^2}=\\dfrac{\\pmb b_2^+-2\\pmb b_1^++\\pmb b_0^+}{(t_{j+1}-t_j)^2}\n$$\n  令\n$$\n\\pmb d^-=\\pmb b_{n-1}^-+\\dfrac{\\Delta_j}{\\Delta_{j-1}}(\\pmb b_{n-1}^\u0026ndash;\\pmb b_{n-2}^-)\n$$\n和\n$$\n\\pmb d^+=\\pmb b_1^+-\\dfrac{\\Delta_{j-1}}{\\Delta_j}(\\pmb b_2^+-\\pmb b_1^+)\n$$\n则有：\n$C^2$连续性$\\Leftrightarrow C^1$连续性+$\\pmb d^-=\\pmb d^+$\n  6.2. 曲线的$G^2$连续性 一般情况下的$G^2$连续性（对所有类型的曲线）\n  给定\n $\\pmb x_1(t)$和$\\pmb x_2(t)$满足 $\\pmb x_1(t_i)=\\pmb x_2(t_i)=\\pmb x(t_i)$ $\\dot{\\pmb x}_1(t_i)=\\dot{\\pmb x}_2(t_i)=\\dot{\\pmb x}(t_i)$    满足在$t=t_i$处$G^2$连续的条件是：\n$$\n\\ddot{\\pmb x}_2(t_i)-\\ddot{\\pmb x}_1(t_i)\\parallel \\dot{\\pmb x}(t_i)\n$$\n  6.3. 某点的$G^2$连续性   要求：曲线在点$\\pmb k_j$处$G^2$连续\n  $G^1$连续\n  $\\pmb b_{n-2}^-,\\pmb b_{n-1}^-,\\pmb k_j,\\pmb b_1^+,\\pmb b_2^+$五个向量共面\n  且面积\n$$\n\\dfrac{\\mathrm{area}(\\pmb b_{n-2}^-,\\pmb b_{n-1}^-,\\pmb k_j)}{\\mathrm {area}(\\pmb k_j,\\pmb b_1^+,\\pmb b_2^+)}=\\dfrac{a^3}{b^3}\n$$\n  7. $C^2$三次Bezier样条曲线 7.1. 三次Bezier样条曲线   给定\n$$\n\\begin{align}\n\\pmb k_0,\\cdots,\\pmb k_n\u0026amp;\\in\\mathbb R^3\\\\\nt_0,\\cdots,t_n\u0026amp;\\in\\mathbb R\\\\\nt_i\u0026lt;t_{i+1}\\ \\mathrm{for}\\ \u0026amp;i=0,\\cdots,n_1\n\\end{align}\n$$\n  目标：插值$C^2$连续分段三次Bezier样条曲线的Bezier点$\\pmb b_0,\\cdots,\\pmb b_{3n}$\n  例子：\n $3n+1$未知点 $\\pmb b_{3i}=\\pmb k_i$，$i=0,\\cdots,n$，共$n+1$个方程 点$\\pmb k_i$处$C^1$连续，$i=1,\\cdots,n-1$，共$n-1$个方程 点$\\pmb k_i$处$C^2$连续，$i=1,\\cdots,n-1$，共$n-1$个方程 两个结束条件方程    7.2. 结束条件 7.2.1. Bessel end condition   $\\pmb k_0$处的切向量等价于插值${\\pmb k_0,\\pmb k_1,\\pmb k_2}$的抛物线在$\\pmb k_0$处的切向量\n  抛物线插值${\\pmb k_0,\\pmb k_1,\\pmb k_2}$\n$$\n\\pmb p(t)=\n\\dfrac{(t_2-t)(t_1-t)}{(t_2-t_0)(t_1-t_0)}\\pmb k_0+\n\\dfrac{(t_2-t)(t-t_0)}{(t_2-t_1)(t_1-t_0)}\\pmb k_1+\n\\dfrac{(t_0-t)(t_1-t)}{(t_2-t_1)(t_2-t_0)}\\pmb k_2\n$$\n  插值抛物线导数\n$$\n\\dot{\\pmb p}(t_0)=\n-\\dfrac{(t_2-t_0)+(t_1-t_0)}{(t_2-t_0)(t_1-t_0)}\\pmb k_0+\n\\dfrac{(t_2-t_0)}{(t_2-t_1)(t_1-t_0)}\\pmb k_1-\n\\dfrac{(t_1-t_0)}{(t_2-t_1)(t_2-t_0)}\\pmb k_2\n$$\n  $\\pmb b_1$的位置\n$$\n\\pmb b_1=\\pmb b_0+\\dfrac{t_1-t_0}{3}\\dot{\\pmb p}(t_0)\n$$\n  7.2.2. Natural end condition $$\n\\begin{align}\n\\ddot {\\pmb x}(t_0)\u0026amp;=0\\Leftrightarrow \\pmb b_1=\\dfrac{\\pmb b_2+\\pmb b_0}{2}\\\\\n\\ddot{\\pmb x}(t_n)\u0026amp;=0\\Leftrightarrow \\pmb b_{3n-1}=\\dfrac{\\pmb b_{3n-2}+\\pmb b_{3n}}{2}\n\\end{align}\n$$\n7.3. 参数化 7.3.1. 问题描述  给定：控制点$\\pmb k_0,\\cdots,\\pmb k_n$以及结序列$t_0\u0026lt;\\cdots\u0026lt;t_n$ 目标：插值曲线 问题：通常情况下，结序列未给定，但会影响曲线的走势  7.3.2. Equidistant (uniform) parameterization  $t_{i+1}-t_i=\\mathrm{const}$ 例如：$t_i=t$ 不考虑数据点的几何形状  7.3.3. Chordal parameterization  $t_{i+1}-t_i=\\Vert \\pmb k_{i+1}-\\pmb k_i\\Vert$ 参数间隔与相邻控制点的距离成正比  7.3.4. Centripetal parameterization  $t_{i+1}-t_i=\\sqrt{\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert}$  7.3.5. Foley parameterization  涉及控制多边形的角度 $t_{i+1}-t_i=\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert\\cdot\\Big(1+\\dfrac{3}{2}\\dfrac{\\hat\\alpha_i\\Vert\\pmb k_i-\\pmb k_{i-1}\\Vert}{\\Vert\\pmb k_i-\\pmb k_{i-1}\\Vert+\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert}+\\dfrac{3}{2}\\dfrac{\\hat\\alpha_{i+1}\\Vert \\pmb k_{i+1}-\\pmb k_i\\Vert}{\\Vert\\pmb k_{i+1}-\\pmb k_i\\Vert+\\Vert\\pmb k_{i+2}-\\pmb k_{i+1}\\Vert} \\Big)$ 其中，$\\hat\\alpha_i=\\min\\Big(\\pi-\\alpha_i,\\dfrac{\\pi}{2}\\Big)$ 且$\\alpha_i=\\mathrm{angle}(\\pmb k_{i-1},\\pmb k_i,\\pmb k_{i+1})$  7.3.6. Affine invariant parameterization  基于仿射不变距离测度的参数化  7.4. 闭合曲线 7.4.1. 问题描述   给定：\n控制点：$\\pmb k_0,\\cdots,\\pmb k_{n-1},\\pmb k_n=\\pmb k_0$\n结序列：$t_0\u0026lt;\\cdots\u0026lt;t_n$\n  分段三次曲线的结束条件：\n$$\n\\begin{align}\n\\dot{\\pmb x}(t_0)\u0026amp;=\\dot{\\pmb x}(t_n)\\\n\\ddot{\\pmb x}(t_0)\u0026amp;=\\ddot{\\pmb x}(t_n)\n\\end{align}\n$$\n  7.4.2. 闭合三次Bezier样条曲线   $C^2$连续且曲线闭合\n  闭合曲线的优势：无需选择结束条件\n  例子：\n$n=3$\n  ","description":"Bezier样条学习笔记","id":5,"section":"note","tags":["CAGD"],"title":"CAGD(4) | Bezier样条","uri":"https://chaphlagical.github.io/zh/note/cagd/cagd4/"},{"content":"Item 26：Postpone variable definitions as long as possible   只要定义了一个变量而其类型带有一个构造函数或析构函数，那么当程序的控制流到达这个变量定义式时，就得承受构造成本；当这个变量离开作用域时，便得承受析构成本。即使这个变量最终并未被使用，仍需耗费这些成本。\n  过早定义变量的一个例子：\n  1 2 3 4 5 6 7 8 9 10  std::string encryptPassword(const std::string\u0026amp; password) { using namespace std; string encrypted; if(password.length()\u0026lt;MinimumPasswordLength){ throw logic_error(\u0026#34;Password is too short\u0026#34;); } ... return encrypted; }     如果函数encryptPassword丢出异常，仍得付出encrypted的构造成本和析构成本\n  延后变量的定义\n  1 2 3 4 5 6 7 8  std::string encryptPassword(const std::string\u0026amp; password) { ... std::string encrypted(password); encrypt(encrypted); return encrypted; }    延后变量定义直到非得使用该变量的前一刻为止，甚至应尝试延后到能够给它初值实参为止 避免构造/析构非必要对象，避免无意义的default构造行为  循环情况\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  //\t方法A：定义于循环外 Widget w; for(int i=0;i\u0026lt;n;i++) { w=...; ... } //\t方法B：定义于循环内 for(int i=0;i\u0026lt;n;i++) { Widget w...; ... }    方法A：1个构造函数+1个析构函数+n个赋值操作 方法B：n个构造函数+n个析构函数 除非你知道赋值成本比“析构+构造”低、你正在处理代码中效率高度敏感的部分，否则应该使用做法B  Item 27：Minimize casting   旧式转型\n (T)expression：C-style T(expression)：函数风格    新式转型\n const_cast\u0026lt;T\u0026gt;(expression)  const_cast通常用来将对象的常量性移除，也是唯一具有此能力的C++-style转型操作符   dynamic_cast\u0026lt;T\u0026gt;(expression)  dynamic_cast主要用来执行“安全向下转型”，用来决定某对象是否归属继承体系中的某个类型 唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作   reinterpret_cast\u0026lt;T\u0026gt;(expression)  reinterpret_cast意图执行低级转型，实际动作可能取决于编译器，这也表示它不可移植   static_cast\u0026lt;T\u0026gt;(expression)  static_cast用来强迫隐式转换      新式转型相较旧式转型的好处\n 容易在代码中被辨识出来，简化“找出类型系统在哪个地点被破坏”的过程 各转型动作的目标越窄化，编译器越可能诊断出错误的运用    任何一种类型转换往往真的令编译器编译出运行期间执行的码，而不是简单地将一种类型视为另外一种类型\n  对象地布局方式和他们的地址计算方式随编译器的不同而不同，意味着“由于知道对象如何布局”而设计的转型，在某一平台上行得通，在其他平台并不一定行得通\n  类继承的转型问题\n  1 2 3 4 5 6 7 8 9 10 11 12 13  class Window{ public: virtual void onResize() {...} ... }; class SpecialWindow: public Window{ public: virtual void Resize(){ static_cast\u0026lt;Window\u0026gt;(*this).onResize(); ... } ... };    上述代码并非是在当前对象上调用Window::onResize之后在该对象上执行SpecialWindow专属动作 而是在当前对象的base class成分的副本上调用Window::onResize，任何在当前对象身上执行SpecialWindow专属动作  正确的写法应该是：\n1 2 3 4 5 6 7 8  class SpecialWindow: public Window{ public: virtual void Resize(){ Window::onResize(); ... } ... };     dynamic_cast的避免\n dynamic_cast的应用场景：你想在一个你认为derived class对象身上执行derived class操作函数，但你的手上只有一个指向base的pointer或reference，只能靠它们来解决问题    方法一：使用容器并在其中存储直接指向derived class 对象的指针，如此便消除了通过base class接口处理对象的需要\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Window{...} class SpecialWindow: public Window{ public: void blink(); ... }; // dynamic_cast实现方法 typedef std::vector\u0026lt;std::trl::shared_ptr\u0026lt;Window\u0026gt;\u0026gt; VPW; VPW winPtrs; ... for(VPW::iterator iter=winPtrs.begin();iter!=winPtrs.end();++iter) { if(SpecialWindow* psw=dynamic_cast\u0026lt;SpecialWindow*\u0026gt;(iter-\u0026gt;get())) psw-\u0026gt;blink(); } // 改进实现方法 typedef std::vector\u0026lt;std::trl::shared_ptr\u0026lt;SpecialWindow\u0026gt;\u0026gt; VPSW; VPSW winPtrs; ... for(VPSW::iterator iter=winPtrs.begin();iter!=winPtrs.end();++iter) { (*iter)-\u0026gt;blink(); }    该方法使你无法在同一个容器内存储指针”指向所以可能的Window派生类“。处理多中Window类型需要多各容器，它们都必须具备类型安全性  方法二：通过base class接口处理所有可能的Window派生类，即在base class内提供virtual函数做你想对各个window派生类做的事\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Window{ public: virtual void blink() { } ... }; class SpecialWindow: public Window{ public: virtual void blink() { ... }; ... }; typedef std::vector\u0026lt;std::trl::shared_ptr\u0026lt;Window\u0026gt;\u0026gt; VPW; VPW winPtrs; ... for(VPW::iterator iter=winPtrs.begin();iter!=winPtrs.end();++iter) (*iter)-\u0026gt;blink();   Item 28：Avoid returning \u0026ldquo;handles\u0026rdquo; to object internals  考虑矩形类：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Point{ public: Point(int x, int y); ... void setX(int newVal); void setY(int newVal); ... }; struct RectData{ Point ulhc; Point lrhc; }; class Rectangle{ ... private: std::trl::shared_ptr\u0026lt;RectData\u0026gt; pData; };     handles： Reference、指针和迭代器\n  降低对象封装性\n  可能导致虽然调用const成员函数却造成对象状态被更改\n例如：\n    1 2 3 4 5 6 7 8 9 10 11 12 13  class Rectangle{ public: ... Point\u0026amp; upperleft() const {return pData-\u0026gt;ulhc;} Point\u0026amp; lowerright() const {return pData-\u0026gt;lrhc;} ... }; Point coord1(0, 0); Point coord2(100, 100); const Rectangle rec(coord1, coord2); rec.upperLeft().setX(50);\t// 将会改变rec，而定义使用了const   ​\t该问题的解决方法是返回const reference：\n1 2 3 4 5 6 7  class Rectangle{ public: ... const Point\u0026amp; upperleft() const {return pData-\u0026gt;ulhc;} const Point\u0026amp; lowerright() const {return pData-\u0026gt;lrhc;} ... };     返回代表对象内部的handles可能导致空悬的句柄（dangling handles）：这种handles所指的东西不复存在\n例如：\n  1 2 3 4 5  class GUIObject {...}; const Rectangle boundingBox(const GUIObject\u0026amp; obj); GUIObject* pgo; ... const Point* pUpperLeft = \u0026amp;(boundingBox(*pgo).upperLeft());     这里boundingBox生成一个临时变量，在语句结束后将自动被销毁，最后pUpperLeft得到将是一个空悬、虚吊的handles\n  返回handles的特例：重载operator[]以获取数据等\n  Item 29：Strive for exception-safe code  举例一个希望用于多线程环境的GUI菜单类  1 2 3 4 5 6 7 8 9 10  class PrettyMenu{ public: ... void changeBackground(std::istream\u0026amp; imgSrc); ... private: Mutex mutex;\t// 互斥器  Image* bgImage;\t// 目前背景图片  int imageChanges;\t// 背景图片被改变的次数 };   changeBackground函数的一个实现：\n1 2 3 4 5 6 7 8  void PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { lock(\u0026amp;mutex);\t// 获取互斥器  delete bgImage;\t// 删除旧背景  ++imageChanges;\t// 修改图片变更次数  bgImage=new Image(imgSrc);\t// 使用新背景  unlock(\u0026amp;mutex);\t// 释放互斥锁 }   从“异常安全性”上看，这个函数的设计很糟糕\n  异常安全性函数的满足条件：\n 不泄露任何资源  对上述changeBackground函数的实现，若new Image(imgSrc)发生异常，则unlock永远不会被调用，互斥器永远被把持住   不允许数据败坏  若new Image(imgSrc)抛出异常，bgImage将指向一个被删除的对象，imageChanges也被累加，而事实上并没有新的图像加载成功      此处资源泄露问题可以使用资源管理类解决\n  1 2 3 4 5 6 7  void PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { lock m1(\u0026amp;mutex);\t// 获取互斥器，并确保未来销毁  delete bgImage;\t// 删除旧背景  ++imageChanges;\t// 修改图片变更次数  bgImage=new Image(imgSrc);\t// 使用新背景 }     异常安全函数提供三个保证\n  基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而败坏，所有对象均处于一种内部前后一致的状态。然而程序的现实状态恐怕不可预料。例如，可以编写changeBackground函数异常抛出时，PrettyMenu可以继续拥有背景图片，或者令它拥有某个缺省的背景图像，但客户无法预期是哪一种情况\n  强烈保证：如果异常被抛出，程序状态不改变。调用这样的函数需要有这样的认知：如果函数成功，就是完全成功，如果函数失败，程序会回退到函数调用之前的状态\n  不抛掷保证：承诺绝不抛出异常，因为它们总能完成它们原先承诺的功能。作用于内置类型身上的所有操作都提供nothrow保证。例如\n    1  int doSomethin() throw();   ​\t并不是说明doSomething不会抛出异常，而是说如果doSomething抛出异常，将是严重错误，会有意想不到的函数被调用。同时doSomething也没有提供任何异常保证\n  对changeBackground函数安全性的优化\n 改变PrettyMenu的bgImage成员变量类型，从一个类型为Image*的内置指针改为一个智能指针 重新排列changeBackground函数内语句次序，使得在更换图像之后才累加imageChanges    1 2 3 4 5 6 7 8 9 10 11  class PrettyMenu{ ... std::tr1::shared_ptr\u0026lt;Image\u0026gt; bgImage; ... }; void PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { Lock m1(\u0026amp;mutex); bgImage.reset(new Image(imgSrc)); ++imageChanges; }    如果Image构造函数抛出异常，有可能输入流的读取记号已被移走，这样的搬移对程序的其余部分是一种可见的状态改变，在保证changeBackground提供强烈保证前提下，可以使用下述方法解决这一问题  copy and swap策略：为打算修改的对象做出一份副本，然后在那副本身上做一切必要修改。若有任何修改动作抛出异常，原对象仍保持未改变状态。待所有改变都成功后，再将修改过的那个副本和原对象在一个不抛出异常的操作中置换 实现：将所有“隶属对象的数据”从原对象放进另外一个对象内，如何赋予原对象一个指针，指向那个所谓的实现对象（即副本）。该手法常称为pimpl idiom    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  struct PMImpl{ std::tr1::shared_ptr\u0026lt;Image\u0026gt; bgImage; int imageChanges; }; class PrettyMenu{ ... private: Mutex mutex; std::tr1::shared_ptr\u0026lt;PMImpl\u0026gt; pImpl; }; void PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { using std::swap; Lock ml(\u0026amp;mutex); std::tr1::shared_ptr\u0026lt;PMImpl\u0026gt; pNew(new PMImpl(*pImpl)); pNew-\u0026gt;bgImage.reset(new Image(imgSrc)); ++pNew-\u0026gt;imageChanges; swap(pImpl, pNew); }    copy-and-swap策略是对对象状态做出全有或全无改变的一个很好方法，但一般而言它并不保证整个函数具有强烈的异常安全性，考虑代码：  1 2 3 4 5 6 7  void someFunc() { ... f1(); f2(); ... }     如果f1或f2的异常安全性比“强烈保证”低，就很难让someFunc成为“强烈异常安全”。例如，假设f1只提供基本保证，则为了使someFunc提供强烈保证，必须写出代码获得调用f1之前的整个程序状态、捕捉f1所有可能异常、然后恢复原状态\n  如果f1和f2都是“强烈异常安全”，如果f1圆满结束，程序状态在任何方面都可能有所改变，因此如果f2随后抛出异常，程序状态和someFunc被调用前并不相同，甚至当f2没有改变东西时也是如此\n  函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者\n  Item 30：Understand the ins and outs of inlining   在一台内存有限的机器上，过度热衷inlining会造成程序体积太大（对可用空间而言）。即使拥有虚内存，inline造成的代码膨胀亦会导致额外的换页行为，降低指令高速缓存装置的击中率，以及伴随这些而来的效率损失\n  如果inline函数本体很小，编译器针对函数本体所产生的码可能比针对函数调用所产生的码更小。这样的话，将函数inlining确实可能导致较小的目标码和较高的指令高速缓存装置击中率\n  inline只是对编译器的一个申请，不是强制命令\n 可以明确提出    1 2 3 4 5  template\u0026lt;typename T\u0026gt; inline const T\u0026amp; std::max(const T\u0026amp; a, const T\u0026amp;b) { return a\u0026lt;b? b : a; }    也可以隐喻方式提出，即将函数定义于class定义式内  1 2 3 4 5 6 7 8  class Person{ public: ... int age() const {return theAge;} ... private: int theAge; };     inline函数通常一定被置于头文件内，因为大多数建置环境在编译过程中进行inlining，而为了将一个“函数调用”替换为“被调用函数的本体”，编译器必须知道那个函数长什么样。inlining在大多数C++程序中是编译期行为\n  template通常也被置于头文件内，因为它一旦被使用，编译器为了将它具现化，需要知道它长什么样。而template与inlining无关，所以不应该将所有的tempalte function声明为inline\n  所有对virtual函数的调用也都会使inlining落空，因为virtual意味着“等待，直到运行期才确定调用哪个函数”，而inline意味着“执行前，先将调用动作替换为被调用函数的本体”\n  一个表面看似inline的函数是否真的能inline取决于建置环境，主要取决于编译器。大部分编译器对无法inline的函数都会抛出一个警告信息\n  有时候虽然编译器有意愿inlining某个函数，但可能还是为该函数生成一个函数本体。例如，如果程序需要取某个inline函数的地址，编译器通常必须为此函数生成一个outlined函数本体。编译器通常不对“通过函数指针而进行的调用”实施inlining，这意味着inline函数的调用可能被inlined，也可能不被inlined，取决于该调用的实施方式：\n  1 2 3 4 5  inline void f() { .. } void (*pf)()=f; ... f(); pf();     有时候编译器会生成构造函数和析构函数的outline副本，构造函数和析构函数不适合进行inlining，即使其函数内容为空\n 构造函数和析构函数并非真的为空，派生类构造函数至少一定会陆续调用其成员变量和基类两者的构造函数，这些调用会影响编译器是否对此空白函数inlining    inline函数无法随程序库的升级而升级\n 如果f是程序库内的一个inline函数，客户将f函数本体编进其程序中，一旦程序库设计者决定改变f，所有用到f的客户端程序都必须重新编译 如果f是non-inline函数，一旦它有任何修改，客户端只需重新连接就好，远比重新编译的负担少很多。如果程序库采取动态链接，升级版函数甚至可以不知不觉地被应用程序吸纳    Item 31：Minimize compilation dependencies between files  C++“接口从实现分离”的缺陷：class的定义式不止详细叙述了class接口，还包括十足的实现细节  1 2 3 4 5 6 7 8 9 10 11 12  class Person{ public: Person(const std::string\u0026amp; name, cosnt Date\u0026amp; birthday, const Address\u0026amp; addr); std::string name() const; std::string birthDate() const; std::string address() const; ... private: std::string theName; Date theBirthDate; Address theAddress; };   上述代码无法通过编译，因为找不到std::string，Date和Address的定义 ，需要包含相关头文件。而当相关依赖头文件修改时，每一个包含该头文件的源文件均需要进行编译\n  优化方法：以“声明的依存性”替换“定义的依存性”\n  如果使用object reference或object pointer可以完成任务，就不要使用object\n 定义一个类型的reference或pointer只需要一个类型声明式 定义某类型的objects需要用到该类型的定义式    尽量以class声明式替换class定义式\n  为声明式和定义式提供不同的头文件\n 类似\u0026lt;iosfwd\u0026gt;，\u0026lt;iosfwd\u0026gt;含iostream各组件的声明式，其对应定义则分布在若干不同的头文件内，包括\u0026lt;sstream\u0026gt;、\u0026lt;streambuf\u0026gt;、\u0026lt;fstream\u0026gt;和\u0026lt;iostream\u0026gt;      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;string\u0026gt;#include \u0026lt;memory\u0026gt; class PersonImpl;\t// Person实现类的前置声明 class Date; class Address; class Person{ public: Person(const std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr); std::string name() const; std::string birthDate() const; std::string address() const; ... private: std::tr1::shared_ptr\u0026lt;PersonImpl\u0026gt; pImpl; };     使用pimpl idiom的classes通常称为Handles classes\n 将它们所有函数转交给相应的实现类并由后者完成实际工作    1 2 3 4 5 6  #include \u0026#34;Person.h\u0026#34;#include \u0026#34;PersonImpl.h\u0026#34; Person::Person(const std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr) : pImpl(new PersonImpl(name, birthday, addr)){} std::string Person::name() const{return pImpl-\u0026gt;name();}    Interface class：抽象基类，用于描述derived classes的接口，通常不带成员变量也没有构造函数，只有一个virtual析构函数和一组pure virtual函数来叙述整个接口  1 2 3 4 5 6 7 8  class Person{ public: virtual ~Person(); virtual std::string name() const = 0; virtual std::string birthDate() const = 0; virtual std::string address() const = 0; ... };    interface class的客户必须有办法为这种class创建对象。通常调用一个特殊函数，此函数扮演“真正被具现化”的那个derived classes的构造函数角色，这种函数通常称为工厂函数（factory）或virtual构造函数。它们返回指针，指向动态分配所得对象，而该对象支持interface class接口。这类函数在interface class中常声明为static如  1 2 3 4 5 6  class Person{ public: ... static std::tr1::shared_ptr\u0026lt;Person\u0026gt; create(cosnt std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr); ... };    客户使用如下：  1 2 3 4 5 6  std::string name; Date dateOfBirth; Address address; std::tr1::shared_ptr\u0026lt;Person\u0026gt; pp(Person::create(name, dateOfBirth, address)); ...   支持interface class接口的那个具象类必须被定义出来，且真正的构造函数必须被调用，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class RealPerson: public Person{ public: RealPerson(const std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr) : theName(name), theBirthDate(birthday), theAddress(addr){} virtual ~RealPerson(){} std::string name() const; std::string birthDate() const; std::string address() const; private: std::string theName; Date theBirthDate; Address theAddress; }; std::tr1::shared_ptr\u0026lt;Person\u0026gt; Person::create(cosnt std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr) { return std::tr1::shared_ptr\u0026lt;Person\u0026gt;(new RealPerson(name, birthday, addr)); }   上述代码示范了interface classes的一种最常见机制：从interface class继承接口规范，然后实现出接口所覆盖的函数\n  Handles classes和interface classes解除了接口和实现之间的耦合关系，降低文件之间的编译依存性\n  代价分析：\n  对于Handles classes，成员函数必须通过implementation pointer取得对象数据。这将为每次访问增加一层间接性。而每一个对象消耗的内存数量必须增加implementation pointer的大小。最后implementation pointer必须进行初始化（在Handles classes构造函数内），指向一个动态分配得到的implementation object，因此将蒙受因动态内存分配及其释放所带来的额外开销，以及遭遇bad_alloc异常（内存不足）的可能\n  对于Interface classes，由于每个函数都是virtual，因此每次调用都应付出一个间接跳跃代价。此外interface class派生对象必须内含一个virtual table pointer（vtpr），这个指针可能增加存放对象所需的内存数量——实际取决于这个对象除了interface class之外是否有其他virtual函数来源\n  无论Handles classes还是Interface classes，一旦脱离inline函数都无法有太大作为\n    ","description":"《Effective C++学习笔记第五章》","id":6,"section":"note","tags":["Effective C++","C++"],"title":"Chapter 5: Implementations","uri":"https://chaphlagical.github.io/zh/note/effectivecpp/ch5/"},{"content":"1. 参数曲线 1.1. 直观简介  参数曲线$c$可以视为移动粒子的运动轨迹 参数$t$可视为时间参数  1.2. 数学描述 1.2.1. 定义 $\\mathbb R^n$中的曲线类$C^k(k\\geq 1)$的参数化是光滑映射$c:I=[a,b]\\subset \\mathbb R\\rightarrow\\mathbb R^n$，其中$c$属于类$C^k$\n1.2.2. 迹线（trace） 图像集合$c(I)$称为曲线的迹线\n 不同的参数化可能有相同的迹线  1.2.3. 自相交（self-intersection） 迹线中的一个点对应多个参数值$t$，则称曲线的自相交\n1.2.4. 速度向量 曲线$c$在时刻$t$的导数$c'(t)$称为曲线的速度向量\n $c'(t)$给定移动的方向 $|c'(t)|$给定速度大小  1.3. 正则参数曲线（Regular parametric curves）  正则参数化  对于所有的$t$，有$c'(t)\\neq 0$ 正则曲线上的点称为平凡（ordinary）点 非正则曲线上的点称为奇异（singular）点    1.4. 参数的变换 给定一个光滑的正则参数化，参数所允许的更改为任意光滑（可微）函数\n$$\nf:I_1\\rightarrow I\\ \\mathrm{such}\\ \\mathrm{that}\nf'\\neq 0\\ \\mathrm{on}\\ I_1\n$$\n当$f'\u0026gt;0$将保持方向\n 我们可以将正则曲线视为正则参数化的集合，其中任意两个参数都是彼此之间的重新参数化（等价类） 我们对参数变换下的不变量感兴趣  1.5. 几何观察 切线向量（Tangent vector）\n 正则曲线$c(t)$在点$\\pmb p_0=\\pmb c(t_0)$处的正弦线定义为满足$\\pmb p-\\pmb p_0\\parallel\\pmb c_0'$的点$\\pmb p$，其中$\\pmb c'_0=\\pmb c'(t_0)$ 归一化向量$\\pmb t=\\dfrac{\\pmb c'}{\\vert c'\\vert}$称为切线向量  法平面（Normal plane）\n法平面描述为满足$\\pmb p-\\pmb p_0\\perp\\pmb c_0'$的点$\\pmb p$，即\n$$\n(\\pmb p-\\pmb p_0)\\cdot\\pmb c_0'=0\n$$\n密切平面（Osculating plane）\n  假设曲线$\\pmb c(t)$不是一条直线，任意三个不共线的点$\\pmb p_1,\\pmb p_2,\\pmb p_3$，能够决定一个平面\n  如果$\\pmb p_1,\\pmb p_2,\\pmb p_3$趋于于曲线$\\pmb c$上的同一个点$\\pmb p_0$，那么其构成的平面称为曲线$\\pmb c$在点$\\pmb p_0$处的密切平面$T$\n  若曲线在点$\\pmb p_0$处的一阶导数$\\pmb c_0'$和二阶导数$\\pmb c''_0$线性独立，则密切平面给定为：\n$$\n(\\pmb c_0'\\times\\pmb c_0'')\\cdot(\\pmb p-\\pmb p_0)=0\n$$\n  观察$\\pmb p(t+\\Delta t)$与以$\\pmb a$为法向量且穿过点$\\pmb p(t)$的平面的距离，有\n$$\n\\pmb a\\cdot(\\pmb p(t_0+\\Delta t)-\\pmb p(t_0))=\\pmb a\\cdot \\Big(\\dot{\\pmb p}(t_0)\\Delta t+\\dfrac{\\ddot{\\pmb p}(t_0)}{2!}\\Delta t^2+\\cdots \\Big)\n$$\n当距离取最小值时，有\n$$\n\\pmb a\\cdot\\dot{\\pmb P}(t_0)=0,\\ \\ \\\n\\pmb a\\cdot\\ddot{\\pmb P}(t_0)=0\n$$\n此时取得密切平面，密切平面是曲线在$\\pmb p(t_0)$处的最优拟合平面\n从切平面（Rectifying plane）\n同时垂直于密切平面和法平面的平面称为从切平面$R$，从切平面上的点$\\pmb p$满足\n$$\n(\\pmb c_0'\\times(\\pmb c_0'\\times\\pmb c_0''))\\cdot(\\pmb p-\\pmb p_0)=0\n$$\n法向量\n法平面内的任何向量均为曲线的法向量，特别地\n  点$\\pmb p_0$处同时位于密切平面内的法向量$\\pmb n$（密切平面与法平面交线）称为主法向量（principal normal ）\n$$\n(\\pmb c_0'\\times\\pmb c_0'')\\times\\pmb c_0'\n$$\n  点$\\pmb p_0$处同时位于从切平面的法向量$\\pmb b$称为副法向量（binormal）\n$$\n\\pmb c_0'\\times\\pmb c_0''\n$$\n  Frenet标架\n通过以下三个正交向量构造曲线上的局部坐标架\n  切线向量\n$$\n\\pmb t=\\dfrac{\\pmb c'}{|\\pmb c_0'|}\n$$\n  副法向量\n$$\n\\pmb b=\\dfrac{\\pmb c_0'\\times\\pmb c_0''}{|\\pmb c_0'\\times\\pmb c_0''|}\n$$\n  主法向量\n$$\n\\pmb n=\\pmb b\\times\\pmb t\n$$\n  对应的关联平面：\n  法平面\n$$\n(\\pmb p-\\pmb p_0)\\cdot\\pmb t=0\n$$\n  密切平面\n$$\n(\\pmb p-\\pmb p_0)\\cdot\\pmb b=0\n$$\n  从切平面\n$$\n(\\pmb p-\\pmb p_0)\\cdot\\pmb n=0\n$$\n  曲率\n  曲率的基本概念\n 测量曲线的弯曲程度 直线没有弯曲 → 曲率为0 圆有固定的弯曲程度 → 曲率为常数    曲率的计算\n$$\n\\kappa(t)=\\dfrac{|\\pmb c'(t)\\times\\pmb c''(t)|}{|\\pmb c'(t)|^3}\n$$\n特别地，对于平面曲线$\\pmb c(t)=(x(t),y(t))$\n$$\n\\kappa(t)=\\dfrac{|x\u0026rsquo;y''-x'\u0026lsquo;y\u0026rsquo;|}{(x'^2+y'^2)^{\\frac{3}{2}}}\n$$\n曲率半径:$r(t)=\\dfrac{1}{\\kappa(t)}$\n  挠率\n  定义\n  挠率$\\tau$衡量副法向量的变化\n  （曲线从其在密切平面上的投影的偏移量可以视为曲线离平面曲线有多远），由下式给出\n$$\n\\tau(t)=\\dfrac{(\\pmb c'\\times\\pmb c'')\\cdot\\pmb c'''}{|\\pmb c'\\times\\pmb c''|^2}\n$$\n    曲线的长度\n  曲线的弧长\n  正则曲线$C$的弧长定义为：\n$$\n\\mathrm{length}_c=\\int_a^b|\\dot{\\pmb c}|\\mathrm dt\n$$\n  独立于参数的选取\n    2. 弧长曲线曲线 2.1. 弧长参数化   考虑$\\pmb c(t)$从0到$t$跨度的部分，该段弧长$s$为一个关于$t$的函数\n$$\ns(t)=\\int_0^t|\\pmb c'(u)|\\mathrm du\n$$\n  由于$\\dfrac{\\mathrm ds}{\\mathrm dt}=\\vert\\vert \\pmb c'(u)\\vert\\vert\u0026gt;0$，$s$可以作为新的参数化方式\n  易得：\n$$\n\\pmb c'(s)=\\dfrac{\\mathrm d\\pmb c}{\\mathrm ds}=\\dfrac{\\mathrm d\\pmb c/\\mathrm dt}{\\mathrm ds/\\mathrm dt}\\Rightarrow |\\pmb c'(s)|=1\n$$\n  $\\pmb c(s)$称为弧长（单位速度）参数化曲线，参数$s$称为弧长或自然参数\n  2.2. 用弧长进行参数化  弧长（或单位速度）参数化  任意正则曲线都存在弧长参数化 不意味着弧长参数化能够被计算    2.3. 弧长参数化的几何结果   由于$\\vert\\vert\\pmb c'(u)\\vert\\vert=1$，有$\\pmb c'\\cdot\\pmb c'=1$，取导数得到$\\pmb c'\\cdot\\pmb c''=0$\n  $\\pmb c''$与$\\pmb c'$互相垂直（均位于密切平面）\n  因此$\\pmb c''$的方向向量可作为主法向量（$\\pmb c''\\neq \\pmb 0$）\n$$\n\\pmb n=\\dfrac{\\pmb c''}{|\\pmb c''|}\n$$\n  2.4. 曲率   弧长参数曲线$\\pmb c(u)$的曲率为\n$$\n\\kappa=|\\pmb c''(u)|\n$$\n  3. Frenet曲线 3.1. 基本概念  Frenet曲线  Frenet曲线是$\\mathbb R^n$内的弧长参数曲线$\\pmb c$，满足$\\pmb c'(s),\\pmb c''(s),\\cdots,\\pmb c^{n-1}(s)$线性独立   Frenet标架  每条Frenet曲线都有一个独一无二的Frenet标架$\\pmb e_1(s),\\pmb e_2(s),\\cdots,\\pmb e_n(s)$，满足  $\\pmb e_1(s),\\pmb e_2(s),\\cdots,\\pmb e_n(s)$正交且正向   对${\\pmb c',\\pmb c'',\\cdots,\\pmb c^n}$应用Gram-Schmidt正交化    3.2. Gram-Schmidt处理  输入：线性独立向量集合${\\pmb v_1,\\pmb v_2,\\cdots,\\pmb v_n}$ 输出：正交向量集合${\\pmb b_1,\\pmb b_2,\\cdots,\\pmb b_n}$  设$\\pmb b_1=\\dfrac{\\pmb v_1}{\\vert\\vert\\pmb v_1\\vert\\vert}$ 循环：For $k=2,\\cdots,n$  $\\tilde{\\pmb b_k}=\\pmb v_k-\\sum_{i=1}^{k-1}\\langle \\pmb v_k,\\pmb b_i\\rangle \\pmb b_i$ $\\pmb b_k=\\dfrac{\\tilde {\\pmb b_k}}{\\vert\\vert\\tilde {\\pmb b_k}\\vert\\vert}$      3.3. 平面曲线 现在用Frenet标架下弧长参数化表示平面曲线\n法向量：\n$$\n\\pmb e_2(s)=R^{90^\\circ}\\pmb e_1(s)\n$$\n标架方程：\n$$\n\\begin{pmatrix}\n\\pmb e_1(s)\\\\\\pmb e_2(s)\n\\end{pmatrix}'=\n\\begin{pmatrix}\n0\u0026amp;\\kappa(s)\\\\\n-\\kappa(s)\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\pmb e_1(s)\\\\\\pmb e_2(s)\n\\end{pmatrix}\n$$\n有向曲率：\n$$\n\\kappa(s)=\\langle\\pmb e_1'(s),\\pmb e_2(s)\\rangle=\\dfrac{\\langle\\ddot {\\pmb c}(t),R^{90^\\circ}\\dot{\\pmb c}(t) \\rangle}{|\\dot{\\pmb c}(t)|^3}\n$$\n密切圆：\n 半径：$1/\\kappa$ 圆心：$\\pmb c(s)+\\dfrac{1}{\\kappa}\\pmb e_2(s)$  平面曲线的基本定理\n 令$\\kappa:(a,b)\\rightarrow\\mathbb R$是一个光滑函数。对于某些$s_0\\in(a,b)$，假设我们有给定点$\\pmb p_0$和两个正交向量$\\pmb t_0$和$\\pmb n_0$，则存在唯一一个Frenet曲线$\\pmb c:(a,b)\\rightarrow\\mathbb R^2$，有：  $\\pmb c(s_0)=\\pmb p_0$ $\\pmb e_1(s_0)=\\pmb t_0$ $\\pmb e_2(s_0)=\\pmb n_0$ 曲线$\\pmb c$的曲率$c$等于给定函数$\\pmb \\kappa$   换句话说，对于任意光滑函数，存在唯一一条直线以该函数作为其曲率  3.4. 性质   刚性运动\n 刚性运动：$\\pmb x\\rightarrow A\\pmb x+\\pmb b$，其中$A$为正交矩阵（保距离的仿射映射）  当$\\det \\pmb A=+1$时保方向（非镜面） 镜面$\\det\\pmb A=-1$      平面曲线在刚性运动下的不变性\n 曲率在刚性运动下不变  绝对值不变 如果是保方向刚性运动，则有向值不变      平面曲线的刚度\n  具有相同有向曲率函数的两条Frenet曲线的区别仅因保方向刚性运动而不同\n  弧长导数\n  弧长参数化\n 找到参数曲线的一个弧长参数化往往是很困难的 Frenet标架及其导数依旧是可以计算的，这里定义了弧长导数    弧长导数\n 对于参数曲线$\\pmb c:[a,b]\\rightarrow\\mathbb R^n$，定义任意可微函数$f:[a,b]\\rightarrow\\mathbb R$的弧长导数为\n$$\n\\pmb f'(t)=\\dfrac{1}{|\\dot{\\pmb c}(t)|}\\dot{\\pmb f}(t)\n$$      3.5. 空间曲线 $\\mathbb R^3$中的Frenet标架\n  切线向量\n$$\n\\pmb e_1(s)=\\pmb c'(s)\n$$\n  法向量\n$$\n\\pmb e_2(s)=\\dfrac{1}{|\\pmb c''(t)|}\\pmb c''(t)\n$$\n  副法向量\n$$\n\\pmb e_3(s)=\\pmb e_1(s)\\times\\pmb e_2(s)\n$$\n  Frenet-Serret方程：\n  $$\n\\begin{pmatrix}\n\\pmb e_1(s)\\\\\\pmb e_2(s)\\\\\\pmb e_3(s)\n\\end{pmatrix}=\n\\begin{pmatrix}\n0\u0026amp;\\kappa(s)\u0026amp;0\\\\-\\kappa(s)\u0026amp;0\u0026amp;\\tau(s)\\\\0\u0026amp;-\\tau(s)\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\pmb e_1(s)\\\\\\pmb e_2(s)\\\\\\pmb e_3(s)\n\\end{pmatrix}\n$$\n  有向曲率：$\\kappa(s)=\\langle \\pmb e_1'(s),\\pmb e_2(s)\\rangle$\n  挠率：$\\tau(s)=\\langle\\pmb e_2'(s),\\pmb e_3(s)\\rangle$，测量曲线如何弯曲超出$\\pmb e_1$和$\\pmb e_2$的平面\n  $\\mathbb R^n$中曲线的Frenet方程表示为：\n  $$\n\\begin{pmatrix}\n\\pmb e_1(s)\\\\\\pmb e_2(s)\\\\\\vdots\\\\\\pmb e_n(s)\n\\end{pmatrix}=\n\\begin{pmatrix}\n0\u0026amp;\\kappa_1(s)\u0026amp;0\u0026amp;\\cdots\u0026amp;0\u0026amp;0\\\\\n-\\kappa_1(s)\u0026amp;0\u0026amp;\\kappa_2(s)\u0026amp;\\cdots\u0026amp;0\u0026amp;0\\\\\n0\u0026amp;-\\kappa_2(s)\u0026amp;0\u0026amp;\\cdots\u0026amp;0\u0026amp;0\\\\\n\\vdots\u0026amp;\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\u0026amp;\\vdots\\\\\n0\u0026amp;0\u0026amp;0\u0026amp;\\cdots\u0026amp;0\u0026amp;\\kappa_{n-1}(s)\\\\\n0\u0026amp;0\u0026amp;0\u0026amp;\\cdots\u0026amp;-\\kappa_{n-1}(s)\u0026amp;0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\pmb e_1(s)\\\\\\pmb e_2(s)\\\\\\vdots\\\\\\pmb e_n(s)\n\\end{pmatrix}\n$$\n 函数$\\kappa_i(s)$称为$i$次Frenent曲率  小结   对于正则曲线\n 切线向量：$\\pmb t=\\dfrac{\\pmb c'}{\\vert\\vert\\pmb c'\\vert\\vert}$，法平面：$(\\pmb p-\\pmb p_0)\\cdot\\pmb t=0$ 副法向量：$\\pmb b=\\dfrac{\\pmb c'\\times\\pmb c''}{\\vert\\vert\\pmb c'\\times\\pmb c''\\vert\\vert}$，密切平面：$(\\pmb p-\\pmb p_0)\\cdot\\pmb b=0$ 主法向量：$\\pmb n=\\pmb b\\times\\pmb t$，从切平面：$(\\pmb p-\\pmb p_0)\\cdot\\pmb n=0$ 曲率：$\\kappa(t)=\\dfrac{\\pmb c'\\times\\pmb c''}{\\vert\\vert\\pmb c'\\vert\\vert^3}$ 挠率：$\\tau(t)=\\dfrac{(\\pmb c'\\times\\pmb c'')\\cdot\\pmb c'''}{\\vert\\vert\\pmb c'\\times\\pmb c''\\vert\\vert^2}$    弧长参数（单位速度）曲线$\\pmb c(s)$\n 切线向量：$\\pmb t=\\pmb c'$ 副法向量：$\\pmb b=\\pmb t\\times\\pmb n$ 主法向量：$\\pmb n=\\dfrac{\\pmb t'}{\\vert\\vert\\pmb t'\\vert\\vert}=\\dfrac{\\pmb c''}{\\vert\\vert\\pmb c''\\vert\\vert}$ 曲率：$\\kappa(t)=\\vert\\vert\\pmb t'\\vert\\vert=\\vert\\vert\\pmb c''\\vert\\vert$ 有向曲率：$\\kappa(s)=\\pmb t'=\\pmb c''$ 挠率：$\\tau(t)=-\\pmb b'\\cdot\\pmb n$    特殊情况：平面曲线\n  对于正则平面曲线$\\pmb c(t)=(x(t),y(t))$，其曲率定义为\n$$\n\\kappa(t)=\\dfrac{|x\u0026rsquo;y''-x'\u0026lsquo;y\u0026rsquo;|}{(x'^2+y'^2)^{\\frac{3}{2}}}\n$$\n  有向曲率\n$$\n\\kappa(t)=\\dfrac{x\u0026rsquo;y''-x'\u0026lsquo;y\u0026rsquo;}{(x'^2+y'^2)^{\\frac{3}{2}}}\n$$\n    ","description":"曲线微分几何学习笔记","id":7,"section":"note","tags":["CAGD"],"title":"CAGD(3) |  曲线微分几何","uri":"https://chaphlagical.github.io/zh/note/cagd/cagd3/"},{"content":"1.1 A First Look at Function Templates 1.1.1 Defining The Templates 模板声明为：\n1  template\u0026lt;参数列表\u0026gt;   例如：\n1 2 3 4 5 6  // max1.hpp template\u0026lt;typename T\u0026gt; T max(T a, T b) { return b \u0026lt; a ? a : b; }   也可以用关键字代替typename，如：\n1 2 3 4 5  template\u0026lt;class T\u0026gt; T max(T a, T b) { return b \u0026lt; a ? a : b; }   1.1.2 Using the Templates 例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026#34;max1.hpp\u0026#34; int main() { int i = 42; std::cout \u0026lt;\u0026lt; ::max(7, 42) \u0026lt;\u0026lt; std::endl; double f1 = 3.4; double f2 = -6.7; std::cout \u0026lt;\u0026lt; ::max(f1, f2) \u0026lt;\u0026lt; std::endl; std::string s1 = \u0026#34;mathematics\u0026#34;; std::string s2 = \u0026#34;math\u0026#34;; std::cout \u0026lt;\u0026lt; ::max(s1, s2) \u0026lt;\u0026lt; std::endl; }   使用模板时编译器将针对每一套使用的模板参数创建一个实例，见示例\n注意： void也是一个有效的模板参数，例如：\n1 2 3 4 5 6  template\u0026lt;typename T\u0026gt; T foo(T*) {} void* vp = nullptr; foo(vp);   1.1.3 Two-Phase Translation 模板的编译包含两个阶段：\n 第一阶段为不包含实例的definition time，忽略模板参数地检查模板代码本身，包括  Syntax errors are discovered, such as missing semicolons Using unknown names(type names, function names, \u0026hellip;) that don\u0026rsquo;t depend on template parameters are discovered Static assertions that don\u0026rsquo;t depend on template parameters are checked   第二阶段为实例阶段，模板代码被再次确认有效，依赖于模板参数的部分将被确认  一个例子帮助理解：\n1 2 3 4 5 6 7 8  template\u0026lt;typename T\u0026gt; void foo(T t) { undeclared();\t// 编译期第一阶段检查  undeclared(t);\t// 编译期第二阶段检查  static_assert(sizeof(int) \u0026gt; 10, \u0026#34;int too small\u0026#34;);\t// always fails if sizeof(int)\u0026lt;=10  static_assert(sizeof(T) \u0026gt; 10. \u0026#34;T too small\u0026#34;);\t// fails if instantiated for T with size\u0026lt;=10 }   1.2 Template Argument Deduction 1.2.1 Type Conversions During Type Deduction 类型推断时自动类型转换的限制：\n 当声明为按引用传参时，即使是trivial的转换都不能用于类型推断。两个参数必须完全匹配模板参数，例如下述代码编译将报错：  1 2 3 4 5 6 7 8 9 10 11 12 13  template\u0026lt;typename T\u0026gt; T max(T\u0026amp; a, T\u0026amp; b) { return a \u0026gt; b? a : b; } int main() { const int a=1; int b=2; ::max(a,b);\t// const int 和 int在按引用传参下无法转换  return 0; }     当声明为按值传参时，则支持退化(decay)的trivial转换：\n Qualifications with const or volatile are ignored References convert to the referenced type Raw arrays or functions convert to the corresponding pointer type  例如：\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;string\u0026gt; template\u0026lt;typename T\u0026gt; T max(T a, T b) { return a \u0026gt; b? a : b; } int main() { const int a=1; int b=2; std::string s; ::max(a,b);\t// 正确，发生退化转换  ::max(\u0026#34;hello\u0026#34;, s); // 错误，char const[6]无法与std::string发生退化转换  ::max(4, 4.5); // 错误，int与double无法发生退化转换  return 0; }   1.2.2 Type Deduction for Default Arguments 类型推断无法用于默认参数，必须同时指定默认模板参数类型：\n1 2 3 4  template\u0026lt;typename T = std::string\u0026gt; void f(T = \u0026#34;\u0026#34;); ... f();   1.3 Multiple Template Parameters 模板定义支持多参数，如：\n1 2 3 4 5 6 7 8  template\u0026lt;typename T1, typename T2\u0026gt; T1 max(T1 a, T2 b) { return b\u0026lt;a ? a : b; } ... auto m = ::max(4,7.2);   此时返回类型为T1，要使得返回类型更加科学，有以下方法\n1.3.1 Template Parameters for Return Type 显式定义和声明返回类型：\n1 2 3 4  template\u0026lt;typename T1, typename T2, typename RT\u0026gt; RT max(T1 a,T2 b); ... ::max\u0026lt;int, double, double\u0026gt;(4, 7.2);   可将RT移前而T1和T2交给编译器推断：\n1 2 3 4  template\u0026lt;typename RT, typename T1, typename T2\u0026gt; RT max(T1 a,T2 b); ... ::max\u0026lt;double\u0026gt;(4, 7.2);   1.3.2 Deducing the Return Type 使用decltype关键字进行类型推断\n1 2 3 4 5  template\u0026lt;typename T1, typename T2\u0026gt; auto max(T1 a, T2 b) -\u0026gt; decltype(b\u0026lt;a?a:b) { return b \u0026lt; a ? a : b; }   注意： b\u0026lt;a?a:b的最终类型与b\u0026lt;a无关而与a和b是相关的，故这里可以直接使用true来代替b\u0026lt;a\n1 2 3 4 5  template\u0026lt;typename T1, typename T2\u0026gt; auto max(T1 a, T2 b) -\u0026gt; decltype(true?a:b) { return b \u0026lt; a ? a : b; }   有时候可能会返回引用类型，可以使用\u0026lt;type_traits\u0026gt;库中的std::decay\u0026lt;\u0026gt;::type/std::decay_t\u0026lt;\u0026gt;方法进行退化转换：\n1 2 3 4 5 6 7  #include \u0026lt;type_traits\u0026gt; template\u0026lt;typename T1, typename T2\u0026gt; auto max(T1 a, T2 b) -\u0026gt; typename std::decay_t\u0026lt;decltype(true?a:b)\u0026gt; { return b \u0026lt; a ? a : b; }   1.3.3 Return Type as Common Type 使用\u0026lt;type_traits\u0026gt;库中的std::common_type_t\u0026lt;\u0026gt;/std::common_type\u0026lt;\u0026gt;::type方法，可以代替前述的decltype方法：\n1 2 3 4 5 6 7  #include \u0026lt;type_traits\u0026gt; template\u0026lt;typename T1, typename T2\u0026gt; std::common_type_t\u0026lt;T1, T2\u0026gt; max(T1 a, T2 b) { return b \u0026lt; a ? a : b; }   注意：\n C++11规范中使用std::common_type\u0026lt;\u0026gt;::type C++14规范中可以使用std::common_type_t\u0026lt;\u0026gt;  1.4 Default Template Arguments 很简单，模板参数可以设置默认值，例如返回值类型可以沿用typename RT但用decltype或common_type设置默认参数\n1.5 Overloading Function Templates 函数模板能够进行重载\n当函数模板实例与重载函数接口一模一样时，将优先使用非模板函数，例如：\n1 2 3 4 5 6 7 8 9 10 11 12  int max(int a, int b) { return b \u0026lt; a? a : b; } template\u0026lt;typename T\u0026gt; T max(T a, T b) { return b \u0026lt; a ? a : b; } ... ::max(7, 42);\t// 调用非模板函数   1.6 But, Shouldn\u0026rsquo;t We \u0026hellip;? 1.6.1 Pass by Value or by Reference? 在以下情况下，直接传值比传递引用效果更好：\n The syntax is simple Compilers optimize better Move semantics often makes copies cheap And sometimes there is no copy or move at all  1.6.2 Why not inline？ 没必要加上inline关键字，但也应定义在头文件中\n1.6.3 Why not constexpr？ 在编译期计算的关键字\n1 2 3 4 5  template\u0026lt;typename T1, typename T2\u0026gt; constexpr auto max(T1 a, T2 b) { return b \u0026lt; a? a : b; }   1.7 Summary  Function templates define a family of functions for different template arguments When you pass arguments to function parameters depending on template parameters, function templates deduce the template parameters to be instantiated for the corresponding parameter types You can explicitly qualify the leading template parameters You can define default arguments for template parameters. These may refer to previous template parameters and be followed by parameters not having default arguments You can overload function templates When overloading function templates with other function templates, you should ensure that only one of them matches for any call When you overload function templates, limit your changes to specifying template parameters explicitly Ensure the compiler sees all overloaded versions of function templates before you call them.  ","description":"《C++ Templates学习笔记第一章》","id":8,"section":"note","tags":["C++ Templates","C++"],"title":"Chapter 1: Function Templates","uri":"https://chaphlagical.github.io/zh/note/cpptemplate/ch1/"},{"content":"2.1 Implementation of Class Template Stack ","description":"《C++ Templates学习笔记第二章》","id":9,"section":"note","tags":["C++ Templates","C++"],"title":"Chapter 2: Class Templates","uri":"https://chaphlagical.github.io/zh/note/cpptemplate/ch2/"},{"content":"Item 18：Make interfaces easy to use correctly and hard to use incorrectly  考虑一个表现日期的class设计构造函数：  1 2 3 4 5  class Date{ public: Date(int month, int day, int year); ... };   这个接口很容易发生误用：\n1 2  Date d(30, 3, 1995);\t// 无效月份 Date d(2, 30, 1995);\t// 无效天数    优化一：导入外覆类型区别天数、月份和年份  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  struct Day{ explicit Day(int d) : val(d) { } int val; }; struct Month{ explicit Month(int m) : val(m) { } int val; }; struct Year{ explicit Year(int y) : val(y) { } int val; }; class Date{ public: Date(const Month\u0026amp; m, const Day\u0026amp; d, const Year\u0026amp; y); ... }; Date d(30, 3, 1995);\t// 错误类型 Date d(Day(30), Month(3), Year(1995));\t// 错误类型 Date d(Month(3), Day(30), Year(1995));\t// 正确    优化二：限制类型值  1 2 3 4 5 6 7 8 9 10 11 12  class Month{ public: static Month Jan() { return Month(1); } static Month Feb() { return Month(2); } ... static Month Dec() { return Month(12); } ... private: explicit Month(int m); ... }; Date d(Month::Mar(), Day(30), Year(1995));     优化三：限制类型内什么事可以做，什么事不能做\n 常见的限制是加上const    促进正确使用的方法包括：\n 接口一致性（如STL） 与内置类型的行为兼容    防止误用的方法包括：\n 建立新类型 限制类型上的操作 束缚对象值 消除客户的资源管理责任（智能指针）    Item 19：Treat class designs as type design 常见的设计规范：\n 新type的对象应该如何被创建和销毁？  影响到class的构造函数、析构函数以及内存分配函数和释放函数   对象的初始化和对象的赋值该有什么样的差别？  决定构造函数和赋值操作符的行为及其间的差别   新type的对象如果被pass-by-value意味着什么？  copy构造函数用来定义一个type的pass-by-value该如何实现   什么是新type的合法值  对class成员变量而言，通常只有某些数值集是有效的 那些数值集决定了你的class必须维护的约束条件，也决定了你的成员函数（尤其是构造函数、赋值操作符和setter函数）必须进行的错误检查工作 也影响函数抛出的异常以及少数函数异常明细列   你的新type需要配合某个继承图系吗？  如果你继承自某些既有的classes，你就受到那些classes的设计束缚，尤其是受到virtual和non-virtual函数的影响 如果你允许其他classes继承你的classes，将会影响你所声明的函数，尤其是析构函数是否为virtual   什么样的操作符和函数对此新type而言是合理的？  决定你的class声明哪些函数   什么样的标准函数应该被驳回  那些正是你必须声明为private的标准函数   谁该取用新type的成员？  决定哪些成员为public，哪些为protected，哪些为private 决定哪些classes或functions为friend   什么是新type的“未声明接口”？  对效率、异常安全性以及资源运用提供保证所需的相应的约束条件   你的新type有多么一般化？  若定义了一整个types家族，则应考虑使用template   你真的需要一个新的type吗？  应尽可能考虑能否在既有classes基础上新增函数或模板    Item 20：Prefer pass-by-reference-to-const to pass-by-value   缺省情况下C++以pass-by-value方式传递对象至函数。函数参数都是以实际实参的复件为初值，而调用端所获得的亦是函数返回值的一个复件，这些复件由对象的copy构造函数产生，这可能使得pass-by-value成为昂贵的操作\n举例：有两个类定义如下\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Person{ public: Person(); virtual ~Person(); ... private: std::string name; std::string address; }; class Student: public Person{ public: Student(); ~Student(); ... private: std::string schoolName; std::string schoolAddress; };   考虑调用\n1 2 3  bool validateStudent(Student s); Student plato; bool platoIsOK = validateStudent(plato);     以by value方式传递一个Student对象会导致调用一次Student copy构造函数、一次Person copy构造函数、四次string copy构造函数\n  当函数内哪个Student复件被销毁，每一个构造函数调用动作都需要一个对应的析构函数调用动作\n  以by value方式传递的总成本为六次构造函数和六次析构函数\n  pass by reference-to-const\n  1  bool validateStudent(const Student\u0026amp; s);     没有任何构造函数和析构函数被调用，因为没有任何新对象被创建\n  const的必要性：防止函数对引用进行修改\n  避免对象切割问题：当一个derived class对象以by value方式传递并被视为一个base class对象，base class的copy构造函数将被调用，而造成derived class的特化性质被切割掉，仅仅留下一个base class对象\n  不适合使用pass by reference-to-const的应用场景有:\n 内置类型、STL迭代器和函数对象 references往往以指针实现出来，因此pass-by-reference通常意味真正传递的指针 如果对象属于内置类型（或STL迭代器、函数对象），pass by value往往比pass by reference的效率高些    Item 21：Prefer pass-by-reference-to -const to pass-by-value  考虑代码段  1 2 3 4 5 6 7 8 9 10  class Rational { public: Rational(int numerator = 0, int denominator = 1); ... private: int n,d; friend const Rational\u0026amp; operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs); }   opertaor*的实现，需要返回一个reference指向的Rational对象，方法以下：\n 在stack空间上创建local变量  1 2 3 4 5  const Rational\u0026amp; operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { Rational result(lhs.n * rhs.n, lhs.d * rhs.d); return result; }    返回的是local变量，而local变量将在函数结束时被销毁，将带来意外风险  在heap空间上创建对象，并返回reference指向它  1 2 3 4 5  const Rational\u0026amp; operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { Rational* result = new Rational(lhs.n * rhs.n, lhs.d * rhs.d); return *result; }    new之后的对象没能进行delete，将带来内存泄漏  返回reference指向一个被定义于函数内部的static Rational对象  const Rational\u0026amp; operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs)\r{\rstatic Rational result;\rresult = ...;\rreturn *result;\r}\r  多线程安全\n  其他错误：\n  1 2 3 4 5 6 7 8 9 10 11  bool operator==(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs); Rational a, b, c, d; ... if((a * b) == (c * d)) { ... } else { ... }     这里由于operator*返回static Rational的reference，因此函数总是看到它们的现值，故operator==判断总是为true\n  正确的写法应该是：\n  1 2 3 4  inline const Rational lhs, const Rational\u0026amp; rhs) { return Rational(lhs.n * rhs.n, lhs.d * rhs.d); }   而不应返回reference\nItem 22：Declare data members private   语法一致性\n 如果成员变量不是public，客户唯一能够访问对象的办法就是通过成员函数    对成员变量的处理有更加精确的控制，例如：\n  1 2 3 4 5 6 7 8 9 10 11 12 13  class AccessLevels{ public: ... int getReadOnly() const { return readOnly; } void SetReadWrite(int value) { readWrite = value; } int getReadWrite() const { return readWrite; } void setWriteOnly(int value) { writeOnly = value; } private: int noAccess;\t// 不操作  int readOnly;\t// 只读  int readWrite;\t// 读写  int writeOnly;\t// 只写 };    封装  对客户隐藏成员变量（封装），可以确保class的约束条件总是会获得维护，因为只有成员函数可以影响它们 public意味着不封装 protected成员变量同样缺乏封装性 从封装角度看，只有两种访问权限：private和其他    Item 23：Prefer non-member non-friend functions to member functions  代码段示例：  1 2 3 4 5 6 7 8 9  class WebBrowser { public: ... void clearCache(); void clearHistory(); void removeCookies(); ... };   现在需要实现WebBrowser的清除功能，可以有两种方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class WebBrowser { public: ... void ClearEverything();\t// 清除函数作为类成员函数  ... }; void clearBrower(WebBrower\u0026amp; wb) { wb.clearCache(); wb.clearHistory(); wb.removeCookies(); }     事实上，member函数ClearEverything的封装性比non-member函数clearBrower低\n  提供non-member函数可允许对WebBrower相关机能有较大的包裹弹性，而那最终导致较低的编译依赖度，增加WebBrower的可延伸性\n  较大封装性的是non-member non-friend函数，因为它并不增加“能够访问class内的private成分”的函数数量\n  class定义式对客户而言是不能扩展的。客户派生的新的classes无法访问base classes中被封装的成员\n  Item 24：Declare non-member functions when type conversions should apply to all parameters  对有理数类：  1 2 3 4 5 6 7 8 9  class Rational { public: Rational(int numerator = 0, int denominator = 1); // 允许int-to-Rational隐式转换  int numerator() const; int denominator() const; private: ... };    倘若在类内实现operator*运算符的重载，即  1 2 3 4 5 6  class Rational { public: ... const Rational operator*(const Rational\u0026amp; rhs) const; };   此时\n1 2 3 4 5 6  Rational oneEnglish(1, 8); Rational oneHalf(1, 2); Rational result = oneHalf * oneEnglish;\t// very good! result = result * oneEnglish;\t// very good! result = oneHalf * 2;\t// very good! result = 2 * oneHalf;\t// wrong!   要实现最后一句的效果，必须通过：\n1 2  const Rational temp(2); result = oneHalf * temp;   而对于explicit构造函数的Rational类，则下面两句均不能通过编译：\n1 2  result = oneHalf * 2; result = 2 * oneHalf;    要使得两句均可通过编译，应使用non-member函数，允许编译器在每一个实参上执行隐式类型转换  1 2 3 4 5 6 7 8 9 10 11 12  class Rational{ ... }; const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { return Rational(lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator()); } Rational oneFourth(1, 4); Rational result; result = oneFourth * 2;\t// result = 2 * oneFourth;\t// 均可正确编译运行   Item 25：Consider support for a non-throwing swap  标准库实现法  1 2 3 4 5 6 7 8 9  namespace std{ template\u0026lt;typename T\u0026gt; void swap(T\u0026amp; a, T\u0026amp; b) { T temp(a); a = b; b = temp; } }    pimpl手法（pointer to implementation）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class WidgetImpl{ public: ... private: int a, b, c; std::vector\u0026lt;double\u0026gt; v; ... }; class Widget{ public: Widget(const Widget\u0026amp; rhs); Widget\u0026amp; operator=(const Widget\u0026amp; rhs) { ... *pImpl = *(rhs.pImpl);\t// 详见Item 10, 11, 12  ... } ... private: WidgetImpl* pImpl; };     复制三个Widgets，复制三个WidgetImpl对象，非常缺乏效率\n  模板偏特化\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Widget{ public: ... void swap(Widget\u0026amp; other) { using std::swap; swap(pImpl, other.pImpl); } ... }; namespace std{ template\u0026lt;\u0026gt; void swap\u0026lt;Widget\u0026gt;(Widget\u0026amp; a, Widget\u0026amp; b) { a.swap(b); } }    加入类模板  1 2 3 4 5 6 7 8 9 10 11 12  namespace WidgetStuff{ ... ... template\u0026lt;typename T\u0026gt; class WidgetImpl{...}; template\u0026lt;typename T\u0026gt; class Widget{...}; ... ... template\u0026lt;typename T\u0026gt; void swap(Widget\u0026lt;T\u0026gt;\u0026amp; a, Widget\u0026lt;T\u0026gt;\u0026amp; b){ a.swap(b); } }    总结  当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常 如果提供一个member swap，也该提供一个non-member swap来调用前者。对于class也请特化std::swap 调用swap时应针对std::swap使用using声明式，然后调用swap且不带任何“命名空间资格修饰” 为“用户定义类型”进行std template全特化是好的，但不要在std名称空间中加入新东西    ","description":"《Effective C++学习笔记第四章》","id":10,"section":"note","tags":["Effective C++","C++"],"title":"Chapter 4: Designs and Declarations","uri":"https://chaphlagical.github.io/zh/note/effectivecpp/ch4/"},{"content":"1. 曲线的表示 1.1. 隐式表示 曲线隐式表示为$f(x,y)=0$，该方法有诸多局限性：\n 对于同一个$x$横坐标值对应多个纵坐标值 存在一些位置，导数$\\dfrac{\\mathrm dy}{\\mathrm dx}$没有定义 关于轴变换非不变  1.2. 参数表示 曲线参数表示为$c(t)=(x(t),y(t))$\n 求值方便 参数$t$可作为时间进行插值 曲线可以理解为运动粒子的运动轨迹跟踪  2. 曲线建模举例 2.1. 用幂函数基进行建模 以抛物线$\\pmb f(t)=\\pmb at^2+\\pmb bt+\\pmb c$为例\n 幂函数基的系数缺少直觉上的几何意义  2.2. 一种改进的画法 其中，\n $\\pmb b_0^1=(1-t)\\pmb b_0+t\\pmb b_1$ $\\pmb b_1^1=(1-t)\\pmb b_1+t\\pmb b_2$  $$\n\\begin{align}\n\\pmb b_0^2\n\u0026amp;=(1-t)\\pmb b_0^1+t\\pmb b_1^1\\\\\n\u0026amp;=(1-t)[(1-t)\\pmb b_0+t\\pmb b_1]+t[(1-t)\\pmb b_1+t\\pmb b_2]\\\\\n\u0026amp;=(1-t)^2\\pmb b_0+2t(1-t)\\pmb b_1+t^2\\pmb b_2\n\\end{align}\n$$\n以之前的例子\n$$\n\\pmb f(t)=\\begin{pmatrix}1\\\\1\\end{pmatrix}t^2+\\begin{pmatrix}-2\\\\0\\end{pmatrix}t+\\begin{pmatrix}1\\\\0\\end{pmatrix}\n$$\n转为上述形式：\n$$\n\\pmb f(t)=\\begin{pmatrix}1\\\\0\\end{pmatrix}(1-t)^2+\\begin{pmatrix}0\\\\0\\end{pmatrix}2t(1-t)+\\begin{pmatrix}0\\\\1\\end{pmatrix}t^2\n$$\n在图上表示为\n 各系数均有相应的几何意义 更多直觉上的曲线操作  对于四个控制点，同样有：\n$$\n\\begin{matrix}\n\\pmb p_0^0(t)=\\pmb p_0,\u0026amp;\\pmb p_1^0(t)=\\pmb p_1,\u0026amp;\\pmb p_2^0(t)=\\pmb p_2,\u0026amp;\\pmb p_3^0(t)=\\pmb p_3\n\\end{matrix}\n$$\n第一次迭代：\n$$\n\\begin{align}\n\\pmb p_0^1\u0026amp;=(1-t)\\pmb p_0+t\\pmb p_1\\\\\n\\pmb p_1^1\u0026amp;=(1-t)\\pmb p_1+t\\pmb p_2\\\\\n\\pmb p_2^1\u0026amp;=(1-t)\\pmb p_2+t\\pmb p_3\n\\end{align}\n$$\n第二次迭代：\n$$\n\\begin{align}\n\\pmb p_0^2=(1-t)^2\\pmb p_0+2t(1-t)\\pmb p_1+t^2\\pmb p_2\\\\\n\\pmb p_1^2=(1-t)^2\\pmb p_1+2t(1-t)\\pmb p_2+t^2\\pmb p_3\\\n\\end{align}\n$$\n最终得到的曲线方程：\n$$\n\\pmb c(t)=(1-t)^3\\pmb p_0+3t(1-t)^2\\pmb p_1+3t^2(1-t)\\pmb p_2+t^3\\pmb p_3\n$$\n3. De Casteljau算法 3.1. 动机  对给定$t$计算$\\pmb x(t)$  按比例$t:(1-t)$平分控制多边形 用线连接新点（相邻线段） 用相同比例进行插值 迭代，直到只剩下一个点    3.2. 算法描述   输入点：$\\pmb b_0,\\pmb b_1,\\cdots,\\pmb b_n\\in\\mathbb R^3$\n  输出曲线：$\\pmb x(t),t\\in [0,1]$\n  对给定$t$进行点$\\pmb x(t)$的几何构造\n$$\n\\begin{align}\n\\pmb b_i^0(t)\u0026amp;=\\pmb b_i,\\ \\ \\ \\ i=0,\\cdots,n\\\\\n\\pmb b_i^r(t)\u0026amp;=(1-t)\\pmb b_i^{r-1}(t)+t\\pmb b_{i+1}^{r-1}(t)\\\\\nr=\u0026amp;1,\\cdots,n\\ \\ \\ \\ i=0,\\cdots,n-r\n\\end{align}\n$$\n  最后，$\\pmb b_0^n(t)$为所找的曲线点$\\pmb x(t)$在参数值$t$的取值\n  所有系数可写为下三角矩阵：\n$$\n\\begin{matrix}\n\\pmb b_0=\\pmb b_0^0\\\\\n\\pmb b_1=\\pmb b_1^0\u0026amp;\\pmb b_0^1\\\\\n\\pmb b_2=\\pmb b_2^0\u0026amp;\\pmb b_1^1\u0026amp;\\pmb b_0^2\\\\\n\\pmb b_3=\\pmb b_3^0\u0026amp;\\pmb b_2^1\u0026amp;\\pmb b_1^2\u0026amp;\\pmb b_0^3\\\\\n\\vdots\u0026amp;\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\ddots\\\\\n\\pmb b_{n-1}=\\pmb b_{n-1}^0\u0026amp;\\pmb b_{n-2}^1\u0026amp;\\cdots\u0026amp;\\cdots\u0026amp;\\cdots\u0026amp;\\pmb b_0^{n-1}\\\\\n\\pmb b_n=\\pmb b_n^0\u0026amp;\\pmb b_{n-1}^1\u0026amp;\\cdots\u0026amp;\\cdots\u0026amp;\\cdots\u0026amp;\\pmb b_1^{n-1}\u0026amp;\\pmb b_0^n=\\pmb x(t)\n\\end{matrix}\n$$\n伪代码：\n3.3. De Casteljau算法性质   包含点$\\pmb b_0,\\cdots,\\pmb b_n$的多边形称为Bezier多边形\n  点$\\pmb b_i$称为Bezier点（控制点）\n  由Bezier点$\\pmb b_0,\\cdots,\\pmb b_n$和De Casteljau算法所定义的曲线称为Bezier曲线\n  De Casteljau算法是数值稳定的，因为只使用了凸组合\n  De Casteljau算法复杂度\n 时间复杂度$O(n^2)$ 空间复杂度$O(n)$ 其中$n$为Bezier点的数量    Bezier曲线的性质\n  给定Bezier点$\\pmb b_0,\\cdots,\\pmb b_n$和Bezier曲线$\\pmb x(t)$\n  Bezier曲线是$n$阶多项式曲线\n  端点$\\pmb x(0)=\\pmb b_0,\\pmb x(1)=\\pmb b_n$插值，其余的Bezier点仅仅是大致的近似值\n  凸包性质：\n Bezier曲线完全在其Bezier多边形的凸包内部    变化减少\n 没有直线与Bezier曲线的交点比Bezier多边形多    Bezier点的影响：全局但伪局部\n 全局：移动Bezier点会改变整个曲线的形状 伪局部：点$\\pmb b_i$对$x(t)$在$t=\\dfrac{i}{n}$有最大的影响    仿射不变性\n Bezier曲线和Bezier多边形在仿射变换下不变    仿射参数变换不变性\n  对称性\n 以下两条Bezier曲线重合，它们仅在相反的方向上移动：  $$\n\\begin{matrix}\n\\pmb x(t)=[\\pmb b_0,\\cdots,\\pmb b_n]\u0026amp;\n\\pmb x'(t)=[\\pmb b_n,\\cdots,\\pmb b_0]\n\\end{matrix}\n$$\n  线性精确\n 当$\\pmb b_0,\\cdots,\\pmb b_n$共线时，Bezier曲线为线段    重心组合下的不变性\n    4. Bezier曲线 Bezier曲线表示为基函数组合：\n$$\n\\pmb x(t)=\\sum\\limits_{i=0}^n\\pmb B_i^n(t)\\cdot b_i\n$$\n4.1. 期望特性  对基底的要求：  良好性质的曲线  光滑的基函数   局部控制（或者至少半局部）  紧致的基函数   仿射不变性  对控制点或曲线进行仿射变换$\\pmb x=A\\pmb x+b$应该有相同的效果 例如：旋转、平移 否则交互式编辑曲线将非常困难   凸包性质  曲线处于其控制点的凸包内 至少能够避免奇怪的震荡   优点  计算优势（递归相交测试） 更多可预测的行为      4.2. 仿射不变性  仿射变换：$\\pmb x\\rightarrow A\\pmb x+\\pmb b$  4.2.1. 线性不变性 Bezier曲线的线性不变性是显然的，Bezier曲线表示为基函数的线性组合：\n$$\n\\pmb f(t)=\\sum\\limits_{i=1}^nb_i(t)\\pmb p_i=\\sum\\limits_{i=1}^nb_i(t)\\begin{pmatrix}\np_i^{(x)}\\\\p_i^{(y)}\\\\p_i^{(z)}\n\\end{pmatrix}\n$$\n因此\n$$\nA(\\pmb f(t))=A\\Big(\\sum\\limits_{i=1}^nb_i(t)\\pmb p_i \\Big)=\\sum\\limits_{i=1}^nb_i(t)(A\\pmb p_i)\n$$\n4.2.2. 平移不变性 $$\n\\sum\\limits_{i=1}^nb_i(t)(\\pmb p_i+\\pmb b)=\\sum\\limits_{i=1}^nb_i(t)\\pmb p_i+\\sum\\limits_{i=1}^nb_i(t)\\pmb b=\\pmb f(t)+\\Big(\\sum\\limits_{i=1}^nb_i(t)\\Big)\\pmb b\n$$\n 为了满足平移不变性，基函数的和应恒为1 这也称为\u0026quot;partition of unity property\u0026quot;，单位划分性质 $\\pmb b_i$是控制点$\\pmb p_i$的“仿射组合” 该性质对建模非常重要  4.3. 凸包性质   凸组合\n  点集${\\pmb p_1,\\cdots,\\pmb p_n}$的一个凸组合为如下形式\n$$\n\\sum\\limits_{i=1}^n\\lambda_i\\pmb p_i\\ \\mathrm{with}\\sum\\limits_{i=1}^n\\lambda_i=1\\ \\mathrm{and}\\ \\forall i=1,\\cdots,n:0\\leq\\lambda_i\\leq 1\n$$\n  所有允许的凸组合的集合形成点集的凸包\n 凸包是包含所有点集${\\pmb p_1,\\cdots,\\pmb p_n}$以及集合中两个元素之间的每条完整连线的最小集合      相应地\n  如果我们有性质：\n$$\n\\forall t\\in\\Omega:\\sum\\limits_{i=1}^nb_i(t)=1\\ \\mathbb {and}\\ \\forall t\\in\\Omega,\\forall i:b_i(t)\\geq 0\n$$\n所构造地曲线/曲面将满足：\n 仿射不变性（平移，线性映射） 限制在控制点的凸包中    推论：曲线将有linear precision（线性精确）\n 当所有控制点共线时，曲线为直线段 具有平面控制点的曲面也将是平面      凸包性质在实践中十分有用\n 避免不良震荡  被限制在凸包内，不像多项式插值   线性精确性质比较直观（用户友好） 可用于快速范围检查  相交测试可以先对凸包进行，然后再对物体进行 递归相交算法与细分规则结合使用      4.4. Bezier曲线的多项式描述   给定$(n+1)$个控制点$\\pmb b_0,\\cdots,\\pmb b_n$\n  目标：Bezier曲线$\\pmb x(t)$，其中$t\\in[0,1]$\n  定义$n+1$个基函数，通过其线性组合来描述一个Bezier曲线\n$$\nB_0^n(t),\\cdots,B_n^n(t)\\ \\mathbb{over}\\ [0,1]\n$$\n$$\n\\pmb x(t)=\\sum\\limits_{i=0}^nB_i^n(t)\\cdot\\pmb b_i\n$$\n  4.4.1. Bernstein基函数 Bernstein基函数：$B={B_0^{(n)},B_1^{(n)},\\cdots,B_n^{(n)} }$\n  $n$次Bernstein基函数\n$$\nB_i^{(n)}(t)=\\begin{pmatrix}n\\\\ i\\end{pmatrix}\nt^i(1-t)^{n-i}\n$$\n其中，二项式系数\n$$\n\\begin{pmatrix}n\\\\i\\end{pmatrix}=\n\\begin{cases}\n\\dfrac{n!}{(n-i)!!}\u0026amp;\\mathrm {for}\\ 0\\leq i\\leq n\\\\\n0\u0026amp;\\mathrm{otherwise}\n\\end{cases}\n$$\n杨氏三角：\n前三组Bernstein基函数\n  4.4.2. Bernstein基函数的性质 $$\nB={B_0^{(n)},B_1^{(n)},\\cdots,B_n^{(n)}},\\ \\ \\\nB_i^{(n)}=\\begin{pmatrix}n\\\\i\\end{pmatrix}t^i(1-t)^{n-i}\n$$\n光滑性\n基函数为$n$次多项式——显然光滑\n局部控制\n每个基函数$B_i^{(n)}$在$t=\\dfrac{i}{n}$处取最大值——对该处有最大影响\n凸包性质和仿射不变性\n组合数的性质：\n$$\n\\sum\\limits_{i=0}^nB_i^{(n)}(t)=(t+(1-t))^n=1\n$$\n递归计算特性\n$$\n\\begin{align}\nB_i^n(t):=(1-t)B_i^{(n-1)}(t)+tB_{i-1}^{(n-1)}(1-t)\\\\ \\mathrm{with}\\ B_0^0(t)=1,B_i^n(t)=0\\ \\ \\mathrm {for}\\ i\\not\\in{0,\\cdots,n}\n\\end{align}\n$$\n对称性\n$$\nB_i^n(t)=B_{n-i}^n(1-t)\n$$\n非负性\n$$\nB_i^{(n)}(t)\\geq 0\\ \\mathrm{for}\\ t\\in[0,\\cdots,1]\n$$\n$$\nB_i^{(n)}(t)\u0026gt;0\\ \\mathrm{for}\\ 0\u0026lt;t\u0026lt;1\n$$\n$$\n\\begin{align}\nB_0^{(n)}(0)=1,\\ \\ \\ \\ B_1^{(n)}(0)=\\cdots=B_n^{(n)}(0)=0\\\\\nB_0^{(n)}(1)=\\cdots=B_{n-1}^{(n)}=0,\\ \\ \\ \\ B_n^{(n)}(1)=1\n\\end{align}\n$$\n导数\n$$\n\\begin{align}\n\\dfrac{\\mathrm d}{\\mathrm dt}B_i^{(n)}(t)\u0026amp;=\\begin{pmatrix}n\\\\ i\\end{pmatrix}(it^{i-1}(1-t)^{n-i}-(n-i)t^i(1-t)^{n-i-1})\\\\\\ \u0026amp;=\\dfrac{n!}{(n-i)!i!}it^{i-1}(1-t)^{n-i}-\\dfrac{n!}{(n-i)!i!}(n-i)t^i(1-t)^{n-i-1}\\\\\u0026amp;=n\\Bigg[\\begin{pmatrix}n-1\\\\ i-1\\end{pmatrix}t^{i-1}(1-t)^{n-i}-\\begin{pmatrix}n-1\\\\ i\\end{pmatrix}t^i(1-t)^{n-i-1} \\Bigg]\\\\ \u0026amp;=n\\Big[B^{(n-1)}_{i-1}(t)-B_i^{(n-1)}(t)\\Big]\n\\end{align}\n$$\n$$\n\\begin{align}\n\\dfrac{\\mathrm d^2}{\\mathrm dt^2}B_i^{(n)}(t)\u0026amp;=\\dfrac{\\mathrm d}{\\mathrm dt}\\Big[B_{i-1}^{(n-1)}(t)-B_i^{(n-1)}(t) \\Big]\\\\ \u0026amp;=n\\Big[(n-1)\\Big(B_{i-2}^{(n-2)}(t)-B_{i-1}^{(n-2)}(t) \\Big)-(n-1)\\Big(B_{i-1}^{(n-2)}(t)-B_i^{(n-2)}(t) \\Big) \\Big]\\\\ \u0026amp;=n(n-1)\\Big[B_{i-2}^{(n-2)}(t)-2B_{i-2}^{(n-2)}(t)+B_i^{(n-2)}(t) \\Big]\n\\end{align}\n$$\n4.5. Bezier曲线的性质 4.5.1. 前面提到过的性质：   仿射不变性\n  凸包性质\n  控制点影响性\n  4.5.2. 导数性质 对于$t\\in[0,1]$，有\n$$\n\\pmb f(t)=\\sum\\limits_{i=0}^{n-1}\\begin{pmatrix}n\\\\i\\end{pmatrix}t^i(1-t)^{n-i}\\pmb p_i\\\n\\Rightarrow \\pmb f(0)=\\pmb p_0\\ \\ \\ \\ \\pmb f(1)=\\pmb p_1\n$$\n一阶导数\n$$\n\\begin{align}\n\\dfrac{\\mathrm d}{\\mathrm dt}\\pmb f(t)\u0026amp;=n\\sum\\limits_{i=0}^{n-1}\\Big[B_{i-1}^{(n-1)}(t)-B_i^{(n-1)}(t) \\Big]\\pmb p_i\\\\\n\u0026amp;=n\\Big(\\Big[-B_0^{(n-1)}(t) \\Big]\\pmb p_0+\\Big[B_0^{n-1}(t)-B_1^{(n-1)}(t) \\Big]\\pmb p_1+\\cdots\\Big)\n\\end{align}\n$$\n$$\n\\begin{matrix}\n\\dfrac{\\mathrm d}{\\mathrm dt}\\pmb f(0)=n(\\pmb p_1-\\pmb p_0)\u0026amp;\\dfrac{\\mathrm d}{\\mathrm dt}\\pmb f(1)=n(\\pmb p_n-\\pmb p_{n-1})\n\\end{matrix}\n$$\n以此类推，对于边界点${0,1}$，有\n$$\n\\begin{align}\n\\pmb f(0)\u0026amp;=\\pmb p_0\\\\\n\\pmb f(1)\u0026amp;=\\pmb p_1\\\\\n\\pmb f'(0)\u0026amp;=n[\\pmb p_1-\\pmb p_0]\\\\\n\\pmb f'(1)\u0026amp;=n[\\pmb p_n-\\pmb p_{n-1}]\\\\\n\\pmb f''(0)\u0026amp;=n(n-1)[\\pmb p_2-2\\pmb p_1+\\pmb p_0]\\\\\n\\pmb f''(1)\u0026amp;=n(n-1)[\\pmb p_n-2\\pmb p_{n-1}+\\pmb p_{n-2}]\n\\end{align}\n$$\n对于一阶导数，还有：\n$$\n\\begin{align}\n\\pmb f'(t)\u0026amp;=\\sum_{i=0}^n\\dfrac{\\mathrm d}{\\mathrm dt}B_i^{(n)}(t)\\pmb p_i\\\\\n\u0026amp;=n\\sum_{i=0}^n\\Big(B_{i-1}^{(n-1)}(t)-B_i^{(n-1)}(t) \\Big)\\pmb p_i\\\\\n\u0026amp;=n\\sum_{i=0}^nB_{i-1}^{(n-1)}(t)\\pmb p_i-n\\sum_{i=0}^nB_i^{(n-1)}(t)\\pmb p_i\\\\\n\u0026amp;=n\\sum_{i=-1}^{n-1}B_i^{(n-1)}(t)\\pmb p_{i+1}-n\\sum\\limits_{i=0}^nB_i^{(n-1)}(t)\\pmb p_i\\\\\n\u0026amp;=n\\sum_{i=0}^{n-1}B_i^{(n-1)}(t)\\pmb p_{i+1}-n\\sum\\limits_{i=0}^{n-1}B_i^{(n-1)}(t)\\pmb p_i\\\\\n\u0026amp;=n\\sum\\limits_{i=0}^{n-1}B_i^{(n-1)}(t)(\\pmb p_{i+1}-\\pmb p_i)\n\\end{align}\n$$\n高阶导数：\n$$\n\\pmb f^{[r]}(t)=\\dfrac{n!}{(n-r)!}\\sum\\limits_{i=0}^{n-r}B_i^{(n-r)}(t)\\cdot\\Delta^r\\pmb p_i\n$$\n4.6. Bezier曲线升阶（Degree Evaluation）   给定：$\\pmb b_0,\\cdots,\\pmb b_n\\rightarrow \\pmb x(t)$\n  目标：$\\overline{\\pmb b}_0,\\cdots,\\overline{\\pmb b_n},\\overline{\\pmb b}_{n+1} \\rightarrow \\overline{\\pmb x}(t)$ with $\\pmb x=\\overline{\\pmb x}$\n  解决方法：\n  $$\n\\begin{align}\n\\overline{\\pmb b}_0\u0026amp;=\\pmb b_0\\\\\n\\overline{\\pmb b}_{n+1}\u0026amp;=\\pmb b_n\\\\\n\\overline{\\pmb b}_j\u0026amp;=\\dfrac{j}{n+1}\\pmb b_{j-1}+\\Big(1-\\dfrac{j}{n+1}\\Big)\\pmb b_j\\ \\mathrm{for}\\ j=1,\\cdots,n\n\\end{align}\n$$\n  证明：\n考虑\n$$\n\\begin{align}\n(1-t)B_i^n(t)\u0026amp;=(1-t)\\begin{pmatrix}n\\\\i\\end{pmatrix}\n(1-t)^{n-i}t^i\\\\\n\u0026amp;=\\begin{pmatrix}n\\\\i\\end{pmatrix}(1-t)^{n+1-i}t^i\\\\\n\u0026amp;=\\dfrac{n+1-i}{n+1}\\begin{pmatrix}n+1\\\\i\\end{pmatrix}(1-t)^{n+1-i}t^i\\\\\n\u0026amp;=\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)\n\\end{align}\n$$\n类似地，\n$$\ntB_i^n(t)=\\dfrac{i+1}{n+1}B_i^{n+1}(t)\n$$\n从而有：\n$$\n\\begin{align}\n\\pmb f(t)\u0026amp;=[(1-t)+t]\\pmb f(t)\\\\\n\u0026amp;=[(1-t)+t]\\sum\\limits_{i=0}^nB_i^n(t)\\pmb P_i\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\Big[(1-t)B_i^n(t)+tB_i^n(t)\\Big]\\pmb P_i\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\Bigg[\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)+\\dfrac{i+1}{n+1}B_{i+1}^{n+1}(t) \\Bigg]\\pmb P_i\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)\\pmb P_i+\\sum\\limits_{i=0}^n\\dfrac{i+1}{n+1}B_{i+1}^{n+1}(t) \\pmb P_i\\\\\n\u0026amp;=\\sum\\limits_{i=0}^n\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)\\pmb P_i+\\sum\\limits_{i=1}^n\\dfrac{i}{n+1}B_{i}^{n+1}(t) \\pmb P_{i-1}\\\\\n\u0026amp;=\\sum\\limits_{i=0}^{n+1}\\dfrac{n+1-i}{n+1}B_i^{n+1}(t)\\pmb P_i+\\sum\\limits_{i=0}^n\\dfrac{i}{n+1}B_{i}^{n+1}(t) \\pmb P_{i-1}\\\\\n\u0026amp;=\\sum\\limits_{i=0}^{n+1}B_i^{n+1}(t)\\Bigg[\\dfrac{n+1-i}{n+1}\\pmb P_i+\\dfrac{i}{n+1}\\pmb P_{i-1} \\Bigg]\n\\end{align}\n$$\n  4.7. 细分   给定\n$$\n\\pmb b_0,\\cdots,\\pmb b_n\\rightarrow \\pmb x(t),t\\in[0,1]\n$$\n  目标\n$$\n\\begin{align}\n\\pmb b_0^{(1)},\\cdots,\\pmb b_n^{(1)}\\rightarrow \\pmb x^{(1)}(t)\\\\\n\\pmb b_0^{(2)},\\cdots,\\pmb b_n^{(2)}\\rightarrow \\pmb x^{(2)}(t)\\\\\n\\mathrm{with}\\quad \\pmb x=\\pmb x^{(1)}\\cup\\pmb x^{(2)}\n\\end{align}\n$$\n  解决方法\n$$\n\\pmb b_i^{(1)}=\\pmb b_0^i,\\pmb b_i^{(2)}=\\pmb b_0^{n-i}\\ \\mathrm{for}\\ i=0,\\cdots,n\n$$\n  4.8. 曲线范围 4.9. 矩阵实现 三次Bezier曲线\n$$\n\\pmb P(t)=\\pmb V_0B_{0,3}+\\pmb V_1B_{1,3}+\\pmb V_2B_{2,3}+\\pmb V_3B_{3,3}\n$$\n$$\n\\begin{align}\nB_{0,3}\u0026amp;=\\dfrac{3!}{0!3!}t^0(1-t)^3=(1-t)^3\\\\\nB_{1,3}\u0026amp;=\\dfrac{3!}{1!2!}t^1(1-t)^2=3t(1-t)^2\\\\\nB_{2,3}\u0026amp;=\\dfrac{3!}{2!1!}t^2(1-t)^1=3t^2(1-t)\\\\\nB_{3,3}\u0026amp;=\\dfrac{3!}{3!0!}t^3(1-t)^0=t^3\n\\end{align}\n$$\n矩阵形式表示：\n$$\n\\pmb P(t)=\\begin{bmatrix}t^3\u0026amp;t^2\u0026amp;t\u0026amp;1\\end{bmatrix}\n\\begin{pmatrix}\n-1\u0026amp;3\u0026amp;-3\u0026amp;1\\\\3\u0026amp;-6\u0026amp;3\u0026amp;0\\\\-3\u0026amp;0\u0026amp;3\u0026amp;0\\\\1\u0026amp;4\u0026amp;1\u0026amp;0\n\\end{pmatrix}\n\\begin{bmatrix}\nV_{i-1}\\\\V_i\\\\V_{i+1}\\\\V_{i+2}\n\\end{bmatrix}\n$$\n导数的矩阵表示：\n$$\n\\pmb P'(t)=\\begin{bmatrix}3t^2\u0026amp;2t\u0026amp;1\u0026amp;0\\end{bmatrix}\n\\begin{pmatrix}\n-1\u0026amp;3\u0026amp;-3\u0026amp;1\\\\3\u0026amp;-6\u0026amp;3\u0026amp;0\\\\-3\u0026amp;0\u0026amp;3\u0026amp;0\\\\1\u0026amp;4\u0026amp;1\u0026amp;0\n\\end{pmatrix}\n\\begin{bmatrix}\nV_{i-1}\\\\V_i\\\\V_{i+1}\\\\V_{i+2}\n\\end{bmatrix}\n$$\n","description":"Bezier曲线学习笔记","id":11,"section":"note","tags":["CAGD"],"title":"CAGD(2) | Bezier曲线","uri":"https://chaphlagical.github.io/zh/note/cagd/cagd2/"},{"content":"Item 13：Use objects to manage resources   以对象管理资源的两个关键想法\n 获得资源后立即放入管理对象  资源取得时机便是初始化时机（Resource Acquisition Is Initialization；RAII）   管理对象运用析构函数确保资源被释放    智能指针简介\n auto_ptr  被销毁时会自动删除它所指之物 若通过copy构造函数或copy assignment操作符复制它们，它们将变成null，而复制得到的指针取得资源的唯一所有权 受auto_ptrs管理的资源必须绝对没有一个以上的auto_ptr同时指向它 现代C++中常用unique_ptr代替auto_ptr   shared_ptr  属于引用计数型智能指针（Reference-counting smart pointer;RCSP） 持续追踪共有多少对象指向某笔资源，并在无人指向它时自动删除该资源      智能指针auto_ptr和tr1::shared_ptr的析构函数内进行的删除操作为delete，因此不建议在动态分配得到的数组上使用智能指针\n  Item 14：Think carefully about copying behavior in resource-managing classes   复制RAII对象必须一并复制它所管理的资源，所以资源的copy行为决定RAII的copy行为\n  常见的RAIIcopy行为有：\n    禁止复制\n 将copy操作声明为private    对底层资源使用“引用计数”（shared_ptr）\n 保有资源直到其最后一个使用者被销毁，该情况下复制RAII对象，其被引用数将递增 shared_ptr允许指定删除器，引用次数为0时将自动调用删除器，如：    1 2 3 4 5 6 7 8 9 10  class Lock{ public: explicit Lock(Mutex* pm) : mutexPtr(pm, unlock)\t// 指定unlock函数作为删除器  { lock(mutexPtr.get()); } private: std::tr1::shared_ptr\u0026lt;Mutex\u0026gt; mutexPtr; }   复制底部资源  复制资源管理对象时，应该同时复制其所包覆的资源，即进行深度拷贝   转移底部资源的所有权（auto_ptr）  希望确保永远只有一个RAII对象指向一个原始资源 当RAII对象被复制时，资源的拥有权从被复制对象转移到目标对象    Item 15：在资源管理类中提供对原始资源的访问   往往是接口需要\n  显式转换与隐式转换\n  1 2 3 4 5 6 7 8 9 10 11  FontHandle getFont();\t// C API void releaseFont(FontHandle fh);\t// C API class Font{ public: explicit Font(FontHandle fh) :f(fh) {} ~Font(){releaseFont(f);} private: FontHandle f; };    显式转换  1 2 3 4 5 6  class Font{ public: ... FontHandle get() const {return f;} ... };   每次使用时必须调用get\n1 2 3 4 5  void changeFontSize(FontHandle f, int newSize); Font f(getFont()); int newFontSize; ... changeFontSize(f.get(),newFontSize);   这种做法暴露了原始资源，增加资源泄露的风险\n 隐式转换  1 2 3 4 5 6 7  class Font{ public: ... operator FontHandle() const {return f;} ... };   这种方法客户端调用更加自然\n1 2 3 4  Font f(getFont()); int newFontSize; ... changeFontSize(f, newFontSize);   隐式转换也会增加发生错误的机会，比如客户可能在需要Font的时候意外创建一个FontHandle\n1 2 3  Font f1(getFont()); ... FontHandle f2=f1;    一般而言，显式转换比较安全，而隐式转换更加客户友好  Item 16：Use the same form in corresponding uses of new and delete   使用new时，有两件事发生\n 内存被分配出来 针对此内存会有一个或更多构造函数被调用    使用delete时，有两件事发生\n 针对此内存会有一个或更多析构函数被调用 内存被释放    数组的删除\n 和单一对象的内存布局不同，数组所用内存通常还包括“数组大小”的记录，以便删除函数直到需要调用多少次析构函数 对于数组的删除，应当使用delete[]    使用了typedef\n  1 2 3 4  typedef std::string AddressLines[4]; std::string* pal = new AddressLines; delete pal;\t// 行为未定义 deletep[] pal;\t// 正确   为减少错误的产生，尽量不要对数组形式做typedef操作\nItem 17：Stored newed objects in smart pointers in standalone statement  智能指针构造函数需要一个原始指针，但该构造函数是个explicit构造函数，无法进行隐式转换  1 2  int priority(); void processWidget(std::tr1::shared_ptr\u0026lt;Widget\u0026gt; pw, int priority);   考虑调用\n1  processWidget(new Widget, priority());   将不能通过编译，欲使程序正常编译，应显式调用：\n1  processWidget(std::tr1::shared_ptr\u0026lt;Widget\u0026gt;(new Widget), priority());     std::tr1::shared_ptr\u0026lt;Widget\u0026gt;(new Widget)调用过程：\n 执行new Widget表达式 调用std::tr1::shared_ptr构造函数    调用processWidget前编译器的工作：\n  调用priority\n  执行new Widget表达式\n  调用std::tr1::shared_ptr构造函数\n  C++完成上述任务的顺序弹性很大，不过可以肯定的是new Widget一定在std::tr1::shared_ptr构造函数被调用前执行。\n倘若调用priority在其他两个操作中间，此时如果priority调用异常，new Widget得到的指针将无法送到智能指针处，导致资源泄露\n  科学的方法是使用分离语句\n  1 2  std::tr1::shared_ptr\u0026lt;Widget\u0026gt; pw(new Widget); processWidget(pw, priority());   ","description":"《Effective C++学习笔记第三章》","id":12,"section":"note","tags":["Effective C++","C++"],"title":"Chapter 3: Resource Management","uri":"https://chaphlagical.github.io/zh/note/effectivecpp/ch3/"},{"content":"Item 5: Know what functions C++ silently writes and calls   C++对类会提供默认的函数，所有这些函数都是public且inline的\n 默认函数包括default构造函数，copy构造函数，copy assignment操作符，析构函数    下面两块代码等价：\n  1  class Empty{};   1 2 3 4 5 6 7 8 9  class Empty{ public: Empty(){...} Empty(const Empty\u0026amp; rhs){...} ~Empty(){...} Empty\u0026amp; operator=(const Empty\u0026amp; rhs){...} }     编译器产生的析构函数是个non-virtual函数，除非这个class 的基类自身声明有virtual析构函数\n  编译器生成的复制构造函数和复制赋值操作符简单地复制了源对象每个非静态数据成员到目标对象\n  Item 6: Explicitly disallow the use of compiler-generated functions you do not want   C++的默认构造函数和析构函数是自动生成的，如不需要，必须手动进行禁用\n  可以将相关函数声明为private并且不去定义它\n  1 2 3 4 5 6 7 8  class HomeForSale{ public: ... private: ... HomeForSale(const HomeForSale\u0026amp;); HomeForSale\u0026amp; operator=(const HomeForSale\u0026amp;); };    也可以通过设计以下类进行继承以减少代码重复：  1 2 3 4 5 6 7 8 9  class Uncopyable{ protected: Uncopyable(){} ~Uncopyable(){} private: Uncopyable(const Uncopyable\u0026amp;); Uncopyable\u0026amp; operator=(const Uncopyable\u0026amp;); };    使用时，只需要  1 2 3  class HomeForScale:private Uncopyable{ ... };   Item 7: Declare destructors virtual in polymorphic base classes  对于多态类，可以定义一个基类及其派生类，利用指向基类的指针，重新指向派生类进行操作 但对指向派生类的基类指针进行内存释放时，指针将作为基类指针进行删除，如果基类存在一个非virtual析构函数，则只会删除所指派生类的基类部分，而对于派生类剩余部分将造成内存泄漏 解决方法：将基类的析构函数声明为virtual函数，删除派生类时将会把整个对象删除，包括派生类部分 virtual函数的原理：  要实现virtual函数，对象必须携带某些信息，主要用来在运行期决定哪个virtual函数该被调用 该信息由虚表指针（vptr，virtual table pointer）指针指出 vptr指向一个由函数指针构成的数组，称为虚表(vtbl，virtual table) 每一个带有virtual函数的class都有相应的vtbl 当对象调用某一virtual函数，实际被调用的函数取决于该对象的vptr所指向的那个vtbl——编译器在其中寻找合适的函数指针   如果一个类不打算作为基类或为了具备多态性，则最好不要使用virtual函数 多态基函数应该声明一个virtual析构函数，如果class带有任何virtual函数，就应该拥有一个virtual析构函数 如果类中含有纯virtual函数，则该类将变成抽象函数，不能进行实例化  如果希望声明一个没有纯virtual成员函数的抽象类，可以在类中声明一个纯virtual的析构函数 纯virtual析构函数应提供定义   为基类提供virtual拟析构函数的规则仅适用于多态基类，并非所有基类都会用于多态  STL容器均不设计为基类 像Uncopyable这类基类也不设计为多态    Item 8: Prevent exceptions from leaving destructors   C++的析构函数中发生异常是一件很麻烦的事\n  一般C++程序发生异常可能会出现两种情况：\n 程序提前终止 程序发生未知行为  而析构函数发生异常时常出现第二种情况\n  解决方法：\n   手动终止程序  1 2 3 4 5 6 7 8  DBConn::~DBConn() { try{db.close();} catch (...){ //\tLog here  std::abort(); } }   当程序无法正常运行时将进入异常处理函数，调用abort以结束程序\n忽略异常  1 2 3 4 5 6 7  DBConn::~DBConn() { try{db.close();} catch (...){ //\tLog here  } }   一般情况下不推荐做法，但在程序要求持续可靠运行时是个不错的选择\n重新设计接口（推荐做法）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class DBConn{ public: ... void close() { db.close(); closed=true; } ~DBConn() { if(!closed){ try{ db.close(); } catch(...){ // logging  ... } } } private: DBConnection db; bool closed; };    提供自身的close函数，赋予客户端一个机会得以手动处理异常 同时DBConn也可追踪其管理的DBConnection是否关闭，并在答案为否的时候调用析构函数将其关闭  Item 9: Never call virtual functions during construction or destruction  在构造函数和析构函数中不应该调用virtual函数，因为所调用的virtual函数可能不是你想调用的那个virtual函数，举例：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Transaction{ public: Transaction(); virtual void logTransaction() const = 0; ... }; Transaction::Transaction() { ... logTransaction(); } class BugTransaction:public Transaction{ public: virtual void logTransaction() const; ... }; class SellTransaction:public Transaction{ public: virtual void logTransaction() const; ... }; // 执行 BuyTransaction b;     在调用BuyTransaction构造函数之前，基类Transaction构造函数会先被调用\n  Transaction构造函数调用了virtual函数，且该virtual函数此时为Transaction版本\n  对象在派生类构造函数开始执行前不会成为一个派生类对象\n 因为此时派生类成员变量未定值    一个潜藏的问题\n  1 2 3 4 5 6 7 8 9 10 11 12  class Transaction{ public: Transaction(){init();} virtual void logTransaction() const = 0; ... private: void init() { ... logTransaction(); } };     构造函数调用得函数中带有virtual函数\n  若virtual函数为纯virtual函数时，将发生链接错误\n  而若virtual函数有定义时，派生类的构造将得到错误的结果\n  假设有一个基类和多个派生类，基类的构造函数中调用了一个virtual成员函数，此时需要定义一个派生类对象\n 若virtual函数为纯virtual函数，基类构造函数将调用一个基类下的纯virtual函数，发生错误 若virtual函数为普通virtual函数，基类构造函数将调用一个基类下的virtual函数，而不是派生类中的多态函数，无法将派生类的信息传递到基类    解决问题的方法：\n 使用explicit关键字修饰带参数的构造函数 将原来的virtual成员函数定义为非virtual成员函数 在派生类中，使用成员初始化列表对基类进行传参初始化，这样即实现了将信息从派生类传递到基类的构造函数中  举例：\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Transaction{ public: explicit Transaction(const std::string\u0026amp; logInfo); void logTransaction(const std::string\u0026amp; logInfo) const; ... }; Transaction::Transaction(const std::string\u0026amp; logInfo) { ... logTransaction(logInfo); } class BuyTransaction: public Transaction{ public: BuyTransaction(parameters) :Transaction(createLogString(parameters)) {...} ... private: static std::string createLogString(parameters); };    令派生类将必要的构造信息向上传到基类构造函数  Item 10: Have assignment operators return a reference to *this  C++支持链式赋值操作：  1 2  int x,y,z; x=y=z=15;   也等价于\n1  x=(y=(z=15))    因此在定义赋值运算符重载时，最好也返回*this  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Widget{ public: ... Widget\u0026amp; operator=(const Widget\u0026amp; rhs) { ... return *this; } Widget\u0026amp; operator+=(const Widget\u0026amp; rhs) { ... return *this; } Widget\u0026amp; operator*=(const Widget\u0026amp; rhs) { ... return *this; } ... }    这只是个协议规范，并无强制性  Item 11: Handle assignment to self in operator=  将本身的值赋值给本身往往容易出现错误，例如：  1 2 3 4 5 6 7 8 9 10 11 12 13  class Bitmap{...}; class Widget{ ... private: Bitmap* pb; }; Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { delete pb; pb=new Bitmap(*ths.pb); return *this; }   这里ths可能就是其自己本身，而整个代码运行后将返回一个指向已删除对象的指针\n 传统的解决方法是进行测试  1 2 3 4 5 6 7 8  Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { if(this==\u0026amp;rhs)return *this; delete pb; pb=new Bitmap(*rhs.pb); return *this; }   这种方法是有缺陷的，假设在新建Bitmap的过程中出现异常，得到的指针将是有害的，你将不能安全的删除它们，甚至是读取它们\n 一种安全的做法是保存下指针原来所指的值  1 2 3 4 5 6 7  Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { Bitmap *pOrig = pb; pb = new Bitmap(*rhs.pb); delete pOrig; return *this; }   需要复制，效率不够高\n 复制和交换（copy and swap）技术。确保实现既是异常安全又是复制安全  1 2 3 4 5 6 7  Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { Widget temp(rhs); swap(temp);\t// 交换*this和*temp  return *this; }   Item 12: Copy all parts of an object   一般的复制函数包括：复制构造函数和复制赋值运算符\n  默认的复制函数将复制对象中所有的数据\n  自定义的复制函数必须要把所有数据都进行拷贝（包括基类数据）\n 注意类继承时容易出现不完全拷贝的情况，复制函数应确保复制对象内所有成员变量和所有基类成分    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class Data{...} class Customer{ public: ... private: std::string name; Data lastTransaction; }; class PriorityCustomer: public Customer{ public: ... PriorityCustomer(const PriorityCustomer\u0026amp; rhs); PriorityCustomer\u0026amp; operator=(const PriorityCustomer\u0026amp; rhs); ... private: int priority; }; PriorityCustomer::PriorityCustomer(const PriorityCustomer\u0026amp; rhs) :Customer(rhs),priority(ths.priority) { logCall(\u0026#34;PriorityCustomer copy constructor\u0026#34;); } PriorityCustomer\u0026amp; PriorityCustomer::operator=(const PriorityCustomer\u0026amp; rhs) { logCall(\u0026#34;PriorityCustomer copy assignment operator\u0026#34;); Customer::operator=(rhs); priority=rhs.priority; return *this; }   ","description":"《Effective C++学习笔记第二章》","id":13,"section":"note","tags":["Effective C++","C++"],"title":"Chapter 2: Constructors, Destructors, and Assignment Operators","uri":"https://chaphlagical.github.io/zh/note/effectivecpp/ch2/"},{"content":"Item 1: View C++ as a federation of languages   C++的多重范型性：支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式\n  将C++视为次语言的集合：\n C：区块blocks、语句statements、预处理器preprocessor，内置数据结构built-in data types、数组arrays、指针pointers等 Object-Oriented C++：classes（构造与析构函数）、封装encapsulation、继承inheritance、多态polymorphism、virtual函数（动态绑定）等 Template C++：模板元编程TMP STL：template程序库，容器containers、迭代器iterators、算法algorithms、函数对象function objects    Item 2: Prefer consts, enums, and inlines to #define #define的缺陷\n  #define不会被编译器看到，甚至在预处理期就被替换掉了，名称不会进入符号表，直接替换成目标，容易造成调试上的困难\n例如：\n  1  #define ASPECT_RATIO 1.653   当使用常量`ASPECT_RATIO`且获得一个编译错误信息时，该错误信息可能提到1.653而不是`ASPECT_RATIO`，追踪与调试将带来麻烦\r   #define定义的宏可以实现类似函数的功能，且不会带来函数调用的开销，但是宏也存在很大的缺陷\n例如：\n  1  #define CALL_WITH_MAX(a,b) f((a)\u0026gt;(b)?(a):(b))   编写宏时应给每个变量加括号，但即使加了括号还是会有自增自减次数问题，如：\n1 2 3  int a=5,b=0; CALL_WITH_MAX(++a,b);\t// a被累加两次 CALL_WITH_MAX(++a,b+10);\t// a被累加一次   用const修饰常量\n  const修饰的常量名称能够被编译器看到，会进入符号表\n  const修饰常量指针，通常定义在头文件中，对于常量字符串，最好如下定义：\n  1 2  const char* const authorName = \u0026#34;Scott Meyers\u0026#34;;\t// char*-base const std::string authorName = \u0026#34;Scott Meyers\u0026#34;;\t// string class    const修饰class专属常量，为了将常量的作用域限制在class内，需要让它成为class的一个成员，且声明为static以保证此常量至多只有一份实体，例如：  1 2 3 4 5 6 7 8 9 10 11 12 13  class GamePlayer{ private: static const int NumTurns = 5;\t// 声明并定义 \tint scores[NumTurns]; ... }; class CostEstimate{ private: static const double FudgeFactor;\t// 头文件内声明 \t... }; const double ConstEstimate::FudgeFactor = 1.35;\t// 在实现文件中定义   用enum修饰常量\n  enum比const更接近于#define，const修饰的常量可取地址而enum修饰的不能（可用于保护常量），enum不会造成不必要的内存申请（避免他人对该常量取地址取指针）\n  enum是模板元编程的基础技术\n  举例：\n  1 2 3 4 5 6  class GamePlayer{ private: enum{ NumTurns = 5 }; int scores[NumTurns]; ... };   用inline代替宏\n 使用inline关键字定义内联函数，例如：  1 2 3 4 5  template\u0026lt;typename T\u0026gt; inline void callWithMax(const T\u0026amp; a, const T\u0026amp; b) { f(a\u0026gt;b?a:b); }   Item 3: Use const whenever possible const修饰指针与常量的用法\n 当const在星号左侧时，指针指向的为常值 当const在星号右侧时，指针本身为常值 当const星号两侧都有时，指针本身及其指向均为常值 当指针指向常值时，const在类型名前后意思相同  1 2 3 4 5 6 7  char greeting[] = \u0026#34;Hello\u0026#34;; char* p = greeting;\t// non-const pointer, non-const data const char* p = greeting;\t// non-const pointer, const data char* const p = greeting;\t// const pointer, non-const data const char* const p = greeting;\t// const pointer, const data void f1(const Widget *pw); void f1(Widget const *pw);\t// 两个意思相同   STL迭代器的const\n const iterator相当于T* const const_iterator相当于const T*  1 2 3 4 5 6 7 8  std::vector\u0026lt;int\u0026gt; vec; ... const std::vector\u0026lt;int\u0026gt;::iterator iter = vec.begin();\t// 相当于T* const *iter = 10;\t// 正确 ++iter;\t//错误 std::vector\u0026lt;int\u0026gt;::const_iterator cIter = vec.begin();\t// 相当于const T* *cIter = 10;// 错误 ++cIter;\t// 正确   const修饰函数返回值\n 降低客户错误而造成的意外，又不至于放弃安全性和高效性  1 2  class Rational{...} const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs);    若不加const，则错误(a*b)=c（实际是想进行比较(a*b)==c）将难以被发现  const修饰成员函数\n  目的：\n 使得class接口比较容易被理解 使“操作const对象”成为可能    举例：\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class TextBlock{ public: ... const char\u0026amp; operator[](std::size_t position) const { return text[position]; }\t// 返回const对象  char\u0026amp; operator[](std::size_t position) { return text[position]; }\t// 返回non-const对象 private: std::string text; }; // usage TextBlock tb(\u0026#34;Hello\u0026#34;); TextBlock ctb(\u0026#34;Hello\u0026#34;); std::cout\u0026lt;\u0026lt;tb[0];\t// 正确，读non-const tb[0]=\u0026#39;x\u0026#39;;\t// 正确，写non-const std::cout\u0026lt;\u0026lt;ctb[0];\t// 正确，读const ctb[0]=\u0026#39;x\u0026#39;;\t// 错误，写const     Bitwise-constness \u0026amp; Logical-constness\n  Bitwise-constness：成员函数只有在不更改对象的任何成员变量（static除外）时才可说是const\n  Logical-constness：一个const成员函数可以修改它所处理对象内的某些bits，但只有在客户端侦测不出来的情况下才满足const\n 使用mutable关键字，使得成员变量能够在const成员函数内被修改，例如：      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class CTextBlock{ public: ... std::size_t length() const; private: char* pText; mutable std::size_t textLength; mutable bool lengthIsValid; }; std::size_t CTextBlock::length() const { if(!lengthIsValid) { textLength = std::strlen(pText); lengthIsValid = true; } return textLength; }   const和non-const成员函数避免重复\n 使用类型转换 举例：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class TextBlock{ public: ... const char\u0026amp; operator[](std::size_t position) const { ... ... ... return text[position]; } char\u0026amp; operator[](std::size_t position) { return const_cast\u0026lt;char\u0026amp;\u0026gt;(static_cast\u0026lt;const TextBlock\u0026amp;\u0026gt;(*this)[position]); } ... };    static_cast加const强制安全转换（防止出现递归调用） const_cast移除const  Item 4: Make sure that objects are initialized before they\u0026rsquo;re used 内置类型的初始化\n 对于无任何成员的内置类型，手工进行初始化 举例：  1 2 3 4 5  int x = 0;\t// 手工初始化int const char* text = \u0026#34;A C-style string\u0026#34;;\t// 对指针进行手工初始化  double d; std::cin\u0026gt;\u0026gt;d;\t//读取输入流以初始化   成员对象的初始化\n  内置类型以外的任何东西，初始化由构造函数constructors完成\n  成员对象的初始化：成员初值列表（member initialization list）\n 举例：    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class PhoneNumber{...}; class ABEntry{ public: ABEntry(const std::string\u0026amp; name, const std::string\u0026amp; address, const std::list\u0026lt;PhoneNumber\u0026gt;\u0026amp; phones); private: std::string theName; std::string theAddress; std::list\u0026lt;PhoneNumber\u0026gt; thePhones; int numTimesConsulted; }; /* ABEntry::ABEntry(const std::string\u0026amp; name, const std::string\u0026amp; address, const std::list\u0026lt;PhoneNumber\u0026gt;\u0026amp; phones) { theName = name; theAddress = address; thePhones = phones; numTimesConsulted = 0; }\t// 赋值 */ ABEntry::ABEntry(const std::string\u0026amp; name, const std::string\u0026amp; address, const std::list\u0026lt;PhoneNumber\u0026gt;\u0026amp; phones) :theName(name), theAddress(address), thePhones(phones), numTimesConsulted(0) { }\t// 初始化   * 赋值 vs 初始化\r* 赋值：首先调用默认构造函数为成员变量赋初值，然后立刻再对它们赋新值\r* 使用成员初值列表避免赋值的问题，效率较高\r* 没有在成员初值列表中指定初值的成员变量：\r* 对于用户自定义类型的成员变量，将会自动调用其自身的默认构造函数\r* 对于内置类型的成员变量，则可能出现随机结果，带来问题\r 初始化顺序问题\n  一个源文件及其所有#include的文件称为一个编译单元translation unit\n  两种static对象：函数内的static对象称为local static对象，其他static对象称为non-local static对象\n  如果一个编译单元的non-local static对象的初始化用到另外一个不同的编译单元中的non-local static对象，则这个被用到的对象可能未被初始化\n C++对定义不同编译单元中的non-local static对象的初始化顺序没有明确定义    解决方法：将每个non-local static对象移动到各自的函数，这些函数内把对象声明为static，函数的返回包含它们包含的对象的引用。客户端调用函数而不是直接使用对象，这样一来将non-local static对象转化为local static对象（实际上就是设计模式中的单例模式）\n 原理：C++保证函数内的local-static对象会在\u0026quot;该函数被调用期间\u0026quot;以及\u0026quot;首次遇到该对象的定义式\u0026quot;时被初始化    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class FileSystem{...}; FileSystem\u0026amp; tfs() { static FileSystem fs; return fs; } class Directory{...}; Directory::Directory(params) { ... std::size_t disks = tfs().numDisks(); ... } Directory\u0026amp; tempDir() { static Directory td; return td; }    这种方法在多线程系统内具有不确定性，解决方法：可以在程序的单线程启动部分期间手动调用所有返回引用的函数，消除与初始化相关的竞争形势  小结\n初始化三部曲:\n 手动初始化内置型non-member对象 使用成员初值列表member initialization lists处理成员对象初始化 针对初始化次序不确定性加强设计  ","description":"《Effective C++学习笔记第一章》","id":14,"section":"note","tags":["Effective C++","C++"],"title":"Chapter 1: Accustoming Yourself to C++","uri":"https://chaphlagical.github.io/zh/note/effectivecpp/ch1/"},{"content":"1. 插值 1.1. 插值问题的描述 1.1.1. 问题的一般形式   寻找定义域$\\Omega\\subseteq \\mathbb R^d $，值域$\\mathbb R$上的函数$f:\\Omega\\rightarrow\\mathbb R$\n  基函数集合：$B={b_1,\\cdots,b_n}$，$b_i:\\Omega\\rightarrow\\mathbb R$\n  将$f$表示为基函数的线性组合\n  $$\nf_\\lambda(x)=\\sum\\limits_{k=0}^n\\lambda_ib_i(x)\n$$\n​\t其中，$f$由$\\lambda=\\begin{pmatrix}\\lambda_1 \\\\ \\vdots\\\\ \\lambda_n\\end{pmatrix}$唯一确定\n 函数值${(x_1,y_1), \\cdots,(x_n,y_n)}$，$(x_i,y_i)\\in \\mathbb R^d\\times\\mathbb R$ 目标找到$\\lambda$使得$f_\\lambda(x_i)=y_i$对所有$i$成立  1.1.2. 插值问题应用举例 最简单的光滑曲线曲面建模问题：\n 给定曲线或曲面上的一组点 选择一组可张成合适函数空间的基函数  光滑基函数 任意线性组合也为光滑函数   找到一个线性组合能够使得曲线或曲面能插值给定点  1.2. 插值问题的求解 构造线性方程组：\n 在数据点$x_i$上计算基函数：  $$\n\\forall i\\in{1,\\cdots,n}:\\sum\\limits_{i=1}^n\\lambda_ib_i(x_i)=y_i\n$$\n 写成矩阵形式：  $$\n\\begin{pmatrix}\nb_1(x_1)\u0026amp;\\cdots\u0026amp;b_n(x_1)\\\\\n\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\\nb_1(x_n)\u0026amp;\\cdots\u0026amp;b_n(x_n)\n\\end{pmatrix}\n\\begin{pmatrix}\n\\lambda_1\\\\ \\vdots\\\\ \\lambda_n\n\\end{pmatrix}=\n\\begin{pmatrix}\ny_1\\\\ \\vdots\\\\ y_n\n\\end{pmatrix}\n$$\n1.2.1. 多项式插值示例   使用多项式基$B={1,x,x^2,x^3,\\cdots,x^{n-1}}$\n  求解线性方程组\n  $$\n\\begin{pmatrix}\n1\u0026amp;x_1\u0026amp;\\cdots\u0026amp;x_1^{n-1}\\\\\n1\u0026amp;x_2\u0026amp;\\cdots\u0026amp;x_2^{n-1}\\\\\n\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\\n1\u0026amp;x_n\u0026amp;\\cdots\u0026amp;x_n^{n-1}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\lambda_1\\\\ \\lambda_2\\\\ \\vdots\\\\ \\lambda_n\n\\end{pmatrix}=\n\\begin{pmatrix}\ny_1\\\\ y_2\\\\ \\vdots\\\\ y_n\n\\end{pmatrix}\n$$\n1.2.2. 多项式插值存在的问题  系统矩阵稠密 依赖于基函数选取，矩阵可能病态，导致难以求解（求逆）  病态问题\n  输入数据的细微变化导致输出（解）的剧烈变化\n  将线性方程看成直线（超平面）\n 当系统病态时，直线编程近似平行 求解（即直线求交）变得困难、不精确    举例：\n  考虑二元方程组\n$x_1+0.5x_2=1.5$ 和 $0.667x_1+0.333x_2=1$\n解为$(1,1)$\n  对第二个方程右边项扰动0.001\n$x_1+0.5x_2=1.5$ 和 $0.667x_1+0.333x_2=0.999$\n解为$(0,3)$\n  对矩阵系数进行扰动\n$x_1+0.5x_2=1.5$ 和 $0.667x_1+0.334x_2=0.999$\n解为$(2,-1)$\n    1.2.3. 矩阵条件数 $$\n\\kappa_2(A)=\\dfrac{\\max\\limits_{x\\neq 0}\\dfrac{|Ax|}{|x|}}{\\min\\limits_{x\\neq 0}\\dfrac{|Ax|}{|x|}}\n$$\n 等于最大特征值和最小特征值之间的比例 条件数大意味着基元之间有太多相关性  考虑多项式插值\n 多项式插值问题是病态的  对于等距分布的数据点$x_i$，范德蒙矩阵的条件数随着数据点数$n$呈指数级增长（多项式最高次数为$n-1$）    原因：\n  幂（单项式）函数基\n 幂函数之间差别随次数增加而减小 不同幂函数之间唯一差别为增长速度    1.2.4. 函数互相抵消   对于单项式函数基，从左到右，首先由常函数1主宰，接着$x$增长最快，接着$x^2$增长最快，接着$x^3$增长最快\u0026hellip;\n  好的基函数一般需要系数交替以达到函数的互相抵消\n  解决方法：\n 使用正交多项式基 正交基获得方法：Gram-Schmidt正交化  1.3. 拉格朗日插值方法 拉格朗日插值方法避免求解线性方程组\n1.3.1. 拉格朗日插值的一般形式   构造插值问题的通用解\n  给定$n+1$个点${(x_0,y_0),\\cdots,(x_n,y_n) }$，寻找一组次数为$n$的多项式基函数$l_i$使得\n$$\nl_i(x_j)=\\begin{cases}\n1,\u0026amp;若i=j\\\n0,\u0026amp;若i\\neq j\n\\end{cases}\n$$\n    插值问题的解为\n$$\nP(x)=y_0l_0(x)+y_1l_1(x)+\\cdots+y_nl_n(x)=\\sum\\limits_{i=0}^ny_il_i(x)\n$$\n  1.3.2. 拉格朗日多项式的计算   $n$阶多项式，且有以下$n$个根\n$$\nx_0,x_1,x_2,\\cdots,x_{i-1},x_{i+1}\\cdots,x_n\n$$\n  可表示为\n$$\n\\begin{align}\nl_i(x)\u0026amp;=C_i(x-x_0)(x-x_1)\\cdots(x-x_{i-1})(x-x_{i+1})\\cdots(x-x_n)\\\\\n\u0026amp;=C_i\\prod_{j\\neq i}(x-x_j)\n\\end{align}\n$$\n  由$l_i(x_i)=1$，可得\n$$\n1=C_i\\prod_{j\\neq i}(x_i-x_j)\\Rightarrow C_i=\\dfrac{1}{\\prod_{j\\neq i}(x_i-x_j)}\n$$\n  最终的多项式基函数为\n$$\nl_i(x)=\\dfrac{\\prod_{j\\neq i}(x-x_j)}{\\prod_{j\\neq i}(x_i-x_j)}\n$$\n多项式$l_i(x)$称为拉格朗日多项式\n  1.3.3. 拉格朗日插值 vs 单项式基插值 事实上，给定同一组输入点，利用拉格朗日多项式和利用范德蒙矩阵（单项式基）进行插值所得到的解完全相同\n 假设解不同。记两个解的差别多项式为$R_n$，$R_n$阶数至多为$n$ 那么$R_n(x_i)=0$，$i=0,1,\\cdots,n$，$x_i$为不同插值点。因此$R_n$是有$n+1$个根的$n$阶多项式，因此$R_n=0$  1.3.4. 多项式插值分析  多项式插值不稳定 控制点的微小变化可导致完全不同的结果 振荡现象：多项式随着插值点数（可以是细微的）增加而摆动  解决方法：\n 使用更好的基函数做插值，例如：分片多项式  2. 逼近 2.1. 动机 2.1.1. 使用逼近的原因  数据点含噪声（采样） 更紧凑的表达 计算简单  2.1.2. 常用的逼近函数  多项式 有理函数（多项式商） 三角函数  2.2. 多项式逼近 2.2.1. 万能逼近定理 又叫Weierstrass定理：\n令$f$为闭区间$[a,b]$上任意连续函数，则对任意给定$\\varepsilon$，存在$n$和多项式$P_n$使得\n$$\n|f(x)-P_n(x)|\u0026lt;\\varepsilon,\\forall x\\in[a,b]\n$$\nWeierstrass只证明了存在性，而未给出多项式\n2.2.2. Bernstein多项式逼近 Bernstein多项式构造定理\n对$[0,1]$区间上任意连续函数$f(x)$和任意正整数$n$，以下不等式对所有$x\\in[0,1]$成立\n$$\n|f(x)-B_n(f,x)|\u0026lt;\\dfrac{9}{4}m_{f,n}\n$$\n $m_{f,n}=\\mathop {\\mathrm {lower\\ upper\\ bound}}\\limits_{y_1,y_2\\in[0,1]且|y_1-y_2|\u0026lt;\\frac{1}{\\sqrt{n}}}|f(y_1)-f(y_2)|$ $B_n(f,x)=\\sum_{j=0}^nf(x_j)b_{n,j}(x)$，其中$x_j$为$[0,1]$上等距采样点 $b_{n,j}=\\begin{pmatrix}n\\\\ j\\end{pmatrix}x^j(1-x)^{n-j}$为Bernstein多项式  Bernstein多项式逼近特点\n 逼近结果优秀，但需要高阶 计算昂贵 容易带来误差  2.3. 最小二乘逼近 2.3.1. 逼近问题  给定一组线性无关的连续函数集合$B={b_1,\\cdots,b_n}$和一组结点${(x_1,y_1),\\cdots,(x_m,y_m)}$，其中$m\u0026gt;n$ 在$B$张成空间中寻找对结点逼近最好的函数$f\\in\\mathrm{span}(B)$  2.3.2. 最佳逼近的定义 最小二乘逼近\n$$\n\\mathop{\\mathrm{argmin}}\\limits_{f\\in\\mathrm{span(B)}}\n\\sum\\limits_{j=1}^m(f(x_j)-y_j)^2\n$$\n$$\n\\begin{align}\n\\sum\\limits_{j=1}^m(f(x_j)-y_j)^2\u0026amp;=\\sum\\limits_{j=1}^m\\Big(\\sum\\limits_{i=1}^n\\lambda_ib_i(x_j)-y_j\\Big)^2\\\\\n\u0026amp;=(M\\pmb\\lambda-\\pmb y)^T(M\\pmb \\lambda-\\pmb y)\\\\\n\u0026amp;=\\pmb y^T\\pmb y-2\\pmb y^TM\\pmb \\lambda+\\pmb \\lambda^TM^TM\\pmb \\lambda\n\\end{align}\n$$\n其中，$\\pmb \\lambda=(\\lambda_1,\\lambda_2,\\cdots,\\lambda_n)^T$，$\\pmb y=(y_1,y_2,\\cdots,y_m)^T$，$M=\\begin{pmatrix}b_1(x_1)\u0026amp;\\cdots\u0026amp;b_n(x_1)\\\\ \\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\ b_1(x_m)\u0026amp;\\cdots\u0026amp;b_n(x_m) \\end{pmatrix}$\n2.3.3. 最小二乘解   关于$\\pmb\\lambda$的二次多项式\n$$\n\\pmb\\lambda^TM^TM\\pmb\\lambda-2\\pmb y^TM\\pmb \\lambda+\\pmb y^T\\pmb y\n$$\n  最小解满足\n$$\nM^TM\\pmb\\lambda=M^T\\pmb y\n$$\n  ","description":"插值与逼近学习笔记","id":15,"section":"note","tags":["CAGD"],"title":"CAGD(1) | 插值与逼近","uri":"https://chaphlagical.github.io/zh/note/cagd/cagd1/"},{"content":"课内资料 电子设计实践：课程资料\n人工智能导论：课程资料\n线性电子线路：课程资料\n数字逻辑电路：课程资料\n模式识别导论：课程资料\n自动控制原理：课程资料\n执行器技术：课程资料\n运筹学基础：课程资料\n传感器原理与技术：课程资料\n计算机网络：课程资料 期末总复习\n现代控制理论：课程资料 期末总复习\n微机原理与嵌入式：课程资料 期末总复习\n理论力学：课程资料 期末总复习\n系统辨识：课程资料\n图像处理基础：课程资料\n多媒体系统概论：课程资料\n计算机图形学：课程资料 期末总复习\n数学学习资源 EE364a Convex Optimization：主页链接\n机器人学学习资源 轨迹优化：主页链接\n概率机器人：主页链接\n人工智能学习资源 CSE 599W: Systems for ML：主页链接\nCS231n Convolutional Neural Networks for Visual Recognition：主页链接\n计算机图形学 Ray Tracing系列：主页链接\nPBRB网页版：主页链接\nSPH教程：主页链接\nFluid Simulation for Computer Animation：主页链接\n常用的Github开源项目 Immediate Mode GUI Framework：Dear ImGui\nImGui的扩展：implot，ImGuiFileDialog，ImGuizmo，imgui-markdown\nImGui的Python版本：DearPyGui、pyimgui\n开源自制游戏引擎：octoon，Overload，Hazel，luna-Engine，LumixEngine\n物理引擎：box2d\n模型导入库：tinyobjloader，assimp\nLogging System：spdlog\n获取文件/路径信息：dirent\nEntity Component System：entt\ncmake资源：awesome-cmake\n","description":"本科课程资料（PPT、复习）以及一些本人感兴趣的学习资源","id":16,"section":"posts","tags":["Resource"],"title":"资源资料","uri":"https://chaphlagical.github.io/zh/posts/2020-09-25-resource/"}]