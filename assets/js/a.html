<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" type="image/png" href="favicon.png">  <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']} }); </script> <script type='text/javascript' src='bug.js'></script>
		<script type='text/javascript'>
			// default fruit fly bug:
			new BugController({
			});

			// default spiders:
			new SpiderController({
			});
		</script><script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> <script type='text/javascript' src='/assets/js/bug.js'></script> <script type='text/javascript'> // default fruit fly bug: new BugController({ }); // default spiders: new SpiderController({ }); </script> 多功能微信机器人</title><meta name="description" content="本文介绍一款多功能微信机器人"><link rel="canonical" href="https://chaphlagical.github.io/posts/%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA/"><link rel="alternate" type="application/rss+xml" title="Chaf" href="https://chaphlagical.github.io/feed.xml"><link href='https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|Roboto+Condensed:700&subset=latin' rel='stylesheet' type='text/css'><link rel="stylesheet" href="/assets/css/main.css"><meta property="og:url" content="https://chaphlagical.github.io/posts/%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA/"><meta property="og:type" content="website"><meta property="og:title" content="多功能微信机器人"><meta property="og:description" content="多功能微信机器人"><meta property="og:site_name" content="Chaf"><meta name="twitter:card" content="summary"><meta name="twitter:url" content="https://chaphlagical.github.io/posts/%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA/"><meta name="twitter:title" content="多功能微信机器人"><meta name="twitter:description" content="多功能微信机器人"><meta property="og:image" content="https://chaphlagical.github.io/assets/images/2019-03-24.jpg"><meta name="twitter:image" content="https://chaphlagical.github.io/assets/images/2019-03-24.jpg"><body><div id="shadow"></div><header class="main-header content-wrapper"><link rel="icon" type="image/png" href="favicon.png"> <input type="checkbox" id="menu-checkbox" /><nav class="center-wrapper nav-main"> <a class="blog-logo" href="/">Chaf</a> <a href="/about/">About</a> <a href="/posts/">Archive</a> <a href="/feed.xml">RSS</a> <label for="menu-checkbox" class="toggle-button" data-open="☰" data-close="☰" onclick></label></nav></header><aside class="sidebar" role="note" style="background-image: url(/assets/images/2019-03-24.jpg)"><div class="cover"><div class="cover-text"><div class="heading"> <a href="/posts/#项目">项目</a></div><p> 多功能微信机器人</div></div><div id="switcher"></div></aside><main class="content-wrapper"><article class="post"><h1 class="post-title">多功能微信机器人</h1><p class="post-meta"> <time datetime="2019-03-24">24-03-2019</time> &nbsp;/&nbsp; <span>Chaf</span><div class="post-content"><p>本文介绍一款多功能微信机器人<h1 id="多功能微信机器人">多功能微信机器人</h1><p><strong>项目地址：<a href="https://github.com/Chaphlagical/WeChat-Robot">https://github.com/Chaphlagical/WeChat-Robot</a></strong><h2 id="一概览">一、概览</h2><p>以Python的微信接口库wxpy为基础，通过微信端人机交互，实现不同丰富的功能。<h2 id="二功能简介">二、功能简介</h2><h3 id="一朋友圈数据分析">（一）朋友圈数据分析</h3><h4 id="1基本原理">1、基本原理</h4><h5 id="1jieba">（1）jieba</h5><p>用于分词以生成好友个性签名词云<h5 id="2pyecharts">（2）pyecharts</h5><p>用于可视化数据<h4 id="2文件结构">2、文件结构</h4><h5 id="1analysisuser_analysispy">（1）./analysis/user_analysis.py</h5><p>用户好友数据分析类User_Friends<h5 id="2analysisgroup_analysispy">（2）./analysis/group_analysis.py</h5><p>好友群组数据分析类User_Group<h5 id="3analysistoolspy">（3）./analysis/tools.py</h5><p>基础预处理函数（例如排序、统计、字符串操作等）<h5 id="4scriptsfunctionanalysispy">（4）./scripts/function/analysis.py</h5><p>対各个数据分析函数再进行一次上层封装<h4 id="3基本使用方法">3、基本使用方法</h4><p>运行程序，扫码登陆微信，在任意一个聊天里，输入：<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>analysis friends
</code></pre></div></div><p>电脑端程序开始运行，<p>生成以下文件（夹）<ul><li>./data/user/avatar保存好友头像，<li>markdown文件./data/user/user_friends_data.md保存好友的备注、昵称、地区、头像、性别等信息，<li>html文件./data/user/Graph/China.html记录好友在中国的分布<li>html文件./data/user/Graph/Gender.html可视化好友的性别比例<li>html文件./data/user/Graph/Signature.html可视化好友个性签名词云<li>html文件./data/user/Graph/province.html记录好友所在人数最多省份的具体分布</ul><p>输入：<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>check friend [-好友名]
</code></pre></div></div><p>将显示好友的基本信息<p>输入：<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>analysis group [-群组名]
</code></pre></div></div><p>或者分析所有群组（时间较长，不推荐）：<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>analysis all group
</code></pre></div></div><p>生成以下文件（夹）：<ul><li>./data/group/[group_name]/group_members_data.md 保存群组成员的信息<li>./data/group/[group_name]/avatar保存群组成员头像<li>./data/group/[group_name]/Graph/Relationship.html群组成员关系可视化</ul><p>输入：<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>check group [-群组名]
</code></pre></div></div><p>将显示群组的基本信息<h4 id="效果">效果</h4><p>html文件已保存为图片<p><img src="/assets/images/WeChat/3.jpg" alt="" /> <img src="/assets/images/WeChat/China.png" alt="" /> <img src="/assets/images/WeChat/gender.png" alt="" /> <img src="/assets/images/WeChat/guangdong.png" alt="" /> <img src="/assets/images/WeChat/wordcloud.png" alt="" /><h3 id="二将手机变成电脑终端">（二）将手机变成电脑终端</h3><h4 id="1基本原理-1">1、基本原理</h4><h5 id="os-操作系统库">os 操作系统库</h5><p>用于命令输入控制<h4 id="2文件结构-1">2、文件结构</h4><p>./scripts/function/cmd.py<p>基本操作函数<h4 id="3基本使用方法-1">3、基本使用方法</h4><h5 id="1将聊天变成命令行">（1）将聊天变成命令行：</h5><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd on
</code></pre></div></div><p>之后用户收到的每一句话都会作为命令输入。<h5 id="2退出命令行模式">（2）退出命令行模式：</h5><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd off
</code></pre></div></div><h5 id="3杀死所有命令行进程">（3）杀死所有命令行进程</h5><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd kill
</code></pre></div></div><h4 id="效果-1">效果：</h4><p><img src="/assets/images/WeChat/1.jpg" alt="" /><h3 id="三聊天机器人">（三）聊天机器人</h3><h4 id="1基本原理-2">1、基本原理</h4><p>图灵机器人API （<a href="http://www.turingapi.com/">http://www.turingapi.com/</a>）实现人机交互<h4 id="2文件结构-2">2、文件结构</h4><p>./scripts/function/turing.py 实现相关功能函数<h4 id="3基本使用方法-2">3、基本使用方法</h4><h5 id="1启动聊天机器人">（1）启动聊天机器人：</h5><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>turing on
</code></pre></div></div><p>之后当用户在群里被@或者私聊模式下将会对收到的消息进行自动应答。<h5 id="2退出聊天机器人">（2）退出聊天机器人：</h5><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>turing off
</code></pre></div></div><h5 id="3杀死所有聊天机器人进程">(3）杀死所有聊天机器人进程</h5><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>turing kill
</code></pre></div></div><h4 id="效果-2">效果：</h4><p><img src="/assets/images/WeChat/2.jpg" alt="" /><h3 id="四目标识别">（四）目标识别</h3><h4 id="1基本原理-3">1、基本原理</h4><p>基于yolov3的目标识别神经网络（<a href="https://pjreddie.com/darknet/yolo/">https://pjreddie.com/darknet/yolo/</a>），实现对收到的图片进行物体目标识别<h4 id="2文件结构-3">2、文件结构</h4><h5 id="1analysiscvcvpy">（1）./analysis/CV/cv.py</h5><p>基本接口函数<h5 id="2analysiscvyolo">（2）./analysis/CV/yolo</h5><p>yolo神经网络<h5 id="3scriptsfunctionyolopy">（3）./scripts/function/yolo.py</h5><p>对相关函数进行封装<h4 id="3基本使用方法-3">3、基本使用方法</h4><h5 id="1进入目标识别模式">（1）进入目标识别模式</h5><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yolo on
</code></pre></div></div><p>之后用户受到的图片将会输入神经网络进行处理（限制在处理完一张之前不接受其他输入图片）<h5 id="2退出目标识别模式">（2）退出目标识别模式</h5><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yolo off
</code></pre></div></div><h5 id="3杀死所有目标识别进程">（3）杀死所有目标识别进程</h5><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yolo kill
</code></pre></div></div><h4 id="效果-3">效果：</h4><p><img src="/assets/images/WeChat/4.jpg" alt="" /> <img src="/assets/images/WeChat/5.jpg" alt="" /><h3 id="五电影链接获取">（五）电影链接获取</h3><h4 id="1基本原理-4">1、基本原理</h4><p>利用网络爬虫，爬取电影天堂（<a href="http://www.ygdy8.com/">https://www.ygdy8.com/</a> ）的下载资源<h5 id="1requests库">（1）requests库</h5><p>实现网络通信<h5 id="2urllib库">（2）urllib库</h5><p>抓取URL信息<h5 id="3re库">（3）re库</h5><p>正则表达式<h4 id="2文件结构-4">2、文件结构</h4><p>./scripts/function/movie.py<p>包含抓取电影资源的函数<h4 id="3基本使用方法-4">3、基本使用方法</h4><p>只需要在聊天中输入<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>movie [-电影名]
</code></pre></div></div><p>就可以得到结果<h4 id="效果-4">效果：</h4><p><img src="/assets/images/WeChat/7.jpg" alt="" /><h3 id="五shazam">（五）Shazam！</h3><h4 id="1基本原理-5">1、基本原理</h4><p>受即将上映的DC超级英雄电影《雷霆沙赞》启发，利用ECCV2018上的一个人脸姿态重建的算法（<a href="http://github.com/YadiraF/PRNet">https://github.com/YadiraF/PRNet</a>），实现换脸“变身”<h4 id="2文件结构-5">2、文件结构</h4><h5 id="1analysiscvcvpy-1">（1）./analysis/CV/cv.py</h5><p>基本接口函数<h5 id="2analysiscvprnet">（2）./analysis/CV/PRNet</h5><p>PRNet神经网络<h5 id="3scriptsfunctionheropy">（3）./scripts/function/hero.py</h5><p>对相关函数进行封装<h4 id="3基本使用方法-5">3、基本使用方法</h4><h5 id="1进入换脸模式">（1）进入换脸模式</h5><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hero on
</code></pre></div></div><p>开启之后，电脑将保存用户收到的图片，当用户输出”shazam“时，最近保存的一张照片将输入神经网络进行处理。<h5 id="2退出换脸模式">（2）退出换脸模式</h5><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hero off
</code></pre></div></div><h5 id="3杀死所有换脸进程">（3）杀死所有换脸进程</h5><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hero kill
</code></pre></div></div><h4 id="效果-5">效果：</h4><p><img src="/assets/images/WeChat/6.jpg" alt="" /><h3 id="六pc端微信">（六）PC端微信</h3><h4 id="1基本原理-6">1、基本原理</h4><p>通过GUI实现类似电脑版微信的功能，由于时间关系没有添加过多功能<h4 id="2文件结构-6">2、文件结构</h4><h5 id="1guigui_classpy">（1）./GUI/gui_class.py</h5><p>定义的类<h5 id="2guiguipy">（2）./GUI/gui.py</h5><p>GUI构建函数<h4 id="效果-6">效果：</h4><p><img src="/assets/images/WeChat/GUI.png" alt="" /><h2 id="三程序结构详解">三、程序结构详解：</h2><h3 id="一功能协调">（一）功能协调</h3><p>为将各个功能系统配合起来，又想尽可能减少分支语句的使用，我建了一个文件夹./scripts/function用来存放各个功能实现的函数高级封装，通过文件./scripts/func.py将各函数放在一个字典中，通过主函数中受到的消息关键句进行调用。<h3 id="二图像的处理">（二）图像的处理</h3><p>先保存到特定路径下在进行处理调用，最后发送回微信端。<p>其他细节处理比较多，便不一一叙述<h2 id="五实验感想">五、实验感想</h2><p>其实一开始只做了命令行和图灵机器人的功能，恰好最近在学习object detection了解到faster-rcnn、yolo等框架，于是突发奇想用到了微信机器人上，有了物体识别又想做点人脸的，感觉人脸检测人脸识别略微俗套，于是就有了换脸功能，想起一年前写过一个电影天堂下载器，发现还能用，便也集成进来，然后听说作业要求有GUI展示，于是就简单写了个电脑端微信（优点是可以发送空消息，可以保存别人撤回的消息），中间用的库还是相对比较熟悉的，但也踩了不少坑，总体上顺利。<div class="post-links"> <a class="link-to-post" href="/posts/LeNet%E8%A7%A3%E8%AF%BB/"> <span class="link-to-post__prev">&#10535; &nbsp;Previous post</span> <span class="link-to-post__title">LeNet解读</span> </a></div></div></article></main><footer class="blog-footer content-wrapper"><link rel="icon" type="image/png" href="favicon.png"><p>&copy; <span class="full-year"></span> Chaf</footer><script src="/assets/js/scripts.js"></script> <script type='text/javascript' src='/assets/js/bug-min.js'></script> <script type='text/javascript'> // default fruit fly bug: new BugController({ }); // default spiders: new SpiderController({ }); </script> <script src="/js/jquery.min.js"></script><style> .videoWrapper { position: relative; padding-bottom: 56.333%; height: 0; background: black; } .videoWrapper iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0; }</style><script> function get_youtube_id(url) { var p = /^(?:https?:\/\/)?(?:www\.)?(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))((\w|-){11})(?:\S+)?$/; return (url.match(p)) ? RegExp.$1 : false; } function vimeo_embed(url,el) { var id = false; $.ajax({ url: 'https://vimeo.com/api/oembed.json?url='+url, async: true, success: function(response) { if(response.video_id) { id = response.video_id; if(url.indexOf('autoplay=1') !== -1) var autoplay=1; else var autoplay=0; if(url.indexOf('loop=1') !== -1) var loop=1; else var loop=0; var theInnerHTML = '<div class="videoWrapper"><iframe src="https://player.vimeo.com/video/'+id+'/?byline=0&title=0&portrait=0'; if(autoplay==1) theInnerHTML += '&autoplay=1'; if(loop==1) theInnerHTML += '&loop=1'; theInnerHTML += '" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>'; el.innerHTML = theInnerHTML; } } }); } function video_embed() { var p = document.getElementsByTagName('p'); for(var i = 0; i < p.length; i++) { //check if this is an external url (that starts with https:// or http:// if (p[i].innerHTML.indexOf("http://") == 0 || p[i].innerHTML.indexOf("https://") == 0) { var youtube_id = get_youtube_id(p[i].innerHTML); if(youtube_id) { if(p[i].innerHTML.indexOf('autoplay=1') !== -1) var autoplay=1; else var autoplay=0; if(p[i].innerHTML.indexOf('loop=1') !== -1) var loop=1; else var loop=0; var theInnerHTML = '<div class="videoWrapper"><iframe width="720" height="420" src="https://www.youtube.com/embed/' + youtube_id + '?rel=0&showinfo=0'; if(autoplay==1) theInnerHTML += '&autoplay=1'; if(loop==1) theInnerHTML += '&loop=1&playlist='+youtube_id+'&version=3'; theInnerHTML += '" frameborder="0" allowfullscreen></iframe></div>'; p[i].innerHTML = theInnerHTML; } if(p[i].innerHTML.indexOf('vimeo.com') !== -1) { //ask vimeo for the id and place the embed vimeo_embed(p[i].innerHTML,p[i]); } } } } video_embed(); function mp3_embed() { var p = document.getElementsByTagName('p'); for(var i = 0; i < p.length; i++) { if(p[i].innerHTML.indexOf('.mp3') !== -1) { var str = p[i].innerHTML.split('?'); if(str.length == 1) str[1] = ''; var str1 = str[1]; str1 = str1.replace('&','').replace('&',''); str1 = str1.replace('autoplay=1','').replace('autoplay=0',''); str1 = str1.replace('loop=1','').replace('loop=0',''); str1 = str1.replace('controls=0','').replace('controls=1',''); if (str[0].lastIndexOf('.mp3', str[0].length - 4) === str[0].length - 4 && str1.length == 0) { if(str[1].indexOf('autoplay=1') !== -1) var autoplay=1; else var autoplay=0; if(str[1].indexOf('loop=1') !== -1) var loop=1; else var loop=0; if(str[1].indexOf('controls=0') !== -1) var controls=0; else var controls=1; var newInnerHTML = '<audio'; if(autoplay==1) newInnerHTML += ' autoplay'; if(loop==1) newInnerHTML += ' loop'; if(controls==1) newInnerHTML += ' controls'; newInnerHTML += '><source src="'+str[0]+'" type="audio/mpeg">Your browser does not support the audio element.</audio>'; p[i].innerHTML = newInnerHTML; } } } } mp3_embed(); </script>

