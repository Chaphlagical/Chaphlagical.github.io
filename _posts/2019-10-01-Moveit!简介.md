---
title: Moveit!简介
tags: Moveit!
article_header:
  type: cover
  image:
    src: /assets/images/Moveit.jpg
---

<!--more-->

## 一、基本结构

* 系统结构：

![](http://images.ncnynl.com/ros/2016/Overview.0012.jpg)

* **move_group**节点
  **move_group**节点充当整合器：整合多个独立的组件，并提供ROS风格的action和service
* **User Interface**（用户接口，三种接口可供调用）
  - C++， 利用move_group_interface包可以方便使用move_group。
  - Python，利用moveit_commander包
  - GUI（界面），利用Motion Planning 的 Rviz插件。
* **配置**，move_group是ROS节点，它在ROS param server获取三种信息，
  - URDF ，从ROS param server中查找robot_description，获取URDF，它是机器人的描述文件。
  - SRDF ，从ROS param server中查找robot_description_semantic，获取SRDF.它一般通过MoveIt! Setup Assistant生成。
  - MoveIt! configuration ，从ROS param server中获取更多信息，如joint limits, kinematics, motion planning, perception and other information。
  - 配置文件由MoveIt! Setup Assistant生成，存放在MoveIt! config目录中。
* **Robot Interface**（机器人接口）
  - move_group通过ROS topics和actions与机器人通讯，获取机器人的状态（位置，节点等），获取点云或其他传感器数据再传递给机器人的控制器。
* **Joint State Information**（节点状态信息）
  - move_group监听 /joint_states 主题确定状态信息。例如：确定每个节点的位置。
  - move_group能够监听在这主题的多个发布器信息，即使是发布部分的信息（例如：独立的发布器可能是用于机械臂或移动机器人）。
  - ove_group不会建立自己的节点状态发布器。这就需要在每个机器人单独来建立。
* **Transform Information**（变换信息）
  - Move_group通过ROS TF库来监视变换信息。这允许节点获取全局的姿态信息。
  - 例如：navigation包发布机器人的map frame和base frame到TF，move_group可以使用TF找出这个变换信息，在内部使用。
  - 注意：Move_group只是监听TF，你需要启动robot_state_publisher才能发布TF。
* **Controller Interface** （控制器接口）
  - 通过ROS的action接口，FollowJointTrajectoryAction接口来使用控制器。
  - 一个机器人的服务器服务于这个action-这个服务器不是有move_group提供。
  - move_group只会实例化客户端与机器人的控制器action服务器通讯。
* **Planning Scene**（规划场景）
  - move_group使用规划场景监视器来维护规划场景。
  - 场景是世界的和机器人的状态的表现。
  - 机器人状态包含机器人刚性连接到机器人的所有物体。
  - 关于维护和更新规划场景的体系结构的详细信息在下面的规划场景部分中描述。
* **Extensible Capabilities**（可扩展能力）
  - move_group的结构被设计成容易扩展，独立的能力如抓放，运动学，运动规划。
  - 扩展自公共类，但实际作为独立的插件运行。
  - 插件可经由一系列的ROS yaml parameters 和ROS pluginlib库配置。

## 二、运动规划

* **The Motion Planning Plugin**（运动规划插件）
  - 运动规划器通过插件接口方式与MoveIt一起工作。这使得MoveIt更容易扩展，能同时与不同的库不同的运动规划器通讯。
  - 运动规划器接口通过ROS Action或service方式提供。
  - 针对 move_group的默认规划器通过MoveIt! Setup Assistant来配置使用OMPL或OMPL的MoveIt!接口
* **The Motion Plan Request**（运动规划请求）
  - 运动计划请求清楚地指定你想要的运动计划做什么。
  - 通常情况下，你会要求运动规划器将一只手臂移动到一个不同的位置（在关节空间）或末端执行器到一个新的姿势。
  - 默认情况下会进行碰撞检查（包括自碰撞）
  - 您可以将一个对象附加到末端执行器（或机器人的任何一部分），例如，如果机器人拿起一个对象。这使得运动规划器考虑到对象的运动而进行路径规划。
  - 你可以指定运动规划器检查的约束 - 内置的约束由kinematic constraints提供： 
    - **Position constraints**（位置约束） - 限制连接的位置在某个空间区域
    - **Orientation constraints**（方向约束） - 限制连接的方向在指定的roll, pitch和yaw范围
    - **Visibility constraints**（可视化约束） - 限制连接的点在特定传感器的一个可视化的锥形范围
    - **Joint constraints**（节点约束） - 限制节点位于两个值之间
    - **User-specified constraints**（自定义约束） - 利用自定义回调函数来指定自定义的约束。
* **The Motion Plan Result**（运动规划结果）
  - move_group节点会根据的运动规划请求，产生一个期望的轨迹。这个轨迹会移动机械臂（一组节点）到期待的位置。
  - move_group的结果是轨迹不仅仅是路径 - move_group会以希望最大的速度和加速度（需指定）来生成用于轨迹。
  - 此轨迹需要遵循速度和加速度的限制
* **Motion planners and Plan Request Adapters**（运动规划器和规划请求适配器）

![](http://images.ncnynl.com/ros/2016/Overview.002.jpg)

## 三、OPML

*  OMPL (Open Motion Planning Library) 
  是一个开源的运动规划库，主要是执行随机规划器。MoveIt直接整合OMPL，使用其库里的运动规划器作为主要/默认的一套规划器。在OMPL规划器是抽象的，例如：OMPL没有机器人的概念。MoveIt!配置OMPL，提供一个后端处理，用于解决机器人的问题。
* 结构：

![](http://images.ncnynl.com/ros/2016/Overview.0031.jpg)

* 规划场景，用于显示机器人的世界，同时保存机器人自己的状态。它由Move_group节点内的规划场景监视器来维护。规划场景监视器监听：
  - State Information（状态的信息）:  joint_states 主题
  - Sensor Information（传感器的信息）: using the world geometry monitor described below
  - World geometry information（世界的几何图形信息）: from user input on the planning_scene topic (as a planning scene diff).
* **World Geometry** 
  Monitor（世界几何图形监视器），它通过来自机器人的传感器信息和来自用户的输入建立世界几何图形。它使用occupancy map 
  monitor（occupancy地图监视器）建立围绕机器人的3D感知环境和通过planning_scene主题中附带的参数来增加对象的信息。

* 3D Perception（3D感知）

![](http://images.ncnynl.com/ros/2016/Overview.004.jpg)

* 在MoveIt，3D感知是由occupancy map monitor处理，它使用插件结构处理不同的传感器输入。MoveIt有两个内置支持可以处理两种输入：
  - Point clouds: handled by the point cloud occupancy map updater plugin
  - Depth images: handled by the depth image occupancy map updater plugin
* 你可为occupancy map monitor编写自己的插件。
* **Octomap**，
  Occupancy map monitor使用Octomap维持Occupancy map的环境。

* **Depth Image Occupancy Map Updater**，深度图像栅格地图的更新器包括它自己的过滤器，例如：它可以从深度图消除机器人的可见部分。它使用目前有关的机器人的信息（机器人状态）进行此操作。

## 四、**Kinematics（运动学）**

* **The Kinematics Plugin**（运动学插件），MoveIt!使用插件结构，尤其是允许用户编写自己的逆运动学算法。**Forward kinematics**（正向运动学） and **finding jacobians**（查找雅可比矩阵）被整合到自己的**RobotState**类。默认逆运动学插件配置使用**KDL numerical jacobian-based solver**.由MoveIt! Setup Assistant自动配置。
* **IKFast Plugin**（IKFast插件），通常，用户可以选择执行自己的运动学求解器，例如PR2的有自己的运动学求解器。要实现这样的求解的一种流行的方法是使用ikfast包产生的需要与您的特定工作的机器人的C++代码。
* **Collision Checking**（冲突检测），在规划场景中，冲突检测通过CollisionWorld对象来配置，由FCL包（主要的CC库）来执行。
* **Collision Objects**（冲突对象），MoveIt支持不同类型对象的冲突检测。
  - Meshes（网格）
  - Primitive Shapes（基本形状） - 例如： boxes（箱）, cylinders（圆柱）, cones（圆锥）, spheres（球） and planes（平面）
  - Octomap -  Octomap 对象能直接用于冲突检测
* **Allowed Collision Matrix** 
  (ACM)（免检冲突矩阵），在运动规划里，冲突检测会耗费甚至达到90%的计算资源。ACM编码需要检测的对象间的对应关系（机器人的或世界的）。如果在ACM关联两对象的值为1，那就不需要检测，这情况就比如两个对象相隔很远，永远不会发生碰撞。

## 五、Trajectory Processing（轨迹处理）

- **Time  parameterization**（时间参数化），运动规划器一般只会生成路径，这个路径不带时间信息。MoveIt包含轨迹处理程序。它对结合路径和时间参数化的关节限制的速度和加速度来生成轨迹。这些限制是在joint_limits.yaml中为每个机器人指定的。