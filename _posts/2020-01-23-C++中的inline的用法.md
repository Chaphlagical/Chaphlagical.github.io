---
title: C++中的inline的用法
tags: C++
article_header:
  type: cover
  image:
    src: /assets/images/C++.jpg
---

<!--more-->  

## 一、inline修饰符的作用 

在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 `inline`修饰符，表示为内联函数。

栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。

在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。

示例：

```c++
#include <stdio.h>
//函数定义为inline即:内联函数
inline char* dbtest(int a) {
    return (i % 2 > 0) ? "奇" : "偶";
} 
 
int main()
{
   int i = 0;
   for (i=1; i < 100; i++) {
       printf("i:%d    奇偶性:%s /n", i, dbtest(i));    
   }
}
```

工作原理：在每个 **for** 循环的内部任何调用 **dbtest(i)** 的地方都换成了 **(i%2>0)?"奇":"偶" ** ，这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。

## 二、inline使用限制 

inline 只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。

## 三、类中成员函数与inline 

**定义**在类中的**成员函数**默认都是**内联的**，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 **inline**，否则就认为不是内联的。

```c++
class A
{
    public:void Foo(int x, int y) {  } // 自动地成为内联函数
}
```

将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：

```c++
// 头文件
class A
{
    public:
    void Foo(int x, int y);
}
 
 
// 定义文件
inline void A::Foo(int x, int y){}
```

## 四、不适合使用inline的情况 

* 如果函数体内的代码**比较长**，使用内联将导致**内存消耗代价较高**。 
* 如果函数体内出现**循环**，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心**构造函数和析构函数可能会隐藏一些行为**，如"偷偷地"执行了**基类或成员对象**的构造函数和析构函数。所以**不要随便地将构造函数和析构函数的定义体放在类声明中**。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。