---
title: C++ STL deque
tags: C++
article_header:
  type: cover
  image:
    src: /assets/images/C++.jpg
---

<!--more-->

如果一个类将`()`运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象。函数对象是一个对象，但是使用的形式看起来像函数调用，实际上也执行了函数调用

示例：

```c++
#include <iostream>
using namespace std;

class CAverage
{
public:
    double operator()(int a1, int a2, int a3)
    {  //重载()运算符
        return (double)(a1 + a2 + a3) / 3;
    }
};

int main()
{
    CAverage average;  //能够求三个整数平均数的函数对象
    cout << average(3, 2, 3);  //等价于 cout << average.operator(3, 2, 3);
    return 0;
}
```

## 应用实例：accumulate算法

STL中实现累加算法的函数模板：

```c++
template <class InIt, class T, class Pred>
T accumulate(InIt first, InIt last, T val, Pred op);
```

该模板的功能是对 [first, last) 中的每个迭代器 I 执行 `val = op(val, *I)`，返回最终的 val。

此模板被实例化后，`op(init, *first)`必须要有定义，则 op 只能是函数指针或者函数对象。因此调用该 accmulate 模板时，形参 op 对应的实参只能是函数名、函数指针或者函数对象。

示例：通过accumulate模板求vector中元素的平方和

```c++
#include <iostream>
#include <vector>
#include <numeric> //accumulate 在此头文件定义
using namespace std;
template <class T>
void PrintInterval(T first, T last)
{ //输出区间[first,last)中的元素
    for (; first != last; ++first)
        cout << *first << " ";
    cout << endl;
}
int SumSquares(int total, int value)
{
    return total + value * value;
}
template<class T>
class SumPowers
{
private:
    int power;
public:
    SumPowers(int p) :power(p) { }
    const T operator() (const T & total, const T & value)
    { //计算 value的power次方，加到total上
        T v = value;
        for (int i = 0; i < power - 1; ++i)
            v = v * value;
        return total + v;
    }
};
int main()
{
    const int SIZE = 10;
    int a1[] = { 1,2,3,4,5,6,7,8,9,10 };
    vector<int> v(a1, a1 + SIZE);
    cout << "1) "; PrintInterval(v.begin(), v.end());
    int result = accumulate(v.begin(), v.end(), 0, SumSquares);
    cout << "2) 平方和：" << result << endl;
    result = accumulate(v.begin(), v.end(), 0, SumPowers<int>(3));
    cout << "3) 立方和：" << result << endl;
    result = accumulate(v.begin(), v.end(), 0, SumPowers<int>(4));
    cout << "4) 4次方和：" << result;
    return 0;
}
```

## 应用实例：sort算法

STL 中的排序模板 sort 能将区间从小到大排序。sort 算法有两个版本。第一个版本的原型如下：

```c++
template <class_Randlt>
void sort(_Randlt first, _RandIt last);
```

该模板可以用来将区间 [first, last) 中的元素从小到大排序，要求 first、last 是随机访问迭代器。元素比较大小是用`<`进行的。如果表达式`a的值为 true，则 a 排在 b 前面；如果`a的值为 false，则 b 未必排在 a 前面，还要看`b是否成立，成立的话 b 才排在 a 前面。要使用这个版本的 sort 算法，待排序的对象必须能用`<`运算符进行比较。

sort 算法第二个版本的原型如下：

```c++
template <class_Randlt, class Pred>
void sort(_Randlt first, _RandIt last, Pred op);
```

这个版本和第一个版本的差别在于，元素 a、b 比较大小是通过表达式`op(a, b)`进行的。如果该表达式的值为 true，则 a 比 b 小；如果该表达式的值为 false，也不能认为 b 比 a 小，还要看`op(b, a)`的值。总之，op 定义了元素比较大小的规则。

示例：

```c++
#include <iostream>
#include <algorithm>  //sort算法在此头文件中定义
using namespace std;
template <class T>
void Printlnterva1(T first, T last)
{  //用以输出 [first, last) 区间中的元素
    for (; first != last; ++first)
        cout << *first << " ";
    cout << endl;
}
class A
{
public:
    int v;
    A(int n) : v(n) {}
};
bool operator < (const A & a1, const A & a2)
{  //重载为 A 的 const 成员函数也可以，重载为非 const 成员函数在某些编译器上会出错
    return a1.v < a2.v;
}
bool GreaterA(const A & a1, const A & a2)
{  //v值大的元素作为较小的数
    return a1.v > a2.v;
}
struct LessA
{
    bool operator() (const A & a1, const A & a2)
    {  //v的个位数小的元素就作为较小的数
        return (a1.v % 10) < (a2.v % 10);
    }
};
ostream & operator << (ostream & o, const A & a)
{
    o << a.v;
    return o;
}
int main()
{
    int a1[4] = { 5, 2, 4, 1 };
    A a2[5] = { 13, 12, 9, 8, 16 };
    sort(a1, a1 + 4);
    cout << "1)"; Printlnterva1(a1, a1 + 4);  //输出 1)1 2 4 5
    sort(a2, a2 + 5);  //按v的值从小到大排序
    cout << "2)"; Printlnterva1(a2, a2 + 5);  //输出 2)8 9 12 13 16
    sort(a2, a2 + 5, GreaterA);  //按v的值从大到小排序
    cout << "3)"; Printlnterva1(a2, a2 + 5);  //输出 3)16 13 12 9 8
    sort(a2, a2 + 5, LessA());  //按v的个位数从小到大排序
    cout << "4)"; Printlnterva1(a2, a2 + 5);  //输出 4)12 13 16 8 9
    return 0;
}
```

## STL中的函数对象类模板

| 函数对象类模板      | 成员函数 T operator ( const T & x, const T & y) 的功能   |
| ------------------- | -------------------------------------------------------- |
| plus \<T\>          | return x + y;                                            |
| minus \< \>         | return x - y;                                            |
| multiplies \<T\>    | return x * y;                                            |
| divides \<T\>       | return x / y;                                            |
| modulus \<T\>       | return x % y;                                            |
|                     | 成员函数 bool operator( const T & x, const T & y) 的功能 |
| equal_to \<T\>      | return x == y;                                           |
| not_equal_to \<T\>  | return x! = y;                                           |
| greater \<T\>       | return x > y;                                            |
| less \<T\>          | return x < y;                                            |
| greater_equal \<T\> | return x > = y;                                          |
| less_equal \<T\>    | return x <= y;                                           |
| logical_and \<T\>   | return x && y;                                           |
| logical_or \<T\>    | return x \|\| y;                                         |
|                     | 成员函数 T operator( const T & x) 的功能                 |
| negate \<T\>        | return - x;                                              |
|                     | 成员函数 bool operator( const T & x) 的功能              |
| logical_not \<T\>   | return ! x;                                              |


例如，如果要求两个 double 型变量 x、y 的乘积，可以写：

```c++
multiplies<double> () (x, y)
```