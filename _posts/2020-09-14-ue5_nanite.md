---
layout: post
title: UE5 Prediction II
subtitle: Nanite
thumbnail-img: /assets/images/thumbnail-img/ue5_nanite.jpg
cover-img: /assets/images/cover-img/ue5_nanite.jpg
comments: true
tags: [CG, Game Engine]
readtime: true
---

上一篇文简要介绍了UE5的Demo展示的情况，本文将着重分析和介绍Nanite系统中可能用到的技术和方法

> 注：此文为网络流行的比较靠谱的方法的一种，非本人纯原创，非喜勿喷

## 1. 基本概念：几何与贴图

在图形学中，曲面通常离散化为三角网格的形式，通过纹理贴图来赋予模型颜色：

![image-20200913111531330](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/image-20200913111531330.png){: .mx-auto.d-block :}

![image-20200913111729883](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/image-20200913111729883.png){: .mx-auto.d-block :}

为了提高渲染速度，减少渲染的存储需求，游戏中常常采用LOD的方法，构造一系列不同解析率的三角网格，对离得远的物体使用低精度网格，而对离得近的物体使用高精度网格

![img](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/v2-0323e0db3986e136f7f8a8a6a4bac3cd_720w.jpg)

对纹理贴图而言，如果对视野内所有模型都贴上相同的高分辨率贴图的话，会出现摩尔纹现象：

![image-20200913112302930](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/image-20200913112302930.png){: .mx-auto.d-block :}

这是采样不足的原因导致的

![image-20200913112332582](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/image-20200913112332582.png){: .mx-auto.d-block :}

为解决摩尔纹现象，常用的方法是对纹理贴图也做相似的处理，称为MipMap，即构造一系列分辨率不同的子图，对不同距离的模型贴上不同分辨率的贴图以消除摩尔纹

![image-20200913112521867](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/image-20200913112521867.png){: .mx-auto.d-block :}

在现代可编程渲染管线中，曲面细分部分可以交给Tessellation Shader进行计算，同时贴图中也可以存储许多如材质、法向、位移等信息。在游戏领域，通常采用对低模贴上法线贴图、光照贴图等来增加细节

![image-20200913113012722](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/image-20200913113012722.png){: .mx-auto.d-block :}

## 2. 虚拟纹理技术

随着游戏规模的增大，场景越来越复杂，渲染一帧场景所用的资源也越来越多。对于高质量的游戏场景渲染，所需的贴图占用内存是极大的，有时甚至超出GPU显存的容量。为解决这个问题，已经普遍用于计算机系统的虚拟存储技术在GPU纹理存储上得到了借鉴和应用。

虚拟存储器技术是为解决应用程序过大导致内存无法容纳而提出的一种方法，其基本思想是程序，数据，堆栈的总的大小可以超过物理存储器的大小，操作系统把当前使用的部分保留在内存，而把其他未被使用的部分保存在磁盘上

举个例子，一个16MB的程序和一个内存只有4MB的机器，操作系统通过选择，可以决定各个时刻将哪4MB的内容保留在内存中，并在需要时在内存和磁盘间交换程序片段，这样就可以把这个16M的程序运行在一个只具有4M内存机器上了。

![](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/image-20200310131447780.png){: .mx-auto.d-block :}

任何计算机上都存在一个程序能够产生的地址集合，称之为**地址范围**。这个范围的大小由CPU的位数决定，例如一个32位的CPU，它的地址范围是0~0xFFFFFFFF (4G)。这个地址范围称为虚拟地址空间，该空间中的某一个地址我们称之为虚拟地址。为什么叫虚拟地址呢？因为实际的物理器件（内存）可能并没有达到这个容量，例如一台内存为256MB的32bit x86计算机而言，其真正有效地址范围只是0x000000000~0x0FFFFFFF（256MB），这256MB地址范围称为物理地址。虚拟地址一般大于物理地址，在使用时，内存中只装入需要使用的代码数据片段，程序员可以直接使用虚拟地址进行操作，操作系统将负责将虚拟地址映射到物理地址，实现代码数据存取。因此，即使内存只有256MB的电脑，只需将存储器里的东西在每次要用的时候放入内存，通过地址映射建立起虚拟地址和物理地址的相互转换，便可以运行空间占有量大于256MB的应用程序。

![image-20200913220759191](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/image-20200913220759191.png){: .mx-auto.d-block :}

和虚拟存储技术类似的，GPU只存储程序运行所需要的纹理块而不是所有的纹理数据

![img](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/640.png){: .mx-auto.d-block :}

![img](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/641.png){: .mx-auto.d-block :}

![img](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/642.png){: .mx-auto.d-block :}

而虚拟纹理系统的核心任务是建立起虚拟地址和GPU物理地址的映射，这和虚拟存储器技术也有很多相似之处。一般来说，从虚拟地址到物理地址的映射被保存在GPU中的一张查询表格中，该表格一般是四叉树结构，也用纹理图像来表达

![img](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/643.png){: .mx-auto.d-block :}

当渲染所需的纹理块都存在于GPU中时，渲染器将进行二次渲染绘制：找到相应的查询表项，完成虚拟地址到物理地址的转换，从而读取出存储在GPU中的纹理块，进行纹理贴图操作

## 2. 几何图像

看到这里，或许思路已经开始渐渐清晰，从虚拟内存到虚拟纹理，如今的Nanite虚拟几何系统是不是也是使用类似的原理呢？

这里还有一个难点需要解决，那就是几何模型的存储方式。常用的模型存储方式通常采用文本文件或十进制文件，例如常见的`.obj`文件格式如下：

```
v 1.0 0.0 0.0
v 0.0 1.0 0.0
v 0.0 -1.0 0.0
v 0.0 0.0 1.0
f 1 2 3
f 1 4 2
f 3 2 4
f 1 3 4
```

上述文件表示一个四面体模型，`v`后面接顶点坐标，`f`后面接三角面片的顶点索引

在传统的渲染时，也是类似地将一系列坐标数据数组输入到GPU中进行计算，这种数据方式不像图像数据那样具有很多良好的性质和众多处理算法进行压缩、重建等。所以我们想能否像存纹理一样存我们的几何数据？答案是肯定的，顾险峰教授在2002年的Siggraph上的工作几何图像（Geometry Images）便说明了这种想法的可行性。

几何图像的原理并不难理解，其本质也是曲面参数化。所谓曲面参数化，数学上描述为从曲面$\R^3$到平面$\R^2$的一个双向映射，在CG应用中十分广泛，最常见的就是纹理贴图设计的UV展开。（这里想起这学期复现老师08年所作的ARAP时的绝望感）

![image-20200913223600986](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/image-20200913223600986.png){: .mx-auto.d-block :}

![enter image description here](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/2N5oo.jpg)

![image-20200913232532698](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/image-20200913232532698.png){: .mx-auto.d-block :}

几何图像与纹理贴图事实上也是非常相似的，只是几何图像存储的不是颜色像素数据，而是几何信息

几何图像生成流程如下：

![image-20200913224808383](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/image-20200913224808383.png){: .mx-auto.d-block :}

通过对三维模型进行参数化展开，利用类似纹理贴图的方法对模型的对应点坐标进行采样，最后通过插值生成几何图像，在需要渲染时，只需要利用一个简单网格在几何图像上获取相应的坐标和法向量信息，即可重建出三维模型。而且注意到重建的模型的三角面片数取决于用于重建的简单网格三角面片数。

![image-20200913225318008](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/image-20200913225318008.png){: .mx-auto.d-block :}

![img](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/v2-0c0ee88837bbd737690f3f821720606a_720w.jpg){: .mx-auto.d-block :}

我们都知道常见的图像都是三通道图像，存储着RGB三个分量的信息（有些还存着透明度A的信息），现在，我们完全可以在原来的纹理图像上增加通道，存放xyz坐标信息、法向量信息，乃至金属度、粗糙度等物体材质信息，各种应用于纹理图像处理的算法同样也可以用于这个复合图像。我们可以将MipMap和LOD统一起来，能够采用虚拟纹理技术将模型的几何信息分块存放在GPU中。

因此即使原来导入的模型有数十亿个三角面片，真正用于渲染场景所需的面片数事实上要少好几个数量级，而利用Tessellation Shader等方法我们能够实现三角形面片数的动态改变（可以理解为动态LOD），于是，游戏运行过程出现在视野内的场景有一种永远是高模的错觉，这也达到Nanite的超多三角面片数渲染的效果。

![youtu.be-qC5KtatMcUw (1)](https://chaphlagical.github.io/assets/images/assets-img/Nanite.assets/youtu.be-qC5KtatMcUw (1).jpg){: .mx-auto.d-block :}

## 3. 小结

事实上在2018年Nvidia发布的DX12 mesh shader渲染管线也有类似的效果，也是采用GPU实现动态LOD，不过UE5项目要比mesh shader开始得早，相关负责人也说了没有直接使用到mesh shader，只是某些技术上可能比较接近，不过正常也八九不离十，万变不离其宗。不得不说几何处理的威力还是相当巨大的，而几何处理中所涉及的离散微分几何、计算共形几何等数学方法也是非常多的，借导师一言：”数学不是没有用，是不够用！“。数学，还是相当重要的。