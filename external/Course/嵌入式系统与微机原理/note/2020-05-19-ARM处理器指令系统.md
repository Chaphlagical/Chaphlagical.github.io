---
title: ARM处理器指令系统
tags: 微机原理与嵌入式系统
article_header:
  type: cover
  image:
    src: /assets/images/embed.jpg
---

<!--more-->

## 一、ARM处理器指令集概述

* 指令集体系架构（ISA）
	* 描述处理器指令及其功能、组织方式的规范
* 指令系统
	* 计算机系统中所有机器指令的集合
* 机器指令
	* 表示一条指令的二进制代码（即比特串，或称位串）称为指令字，简称指令
	* 指令字可以是固定长度的，也可以是可变长度的
	* 指令字需要包含操作码、操作数（可能有多个）和操作数地址等字段
	* 所有指令字的相关信息在指令集中予以规定

### (一) ARM的不同指令集

#### 1、ARM处理器的指令集

* ARM Instruction Set Architecture
* 不同时期的ARM处理器指令集存在较大差异
	* ARM公司在多个体系结构版本的基础上，还定义了若干增强型版本，配合相应的硬件部件以支持协处理器、DSP、VFP、Java和SIMD多媒体信号处理等功能
* 目前，ARM公司将其不同系列处理器所支持的指令集架构ISA统一为三个
	* A64：与现有A32指令集相似，仍然是32位宽，具有相似的语法，支持64位处理器
	* A32：即原来的ARM指令集，指令长度固定为32比特
	* T32：即原来的Thumb-2指令集，16位和32位指令共存

#### 2、各个版本架构所支持的指令集

<img src="/assets/images/ARM处理器指令系统.assets/image-20200430143407031.png" alt="image-20200430143407031" style="zoom:67%;" />

* 说明
	* 自ARMv6-M之后，所有版本都支持T32指令集
	* 不同处理器设计（配置的功能部件不同），增加了不同的指令集扩展（也称扩展指令）

### (二) ARM的指令集扩展

#### 1、指令集扩展

* 除基本指令集以外，为满足具体应用需求，ARM处理器可选配一些功能部件，并增加与之“配套”的指令，构成扩展指令集（Arm Architecture Extensions）
* 例如：
	* DSP extensions $\rightarrow$ 数字信号处理
	* Floating-point Extension $\rightarrow$ 浮点数运算（如Cortex-M4）
	* Neon: 单指令多数据（SIMD）
	* Helium: Armv8.1-M引入的M-Profile Vector Extension，矢量处理，用于Cortex-M系列
	* ......

#### 2、ARM指令集的扩展过程

* ARMv8-A的的指令集扩展过程：先后增加了Jazelle、VFP、TrustZone、SIMD 、NEON以及可选密码扩展

#### 3、ARM的指令集扩展

* DSP 扩展
	* 单周期16×16 和32×16 MAC 实现
	* 零开销饱和运算扩展支持
	* 用于加载和存储寄存器对的新指令，包含增强的寻址模式
	* CLZ 指令，改善归一化以及除法运算性能
* 浮点数运算扩展
	* 半精度、单精度和双精度浮点运算支持
	* 运算指令：Add、Sub、Mult、Neg-Mult、Negate、Abs Value、Compare、Div、Square Root
	* FMAC：Multiply-Add、Multiply-Subtract、Neg-Multiply-Add、Neg-Multiply-Subtract、类型转换、加载/存储标量和矢量，64 位/周期
* 多媒体SIMD 扩展
	* 小数运算
	* 用户可定义的饱和模式（任意字宽）
	* 同时计算2×16位或4×8位操作数
	* 双16×16 乘加/减和32×32 小数MAC
* NEON 是SIMD的128 位升级版，具有32个64 位宽（也可以看作16个128位宽）寄存器
	* 寄存器被视为同一数据类型的元素的矢量
	* 数据类型：8 位、16 位、32 位、64 位单精度浮点
	* 指令在所有通道中执行同一操作
* JAVA加速
	* ARM Jazelle 包括在任何现有JVM 和Java 平台中支持Jazelle 硬件的技术
* 安全计算的指令扩展
	* ARM TrustZone 技术是系统级的安全方法，针对高性能计算平台上的大量应用，包括安全支付、数字版权管理(DRM) 和基于Web 的服务
* 虚拟机有关的指令扩展
	* ARM架构的虚拟化扩展（Virtualization Extensions ）提供了在ARM处理器基础上建立虚拟机（virtual machines ）的基本支持

#### 4、Cortex-M支持的指令集

* 部分Cortex-M系列处理器所支持的指令集以及扩展指令功能

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519090656588.png" alt="image-20200519090656588" style="zoom:50%;" />

#### 5、Cortex-M处理器的兼容性

* 由上图可见，在Cortex-M0/M0+/M1上编译过的代码可在Cortex-M3/M4上直接运行
* Cortex-M3/M4不支持ARM指令，不能向后兼容传统ARM处理器（如ARM7TDMI），亦即Cortex-M处理器不能直接运行ARM7TDMI的二进制代码
* 但是，Cortex-M3/M4的Thumb-2指令是Thumb指令的超集，大部分ARM7TDMI的指令可以移植为等价的32位Thumb-2指令，因此传统ARM处理器上的应用软件可以重新编译后再移植到Cortex-M3/M4上
* 虽然指令有16位和32位之分，对于同一个操作，不同长度的指令执行时间相同

#### 6、Cortex-M处理器的适用场景

* 对于一般的数据处理和I/O控制，Cortex-M0/M0+完全可以胜任（性能达2.15 Core Mark/MHz）
* 如果需要进行复杂的数据处理和快速乘加运算，就应该升级到Cortex-M3/M4处理器
* 如果需要DSP功能，则应该选择Cortex-M4
* 如果还需要计算浮点数，Cortex-M4还应该选配FPU
* 需要特别指出的是：
	* 虽然Cortex-M3/M4支持的指令较多，但是C编译器也能生成高质量的代码，CMSIS-DSP库提供了较丰富的应用函数，现代大多数嵌入式软件都使用C或C++语言开发，因此无需过于关注汇编指令的细节

## 二、T32指令格式

**指令的概念**

* 每种计算机都有一组指令集供用户使用，这组指令集就称为计算机的指令系统
	* 机器指令：计算机能识别和执行的指令二进制代码，如：0100 0110 1000
	* 汇编指令：用助记符表示机器指令的操作码和操作数，如：MOV R0, R1

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519092331016.png" alt="image-20200519092331016" style="zoom:50%;" />

**指令的一般格式**

* 指令一般由操作码字段和操作数字段两部分组成

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519092414724.png" alt="image-20200519092414724" style="zoom:50%;" />

	* 操作码字段——指示计算机要执行是什么操作

	* 操作数字段——指令执行操作过程中所需要的操作数；

		该字段可以是：

	1. 操作数本身
	2. 操作数地址或是地址的一部分
	3. 指向操作数地址的指针
	4. 或其他有关操作数的信息（如寄存器名称）

* ARM处理器绝大多数算逻运算指令支持3操作数，也有1～2个操作数，少数隐含多个操作数（如LDM指令），还有若干指令无操作数17操作码字段操作数字段......操作数字段

**T32的指令编码分式**

* ARMv7-A/R/M中有T1、T2、T3、T4、A1和A2多种编码格式，例如对于：MOV  Rd, Rm指令，就有：

	* Encoding T1格式，16比特

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519092734991.png" alt="image-20200519092734991" style="zoom:50%;" />

	* Encoding T3格式，16比特

		<img src="/assets/images/ARM处理器指令系统.assets/image-20200519092809682.png" alt="image-20200519092809682" style="zoom:50%;" />

	* Encoding T3格式，32比特

		<img src="/assets/images/ARM处理器指令系统.assets/image-20200519092833828.png" alt="image-20200519092833828" style="zoom:50%;" />

**16位指令 vs 32位指令**

* T32的指令由半字对齐的序列构成
	* 若为16位Thumb指令，则指令中含有一个半字
	* 若为32位Thumb指令，则指令包含两个半字
* 通过半字的最高5位区分是16位指令还是32位指令
	* 若最高三位是111，接下来两位不是00，该半字是一条32位指令的第一个半字，接下来的半字是32位指令的另外一个半字
	* 如果最高三位不是111，则该半字是一条16位指令

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519092959299.png" alt="image-20200519092959299" style="zoom:50%;" />

### (一) 16比特指令二进制格式

* 指令的高6位是操作码

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519093222202.png" alt="image-20200519093222202" style="zoom:50%;" />

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519093242993.png" alt="image-20200519093242993" style="zoom:50%;" />

### (二) 32比特指令二进制格式

* 三段操作码

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519093310847.png" alt="image-20200519093310847" style="zoom:50%;" />

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519093331069.png" alt="image-20200519093331069" style="zoom:50%;" />

### (三) T32指令的汇编指令

#### 1、汇编语言

* 在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址，因此汇编语言也称为符号语言
* 不同的设备中，汇编语言对应着不同的机器语言指令集，特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植
* 在传统ARM处理器中，ARM指令与Thumb指令的汇编语言语法不同，对操作数（例如立即数）的限制也不同，往往会导致汇编结果出错
	* 例如：ARM指令、16位的Thumb指令和32位的Thumb2指令，对立即数的要求不同

#### 2、统一汇编语言UAL

* 为了支持Thumb-2技术，在ARMv7以后提出了UAL（Unified Assembly Language ）语法机制

* 对于16位和32位指令都能完成的操作（常见于数据处理操作），有时虽然指令的操作数不同，或者对立即数的限制不同，按照UAL语法格式统一描述，由汇编器决定采用哪种指令

* UAL统一了ARM指令和Thumb指令的书写格式，16位和32位的汇编指令可以无缝出现在同一份代码中

	* 例如以下两条指令等价

		```
		ADD R0, R1;			传统Thumb语法
		ARR R0, R0, R1;		UAL语法
		```

#### 3、T32指令的汇编语法

* ARM处理器汇编指令的通用格式

	```
	<opcode> [cond] [q] [S] _<Rd>, _<Rn> [,_Oprand2]
	```

	* 其中，`<>`内是必选参数，而`[]`内是可选参数
	* `opcode`，操作码，也称为助记符
	* `cond`：condition，条件码（可选后缀），指令执行条件
	* `q`，可选后缀，指令宽度选择
	* `S`，可选后缀，含`S`代表指令执行会更新APSR
	* `Rd`，目标操作数，总是一个寄存器
	* `Rn`，存放第一源操作数寄存器，该操作数必须是寄存器
	* `Oprand2`，第二源操作数，不仅可以是寄存器，还能是立即数，而且能用经过偏移量计算的寄存器和立即数

#### 4、操作码的助记符示例

* 汇编语言所描述的机器指令的形式

	```
	标号_助记符_操作数1,_操作数2, ... ;注释
	```

	示例：

	```
	label  MOVR0,  R1;R1中的数值装载到R0
	```

	* 标号“label”是指令的符号地址，属于伪指令内容

	* 不同汇编工具的语法有稍许区别，但助记符和汇编指令相同，伪指令、标号和注释语法可能会有差异

	* 例如，对于GNU工具链，上例的语法为：

		```
		label: MOV  R0,  R1/* 注释*/
		```

	* 例如，对于gcc，插入注释的语法为：

		```
		label: MOV  R0,  R1@ 注释
		```

### (四) T32的条件执行指令

* T32中多数指令可以根据应用程序状态寄存器APSR中的标志位决定当前指令是否被执行

* APSR(Application Program Status Register)

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519094147590.png" alt="image-20200519094147590" style="zoom:50%;" />

	* N bit[31] 负数标志位，N=1表示上一次运算结果为负数
	* Z bit[30] 零标志位，Z=1表示上一次运算结果为零
	* C bit[29] 进位标志位，C=1表示上一次运算产生了进位
	* V bit[28] 溢出标志位，V=1表示上一次运算产生了溢出
	* Q bit[27] 饱和标志位，Q=1表示上一次运算有饱和操作
	* GE[3:0] bits[19:16] ，DSP扩展指令中SIMD类指令指示

### (五) T32指令格式示例

#### 1、条件码含义示例

* 操作码助记符的条件码后缀

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519094411309.png" alt="image-20200519094411309" style="zoom:50%;" />

* 例句：

	```
	MOV EQ R0,  R1  ;Z==1时将R1中的数值装载到R0
	```

* 注意：含有条件码（后缀）的MOV指令需要和IT（IF-THEN）指令配合使用

#### 2、关于S后缀

* UAL仍然允许使用传统的Thumb语法格式。但是，如果使用传统Thumb语法，有些指令执行后会默认更新APSR，即使没有使用S后缀如果使用UAL语法格式，则必须加S后缀才会更新APSR

* 例如，以下两条指令等价：

	```
	AND  R0, R1			;Thumb语法，执行后更新APSR
	ANDS R0, R0,R1		;UAL语法，执行后更新APSR
	```

* 但是：

	```
	AND R0, R0,R1		;UAL语法，执行后不更新APSR
	```

## 三、T32指令集寻址方式

### (一) 寻址和寻址方式

* 寻址——根据指令内容确定操作数地址的过程
* 寻址方式——如何寻找操作数的方法。不同寻址方式实质上是构成操作数地址的方法不同
* 寻址包括两种情形：
	1. 确定当前指令中的操作数地址，称作数据寻址
	2. 确定下一条待执行指令的地址，常称作指令寻址
* 32位或64位的处理器中，32/64位宽的寄存器存放地址，可寻址范围2^32^或2^64^
* 16位处理器中寄存器只有16位，为增加寻址范围，另外使用段寄存器+有效地址EA（Effective Address）的方式寻址（注：EA可认为是段内偏移量）

### (二) 操作数的存放

* 操作数包含在指令中

	* 这种操作数称为立即数，例：

		```
		MOV  R0 , #0x08
		```

		说明：“#”表示是立即数

* 操作数包含在CPU的内部寄存器中

	* 例：

		```
		ADD Rd, Rn, Rm ;Rd= Rn+ Rm
		```

		说明：操作数存放在Rn, Rm寄存器中

* 操作数在存储器数据区
	
	* 操作数字段包含着此操作数的地址信息

### (三) 寻址方式分类

* 寻址方式共10种

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519184955267.png" alt="image-20200519184955267" style="zoom:50%;" />

#### 1、立即数寻址

* 立即数寻址也称为立即寻址，是一种特殊的寻址方式，操作数本身包含在指令中，只要取出指令也就取到了操作数，例如：

	```
	MOV R0, #66 		;将立即数66传送到寄存器R0
	ADD R0, R0, #66		;R0+66→R0
	SUB R0, R0, #0x33	;R0-0x33→R0
	```

* Cortex-M3或M4支持的T32指令集中，指令长度要么是16比特，要么是32比特，指令长度有限立即数取值只能在一定范围内

* 换言之，ARM处理器中的立即数要满足一定的规则。但是不同的指令集中对立即数的限制不同

##### (1) 对立即数的限制

* 在传统ARM处理器所使用的32位ARM指令中，要求32位立即数必须是一个“位图”数据
	* 位图数据：一个任意的8位立即数经过偶数次循环左移得到的数据
* 在16位Thumb指令集中，可以将任意8位立即数通过左移得到一个32位立即数
* 32位Thumb-2指令中，立即数要根据下图中i:imm3:a三部分的编码确定，就更加复杂
* 不满足条件，汇编会报错。并且可以通过其他手段解决这一问题

#### 2、寄存器寻址

* 利用寄存器中的数值作为操作数，也称为寄存器直接寻址

* 这种寻址方式的执行效率高，各类微处理器均支持这种寻址方式

* 示例：

	```
	ADD R0, R1, R2 
	;将R1和R2相加结果送入R0
	;常常记为：R1+R2→R0
	```

* 注意：寄存器限定于通用寄存器，不可以是PC

#### 3、寄存器间接寻址

* 寄存器间接寻址就是把寄存器中存放的数值作为操作数地址，通过这个地址去取得操作数，操作数本身存放在存储器中
* 例如，以下两条指令均使用了寄存器间接寻址

```
LDR R0, [R1] 
; 以寄存器R1的值作操作数的地址，取得操作数后传
; 送到R0
; 常常记为[R1] → R0
ADD R0, R1, [R2]
; 基于寄存器R2间接寻址取得操作数后与R1相加，结
; 果存入R0
; 常常记为R1+[R2]→R0
```

#### 4、寄存器移位寻址

* 寄存器移位寻址（Shifts applied to a register）是ARM指令集特有的寻址方式。其寻址方式为：先由寄存器寻址得到操作数，对该操作数再进行移位操作后得到最终的操作数，例如：

	```
	MOV R0, R2, LSL #3 ;R2<<3，→ R0
	MOV R0, R2, LSL R1 ;R2<<R1，→ R0
	```

* 支持的移位方式

	* LSL：逻辑左移（Logical Shift Left）
	* LSR：逻辑右移（Logical Shift Right）
	* ASR：算术右移（Arithmetic Shift Right）
	* ROR：循环右移（Rotate Right）
	* RRX：带扩展的循环右移（Rotate Right extended）

**移位运算示例**

* ARM处理器支持多种移位运算，因为在处理器ALU中内置了桶形移位器。寄存器移位寻址也是建立在桶形移位器基础之上的

	* 对于无符号数，应该使用逻辑右移或逻辑左移
	* 对于有符号数，算术左移等同逻辑左移，但是算术右移时，每移动一位最高位都填充符号位

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519120101397.png" alt="image-20200519120101397" style="zoom:50%;" />

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519120150136.png" alt="image-20200519120150136" style="zoom:50%;" />

#### 5、寄存器偏移寻址

* 可以对前述寄存器间接寻址进行拓展，操作数地址由一个寄存器中存放的数值与指令中给出的地址偏移量相加得到
* 其汇编语法为：`opcode [<Rn>,<offset>]`
* 通常把存放在寄存器中的地址信息称作基址（base address），该寄存器称作基址寄存器。而指令中给出的地址偏移量（offset）存在如下三种不同的形式
	* 立即数（Immediate）
	* 寄存器（Register）
	* 寄存器移位（Scaled register）

**寄存器偏移寻址的不同形式**

* 以LDR指令为例
	* 类型1：`LDR <Rt>, [<Rn>{,#<imm>}]`
	* 类型2：`LDR <Rt>, [<Rn>, <Rm>]`
	* 类型3：`LDR <Rt>, [<Rn>, <Rm> {, LSL #<shift>}]`
* 其中：`<Rn>`表示基址寄存器，而`<offset>`表示偏移量，偏移量可以是：
	* 5位立即数（`<imm5>`）或8位立即数（`<imm8>`）或12位立即数（`<imm12>`）
	* 寄存器值`<Rm>`
	* 寄存器值移位，如`<Rm>, LSL #<shift>`，`#<shift>`表示移位的位数（左移n位相当于×2^n^）

**寄存器偏移寻址示例**

* 类型1示例：

	```
	LDR R0, [R1, #4] 
	; 将R1中的值加4形成操作数地址，取得的操作数送
	; 入寄存器R0
	```

* 类型2示例：

	```
	LDR R0, [R1, R2]
	; R1中的值加上R2中的值形成操作数地址，取得的操
	; 作数送入R0
	```

* 类型3示例：

	```
	LDR R0, [R1, -R2, LSL#4]
	; R1中的值减去R2中的值×16，形成操作地址，取得
	; 的操作数送入R0，R1和R2的值不变
	```

#### 6、前变址寻址

* 也称为前序寻址或前索引寻址（Pre-indexed addressing）

* 指令执行时，将基址与偏移相加后形成的操作数地址写回到基址寄存器中

	* 格式：`opcode [<Rn>,<offset>]!`
	* “!”后缀表示指令完成时是更新存放基地址的基址寄存器（写回）

* 例：以下4条指令分别使用了寄存器偏移寻址和前变址寻址，注意彼此的区别

	```
	LDR R0, [R1, #4] 	;将地址为R1+4的内容送入R0，R1不变
	LDR R0, [R1, #4]!	;与上条指令区别：执行后R1=R1+4
	LDR R0, [R1, R2]	;将地址为R1+R2的内容送入R0，R1和R2不变
	LDR R0, [R1, R2]! 	;与上条指令区别：执行后R1=R1+R2
	```

#### 7、后变址寻址

* 也称为后序寻址或后索引寻址（Post-indexed addressing）

* 指令执行时，操作数地址从基址寄存器获取；指令执行后，再将操作数地址加上偏移量写入基址寄存器

	* 格式：`opcode  [<Rn>], <offset>`
	* 注意方括号的范围

* 例：如下三条指令分别使用了寄存器偏移寻址、前变址寻址、后变址寻址方式

	```
	LDR R0, [R1, #4]  ;将地址为R1+4的内容送入R0，执行后R1不变
	LDR R0, [R1, #4]! ;与上条指令区别：执行后R1=R1+4
	LDR R0, [R1], #4 ;将地址为R1的内容送入R0，然后R1=R1+4
	```

#### 8、多寄存器寻址

* 从一连续存储器区域装载多个数据到多个寄存器中，LDM和STM指令使用此寻址方式
	* 格式：`LDM/STM{addr_mode} <Rn>{!}, <registers>`
	* `<Rn>`为基址寄存器
	* `<registers>`为需要载入数据的寄存器集合
	* 可选项`{!}`表示需要将修改后的地址写入基址寄存器`<Rn>`
	* 可选后缀`{addr_mode}`可选择如下四种方式
		* `IA(Inc. addr. After each access)`，取操作数后基址寄存器递增
		* `IB(Inc. addr. Before each access)`，取操作数前基址寄存器递增
		* `DB(Dec. addr. Before each access)`，取操作数前基址寄存器递减
		* `DA(Dec.t addr. After each access)`，取操作数后基址寄存器递减

**多寄存器寻址示例：**

* 多寄存器加载指令LDM（Load Multiple registers）

	```
	LDMIAR0, {R1, R2, R3, R4}; 4寄存器加载指令
	```

	* 该指令将地址为R0、R0+4、R0+8和R0+12的4个字数据分别加载R1、R2、R3和R4

	* IA后缀表示在取操作数后R0的值递增

	* 在使用多寄存器寻址指令时，寄存器集合的顺序如果由小到大的顺序排列，可以使用“-”连接，否则用“,”分隔书写

	* 下面的指令完成和上面一条指令相同的功能

		```
		LDMIAR0, {R1-R4}
		```

* STM（Store Multiple registers ）指令，保存多个寄存器到存储区连续区域

	* 例：

	```
	STMIAR0!, {R1-R7} 	; R1~R7的数保存到R0指向的地址，
						; 每取一个数后R0递增4
	STMIBR0!, {R1-R7} 	; R1~R7的数保存到R0指向的地址，
						; 每取一个数前R0递增4
	STMDAR0!, {R1-R7}	; R1~R7的数保存到R0指向的地址，
						; 每取一个数后R0递减4
	STMDBR0!, {R1-R7} 	; R1~R7的数保存到R0指向的地址，
						; 每取一个数前R0递减4
	```

#### 9、堆栈寻址

* 如果把多寄存器寻址方式中LDM或STM指令中的基址寄存器更换为堆栈指针寄存器SP，并添加可选项{!}（每次压栈/出栈更新SP），就成为堆栈寻址

* 例如：

	```
	STMFDSP!, {R1-R7}  ;将R1~R7寄存器中的数压入堆栈
	LDMFDSP!, {R1-R7}  ;将堆栈数据取出存入R1~R7寄存器
	```

* 注意：
	* 指令后缀FD表示是满减栈，如果堆栈类型是满增、空减或空增，指令后缀应改为相应的FA、ED和EA
	* 每次压栈或出栈操作，SP按照堆栈操作的规定变化

#### 10、PC相对寻址

* PC-relative，是一种特殊的基址变址寻址，常简称为相对寻址。以程序计数器（PC）寄存器的当前值作为基地址，指令中的地址标号作为偏移量，将两者相加获得操作数的地址
* 偏移量有两种表示方法
	* 汇编语句标号（Label）
	* 存储器代码区数据块相对当前代码的位置
		* 文本池（literal pool）：如果指令需要使用一个4字节的常量数据（可以是内存地址或数字常量），为了解决指令长度受限问题，编译器或汇编器在代码区中分配一块内存，保存这个4字节的数据常量。指令执行时，再使用一条指令把这个常量加载到寄存器中参与运算

**示例：**

* 例1：用BL指令跳转到“MY_SUB”标号处执行

	```
	BL MY_SUB				;相对寻址，跳转到MY_SUB处执行
	......					;其他指令
	MY_SUB   ADD R0, R0, R1	;转移目标指令
	......					;其他指令
	```

* 例2：用ADR（Address to Register）指令获取PC相对寻址结果

	```
	StartMOV R0, #10	 ;Start是标号
	......				 ;其他指令
	ADR R2，start		;将标号为“start”语句的地址送入R2
	```

	

* 例3：利用LDR指令将相对当前代码位置后12字节位置的数据（32比特）传送到R0寄存器

	```
	LDR R0, [PC, #0xC]
	```

## 四、Cortex-M3/M4指令集

### (一) 处理器内的数据传送指令

* 实现处理器内部不同电路单元之间的数据传送
	* 将数据从一个寄存器送到另外一个寄存器
	* 通用寄存器和特殊功能寄存器之间传送数据
	* 将立即数送到寄存器

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519185821229.png" alt="image-20200519185821229" style="zoom:50%;" />

* MOVW和MOVT指令的功能

	* MOVW：把16位任意立即数传送到目的寄存器的低16位，高16位清0
	* MOVT：把16位任意立即数传送到目的寄存器的高16位，低16位不变

* 使用以上两条指令，可以将任意的32位立即数传送到32位寄存器中

	* 事实上，有些汇编器会根据立即数的大小，如果是9~16位，MOV和MOVS指令会自动转成MOVW

* 如果需要将一个任意的32位立即数装入寄存器，还有许多其他方法

	* 最常用的方法是使用伪指令，例如

		```
		LDRR0,=0x12345678;“=”是伪指令运算符
		```

	* 这不是一条实际指令，汇编器会将上述伪指令转换成存储器加载指令和存储在代码区文本池中的一个常量

		```
		LDRR0,[PC,#offset]	;汇编器计算#offset
		......
		DCD0x12345678		;伪指令，告诉汇编器分配连续的;字存储单元并用指定的数据初始化
		```

	* 因流水线的原因，LDR语句执行时的PC并非是LDR指令的地址，但是汇编器会自动计算offset，无需担心

### (二) 存储器访问指令

* 有多条（系列）Load/Store指令用于存储器访问
* 寻址模式
	* 立即数寻址、寄存器寻址、寄存器移位寻址、寄存器间接寻址、基址变址寻址、多寄存器寻址（块拷贝寻址）、堆栈寻址、PC相对寻址
* 指令中操作数类型
	* 无符号：字节（8bits）、半字（16bits）、字（32bits）、双字（64bits）、多字
	* 有符号：字节（8bits）、半字（16bits）、字（32bits）、双字（64bits）
	* 此外，还有安全增强和排他访问增强指令

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519190212972.png" alt="image-20200519190212972" style="zoom:50%;" />

* 安全性增强：即使是特权访问等级程序，如果使用非特权的LDRT或者STRT指令，也只能访问非特权访问等级才能访问的区域，否则将引起Fault异常
* 排他访问增强

#### 1、不同的操作数类型

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519190424926.png" alt="image-20200519190424926" style="zoom:50%;" />

* 可以存储的的数据类型：
	* 字节、半字、字
* 读/写存储器操作支持的数据类型：
	* 32-bit指针
	* 无符号/有符号的32位整数
	* 无符号的16-bit或8-bit整数，须零扩展
	* 有符号的16-bit或8-bit整数，须符号扩展
	* 无符号/有符号的64-bit整数，由2个寄存器保存的多个32-bit数

#### 2、零扩展和符号扩展

* 零扩展（zero-extended）即在高位补“0”

	* 例，8-bit数值“10001010”零扩展至16-bit“0000000010001010”

* 符号扩展（sign-extended）操作用于保护有符号数的符号位

	* 例，8-bit数值“0000 1010”扩展至16-bit“0000 0000 0000 1010
	* 例，8-bit数值“1000 1010”扩展至16-bit“1111 1111 1000 1010”

* 以LDRSB为例：

	* 使用LDRSB或LDRSH将一个字节或半字数据加载到32位寄存器，会对被加载数据自动执行符号位扩展，例如：

		```
		LDRSBR7,0x83	;数据加载前会被转换为0xFFFFFF83
		LDRSBR7,0x03	;数据加载前会被转换为0x00000003
		```

	* 讨论：低位宽的数转换至高位宽的数时，零扩展和符号扩展能保证数值不变吗？
		* 有符号数0x83$\rightarrow$[10000011b]~补~$\rightarrow$[11111101b]~原~$\rightarrow$0xFD、十进制-175
		* 0xFFFFFF83$\rightarrow$[11...110000011b]~补~$\rightarrow$[10...001111101b]~原~$\rightarrow $0x8000007D、十进制-175 

#### 3、不同寻址模式——以LDRB为例

* 偏移寻址（Offsetaddressing）模式

	```
	LDRBRd,[Rn,#offset]
	;从存储器位置[Rn]+offset读取字节
	```

* 前变址（Pre-indexedaddressing）寻址模式

	```
	LDRBRd,[Rn,#offset]!
	;从[Rn]+offset读取字节，然后更新Rn为Rn+offset
	```

* 后变址（Post-indexedaddressing）寻址模式

	```
	LDRBRd,[Rn],#offset
	;读取[Rn]处的字节到Rd，然后更新Rn为Rn+offset
	```

* 寄存器移位寻址（Shiftsappliedtoaregister）模式

	```
	LDRBRd,[Rn,Rm,LSL#n)]
	;从存储器位置Rn+(Rm<<n)处读取字节
	```

#### 4、多加载和多存储指令

* ARM处理器的一个重要特性，可以读（LDM指令）或者写（STM指令）存储器中的多个连续数据
	* Cortex-M3/M4只支持IA和DB两种地址变更方式
	* 只能支持32位传送
	* EA和FD表示“空递增”和“满递减”两种堆栈类型

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519204621901.png" alt="image-20200519204621901" style="zoom:50%;" />

#### 5、读/写存储器多个数据的系列指令

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519204726803.png" alt="image-20200519204726803" style="zoom:50%;" />

1. 指令等价于LDMIA指令以SP作为基址寄存器且更新基址寄存器
2. 指令等价于STMDB指令以SP作为基址寄存器且更新基址寄存器

#### 6、堆栈操作：压栈和出栈

* 对于FD型堆栈，以下两条指令等价（Equivalent）

	```
	PUSH<cond><q><registers>
	STMDB<cond><q>SP!,<registers>
	```

	* 例如：

	  ```
	  PUSH{R0,R4-R6,R8}
	  ;将R0、R4、R5、R6和R8压入栈中
	  ```

* 对于FD型堆栈，以下两条指令等价

	```
	POP<cond><q><registers>
	LDMIA<cond><q>SP!,<registers>
	```

	* 例如：

		```
		POP{R1,R2}
		;将栈中内容存入R1和R2
		```

#### 7、PC相对寻址模式

* 如果使用PC寄存器作为基地址，再加上偏移量形成待访问操作数地址。常用于将立即数加载到寄存器中，如前述的文本池（LiteralPool）访问

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519210913939.png" alt="image-20200519210913939" style="zoom:50%;" />

#### 8、非特权等级加载和存储

* RM中提供了一组特殊的加载和存储指令，在特权访问等级程序中使用这些指令加载或保存的数据，如同非特权访问等级程序的访问效果

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519210951907.png" alt="image-20200519210951907" style="zoom:50%;" />

使用场景：特权等级的OS代码在API中向非特权等级的用户程序传递数据时，可使用这些特殊指令存取目标存储器位置，如果存取过程发生异常，则OS可知用户程序是无法访问这些位置，无法实现传送，需要进行调整

#### 9、排他式访问

* ```
	LDREX Rx,[Ry]
	;排他加载，[Ry]→Rx，同时对Ry指向的内存区域标记独占访问，如果执行时发现已被标记，对指令执行没有影响
	```

* ```
	STRRx,Ry,[Rz]
	;排他存储，Ry→[Rz]，如果成功，则将Rx更新为0；若不成功，则将Rx置1
	```

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519211214076.png" alt="image-20200519211214076" style="zoom:50%;" />

**小结：读/写存储器单个数据的系列指令**

* 指令中操作数类型
	* LDRB、LDRSB、LDRH、LDRSH、LDR、POP
	* LDRD、LDM、LDMIA、LDMDB
* 指令中操作数地址获取方式
	* LDRBRd,[Rn,#offset]
	* LDRBRd,[Rn,#offset]!
	* LDRBRd,[Rn],#offset
	* LDRBRd,[Rn,Rmi,LSL#n)]
* 针对提升安全性的增强
	* LDRBT、LDRSBT、LDRHT、LDRSHT、LDRT
* 针对提升并发控制能力的增强（排他访问）
	* LDREXB、LDREXH、LDREX

### (三) 算术运算指令

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519211528964.png" alt="image-20200519211528964" style="zoom:50%;" />

* 后缀不同，进位方式以及对APSR标志位的影响不一样，对应的二进制机器码也不同
* 按照传统的Thumb汇编语法，在使用16位Thumb代码时，ADD指令将修改APSR中的标志
* 32位Thumb-2指令可以修改这些标志，也可以不修改
* 为区分这两种操作，建议使用统一汇编语言UAL语法，如需更新APSR标志位，应使用S后缀

```
ADD  R0,R0,R1		;R0=R0+R1，不修改APSR
ADDS R0,R0,0x12		;R0=R0+0x12，更新APSR
ADC  R0,R1,R2		;R0=R1+R2+进位，不修改APSR75
```

**Cortex-M3/M4乘法和MAC指令**

* Cortex-M3/M4都支持具有32位和64位结果的32位乘法指令和乘加（MAC）指令，APSR标志不受这些指令的影响。Cortex-M4处理器还支持额外的快速MAC指令

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519211737448.png" alt="image-20200519211737448" style="zoom:50%;" />

### (四) 逻辑运算指令

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519212527480.png" alt="image-20200519212527480" style="zoom:50%;" />

* BIC（位清除）指令的一般格式：

	```
	BIC{条件}{S}Rd,Rn,Operand2
	```

* 该指令将Rn与Operand2的反码按位相“与”，结果存入Rd，该指令常用于将Rn的某些位清零

	* 例1：

		```
		BICR1,R1,#0xF0000000	;将R1高4位清零
		```

	* 例2：

		```
		BICR2,R3,#0x0F	;将R3低4位清0结果存入R2
		```

	* 说明：

		* 如果使用16位指令，只有2个操作数，目的操作数必须是源操作数之一，而且只能是低位寄存器（R0~R7)

* ORN（按位或非）没有16位指令，该指令将源操作数按位取反后，再执行按位进行逻辑或运算

### (五) 移位和循环移位指令

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519212737889.png" alt="image-20200519212737889" style="zoom:50%;" />

* 若使用S后缀，循环和移位指令也会更新APSR中的进位标志位；多位移位运算之后，进位位为最后移出寄存器的哪一位
* 为什么只有循环右移而没有循环左移？
	* 循环左移可以使用一定次数的循环右移代替
	* 例如，循环左移6位可以使用循环右移26位代替，目的寄存器中的内容相同，执行时间也相同，只是标志位可能不同
* 除了RRX（包含进位位的循环右移）指令以外，移位与运算指令还有16位版本，但是16位版本只能使用低位寄存器（R0~R7）

### (六) 数据格式转换

* 符号扩展（SigneXtend）和无符号扩展（Zeroextend）

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519212930533.png" alt="image-20200519212930533" style="zoom:50%;" />

	* 上述指令也有16位和32位两种形式，16位指令只能访问低位寄存器，32位可以访问高位寄存器

	* 例：若R0为0x55AA8765，以下指令执行后R1的数值:

		```
		SXTB Rl,R0`;R1=0x00000065，只转换R0中的0x65
		SXTH R1,R0`;R1=0xFFFF8765，只转换R0中的0x8765
		UXTB Rl,R0`;R1=0x00000065，只转换R0中的0x65
		UXTH R1,R0`;R1=0x00008765，只转换R0中的0x8765
		```

* 上述指令的32位形式还可以选择在有符号扩展运算之前将Rn循环右移

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519213131492.png" alt="image-20200519213131492" style="zoom:50%;" />

* 数据反转指令：常用于大小端数据转换

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519213155423.png" alt="image-20200519213155423" style="zoom:50%;" />

* 示例：

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519213223339.png" alt="image-20200519213223339" style="zoom:50%;" />

	例：假设R0为0x12345678，则有：

	```
	REV   R1,R0	;R1变为0x78563412
	REVH  R2,R0	;R2则会变为0x34127856
	REVSH R3,R0	;R3则会变为0x0000785684
	```

### (七) 位域处理指令

* 位域(BitField)处理指令用于控制类用于

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519213959567.png" alt="image-20200519213959567" style="zoom:50%;" />
	* BFC（位域清除）指令：清除Rd中位置由`<lsb>`指定的、宽度为`<width>`的相邻位

		* 例：假设R0=0x1234FFFF

			```
			BFCR0,#4,#8		;执行后R0=0x1234F00F
			```

	* BFI（位域插入）指令：将Rn中的1~31位（`#width`）插入到Rd中由`#lsb`（最低位）指定的位置

		* 例：假设R0=0x24681357，R1=0x89ABCDEF

			```
			BFIR0,R1,#8,#16		;将R1的[15:0]插入R0[23:8]中
								;执行后R0=0x24CDEF57
			```

	* CLZ指令：计算Rn中前导零的个数，结果存入Rd

		* 常用于数据归一化处理之前，确定需要移位的位数
		* 如果Rn全为1，Rd=0；若Rn全为0，Rd=32

	* RBIT（反序）指令：将Rn中的字数据反序后存入Rd

		* 例如：

			假设R1=0b11000011101001011011110110000001

			RBITR0,R1;R0=0b10000001101111011010010111000011

	* SBFX/UBFX指令：将Rn中从`#lsb`起提取宽度为`#width`的位域复制到Rd中，并进行符号展开/零展开

### (八) 比较和测试指令

* 以下指令后，更新APSR但不保存运算结果！
* 这些指令的后续指令往往是条件跳转和条件执行指令

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519215511378.png" alt="image-20200519215511378" style="zoom:50%;" />

### (九) 程序流控制指令

* 包括无条件跳转和函数调用、条件跳转、比较和条件组合跳转、条件执行（IF-THEN）、以及表格跳转等

#### 1、无条件跳转和函数调用指令

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519215727674.png" alt="image-20200519215727674" style="zoom:50%;" />

* 更新PC的数据处理指令（如MOV、ADD），或写入PC的加载指令（如LDR、LDM、POP）也可以引起跳转，但不常用
* 关于函数调用指令的说明
	* BL和BLX指令将返回地址存入LR（R14）之后，会覆盖LR原来的内容，如果原来LR的内容需要保护，则应在执行函数调用指令之前将LR的内容压栈保存
	* 如果调用的是按照AAPCS（ARM架构过程调用标准）编写的C语言函数，可能还会用到R0~R3和R12寄存器，这些寄存器的内容也需要压栈保存
	* 注意：传统ARM处理器中有一条`BLX<label>`指令，（不同于Cortex-M3/M4的`BLX<Rm>`），该指令执行跳转并总是切换状态。由于Cortex-M3/M4只有Thumb状态，所以不支持`BLX<label>`指令

#### 2、条件跳转

* 基于APSR当前的标志位决定是否跳转

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519224029807.png" alt="image-20200519224029807" style="zoom:50%;" />

* cond为以下14个可能的条件后缀之一

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519224050978.png" alt="image-20200519224050978" style="zoom:50%;" />

#### 3、比较和跳转

* ARMv7架构增加了两条比较跳转指令

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519224127890.png" alt="image-20200519224127890" style="zoom:50%;" />

* 说明：相当于CMP和BEQ/BNE的组合。只能向前跳转，不能向后跳转，跳转范围为当前指令后的4\~130字节，且只能使用R0\~R7，常用于小范围的循环控制。例如：

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519224301282.png" alt="image-20200519224301282" style="zoom:50%;" />

	#### 4、条件执行

* IT指令允许跟随其后的最多四条指令是条件执行的，IT指令后的几条指令被称作一个IT块（ITblock）

* “IT”指令的汇编语法为：`IT{x{y{z}}}cond`

	* `cond`为IT块中第1条指令使用的条件码
	* `x`指定IT块中第2条指令的是否执行的开关
	* `y`指定IT块中第3条指令的是否执行的开关
	* `z`指定IT块中第4条指令的是否执行的开关

* `x`、`y`和`z`对应的有两种开关：

	* T-Then，条件成立则执行
	* E-Else，条件不成立则执行

* 增加不同位数后缀的IT指令（IT+T和E的各种组合）

	* 只有1个条件：IT，“If-Then”，以下1条指令条件执行

	* 有2个条件：ITT、ITE，以下2条指令条件执行

	* 有3个条件：ITTT、ITTE、ITET、ITEE，以下3条指令条件执行

	* 有4个条件：ITTTT、ITTTE、ITTET、ITETT、ITTEE、ITEET、ITETE、ITEEE，以下4条指令条件执行

	* 例1：

		```
		ITEQ			;意为“If-Then”，下条指令条件执行
		ADDEQR0,R1,R2	;若Z=1，则(R1+R2)→R093
		```

	* 例2：

		```
		ITETTNE				;“If-Then-Else-Then-Then”，随后四条指令条件执行
		ADDNE R0,R0,R1		;若Z=0（不等），则（R0+R1）→R0
		ADDEQ R0,R0,R3		;若Z=1，则（R0+R3）→R0
		ADDNE R2,R4,#1		;若Z=0，则（R4+1）→R0
		MOVNE R5,R3			;若Z=0，R3→R5
		```

#### 5、按跳转表跳转

* 为什么要用一个表来定义跳转方式？
	* 汇编编程直接实现类似C语言中switch(case)的多分支跳转控制十分困难，因为跳转目标地址与某个变量有关
	* 如果预先定义一个数组（跳转表），每个数组元素是一个目标地址，那么通过改变数组下标，就可以通过数组元素得到不同的目标地址
* Cortex-M3/M4支持两条表格跳转指令：
	* TBB（按照字节为单位的跳转表进行跳转）
	* TBH（按照半字为单位的跳转表进行跳转）
* 事实上，很少有人使用汇编语言实现多分支跳转，因为定义跳转表较为复杂，并且往往容易出错

### (十) 饱和运算

* 定点运算中经常遇到运算结果溢出的情况，有上溢和下溢两种

* 溢出运算：

	* 传统运算方式（即“环绕式”运算）的处理通常是自动回到计数零点
	* 饱和（Saturation）运算：当达到最大值/最小值时不再增加/减少，而是保持在这个最大值/最小值上。
	* 只有加、减指令才有饱和方式
	* 例如：在图像和图形处理中，用8位无符号数表示一个象素值或颜色分量值，最大数255表示亮度的最大值，如果运算结果超出这个范围，仍然表示为“最亮”是符合实际情况的

* Cortex-M3支持以下两条饱和运算指令：

  * SSAT：有符号数饱和运算指令
  * USAT：无符号数饱和运算指令

  <img src="/assets/images/ARM处理器指令系统.assets/image-20200519230650888.png" alt="image-20200519230650888" style="zoom:50%;" />

  * 除了以上两条饱和运算指令以外，Cortex-M4还拥有十多条饱和运算指令，其中有些指令还支持SIMD

* 以下以SSAT和USAT为例，介绍饱和运算相关概念

* SSAT和USAT指令的语法格式：

	* ```
		SSAT<Rd>,#<immed>,<Rn>,{,<shift>};有符号饱和
		```

	* ```
		USAT<Rd>,#<immed>,<Rn>,{,<shift>};无符号饱和
		```

	* 其中：

		* `<Rn>`为输入值
		* `<shift>`为饱和前可选的移位操作，可为`LSL#n`或`ASR#n`
		* `<Rd>`为目的寄存器
		* `#immed`为执行饱和的位的位置

	* 如果运算过程中出现了饱和，APSR中的Q位置1

* 示例

	* 例1：如果需要将一个32位有符号数饱和为16位有符号数，可以使用如下指令：

		```
		SSATR1,#16,R0
		```

	* 例2：如果需要将一个32位有符号数饱和为16位无符号数，可以使用如下指令：

		```
		USATR2,#16,R0
		```

* 当R0为不同数值时，SSAT和USAT指令执行后，R1和R2的值以及Q位如下表所示

	<img src="/assets/images/ARM处理器指令系统.assets/image-20200519231026494.png" alt="image-20200519231026494" style="zoom:50%;" />

### (十一) 其他杂类指令

<img src="/assets/images/ARM处理器指令系统.assets/image-20200519231053285.png" alt="image-20200519231053285" style="zoom:50%;" />

#### 1、休眠模式指令

* WFI指令会使处理器立即进入休眠模式，中断、复位或调试操作可以将处理器从休眠中唤醒。
* WFE会使处理器有条件地进入休眠。在Cortex-M3/M4处理器内部，有一个只有一位的寄存器会记录事件。若该寄存器置位，WFE指令不会进入休眠而只是清除事件寄存器并继续执行下一条指令；若该寄存器清零，则处理器会进入休眠而且会被事件唤醒，事件可以是中断、调试操作、复位或外部事件输入的脉冲信号。
* SEV指令可用于发送事件，多处理器系统中可用于向其他处理器传递信号。Cortex-M处理器的接口信号包括一个事件输入和一个事件输出。处理器的事件输入可由多处理器系统中其他处理器的事件输岀产生，因此，处于WFE休眠的处理器可由其他的处理器唤醒。

#### 2、异常相关指令

* 管理调用（SVC）指令用于产生SVC异常（异常类型为11）。SVC一般用于嵌入式操作系统（OS），其中，非特权应用可以请求使用具有特权OS提供的服务（类似于x86系统中的系统功能调用）
	* SVC指令要求SVC的优先级高于当前优先级，并且没有被PRIMASK等寄存器屏蔽
	* SVC指令格式：SVC#<immed>
		* 其中`immed`为8位立即数，是OS定义的系统功能调用号
	* 另一个和异常相关的指令是CPS指令，用于改变处理器状态。使用这条指令可以设置或清除PRIMASK和FAULTMASK等中断屏蔽寄存器

#### 3、空指令和断电指令

* Cortex-M支持NOP指令，用于产生指令对齐或延时
	* 注意，NOP指令产生的延时在不同系统间可能会存在差异。若需精确延时，应使用硬件定时器
* 在软件开发/调试过程中，断点（BKPT:Breakpoint）指令用于实现应用程序中的软件断点
	* 若程序在SRAM中执行，则该指令一般由调试器插入以替换原有的指令
	* 当到达断点时，处理器会被暂停，然后调试器就会恢复原有的指令，用户也可以通过调试器执行调试任务
	* BKPT指令也可以用于产生调试监控异常，它具有一个8位立即数，调试器或调试监控异常可以将该数据提取出来，并根据该信息确定要执行的动作

### (十二) Cortex-M4特有指令

* 与Cortex-M3处理器相比，Cortex-M4支持的指令更多。新增的功能包括：单指令多数据（SIMD）、饱和指令、其他的乘法和MAC（乘累加）指令、打包和解包指令、可选的浮点指令等。这些指令可以让Cortex-M4可以更加高效地进行实时数字信号处理
	* 往往对数组的不同元素做相同的运算
	* 循环体内往往是两个操作数相乘之后进行累加
	* 往往操作数动态范围很大，用的是浮点数