---
title: ARM处理器体系结构
tags: 微机原理与嵌入式系统
article_header:
  type: cover
  image:
    src: /assets/images/embed.jpg
---

<!--more-->

## 一、ARM体系结构与ARM处理器概述

### (一) 指令集体系结构与微架构

#### 1、CA：计算机体系结构

* CA是对计算机系统的设计思想、逻辑特征、原理特征、结构特征和功能特征的一种抽象
* 广义上CA涵盖处理器的指令集体系结构（Instruction Set Architecture，ISA）和微架构（Microarchitecture，简称μarch）以及硬件实现（Hardware Implementation）
* 狭义的计算机体系结构（至少在历史上有段时间）只是指ISA指令集体系结构
* 本章所说的ARM处理器体系结构除了ISA，还包括存储器模型和异常模型

#### 2、指令集体系结构ISA

* 描述软件如何使用硬件的一种规范和约定，是程序员眼中的概念结构和功能特征，具体地就是程序员编程时能看到或者能用到的资源以及使用方式，包括：
	* 可执行指令集合，包括指令格式、操作种类以及每种操作所对应的操作数规范
	* 指令可接受的操作数类型
	* 寄存器组结构，包括名称、编号、长度和用途
	* 存储空间的大小和编址方式
	* 操作数寻址方式及操作数存放格式
	* 指令执行控制方式，包括程序计数器、条件码定义等

#### 3、微架构

* ISA的硬件实现方式。亦即以何种方式来实现处理器的各种功能，包括运算器、控制器、流水线、超标量和存储系统结构等，属于计算机的组织和实现技术

* 相同ISA的处理器有不同的微架构，例如：
	* ARM9T和ARM7Y
		* 5级流水线哈佛结构vs.3级流水线冯诺依曼结构
	* AMD和Intel
		* 都支持x86 ISA，但微架构不同
* 只要ISA相同→软件兼容

### (二) ARM处理器体系结构简介

#### 1、基于ISA和微架构的处理器分类

<img src="/assets/images/ARM处理器体系结构.assets/image-20200409194924081.png" alt="image-20200409194924081" style="zoom:67%;" />

* ARM处理器
	* ISA-RISC
	* 微架构：两种都有

#### 2、哈佛结构（一种并行体系结构）

* 程序和数据存储在不同的存储空间中，每个存储器独立编址，使用两套总线单独访问
* 可提高数据吞吐率，消除流水线上取指和取操作操作的资源相关，处理器性能高于冯·诺依曼结构
* 哈佛结构较为复杂，实现难度较大，早期较少采用

#### 3、简化的哈佛结构

* Intel MCS-51单片机，指令和数据分别存储两个独立的存储模块，但仍共用一条公共总线，仍须分时访问
* 有些内部使用两条独立总线分别访问指令和数据（如Cortex-M系列处理器），有些内部分别配置指令和数据Cache或者TCM。但对外只有一条总线，外部指令和数据仍然存储在一个存储器中，旨在减少硬件复杂性
	* TCM（Tightly Coupled Memory，紧耦合内存），通过专用总线与CPU相连的高速存储器，性能与Cache相当，常与处理器集成在一起，早先也有片外的。与Cache的主要区别：具有物理地址、需占用内存空间、无Cache的不可预测性
	* 用途：存放必须快速执行的中断服务程序和实时任务处理程序，以及不适合存放在Cache中的重要数据，如中断向量表和堆栈

#### 4、ARM体系结构主要版本

##### (1) V1版

* 与ARM1原型机同时诞生，仅用于ARM1原型机
* 32位处理器，地址总线只有26条，内存寻址空间64MB，只提供了一些基本指令，如：
	* 基本数据处理指令，没有乘法运算指令
	* 数据存取指令，可以对字节、半字和字数据进行存取
	* 控制转移指令，包括子程序调用及链接指令
		* 链接指令：一种转移指令，转移时将转移指令的下一条指令存入R14寄存器。需要返回时，使用MOV指令将R14寄存器的内容写入PC，就可实现程序的返回
	* 供操作系统使用的软件中断SWI指令

##### (2) V2版（包括ARMv2a）

* ARM 2的内存寻址空间仍然只有64MB，为了提高数据处理能力，v2版增加了：
	* 乘法运算和乘加运算指令
	* 若干协处理器操作指令
	* 快速中断模式FIQ（优先级高于普通IRQ）
	* 存储器与寄存器之间进行数据交换的SWP（swap）指令，包括字交换指令SWP和字节交换指令SWPB
* 基于ARMv2版架构的处理器有ARM2、ARM2aS和ARM39

##### (3) V3版

* 有较大改进和完善，32位地址，内存寻址空间扩展到4GB，增加了Cache、新的寄存器和新的指令：
	* 增加了CPSR，不再使用R15寄存器保存程序执行状态
	* 增加了SPSR，用于异常处理时保存CPSR，以便恢复
	* 增加了访问CPSR等特殊寄存器的MRS和MSR指令
	* 增加了从异常处理返回指令的功能
	* 新定义了abort和Undefined两种异常及相应的工作模式
	* 将乘法和乘加运算指令扩展为32位
		* 长乘法运算：32位×32位＝64位
		* 长乘加运算：32位×32位+32位＝64位

##### (4) V4版（分为ARMv4 和ARMv4T 两种）

* 基于ARMv4的处理器主要是ARM8和StrongARM
* ARMv4T版本——ARM体系架构的一个里程碑
	* 引入16位Thumb指令集ARM指令集中常用指令经重新编码压缩后的子集
	* 执行时被实时且透明地解压，仍然是32位指令
	* 具有ARM指令集的大部分功能但不如ARM指令集全面，实现某些复杂操作可能需要使用较多的Thumb指令
	* 可提高代码密度，减少存储开销；在数据总线位宽为16位或8位的SOC系统中，可获得更优的性能
	* 新增Thumb状态，与ARM状态可通过指令随意切换
* v4T版在v3版的基础上所做的完善和扩展：
	* 微架构开始采用流水线方式
	* 增加了系统（System）模式，在该模式下可以使用用户模式寄存器运行具有特权级的系统管理任务
	* 对软件中断指令SWI的功能做了完善
	* 增加了无符号字节以及半字数据的加载/存储指令，如LDRB/STRB（字节）、LDRH/STRH（半字）
	* 增加了有符号字节及半字的加载指令LDRSB/LDRSH
	* 把没有使用的指令空间都作为“未定义指令”，并在UND异常中对其进行处理
* ARM7T和ARM9T产品系列都基于v4T版

##### (5) V5版（分为ARMv5TE和ARMv5TEJ两种）

* 微架构方面
	* 增加了DSP，MCU和DSP可以合二为一
	* 可选配矢量浮点处理器（Vector Float Processor，VFP）
	* 增加JazelleDBX (DirectBytecode eXecution) 的Java硬件加速器（ARMv5TEJ），可直接运行Java虚拟机字节码程序
	* 带有AHB或者AHB Lite总线接口
	* 引入（包括指令和数据）TCM或者TCM接口
	* v5版名称后缀中的字母T、E和J分别表示支持Thumb指令、增强的DSP指令和Java硬件加速技术
* ISA方面的改进和完善
	* 增加了DSP指令，为协处理器提供了更多可选择的指令
	* 更加严格定义了乘法指令对条件标志位的影响
	* 增加了支持有符号数的加减饱和运算指令（饱和运算是指出现溢出时，结果等于最大或者最小可表示范围）
	* BLX指令，将可返回的转移指令与状态切换合二为一
	* CLZ指令，计算寄存器操作数最高位0（前导0）的个数，可提高归一化运算、浮点运算以及整数除法运算的性能，也使中断优先级排队操作更为有效
	* BRK指令，软件断点指令
* 基于ARMv5版架构的ARM处理器包含ARM7EJ、ARM9E和ARM10E三个系列产品

##### (6) V6架构（ARM11系列以及Cortex-M0/M0+/M1处理器）

* 发布于2001年，ARM体系结构又一个重要里程碑
* 支持ARMv5TEJ所有指令，在多媒体处理、存储器管理、多处理器支持和异常响应等方面引入许多新技术
* 微架构实现：流水线级数增至8或9级（v6T2），采用动态和静态组合的转移预测方式，准确率可达85%
* 内核与Cache以及与协处理器之间的数据通路为64位，每个流水线周期可读入2条指令或存放2个连续字数据
* 增加了增强型的数字信号处理器以及用于功耗管理的IEM（Intelligent Energy Management）部件，在性能和功耗两个方面又有新的突破
* 在ISA方面，ARMv6版架构增加了以下功能和指令：
	* Thumb-2指令集（v6T2增强版），可以混合执行AMR指令和Thumb指令，兼具两者的优点，可认为是v6版大的进步
	* 新增SIMD指令，使多媒体信号（如左右声道、三基色像素）的处理能力提高了2~4倍
	* 支持混合大小端（Mixed-endian）和非对准（Unaligned）存储访问
	* 采用了名为TrustZone安全解决方案，在硬件层面划分可信区域和不可信区域，分别运行经认证的代码和未经认证的代码，不同代码具有不同的访问权限

##### (7) V7版

* 发布于2004年，ARM体系结构的分水岭
	* 全面支持Thumb-2技术。Thumb-2指令集包括了16位和32位指令，较先前的ARM指令集减少了31％的内存使用量，较原有的Thumb指令集提升了38％性能，并且无需在ARM指令集和Thumb指令集之间来回切换
	* 引入名为NEON的多媒体处理引擎，支持128 位SIMD扩展，性能提升了4倍，以迎合3D图形与手游应用
	* 在处理器的工作状态与操作模式、寄存器组织、异常和中断管理、对操作系统的支持等方面有许多变化，与以往版本有较大的区别，同时也兼顾了与经典ARM处理器软件保存较好的兼容

* 从v1到v7，ARM指令集经历了从单一的32位ARM指令集，到ARM指令集+16位Thumb指令集，再到ARM指令集+ 16位和32位混合的Thumb-2指令集，呈现逐步完善的过程

<img src="/assets/images/ARM处理器体系结构.assets/image-20200409205719792.png" alt="image-20200409205719792" style="zoom:67%;" />

* 从ARMv7版本架构开始，体系结构划分为三种类型（architecture profile）* 
	* 类型A（Application-profile），ARMv7-A版本
	* 类型R（Real Time-profile），ARMv7-R版本
	* 类型M（Microcontroller-profile）ARMv7-M版本

* 按照三种profile，将处理器产品划分为三条产品线
	* 基于ARMv7-A版本：Cortex-A产品线，高性能
	* 基于ARMv7-R版本：Cortex-R产品线，实时处理
	* 基于ARMv7-M版本：Cortex-M产品线，MCU

##### (8) V8版

* 首款支持64位指令集的处理器架构
	* 新增加64位指令集，称作A64，并继续支持原有的ARM指令集和Thumb-2指令集，但是改称为A32和T32指令集
	* 新定义AArch64和AArch32两种运行状态，分别执行64位和32位指令集
	* 在ARMv7安全扩展的基础上，新增加了安全模式，支持与安全相关的应用需求
	* 在ARMv7虚拟化扩展的基础上，提供完整的虚拟化框架，在硬件层面上提供对虚拟化的支持
	* AArch64对异常等级赋予新的内涵，并重新解释处理器运行模式和特权等级概念
* 继续分为ARMv8-A、ARMv8-R和ARMv8-M三种类型
	* v8-A：支持AArch64和AArch32两种运行状态，两种运行状态之间进行切换。除了智能手机和平板电脑传统应用领域之外，开始向通用计算应用领域拓展
	* v8-R：具有快速中断响应能力和确定的中断响应时延，采用容错设计和MPU，支持A32和T32指令集，应用领域均为对实时性和可靠性有着极高的要求的场合
	* v8-M：使用与其他类型不同的异常处理模型，并且只支持T32指令集。主要面向低成本、小体积、低功耗、低中断延迟以及高性能的嵌入式应用
	* 基于上述三种体系结构类型的处理器产品，仍然分为Cortex-A、Cortex-R和Cortex-M三个系列
* 每个基础版还有增强版，支持的指令有区别。在v7版之前，增强版用版本号的字母后缀表示，如：
	* T增强版：表示该版本支持Thumb指令集
	* E增强版：支持增强的DSP算法
	* J增强版：支持Java加速
	* S增强版：提供用于多媒体信号处理的SIMD指令
	* F增强版：支持矢量浮点处理单元
	* V6版还有：
		* T2增强版：支持Thumb-2指令集
		* Z增强版：支持TrustZone安全增强
		* K增强版：支持多核
		* M增强版：超低功耗，用于Cortex-M0/M0+/M1
	* v7版本之后，不再使用

#### 5、ARM处理器相关产品的层次关系

* 从内到外分为：ARM内核、ARM处理器、MCU或者SOC、以及嵌入式系统四个层级

![image-20200409211748721](/assets/images/ARM处理器体系结构.assets/image-20200409211748721.png)

##### (1) ARM内核

* 必备部件
	* CPU，v4T之后均采用流水线技术+转移预测
	* 总线互连矩阵，提供多种数据的并行传送能力
	* 中断管理部件，提供周期确定的低时延中断响应
	* 系统定时器，多任务操作系统必不可少的部件

* 可选部件
	* 指令和数据Cache或TCM
	* MMU或者MPU
	* 数据/指令跟踪单元
	* 浮点单元、Java硬件加速器、多媒体处理部件

##### (2) ARM处理器

* ARM内核的基础上，通过系统总线连接了：
	* 指令存储器，一般是flash
	* 数据存储器，一般是SRAM
	* 协处理器或者协处理器接口部件
	* 扩展RAM控制器，扩展存储器不能与系统总线直接相连，必须通过存储器扩展接口
	* 外设总线桥接器
	* 部分调试跟踪组件
* 通过外设总线连接
	* 调试访问接口
	* 内核私有外设

##### (3) MCU和SOC

<img src="/assets/images/ARM处理器体系结构.assets/image-20200409212344327.png" alt="image-20200409212344327" style="zoom:67%;" />

* 以ARM处理器为核心，增加了
	* 扩展存储器
	* DMAC
	* ADC、DAC
	* 脉宽调制PWM
	* 实时时钟RTC
	* 电源监测BOD
	* 串行接口UART
	* ……

#### 6、ARM处理器产品命名规则

* 体系结构版本与处理器采用两种标识方式，对应关系开始变得较为复杂

* 常见以及仍在使用的产品与ISA的对应关系：

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200409212611977.png" alt="image-20200409212611977" style="zoom: 50%;" />

* V7版之前的产品命名规则
	* 处理器名称后缀中的英文字母含义
		* T、E、J、S、F、T2、Z和K等字母表示所基于体系结构增强版本
		* 基于v4T的产品（如ARM7TDMI ）中还出现过D、M和I，分别表示带有Debug调试接口、硬件乘法器和嵌入式ICE，后来成为标准配置，不再另外表示
	* 第一个数字的舍义
		* 表示产品系列，如ARM7TDMI和ARM920T分别对应ARM7系列和ARM9系列
			* ARM10和ARM11产品系列中，10和11各占两位数字
	* 第二个数字的含义
		* 2：表示带有MMU，如ARM720T和ARM920T
		* 3：改良型MMU
		* 4：表示带有MPU，如ARM946ES
		* 6：无MMU和MPU，如ARM966E-S和ARM968EJ-S
			* ARM1156T2(F)-S中的“5”表示可选指令和数据MPU
			* ARM1176JZ(F)-S中的“7”表示增加了IEM能源管理组件
	* 第三个数字的含义
		* 0：表示标准容量Cache
		* 2：表示减小容量的Cache
		* 6：表示带有紧耦合内存TCM5）
	* 名称最后的“-S”表示软核（HDL描述的产品）

### (三) ARM处理器产品系列简介

#### 1、ARM7系列

* 分为ARM7（基于v3）和ARM7T（基于v4）两个子系列，获得广泛应用的是ARM7T 
	* ARM7T系列基本型产品是ARM7TDMI（-S），同系列其他产品都是在其基础上增加了Cache、MMU或者MPU、以及ASB总线接口
	* MMU和MPU都是用于内存管理，两者的功能和主要区别如下：
		* MMU：内存分页管理+虚拟地址VA到物理地址PA的转换+分区域访问权限管理，适用于多用户系统
		* MPU：内存分区域访问权限管理，适用于要求对处理时间有明确要求的实时系统。

#### 2、ARM9系列

* 分为ARM9T和ARM9E两个子系列
	* ARM9T基于v4T版本架构（与ARM7T相同），但是微架构有不一样，采用的是哈佛结构，流水线为5级
	* ARM9E采用的也是哈佛结构，分为v5TE和v5TEJ两个子版本，从版本号后缀可以看出：
		* T：支持Thumb指令
		* E：支持增强的DSP指令
		* J：支持Java硬件加速
	* 从ARM9E开始增加TCM，性能与Cache相当，可以对TCM进行寻址访问

#### 3、ARM11系列

* ISA大版本都是v6，有四款处理器产品（全是软核），每款处理器的ISA小版本各不相同
	* ARM1136J(F)-S，基于ARMv6版本，主要特性：
		* SIMD、Thumb、Jazelle、MMU以及可选配的VFP
	* ARM1156T2(F)-S，基于ARMv6T2版本，主要特性：
		* Thumb-2指令集、SIMD、可选配MPU以及VFP，主要应用在高可靠性和实时嵌入式应用领域
	* ARM1176JZ(F)-S，基于ARMv6Z版本，主要特性：
		* 在ARM1136J(F) -S基础上增加了TrustZone和IEM部件
	* ARM11MPCore，主要特性：
		* 可配置1~4颗ARM1136J(F)-S的SMP处理器，后期的升级产品为基于ARMv7A系列的Cortex-A5处理器

* ARM 11流水线仍属于单发射标量流水线，但是：

	* 流水线的后几级，算逻单元ALU、乘积累加单元MAC和数据加载/存储单元LSU采用并行部署，属于一种分叉或者分支结构的流水线
	* 当指令完成译码和取操作数之后，不同类型的任务被分发到不同的流水线分支上执行，每一级操作更加简单，执行速度更快，可以减少流水线周期，从而可提高流水线时钟频率
	* ARM11的工作时钟频率在500MHZ以上，最高可达到1GHz，取决于不同的工艺制程，尺寸越小速度越快

* 设计理念：在性能、功耗、芯片面积和成本之间进行均衡，支持休眠模式、待机模式和关机模式

* ARM 11流水线结构：

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200414103647715.png" alt="image-20200414103647715" style="zoom:50%;" />

#### 4、Cortex-A系列

* Cortex-A系列处理器应用场景：

	* 移动计算、智能手机、平板电脑、数字电视、企业网络、通用计算和服务器

* 主要特性：

	* 支持可伸缩（Scalable）的异构或者同构多核的高性能处理器，内置VFP和NEON（DSP+SIMD），支持浮点运算和SIMD多媒体数据处理，时钟频率超过1 GHz，支持Linux、安卓和微软视窗操作系统

* 产品：从A5~A77共计20款，其中A5~A17为基于v7-A版本的32位处理器；A32虽然基于v8-A，但只有AArch32运行状态；A34以后产品基于64位v8-A版本结构，同时支持AArch32和AArch64两种运行模式

* big.LITTLE(bL) 技术

	* 允许拥有两种不同类型的内核，相同类型的内核组成一个簇（cluster），轻负载时运行低功耗内核，高负载时运行高性能内核，在性能和节能之间寻求平衡
	* 采用bL结构的SOC芯片案例：
		* 华为海思麒麟950：4*A72+4*A53+GPU+ISP+Modem+DSP
		* 华为海思麒麟960：4*A73+4*A53+GPU+ISP+Modem+DSP

	![image-20200414103900546](/assets/images/ARM处理器体系结构.assets/image-20200414103900546.png)

* DynamIQ大小核技术

	* bL技术升级版，允许最多8个内核构成一个簇，单个处理器最多可实现32个簇和256个内核
	* Cortex-A55（2017年），第一款采用DynamIQ技术的小核，基于ARMv8.2架构，“具有深远影响的产品”
		* 利用神经网络算法提高转移预测准确性
		* 对NEON、VFP和缓存结构做了改进，低功耗设计
	* 可作为高性能低功耗的64位处理器单独使用，应用于数字电视、VR和AR
	* 但A55的设计目标是作为DynamIQ结构中的小核，目前许多高端手机处理器中，有些虽然采用了自研的大核，但小核几乎都毫无例外地选用了A55

* A76（2018年）和A77（2019年），基于DynamIQ技术的“大核”，设计目标是利用DynamIQ技术与更多的同构或者异构内核集成，提供更强大的计算能力和实现更高效的能源利用效率

	* A76：使用了可以乱序执行的超标量结构，拥有4个解码发射单元和8条并行流水线，流水线级数为13级。采用7nm制程工艺时，峰值时钟频率可达3GHz
	* A77：基本配置与A76基本相同。但在微体系结构做了许多改进，例如采用更大带宽的前端（取指+译码+转移预测+发射）、新的指令缓存技术、新的整数ALU单元和改进的加载/存储队列，在相同制程工艺和时钟频率条件下，A77的IPC比A76提高了20%，可以看作是A76的改良版

* A76应用举例：华为海思麒麟980/990手机处理器

	* A76+A55，基于DynamIQ技术的异构多核架构
	* CPU：两种内核，三种频率，兼顾性能与续航时间

	![image-20200414104140077](/assets/images/ARM处理器体系结构.assets/image-20200414104140077.png)

#### 5、Cortex-R系列

* 聚焦于高性能实时应用，设计目标包括：高性能、低延时、高可靠、可信赖、安全性和容错性，以确保嵌入式系统的时间确定性和行为确定性
	* 时间确定性：有硬性的处理截止时间（Deadline）要求，必须在规定的时间内完成规定的操作
	* 行为确定性：绝不允许出现因处理器或数据错误而导致的误操作。为此，软硬件必须具备一定的容错能力
* Cortex-R应用领域：
	* 手机基带调制解调器、硬盘驱动器、企业级网络设备、汽车电子、医疗设备和工业控制装置等，而后面几种应用对安全稳健（Safety-Critical）有极高要求
* 目前Cortex-R系列处理器共有5款：
	* 基于v7-R版本架构的R4、R5、R7和R8
	* 基于v8-R版本架构的R52，但只能运行AArch32状态
	* 都支持A32和T32指令集，可以实现二进制代码兼容
* 容错设计：多处理器锁步（lock-step）技术
	* 双处理器锁步：主处理器和监控处理器在时间上严格同步地执行相同的指令。主处理器承担系统处理任务并负责驱动输出，监控处理器连续监控主处理器总线上的数据、地址和状态等信息
	* 如果发现两个处理器不一致，则说明某个处理器出现了差错，本次计算结果不输出，实现故障静默
	* 但是，双处理器锁步无法实现故障恢复
* 多处理器锁步：单颗处理器出现故障时，可通过硬件表决方式判断出现故障的处理器并将其屏蔽，由其他处理器负责任务执行，可实现故障的实时恢复
* 所有Cortex-R处理器都支持锁步技术
	* R4是单内核处理器，锁步配置需要使用两颗独立的R4
	* R5升级为一主一备的异构双核，单处理器就可实现能够独立运行的锁步双核
	* R7在异构双核中增加了QoS（服务质量保证），另外增加一对同构双核，以提高处理器的性能
	* R8和R52中可锁步配置的内核数增至3颗或者4颗，可实现故障恢复，同时也增加了同构内核的数量
* 数据纠错/检错：ECC和奇偶校验
	* 奇偶校验：每个数据（字节或半字或字）后面增加一位，使“1”或“0”的总数为奇数或偶数。若错码位数为奇数则可被发现，但是只能检错，无法纠错
	* ECC：存储数据时，利用编码算法在每个数据后面增加若干冗余位，读出时对其进行检查，不仅可以检错还可以纠错，纠错/检错能力与冗余位长度有关
* R系列处理器的Cache或TCM都支持ECC和或奇偶校验，可实现2bit的检错和1bit的纠错
* 除R4外，R5~R52还支持对总线接口的ECC纠错和检错，R52增加了对互连交叉总线的错误防护功能
* 为满足实时性要求，Cortex-R处理器都采用指令和数据分离的哈佛结构，都带有指令和数据Cache、TCM存储器、硬件除法器、双精度FPU、MPU、内存和中断控制器，此外：
	* R4\~R8处理器配置了SIMD单元和DSP
	* R52处理器增加了NEON引擎
	* R5~R52配置了低时延外设接口（Low Latency Peripheral Port ，LLPP），可实现快速外设读取和写入
* 面向实时应用的处理器一般不采用虚拟地址，R系列处理器都没有配置MMU，但是都带有MPU
* ISR一般都存在私有TCM中，以减少中断响应延迟

#### 6、Cortex-M系列

* 面向低成本、低功耗和高性能应用领域，虽然在性能、可靠性和实时性方面不如Cortex-A和Cortex-R系列，但目前是ARM公司销售量最大的产品

* 2019年第4季度ARM处理器的总出货量为64亿片，其中有42亿片属于Cortex-M系列，占比达66%

* Cortex-M系列第一款产品是基于v7-M版本架构的Cortex-M3（2005年）。为减小功耗，流水线只有三级（取指、译码、执行），但带有NVIC、硬件除法器、支持Thumb-2指令集、丰富的调试和跟踪功能

* 2010年发布的Cortex-M4与Cortex-M3基本相似，但增加了DSP，并且可选配FPU

* v7-M出现3年后，ARM继续推出v6-M架构，相关产品有Cortex-M1（面向FPGA设计）、M0和M0+，目标市场是低功耗、小体积和高性价比应用，例如：

	* M0/M0+采用冯.诺依曼结构，3级流水线，带有NVIC、硬件乘法器、能源管理部件和AHB Lite总线接口，可选配WIC，功耗仅为5.3 μW(M0)和3.8μW(M0+)/MHz @1.1v/25°C，属于极低功耗处理器

	![image-20200414105112805](/assets/images/ARM处理器体系结构.assets/image-20200414105112805.png)

* Cortex-M7（2014年9月），基于v7-M，6级流水线，带有双精度浮点单元、可选Cache或者TCM，以迎合高端微控制器和密集型数据处理的需求

* 基于v8-M的M系列处理器：M23、M33和M35P，支持新的增强指令集，增加了TrustZone安全扩展
	* M23具有与M0类似的低成本和小体积特点
	* M33与M3和M4类似，但系统设计更灵活，能效比更高
	* M35P产品型号中的“P”表示具有物理（Physical）防篡改（tamper-resistant）功能，包含了多项防范物理攻击的安全特性

	* 面向未来的物联网中的高端应用，2020年2月10日，ARM公司正式发布了基于ARMv8.1-M版本架构的Cortex-M55处理器（预计2021年才有产品问世），可看作Cortex-M33的下一代产品
	* M55首次使用了基于MVE（M-Profile Vector Extension，矢量扩展）技术的Helium引擎，将执行SIMD指令和DSP处理能力提升了5倍，机器学习能力提升了15倍
	* 同时，ARM还发布了一款与Cortex-M55配套使用的嵌入式NPU，Ethos-U55（此前已有Ethos-N37、N57和N77），Ethos-U55是专为下一代Cortex-M处理器定制的，具有低功耗和低成本的特性
	* M55+U55，未来物联网应用领域的利器

## 二、Cortex-M3/M4处理器结构

### (一) Cortex-M3/M4概述及指令集架构

#### 1、Cortex-M3/M4主要特性

* 基于v7M版本架构，三级流水线（取指、译码和执行），哈佛结构。主要特性如下：
	* 32位处理器，可以处理8位、16位和32位数据；
	* 本身不包含存储器，但提供了连接不同存储器的总线接口；
	* 多种总线接口，可分别连接存储器、外设以及调试接口；
	* 紧耦合的NVIC，能以确定的周期快速响应中断；
	* 丰富的调试和跟踪组件以及外部调试接口；
	* 可选配MPU，实现内存的分区保护；
	* 低功耗，低成本，具有丰富的开发调试工具；
	* 但是，作为低成本低功耗处理器，没有Cache或TCM，没有协处理器以及接口，也不支持虚拟地址（没有MMU）
* 带有系统节拍定时器Systick，可为操作系统所需的定时提供周期性的定时中断
* 双堆栈指针，操作系统和应用任务使用不同的堆栈
	* 主栈指针MSP，供操作系统和中断处理使用
	* 进程栈指针PSP，用户程序使用
	* 对于不使用操作系统的简单应用，可以只使用MSP
* 特权和非特权访问等级
	* 限制非特权等级访问某些寄存器，提高系统安全性
	* 与MPU配合，限制非特权访问某些内存区域，防止破坏操作系统或者其他任务数据；即使用户程序出现问题，不会对其他任务带来影响，提高系统的健壮性
* Cortex-M4可以选配单精度FPU，其功能主要包括：
	* 提供多条浮点运算指令，以及多条浮点数据转换指令
	* 支持融合MAC运算，以提高MAC结果的精度
	* 若不需要浮点单元，可以将其关闭从而降低功耗
* Cortex-M4指令集增加了DSP扩展，例如：
	* 8位和16位SIMD指令，允许对多个数据同时进行并行操作，包括寄存器的高低16位多种组合乘法
	* 支持多个饱和运算指令，包括SIMD运算，避免在出现上溢出和下溢出时计算结果产生大的畸变
	* 单周期16位、双16位以及32位的乘累加（MAC）运算
* Cortex-M3也有几条MAC指令，但不是单周期的

#### 2、Cortex-M3/M4所支持的指令集

* Cortex-M4可看作Cortex-M3的增强版，两者都支持Thumb-2技术，但所支持的指令集有差异

![image-20200414110334295](/assets/images/ARM处理器体系结构.assets/image-20200414110334295.png)

![image-20200414112853371](/assets/images/ARM处理器体系结构.assets/image-20200414112853371.png)

### (二) Cortex-M3/M4处理器结构

![image-20200414112920878](/assets/images/ARM处理器体系结构.assets/image-20200414112920878.png)

* 按各部件作用以及与总线系统的连接关系，整个处理器系统可以分为内核、处理器和系统三个层级

**内核**

* 包括CPU、NVIC、Systick以及可选的指令跟踪接口
* Cortex-M4内核可选配FPU（产品型号为Cortex-M4F）

1. CPU

	* 32位微处理器，取指、译码和执行三级流水线
	* 哈佛结构，指令和数据两条总线
	* 三个关键部件：ALU、控制单元CU和寄存器阵列

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200414113041578.png" alt="image-20200414113041578" style="zoom:50%;" />

2. NVIC和Systick

	* 经典ARM处理器只有7种异常类型和6级优先级

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200414113135227.png" alt="image-20200414113135227" style="zoom:50%;" />

	* 若IRQ不止1个，经典ARM处理器需要另配VIC
	* Cortex-M系列处理器的异常/中断处理较经典ARM处理器有很大改进，内核集成了一个与CPU紧耦合的NVIC，可对大多数系统异常、所有外部中断（最多240个）以及一个NMI进行全面管理
	* 此外，内核还集成了一个简单的倒计时计数器Systick，负责产生类型号为15的系统定时异常（中断）

3. FPU

	* Cortex-M4可选配FPU，支持符合IEEE 754-2008标准的单精度浮点运算，该浮点单元主要特性包括：
		* 由32个32位寄存器组成的浮点寄存器组，可以单独用作32个寄存器，也可以被成对用作16个双字寄存器
		* 支持的转换指令包括“整数↔单精度浮点”、“定点↔单精度浮点”、“半精度↔单精度浮点”
		* 浮点寄存器组和存储器之间的单精度和双字数据的传输
		* 浮点寄存器组和整数寄存器组之间的单精度数据的传输
	* 但是，Cortex-M4的FPU不支持双精度浮点运算、浮点余数以及二进制与十进制之间的转换，如若需要只能另外编写程序实现
	* Cortex-M4的浮点运算指令的助记符都是以v开头
	* FPU一般位于处理器内核与协处理器之间，带有状态控制寄存器，用以标明FPU当前运行状态，并可通过编程对其进行控制
	* 为了与其他协处理器的管控方式一致，FPU被看作协处理器，并通过协处理器访问控制寄存器CPACR（Co-processor Access Control Register）对其进行管理和控制
	* CPACR寄存器中CP10和CP11两位负责对FPU进行管理，所以有时也将FPU看作协处理器CP10和CP11
	* 通过对CPACR寄存器中CP10和CP11两位的置位或者复位操作，可以使能或禁用FPU
	* 经典ARM处理器有单独的特殊寄存器访问指令MCR和MRC，实现对协处理器的操作控制和数据交换
	* 与经典ARM处理器不同，Cortex-M4拥有专门的浮点运算和数据传送指令，实现浮点的读取、运算和写回
	* 在Cortex-M4的三级流水线中，FPU和CPU共用取指阶段，在译码和执行阶段则二者并行执行

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200414113420125.png" alt="image-20200414113420125" style="zoom:50%;" />

**处理器**

1. 总线交换矩阵（Bus Matrix）

	* 基于AHB总线协议的交换网络
	* 通过总线矩阵，Cortex-M3/M4面向各种存储器、片上和片外不同类型的设备、以及调试组件提供了多条总线，可以让数据和指令在不同的总线上并行传送（只要不是访问同一个器件）
	* Cortex-M3/M4的总线矩阵还包含一个写缓冲区，可以加快存储器写操作的速度
	* Cortex-M3/M4处理器的系统总线基于AHB-Lite总线协议，总线上只有一个主设备，无需使用总线仲裁

2. MPU

	* Cortex-M3/M4都可以选配
	* 通过MPU可以把存储空间划分为最多8个Regina（区域），但是区域之间可以重叠
	* 各个区域的存储特性和访问权限可以通过编程定义
	* 如果使用了嵌入式操作系统，MPU由操作系统管理，给每个任务分配不同的存储区域以及访问权限，防止某个应用任务对操作系统或者其他任务的数据造成破坏
	* 在没有操作系统的简单应用中，也可以通过MPU设定需要保护的存储区域和访问权限。例如，把某些存储空间设置为只读属性或只有特权用户才能访问，以提高系统的安全性和可靠性

3. 处理器系统

	* 在处理器基础上，再选配唤醒中断控制器WIC以及若干调试组件之后，就构成Cortex-M3/M4处理器系统

	1. **WIC**

		* 为了减少功耗，Cortex-M处理器引入“睡眠”和“深度睡眠”两种模式

			* 处于睡眠模式时，关闭大部分模块/部件的时钟
			* 在深度睡眠模式时，系统时钟和Systick也被关闭
			* 有些产品还采用了SRPG（State Retention Power Gating）电路。深度睡眠模式时包括内核和NVIC在内大部分电路都处于掉电状态，以进一步减少功率消耗

		* 不同工作状态下的电流消耗

			![image-20200414113807017](/assets/images/ARM处理器体系结构.assets/image-20200414113807017.png)

		* 为使处理器在时钟不可用和掉电状态下也能“醒来”，从Cortex-M3版本r2p0引入了WIC特性

		* WIC的电路非常小巧，通过专有接口与NVIC以及电源管理单元PMU（Power Management Unit）相连

		* 只有在处理器处于深度睡眠模式时，WIC才会使能，此时，如果出现NMI或者未被屏蔽的IRQ时，WIC触发PMU单元，将整个系统唤醒

		![image-20200414113840994](/assets/images/ARM处理器体系结构.assets/image-20200414113840994.png)

	2. 调试组件

		* 经典ARM处理器也有多种调试组件，大都带有JTAG接口，并通过JTAG接口实现对寄存器和存储器的访问
		* 从v7开始，ARM处理器采用了一种命名为CoreSight全新的调试架构。CoreSight调试架构涵盖了调试接口协议、调试总线协议、调试部件控制、安全特性以及跟踪接口等
		* 在Cortex-M3/M4处理器中，调试过程是由NVIC和若干调试组件协作完成的。NVIC中有一些用于调试的寄存器，通过这些寄存器对处理器的调试动作进行控制，如停机（halting）和单步执行（stepping）等
		* Cortex-M3/M4可以选配多种调试组件，这些调试组件提供了指令断点、数据观察点、寄存器和存储器访问、性能分析（profiling）以及各种跟踪机制，如：
			* ETM：嵌入式跟踪宏单元
			* ITM：指令跟踪宏单元
			* DWT：数据观察点和跟踪单元
			* FPB：Flash地址重载和断点单元
			* TPIU：跟踪端口接口单元
			* ROM表：类似于调试组件的“注册表”
		* Cortex-M3/M4处理器中的调试组件

		![image-20200414114224571](/assets/images/ARM处理器体系结构.assets/image-20200414114224571.png)

		* 调试（Debug）：是指通过调试接口读取或修改处理器内部的寄存器或存储器的内容，或者发布一些调试命令，让处理器执行某些调试动作，如暂停、单步执行或者断点执行等
		* 跟踪（Trace）：是指在程序运行期间，无需停止处理器正常的指令执行流程，由相关的跟踪组件实时收集处理器在指令执行过程中产生的各种运行信息，并通过跟踪接口实时输出到外部调试主机中，再由调试分析软件（如Keil）对这些信息进行分析
		* 在CoreSight的调试架构中，ETM、DWT和ITM等调试组件都属于跟踪数据源（Trace Source），负责收集处理器运行过程中产生的各种调试信息
		* TPIU属于调试信号汇集点部件，负责将汇集的调试信息进行格式转换和打包之后，再通过跟踪端口输出到外部的调试主机（PC机）
		* Cortex-M3/M4处理器中的调试信息流向图：

		![image-20200414114317928](/assets/images/ARM处理器体系结构.assets/image-20200414114317928.png)

		* DAP（Debug Access Port）
			* 在CoreSight调试架构中，定义了处理器内部的调试访问接口AP与外部调试端口DP。AP接收来自DP的调试命令，并将这些命令转换成对处理器内部各寄存器和存储单元的访问。DP和AP合称为调试访问端口

		![image-20200414114401092](/assets/images/ARM处理器体系结构.assets/image-20200414114401092.png)

		* SWJ-DP和SW-DP
			* SWJ-DP（Serial Wire JTAG DP）：基于JTAG协议的串行调试接口，有4条线
			* SW-DP（Serial Wire DP）：CoreSight调试架构新增加的串行接口，只有2条线
			* Cortex-M3/M4支持以上两种调试接口，芯片制造商可以根据需要选择其中的一种或者两种

		![image-20200414114440031](/assets/images/ARM处理器体系结构.assets/image-20200414114440031.png)

### (三) 存储器管理

* Cortex-M3/M4没有Cache或者TCM，而是通过多条总线连接片上各种不同类型和容量的存储器件
* 如果需要进一步扩展存储容量，还可以通过存储器接口控制器，连接片外大容量存储器

#### 1、存储器管理特性

* 4GB线性地址空间，可通过存储器接口控制器连接32位、16位和8位的存储器件
* 定义了明确的存储器映射关系，4GB存储空间被划分为多个区域，分别用于不同的存储器和外设
* 支持小端和大端，但芯片制造商只能选择一种类型
* 可选位带（Bit-Band Operations）操作，也称为位段或者位域操作
	* 传统处理器中，如需修改某个存储单元或寄存器的一个bit位，而不影响其他位，需要读出、修改和写入三个步骤
	* 位带操作：在某个区域内，每个bit位可以使用地址直接对其进行操作。但是具体MCU或者SOC芯片是否带有位带操作特性由芯片制造商决定
* 内置写缓冲，可以提高程序的执行速度
* 可选MPU，支持8个可编程区域，可提高系统健壮性
* 所有基于ARNv7M的Cortex-M系列处理器都支持非对准传送，但是非对准传送将增加总线传送次数

#### 2、存储器映射

* 所有基于ARMv7M的Cortex-M系列处理器，都采用相同的存储器映射关系方式（存储区域划分）

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200420144618340.png" alt="image-20200420144618340" style="zoom:50%;" />

* 4GB的地址空间分成以下几个区域

	* CODE区

		* 只能被I-Code和D-Code总线访问，为使两条总线能够同时访问，CODE区可使用两个独立的存储器

		* 最低端部分使用flash器件，用于存储程序代码

		* 另外一部分使用SRAM，存储重要数据I-Code和D-Code对CODE区的所有空间都能访问

		* 只要不是同时访问同一个存储器，两条总线上可以同时传输数据

		* 但是，为了降低成本，许多SOC芯片并没有在CODE区部署SRAM

			<img src="/assets/images/ARM处理器体系结构.assets/image-20200420144927407.png" alt="image-20200420144927407" style="zoom:50%;" />

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200420144858791.png" alt="image-20200420144858791" style="zoom:50%;" />

	* SRAM区

		* 片上主存储区，存放数据
		* 由AHB-Lite系统总线管理
		* 许多芯片制造商只使用SRAM区存放数据

		<img src="/assets/images/ARM处理器体系结构.assets/image-20200420145013607.png" alt="image-20200420145013607" style="zoom:50%;" />

	* 外设区

		* 片上外设连接到系统总线上

			<img src="/assets/images/ARM处理器体系结构.assets/image-20200420145118120.png" alt="image-20200420145118120" style="zoom:50%;" />

		* 片外外设与APB总线相连，APB与AHB之间有一个总线桥

			<img src="/assets/images/ARM处理器体系结构.assets/image-20200420145133596.png" alt="image-20200420145133596" style="zoom:50%;" />

	* 外部RAM区：通过RAM控制器连接片外扩展RAM，可使用的RAM类型取决于RAM控制器

		<img src="/assets/images/ARM处理器体系结构.assets/image-20200420145204985.png" alt="image-20200420145204985" style="zoom:50%;" />

	* 内核私有区域，分为三个部分：

		* 内部私有外设，包括调试组件ITM、DWT和FPB，以及系统控制区SCS
		* 外部私有外设，包括调试组件ETM、TPIU和ROM表，以及外部PPB总线
		* 芯片厂商定义的存储区

		<img src="/assets/images/ARM处理器体系结构.assets/image-20200420155202963.png" alt="image-20200420155202963" style="zoom: 67%;" />

	* 系统控制空间SCS（System Control Space）

		* 位于内核私有区域，0xE000 E000~0xE000 EFFF，64KB
		* 该区域集中了NVIC、Systick、FPU和MPU等在内的各种系统部件的寄存器组，只有特权访问等级才能访问

	* Cortex M系列处理器采用这种统一的地址映射方案，有助于提高设备之间的软件可移植性和代码可重用性

	* 虽然有明确的存储区域划分，但仍具灵活性，例如：

		* 程序代码既可以存放CODE区域，也可以存放在AHB总线所连接的SRAM中，但影响指令执行性能
		* 芯片制造商也可以在CODE区域使用SRAM存储器

### (四) 总线系统

* Cortex-M3/M4总线结构（虚框维可选部件）

<img src="/assets/images/ARM处理器体系结构.assets/image-20200420155404443.png" alt="image-20200420155404443" style="zoom:50%;" />

#### 1、总线系统结构

* 核心：基于AHB总线协议的内部总线互连矩阵。其所连接的各类总线的作用以及主要特性简介如下

	* I-Code总线，基于AHB-Lite总线协议的32位总线，负责在0x0000 0000~0x1FFF FFFF之间的取指操作。取指是以字为单位，对于16位的Thumb指令，一次取指操作可以取出两条指令
	* D-Code总线，与I-Code基本相同，但只负责数据读写
	* I-Code总线与D-Code在物理上彼此独立，但两者之间有一个仲裁器，当I-Code和D-Code同时访问同一区域时，D-CODE优先

* AHB，基于AHB-Lite规范的32位系统总线

	* 访问区域：

		* 0x2000 0000~0xDFFF FFFF
		* 0xE0100000~0xFFFF FFFF

	* 包括：

		* SRAM区
		* 片上外设
		* 外部RAM
		* 片外设备
		* 芯片厂商定义的区域

		<img src="/assets/images/ARM处理器体系结构.assets/image-20200420155630872.png" alt="image-20200420155630872" style="zoom:50%;" />

* APB/PBB，32位APB总线

	* 访问区域

		* 外部私有外设子区域0xE0040000~0xE00F FFFF
		* 但在外部私有外设子区域中，有一部分空间已被ETM、TPIU和ROM表等调试组件所占用，只有0xE004 2000 ~0xE00F EFFF之间可用于连接外部私有设备
		* 由于内核私有区域需要特权访问权限，该总线一般是专门用于连接调试组件，不用于普通的外设，否则将会出现因特权管理导致的各种错误

		<img src="/assets/images/ARM处理器体系结构.assets/image-20200420155742353.png" alt="image-20200420155742353" style="zoom:50%;" />

* 四条总线各自管理的区域

	* 注意：CPU通过内部总线互连矩阵直接访问内核私有外设，不经过四条总线

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200420155842731.png" alt="image-20200420155842731" style="zoom:50%;" />

* 调试访问端口（DAP）

	* 基于“增强型APB”总线规范的32位总线

	* 主要用于连接处理器内部的调试访问接口AP与外部调试端口DP，如SWJ-DP和SW-DP

		<img src="/assets/images/ARM处理器体系结构.assets/image-20200420155950172.png" alt="image-20200420155950172" style="zoom:67%;" />

#### 2、各类总线的连接对象

<img src="/assets/images/ARM处理器体系结构.assets/image-20200420160535531.png" alt="image-20200420160535531" style="zoom:50%;" />

* 需要指出的是：
	* AHB总线互联矩阵属于处理器内核设备
	* CODE区的总线矩阵或者总线复用器是ARM公司提供的两种不同的选件，其作用是让I-Code和D-Code都能够访问CODE区的flash和SRAM
		* 如果选用总线矩阵，I-Code对flash的取指操作与D-Code对SRAM的数据存取操作可以同时进行
		* 如果选用总线复用器，I-Code和D-Code对CODE区的访问只能分时进行，数据传送不再有具有并行性
		* 有些芯片CODE区没有配置SRAM，利用SRAM区存储数据，通过系统总线与I-Code总线的并行性传送数据，虽然浪费了一点存储空间，但可以降低成本
	* 片上SRAM也称为主SRAM，应该连接到系统总线上，使其位于SRAM区，以便可以使用位带操作
		* 说明：Cortex-M3/M4 在SRAM区和片上外设区的各有1个位带区和1个位带别名区，他们的位置都是固定的
		* 如果需要使用片外存储，必须使用片外RAM控制器作为接口，Cortex-M3/M4系统总线不能直接连接片外存储器
		* 图中总线矩阵或者总线复用器、片外RAM控制器、AHB到APB的总线桥、AHB-AP调试访问端口以及UART等各种外设接口都可以根据需要选配。除了ARM公司以外，还有其他IP供应商也能提供

### (五) 异常与中断处理

#### 1、嵌套向量中断控制器NVIC

* Cortex-M3/M4处理器集成了一个与CPU紧耦合的嵌套中断控制器NVIC总共可以管理：
	* 240个外部中断，从IRQ#0 到IRQ#239
	* 1个不可屏蔽中断NMI
	* 多个系统异常
	* NVIC是内核不可分割的一部分，可对240个外部中断以及大部分系统异常进行优先级设定、中断屏蔽、嵌套（抢占）管理、中断挂起（Pending）和解挂等事务进行全面并且细腻的集约化管理

#### 2、支持的异常与中断处理种类

<img src="/assets/images/ARM处理器体系结构.assets/image-20200420160949188.png" alt="image-20200420160949188" style="zoom: 67%;" />

#### 3、异常与中断处理

<img src="/assets/images/ARM处理器体系结构.assets/image-20200420161032920.png" alt="image-20200420161032920" style="zoom:50%;" />

* 注意：CMSIS的中断编号0对应的是IRQ#0，中断编号239对应的是IRQ#239；而编号为负数的-15到-1依次对应的是复位到SYSTICK等系统异常

	* CMSIS，（Cortex Microcontroller Software Interface Standard，微控制器软件接口标准），由ARM公司联合多家芯片和软件供应商合作定义，包含多个组件。其中，内核和设备访问库函数CMSIS-core提供了多种函数，可对CPU内部各种寄存器以及内核设备进行访问

* 配置了NVIC之后，Cortex-M3/M4具有以下异常处理特性：

	* 除了复位和NMI之外，所有异常都可以被屏蔽
	* 除了复位、NMI和硬件错误之外，所有异常都可单独使能或禁止
	* 除复位、NMI和硬件错误具有固定的（高）优先级之外，所有异常/中断都具有多达256级可编程优先级，以及最多128个可抢占（嵌套）优先级
	* 支持优先级的动态修改（Cortex-M0/M0+无此特性）
	* 向量中断方式，中断响应时自动从中断向量表中获取中断处理程序（ISR）入口地址
	* 向量表可以重定位在存储器中的其他区域
	* 低中断处理延迟，对于零等待的存储器系统，中断处理延迟仅为12个时钟周期
	* 中断和多个异常可由软件触发
	* 可以按照优先级对中断进行屏蔽
	* 进入中断/异常服务程序时，自动保存包括PSR在内的多个寄存器；异常返回时自动恢复，无需另外编程
	* 可选配唤醒中断控制器WIC，支持睡眠以及深度睡眠模式
	* 硬件自动抢占管理
		* 当前正在处理的异常/中断优先级被存储专用寄存器中，如果允许抢占（嵌套），自动对新出现的异常与正在处理的异常进行比较，判断是否可以抢占

* Cortex-M3/M4 和NVIC使用了多个可编程寄存器

	* 可通过地址（大都在SCS区）和汇编指令对其进行访问
	* 利用CMSIS-Core提供的调用函数（API）

* 关于中断嵌套

	* 在经典ARM处理器中，所有IRQ同属一个优先级，彼此之间的中断嵌套只能通过软件编程实现
	* Cortex-M3/M4最多可以设置128个可抢占（嵌套）优先级，可通过NVIC对所有的外部中断和大多数系统异常实现硬件嵌套管理，无需另外编程控制
	* 当前正在处理的异常/中断优先级被存储在程序状态寄存器的专用字段中，如果允许抢占（嵌套），当出现新的异常/中断时，硬件电路自动将其可抢占优先级与当前正在处理的异常/中断进行比较，如果新异常/中断的抢占优先级更高，就会中断当前正在执行的中断服务程序，转而处理新的异常/中断，从而实现中断嵌套

* 中断向量表

	* 经典ARM处理器的中断向量表中还包含了跳转到中断服务程序入口的转移指令，而Cortex-M3/M4处理器的中断向量表只有异常/中断服务程序的入口地址
	* Cortex-M3/M4处理器的每个异常服务程序的入口地址为32位，占用4个字节
	* Cortex-M3/M4处理器总共有256个异常/中断异常类型，所以中断向量表的容量为4x256=1024个字节（1 KB）
	* 中断向量表作为一类系统表，起始地址默认位于存储器空间最开始位置（地址0x0）
	* Cortex-M3/M4支持中断向量表
		* 重定位中断向量表重定位：IVT的存放位置可以改变（relocate）

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200420161905384.png" alt="image-20200420161905384" style="zoom:50%;" />

* 在中断响应时，若中断类型号为n，只需计算n×4（左移两位），立刻得到对应的中断向量在中断向量表中存放地址，可以快速获取中断服务程序的入口地址
* 中断响应时，读取中断向量以及ISR的取指操作可以与寄存器压栈操作同时进行；前者由I-Code完成，后者交由D-Code或者系统总线实现，以充分发挥哈佛结构的优势
* 由于中断向量表位于存储空间最开始的位置，而这片区域属于CODE区，由I-Code总线负责管理
* 理论上中断响应时的压栈操作可由D-Code或者系统总线完成，但是有些芯片制造商为了减少一片CODE区的SRAM，把数据都存放在由系统总线负责管理的SRAM区，这种情况下压栈操作只能由系统总线完成

#### 4、系统节拍定时器SysTick

* 在多任务系统中，CPU在不同的时间片为不同的任务进行进行服务，因此需要一个定时器来产生周期性的定时信号，“提醒”操作系统对任务进行切换
* 计算机中还有其他系统事务也需要定时信号，例如DRAM的定时刷新操作
* 为了支持多任务操作系统，Cortex-M系列处理器集成了一个系统节拍定时器SysTick，其作用是产生周期性的SYSTICK中断（异常号#15）
* 如果没有使用操作系统，SysTick定时器可以作为普通定时器使用，用于产生定时信号和进行时间测量
* SysTick定时器是和NVIC捆绑在一起的，可认为是NVIC的一部分，都属于内核设备，非特权用户程序不能访问

* 内部有一个24位递减计数器和4个寄存器：
	* 状态控制寄存器STCSR（Control and Status Reg.）
	* 加载值寄存器STRVR（Reload Value Reg.）
	* 当前计数值寄存器STCVR（Current Value Reg.）
	* 校准值寄存器STCR（Calibration Value Reg.）
	* SysTick被使能后，便从STRVR中的初值开始，按照时钟周期就那些递减计数，减至0后产生一个异常，在下个时钟周期又从STRVR中重新加载初值，重复递减计数过程，从而产生周期性的定时中断
	* 改变STRVR的加载初值，即可改变定时周期
	* 除了汇编指令外，CMSIS-Core也提供了对SysTick配置和管理的函数

## 三、Cortex-M3/4处理器编程模型

* 所谓处理器的编程模型（Programmer’s model），就是程序员所看到的处理器的工作状态、操作模式以及以寄存器为主的各种资源

* Cortex-M3/M4处理器的编程模型与经典ARM处理器有较大差别，例如：

	* 以ARM7T系列为代表经典ARM处理器，具有ARM和Thumb两种工作状态，在不同的状态下有各自不同的指令系统。两种状态可以切换，但是状态切换会有一定的时间开销
	* 而Cortex-M3/M4支持16位和32位指令并存的Thumb-2技术，不再有ARM和Thumb两种工作状态之分，也不再有状态切换导致的时间开销

* 经典ARM处理器支持以下7种运行模式

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200420162327790.png" alt="image-20200420162327790" style="zoom:50%;" />

* Cortex-M3/M4对这些模式进行了化简与合并。本节将从编程的角度，介绍Cortex-M3/M4处理器的操作状态与操作模式、各类寄存器（包括特殊寄存器）以及堆栈处理机制

### (一) 操作状态与操作模式

* 两种操作状态（Operation modes，也称为运行状态）
	* Thumb状态，执行Thumb指令的状态。由于Cortex-M系列处理器不支持ARM指令集，所以没有ARM状态
	* 调试状态，当处理器被暂停后（例如通过调试器或触发断点后）就会进入调试状态，并停止指令执行
* 两种操作模式（Operation states，也运行模式）
	* 处理模式（Handler mode），类似于经典处理器中的异常模式，执行的是中断服务程序（ISR），此时处理器具有特权访问等级
	* 线程模式（Thread mode），除处理模式以外的模式，又分为特权线程模式（类似于经典处理器sys模式）和非特权线程模式（类似于经典处理器usr模式）
* 关于特权访问等级和非特权访问等级
	* 一种最基本的安全模型，对关键区域提供必要的保护
	* 例如：为了防止不可靠的应用任务破坏操作系统内核以及其他任务使用的存储器和外设，可以通过特权等级划分限制应用程序可访问的区域；即使是某个应用程序出现了崩溃，也不至于影响到操作系统内核和其他应用任务的继续运行
	* 非特权与特权访问等级在编程模型方面的差异：
		* 有几条指令不能使用，否则引起用法错误异常
		* 不能访问内核私有区域以及由MPU设定的保护区域
		* 不能访问某些特殊寄存器，如NVIC内部的各种寄存器
* 系统启动后处于特权线程模式，在此模式下，可以对特殊寄存器CONTRL的写操作，将处理器从特权线程模式切换到非特权线程模式
* 但是非特权线程模式不能访问CONTRL寄存器，因此不能采用类似方式回到特权线程模式

<img src="/assets/images/ARM处理器体系结构.assets/image-20200420163404865.png" alt="image-20200420163404865" style="zoom:50%;" />

* 调试状态仅用于调试操作，有两种方式进入调试状态
	* 调试器发起的暂停请求
	* 处理器中的调试部件产生的调试事件
	* 在调试状态下，调试器可以访问或修改处理器中寄存器的数值
	* 无论在Thumb状态还是调试状态，调试器都可以访问系统存储器以及片上和片外的各种外设
* 无论是特权还是非特权线程模式，在异常响应时都进入处理模式，并具有特权访问等级
	* 非特权线程模式可以利用这种机制，在处理模式中修改CONTROL寄存器，从异常返回时变成特权访问等级
* 处理模式和线程模式的编程模型也很类似，不过线程模式可以切换使用独立的进程栈指针PSP，使应用任务的栈空间和操作系统的主栈空间相互独立，可提高系统的健壮性和可靠性
* Cortex-M系列处理器启动后默认处于特权线程模式以及Thumb状态
* 简单应用，一般都使用特权线程模式和主栈指针
* 但是，基于ARMv6-M版本架构的Cortex-M0处理器不支持非特权线程模式，Cortex-M0+处理器只是将其作为一个可选项

### (二) 寄存器

#### 1、常规寄存器

* 在经典ARM处理器（如ARM7TDMI）中，虽然程序可访问的寄存器数量多达30多个，但在不同的状态和不同的工作模式下只能看到其中的一部分，usr和sys模式只能看到17个，其他模式可以看到18个
* 与经典处理器相比，Cortex-M3/M4处理器的工作模式从7种减为2种，在力求与经典处理器保持相对兼容的前提下，Cortex-M3/M4处理器对各类寄存器也进行了调整和梳理，使得各类寄存器的组织结构更加清晰，功能更加全面
* Cortex-M3/M4处理器中的常规寄存器共有16个，其中13个为32位通用寄存器，其他3个为堆栈指针、链接寄存器和程序计数器

#### 2、经典ARM处理器的寄存器

<img src="/assets/images/ARM处理器体系结构.assets/image-20200420182631045.png" alt="image-20200420182631045" style="zoom:50%;" />

#### 3、Cortex-M处理器的常规寄存器

* Cortex-M3/M4处理器中常规寄存器的分组

<img src="/assets/images/ARM处理器体系结构.assets/image-20200420182724872.png" alt="image-20200420182724872" style="zoom:50%;" />

#### 4、通用寄存器：R0~R12

* 分为2组
	* R0\~R7，8个低位寄存器，因受指令编码空间限制，许多16位Thumb指令只能访问低位寄存器
	* R8\~R12，5个高位寄存器，可用于32位指令和少数几个16位指令（如MOV指令）
* 系统复位之后，R0\~R12的初始值均未定义
* 尽管R0~R12都是通用寄存器，但是为了能够实现汇编程序与C语言程序的相互调用，ARM公司制定了AAPCS（ARM Architecture Procedure Call Standard）规范，规定：
	* R0\~R3用于子程序之间的参数传递
	* R4~R11用于保存子程序的局部变量
	* R12作为子程序调用中间寄存器

#### 5、栈指针：R13

* Cortex-M3/M4处理器采用双堆栈设计，有两个物理上的栈指针，也就是有两个R13寄存器，一个是主栈指针MSP，另一个是进程栈指针PSP，对于一般程序而言，两个栈指针只有一个可见
* MSP为默认栈指针，在系统复位后或处理器处于处理模式时，处理器使用MSP；PSP只能用于线程模式，栈指针的选择是通过特殊寄存器CONTROL设定的
* 在大多情况下，对于不使用操作系统的许多简单而言，没有必要使用PSP，只需使用MSP即可
* 系统复位之后，PSP的初值未定义，而MSP的初值存放在整个存储空间最开始（中断向量表）处第一个字中，在系统初始化时，需要将其取出并对MSP进行赋值
* 尽管v8版架构之前的ARM处理器都是32位的，PUSH和POP操作也是以字为单位进行的，堆栈采用字（4字节）对齐方式即可
* 但是，考虑到64位双精度浮点数的压栈问题，AAPCS规范要求堆栈应该采用双字（8字节）对齐方式
* 在Cortex-M3/M4处理器中，通过对系统控制块SCB（System Control Block）中的配置控制寄存器CCR（Configuration Control Register）进行操作，可以使能或禁止双字栈对齐特性
* 无论是采用字对齐还是双字对齐，MSP和PSP的最低两位总是为00，对这两位的写操作不起作用

#### 6、链接寄存器：R14

* 用于保存函数或子程序调用时的返回地址，在函数或子程序结束时，LR中的数值用于调用返回
* 在异常处理时，LR中将自动保存返回地址EXC_ RETURN，异常处理结束用于异常/中断返回
* 如果是嵌套调用，调用时需将LR中的数值压栈保存
* 由于Cortex-M3/M4中有16位指令，指令有时会对齐到半字地址，即便如此，返回地址总是偶数，LR的最低位默认为是0
	* 但LR第0位可读可写，有些转移/调用操作将LR的第0位置1以表示Thumb状态。但是作为返回地址，无论最低位是0还是1，总是认为最低位是0

#### 7、程序计数器：R15

* 在基于x86处理器的PC机中，不允许对代码段寄存器CS以及指令指针IP进行写操作，CS和IP不能作为数据传送和数据处理指令的目的操作数，程序转移或者过程调用只能通过专门的指令来实现
* 但是在ARM处理器中，PC不仅可读而且可写
	* 读PC时返回的是当前指令地址加4，这是因为流水线的特性以及与ARM7T系列处理器兼容的需要
	* 对PC的写操作可以使用MOVE指令以及数据处理指令来实现，以实现程序的跳转
	* 但在大多数情况下，跳转和调用操作都通过专用指令实现，利用数据传输和数据处理指令更新PC的情况较为少见
* 在Cortex-M3/M4中，由于指令必须对齐半字或字，作为代码地址，PC的最低位总是认为是“0”
* 需要注意的是，无论使用跳转指令还是直接写PC寄存器，写入值必须是奇数，确保其最低位是“1”，以表示其处于Thumb状态，否则将被认为试图转入ARM模式，从而导致出现错误异常
* 当使用高级编程语言（包括C和C++）时，编译器会自动将跳转目标的最低位置“1”，无需担心出错
* 再次强调：PC最低位为“1”，只是表示处于Thumb状态，作为指令地址，PC最低位始终被认为是“0”

#### 8、关于寄存器的名称

* 使用ARM汇编指令编程时，在汇编代码中出现的上述寄存器可以使用不同的名称，如大写、小写或者大小写混用，常用的汇编工具（如Keil MDK-ARM和ARM ADS）都能对其进行识别

<img src="/assets/images/ARM处理器体系结构.assets/image-20200420184250649.png" alt="image-20200420184250649" style="zoom:50%;" />

### (三) 特殊寄存器

* 除了常规寄存器以外，Cortex-M3/M3处理器中、还有多个特殊寄存器，分别是：
	* xPSR：程序状态寄存器，包括APSR、EPSR和IPSR
	* PRIMASK
	* FAULTMASK
	* BASEPRI（以上三个均为中断屏蔽设置寄存器）
	* CONTROL 控制寄存器，定义处理器的操作状态

<img src="/assets/images/ARM处理器体系结构.assets/image-20200420185358537.png" alt="image-20200420185358537" style="zoom:50%;" />

* 这些寄存器没有映射到内存空间，只能利用MSR/ MRS指令通过名字对其访问，例如：

	MRS  <reg>,  <special_reg>；读special_reg到通用寄存器reg

	MSR <special_reg>,  <reg>；将reg内容写入special_reg

* 注意特殊寄存器与“特殊功能寄存器（SFR）”的区别，后者一般用于I/O控制的寄存器

* CMSIS-core也提供了用于访问特殊寄存器的函数。在使用C或C++等高级开发简单应用时，可能不太需要这些特殊寄存器；如果开发需要在嵌入式操作系统环境下运行的应用程序，并且需要高级中断屏蔽特性时，就需要访问这些特殊寄存器

#### 1、程序状态寄存器

* 在ARM7TDMI为代表的经典ARM处理器中，采用了CPSR和SPSR两个程序状态控制器。CPSR保存当前程序状态，SPSR用于在异常/中断处理时保存CPSR的状态，以便异常返回后能够恢复处理器的工作状态
* 从ARMv7版架构开始，ARM采用了新的程序状态寄存器PSR，读取PSR的结果实际包含了APSR、EPSR和IPSR三个状态寄存器内容，因此，有时也将PSR称为xPSR（表中GE[3:0]只有Cortex-M4中有）

<img src="/assets/images/ARM处理器体系结构.assets/image-20200420185612298.png" alt="image-20200420185612298" style="zoom:50%;" />

* PSR中各个标志位的含义如下：

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200420185645135.png" alt="image-20200420185645135" style="zoom:50%;" />

* Cortex-M3/M4的PSR与经典ARM处理器的CPSR有较大差异，下图给出几种ARM处理器PSR的对比

* 与ARM7TDMI的CPSR相比：

	* 取消了反映工作模式的M[4:0]位
	* T标志位的位置发生变化
	* 中断标志I和F被新的PRIMASK所取代

<img src="/assets/images/ARM处理器体系结构.assets/image-20200420185739150.png" alt="image-20200420185739150" style="zoom:50%;" />

#### 2、三个中断屏蔽寄存器

* PRIMASK、FAULTMASK和BASEPRI三个寄存器的用途是为了实现基于优先权等级的异常/中断屏蔽

* 关于Cortex-M3/M4处理器的异常优先级

	* 复位、NMI和HardFault硬件错误三个系统异常具有固定的优先权等级
	* 复位优先权等级为-3，数字最小，具有最高优先权
	* NMI优先权等级为-2，优先权等级仅次于复位
	* 硬件错误优先权等级为-1，优先权等级排行第三
	* 除了上述三个系统异常之外，其它所有异常和中断的优先级均可编程设置，优先权等级数值范围从0~255，数值越小，优先级越高；反之优先权越低

* 下图为三个中断屏蔽寄存器的编程模型，可以看出PRIMASK和FAULTMASK都只有一位

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200420185856268.png" alt="image-20200420185856268" style="zoom:50%;" />

* PRIMASK

	* 当最低位被置位（写入1）后，将屏蔽除复位、NMI和硬件错误以外所有的（优先级数值大于0的）系统异常和外部中断，类似于x86系统中的关中断（IF=0），以便处理紧急事务
	* 当紧急事务处理完毕，要及时将PRIMASK的最低位进行复位，类似于x86系统的“开中断”

* FAULTMASK

	* 当最低位被置位后，硬件错误异常也被屏蔽，相当于把异常/中断的优先级门槛提高到“-1”
	* 常用于执行负责错误处理的中断服务程序。因为既然出现了错误并且正在处理，就无需理会此刻出现的包括硬件错误在内的其他异常（只有几种），以便错误处理程序能够“专心致志”地进行错误修复
	* 与PRIMASK不同的是，FAULTMASK无需主动清理，当错误处理程序运行结束返回时，会自动复位FAULTMASK
	* FAULTMASK是ARMv7-M版架构引入的，Cortex-M0系列处理器没有FAULTMASK寄存器

* BASEPRI

	* 也是ARMv7-M版架构新增的，可以按照具体优先数值对中断屏蔽进行管理

	* BASEPRI寄存器的最低8位采用了“可伸缩”设计，具体宽度取决于芯片制造商实际设计的中断优先级数量

	* 一般而言，芯片制造商设计的中断优先级不少于8级，此时BASEPRI中7:5这3位用于设置中断屏蔽

	* 如果设计了32级中断，BASEPRI的宽度为7:3共5位，假如7:3这5位的数值是0b1 0000，将屏蔽优先级数值大于等于0b1 0000的所有中断

	* 如果7:3这5位的数值是0 0000，其含义则是对所有中断都不屏蔽

	* 中断屏蔽寄存器属于特殊寄存器，只有特权访问等级才可以进行读写访问。非特权状态下的写操作会被忽略，而读操作返回数值为0

	* 使用汇编指令访问三个中断屏蔽寄存器示例：

		```
		MRS  r0,  BASEPRI; 		将BASEPRI寄存器读入R0
		MRS  r0,  PRIMASK; 		将PRIMASK寄存器读入R0
		MRS  r0,  FAULTMASK; 	将FAULTMASK寄存器读入R0
		MSR  BASEPRI,  r0; 		将R0写入BASEPRI寄存器
		MSR  PRIMASK,  r0; 		将R0写入PRIMASK寄存器
		MSR  FAULTMASK,  r0; 	将RO写人FAULTMASK寄存器
		```

	* CMSIS-Core提供的访问函数：

		```
		x = _get_BASEPRI()；		//读BASEPRI寄存器
		x =_get_PRIMARK();		//读PRIMASK寄存器
		x =_get_FAULTMASK();	//读EAULTMASK寄存器
		_set_BASEPRI(x);		//设置BASEPRI的新数值
		_set_PRIMASK(x);		//置位PRIMASK
		_set_FAULTMASK(x);		//置位FAULTMASK
		_disable_irq();			//置位PRIMASK，禁止异常，
								//相当于_set_PRIMASK(1)
		_enable_irq();			//清除PRIMASK，使能异常，
								//相当于_set_PRIMASK(0)
		```

	* 利用修改处理器状态CPS指令，也可以方便地设置或清除PRIMASK和FAULTMASK的数值，例如：

		```
		CPSIE I; 	使能异常（清除PRIMASK位）
		CPSID I; 	禁止异常（置位PRIMASK位）
		PSIE f; 	使能异常（清除FAULTMASK位）
		CPSID f; 	禁止异常（置位FAULTMASK位)
		```

	* 对比上述指令，可以看出来

		* PRIMASK类似于经典ARM处理器CPSR中的“I”标志位，置位后禁止IRQ中断
		* FAULTMASK类似于经典ARM处理器CPSR中的“F”标志位，置位后禁止FIQ中断

#### 3、CONTROL寄存器

* 用于选择线程模式的特权访问等级以及栈指针
* Cortex-M3/M4的CONTROL寄存器的编程模型如下图所示。为了比较，表中也给出了Cortex-M0/M0+的CONTROL寄存器的编程模型
	* Cortex-M3/M4都只有SPSEL和nPRIV两位，配置了FPU的Cortex-M3/M4增加了一位FPCA
	* Cortex-M0没有nPRIV ，Cortex-M0 M0+只是选项

<img src="/assets/images/ARM处理器体系结构.assets/image-20200420190631844.png" alt="image-20200420190631844" style="zoom:50%;" />

* CONTROL寄存器各位的含义

	* nPRIV：设置线程模式的特权访问等级，该位为0/1，处理器进入特权线程模式/非特权线程模式
	* SPSEL：选择线程模式中的堆栈指针
		* 当该位为0时，线程模式使用主栈指针MSP
		* 当该位为1时，线程模式使用进程栈指针PSP
		* 在处理模式下，该位始终为0，并且忽略对其的写操作
	* FPCA：配置FPU的Cortex-M4才有此位。当发生异常时，若该位为1，浮点单元中的寄存器内容被压栈保存。执行浮点指令时FPCA位自动置位，在异常处理程序入口处该位被硬件自动清除

* 复位后，CONTROL寄存器被恢复成默认值0

	* 这意味着复位之后，处理器处于线程模式、具有特权访问等级、并且使用主栈指针
	* 在特权线程模式下，可以通过写CONTROL寄存器进入非特权线程模式
	* 不过，当CONTROL寄存器的最低位nPRIV位被置位后，非特权线程模式下不能继续访问CONTROL寄存器了，也无法再切换回特权线程模式了
	* 如果需要将非特权线程模式切换回特权线程模式，只能借助于异常处理。处理模式具有特权访问等级，可以清除nPRIV位，再在从异常返回线程模式后，处理器就进入特权线程模式

* 特权线程模式与特权线程模式的切换过程

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200420191943525.png" alt="image-20200420191943525" style="zoom:50%;" />

* 对于简单应用，可以一直运行在特权线程模式下，无须修改CONTROL寄存器的数值，并且只使用MSP

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200420192010494.png" alt="image-20200420192010494" style="zoom:50%;" />

#### 4、系统控制块SCB

* System Control Block，实际上是由多个寄存器组成的一个数据结构，属于Cortex-M3/M4内核的一部分并被综合在NVIC中。SCB中各类寄存器的作用包括：
	* 对处理器进行配置。如之前所述的双字栈对齐使能控制，以及低功耗模式设置等
	* 提供错误状态信息。SCB中包含多个反映不同类型错误的状态寄存器
	* 异常和中断管理。例如异常的挂起与解挂控制、优先级设置和优先级分组以及中断向量表的重定位
	* 有多个反映处理器特性、指令集特性、存储模块特性以及调试特性的只读寄存器
	* 对于配置了FPU的Cortex-M4处理器，还有一个协处理器访问控制寄存器
* SCB的各类寄存器被映射到SCS中，地址范围：0xE000 ED00 ~ 0xE000 ED88
	* 如果使用汇编语言，只能通过地址访问这些寄存器
	* 但是CMSIS-Core为每个寄存器分配了一个符号，类似给这些寄存器赋予一个名称，例如：
		* 中断控制和状态寄存器：SCB->ICSR
		* 系统控制寄存器：SCB->SCR
	* 使用C语言并利用CMSIS-Core定义的这些符号，可以更方便地对SCB中的各个寄存器进行访问

### (四) 堆栈结构

#### 1、堆栈的作用和堆栈类型

* 堆栈的作用和堆栈类型
	* 堆栈是一种特殊的数据结构，是一种只能在一端进行插入和删除操作的线型表
	* 堆栈的数据存取操作按照“后进先出（LIFO）”的原则，并通过堆栈指针指示当前的操作位置
	* 压栈指令PUSH向堆栈中增加数据，出栈指令POP指令从堆栈中提取数据
	* 每次PUSH和POP操作后，当前使用的堆栈指针都会自动进行调整
	* 在32位系统中，堆栈操作至少是以字为单位，所以堆栈至少应该做到“字对齐”（在Cortex-M系列处理器中，为了遵守AAPCS的规范，堆栈需要采用双字对齐）
* 堆栈的作用：
	* 在异常/中断响应时，保存被中断程序的下一条指令的地址，以及处理器状态寄存器的内容（保护断点），以便在异常/中断返回后，处理器能够从断点处继续运行
	* 异常/中断服务程序，或者正在执行的函数或者子程序如果需要使用某些寄存器，可以使用堆栈保存这些原来的内容（保存现场），以便异常返回或者函数或子程序处理结束时可以恢复现场
	* 实现主程序与函数或者子程序之间的参数传递
		* 函数或者过程调用有多种参数传递方式，堆栈传递是一种最安全的方式，并且对参数数量几乎没有限制
	* 用于存储局部变量
* 按照堆栈区在存储器中的地址增长方向，可分为：
	* 递增栈（Ascending Stack）：向堆栈写入数据时，堆栈区由低地址向高地址生长
	* 递减栈（Descending Stack）：向堆栈写入数据时，堆栈区是由高地址向低地址生长
* 按照堆栈指针SP所指示的位置，又分为：
	* 满堆栈（Full Stack）：堆栈指针SP始终指向栈顶元素，也就是指向堆栈最后一个已使用的地址
	* 空堆栈（Empty Stack）：SP始终指向下一个将要放入元素的位置，也就是指向堆栈的第一个没有使用的地址或者空位置
* 组合上述两种地址增长方向和两种堆栈指针指示位置，可以得到4种基本堆栈类型：
	* 满递增（FA）：SP指向最后压入的数据，且由低地址向高地址生长
	* 满递减（FD）：SP指向最后压入的数据，且由高地址向低地址生长
	* 空递增（EA）：SP指向下一个可用空位置，且由低地址向高地址生长
	* 空递减（ED）：SP指向下一个可用空位置，且由高地址向低地址生长

#### 2、Cortex-M处理器的堆栈模型

* 许多经典ARM处理器及ARM T32指令集可支持以上四种堆栈类型，但是，Cortex-M系列处理器只能使用满递减（FD）类型

<img src="/assets/images/ARM处理器体系结构.assets/image-20200420193521265.png" alt="image-20200420193521265" style="zoom:50%;" />

* 处理器在启动或者复位后，系统初始化程序从位于内存最开始处的flash中，取出地址为0x0000 0000的第一个字，作为主栈指针MSP的初始值
* 以后每次PUSH操作时，处理器将SP的值减去4，然后将需要压栈保存的数据存储在SP指向的位置
* 每次POP操作，SP所指向的存储器数据被读出，然后SP的数值自动加4，指向POP之后新的栈顶位置
	* 出栈后，原来存放在堆栈中的数据依然存在，但无需理会，因为随后可能出现的PUSH操作将会将其覆盖
* PUSH和POP操作应“匹配”，防止“张冠李戴”导致系统混乱甚至崩溃
* 如果Cortex-M3/M4处理器使能了双字栈对齐模式，当出现异常时，假如压栈操作之后堆栈指针没有对齐到双字边界，将如何处理？
	* 处理器会自动插入一个“空”字，强制堆栈对齐在双字边界上。同时，已经入栈保存的xPSR寄存器的第9位（未使用）被置为1，表示堆栈指针发生过调整
	* 出栈时硬件电路对xPSR第9位进行检查，若为1则说明最后入栈的字是为了双字对齐插入的，应将其丢弃
	* 虽然双字对齐可能会造成堆栈空间的一点点浪费，但是为了提高软件的标准化程度以及便于程序之间的相互调用，建议使用双字对齐模式

#### 3、Cortex-M3/M4处理器中的双堆栈

* Cortex-M3/M4的双堆栈设计有MSP和PSP两个堆栈指针，分别服务于不同的操作模式和特权访问等级
* CONTROL寄存器中nPRIV和SPSEL的不同组合，两个堆栈共有4种场景，其中前三种比较常见

<img src="/assets/images/ARM处理器体系结构.assets/image-20200420193739699.png" alt="image-20200420193739699" style="zoom:50%;" />

* 如果使用双堆栈，应通过MPU在SRAM中建两个区域
	* 一个定义为特权级，其中一部分用作主栈存储区
	* 另一个定义为非特权级，其中一部分用于进程栈
* 注意：Cortex-M3/M4的堆栈是满递减类型，因此两个栈指针的初始值应该是两个区域的最大地址
* 如果采用双字对齐，栈顶应位于双字边界上，MSP和PSP最低3位为000

<img src="/assets/images/ARM处理器体系结构.assets/image-20200420193838599.png" alt="image-20200420193838599" style="zoom:50%;" />

* Cortex-M系列处理器的堆栈空间一般位于系统主存储器SRAM区（也可以放置在CODE区中通过D-Code总线的连接的SRAM中）

* 用于堆栈的存储区需要事先做好规划，预留足够的空间，以防出现堆栈溢出

* MSP的初始值事先存放在0x0000 0000处，该位置通常位于I-Code总线所连接的flash中，系统上电或者复位之后，系统初始化程序完成MSP的初始化

* PSP的初始化需要另外编程实现，PSP的初始化宜使用汇编指令代码，简单高效而且不易出错

* 示例：

	```
	BL  Mpusetup		;调用MPU设置子程序，建立region，并使
						;能存储器保护
	LDR r0, =PSP_TOP	;读取进程栈栈顶
	MSR  PSP, r0		;初始化进程栈指针
	MOV  r0，#0x3		;准备置位CONTROL寄存器的SPSEL和
						;nPRIV
	MSR  CONTROL, r0	;完成CONTROL寄存器的更改，切换到
						;非特权线程模式
	B UserAppStart		;已进入非特权线程模式，跳转到用户
						;程序入口
	```

## 四、Cortex-M处理器存储系统

### (一) 存储器映射

* 所有基于ARMv7M的Cortex-M系列处理器，都采用相同的存储器映射关系方式（存储区域划分）

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428095044184.png" alt="image-20200428095044184" style="zoom:67%;" />

**位段区**

Cortex-M3/M4在SRAM区和片上外设区，各有一个位段区和位段别名区

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428095153925.png" alt="image-20200428095153925" style="zoom:67%;" />

**系统控制区SCS**

* 4KB，早期归属于NVIC，所以也称为NVIC区
* 除NVIC以外，SCS还映射了SysTick、MPU、SCB和FPU等部件的寄存器

![image-20200428095634989](/assets/images/ARM处理器体系结构.assets/image-20200428095634989.png)

![image-20200428095730301](/assets/images/ARM处理器体系结构.assets/image-20200428095730301.png)

**不同存储器区域的用途**

![image-20200428095814787](/assets/images/ARM处理器体系结构.assets/image-20200428095814787.png)

### (二) 连接存储器和外设

* 为提高性能，CODE区使用专门的I-Code和D-Code总线，I-Code、D-Code和系统总线可以并行执行
* 这种结构也会加快中断响应速度，中断响应时，读取中断向量、取指和压栈操作可以同时执行
* 此外，一些芯片制造商也会在MCU中增加自行设计的Flash访问加速器

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428095923323.png" alt="image-20200428095923323" style="zoom:67%;" />

**示例：** Flash访问加速器

意法半导体（ST Microelectronics）的STM32F2（基于Cortex-M3的微控制器）和STM32F4（基于Cortex-M4的微控制器），在I-Code和D-Code总线接口处实现了Flash访问加速器

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428095959576.png" alt="image-20200428095959576" style="zoom:67%;" />

**总线矩阵示例：NXP公司LPC1700**

注意：AHB Lite协议仅适用于单主控设备的情形，有些产品用“总线矩阵”或“多层AHB”等术语来描述芯片内部支持多主控设备总线系统。对多主控设备的支持未在AHB Lite协议中定义

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428100059606.png" alt="image-20200428100059606" style="zoom: 80%;" />

### (三) 存储器的端模式

* 网络传输、文件存储均有大端小端问题
* 在C语言下如果使用指针也需要注意大端小端问题

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428100146385.png" alt="image-20200428100146385" style="zoom:67%;" />

Cortex-M3/M4支持两种端模式

**大端：字节不变大端和字不变大端**

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428100252933.png" alt="image-20200428100252933" style="zoom:67%;" />

区别：数据传输时字节通道不同。字节通道指高低字节与总线上高低位数据线的映射关系

**数据传输时的字节通道**

32位计算机中，总容量为232的存储器分成4个存储体，每个存储体容量为230，每个存储体只需30条地址线，用字节选择信号进行选择

![image-20200428100447582](/assets/images/ARM处理器体系结构.assets/image-20200428100447582.png)

**Cortex-M缺省支持小端模式**

* 小端模式下，Cortex-M3/M4和经典ARM处理器的字节通道都是相同的

![image-20200428100934453](/assets/images/ARM处理器体系结构.assets/image-20200428100934453.png)

* Cortex-M处理器中：
	* 取指令总是采用小端模式
	* 访问包括系统控制区SCS、调试部件和私有外设总线（PPB）在内的0xE000 0000 ~ 0xE00F FFFF区域，总是小端模式
	* 采用小端格式的MCU，若需要处理大端数据，可使用REV、REVSH和REV16等指令将数据做大端和小端转换

### (四) 非对齐数据的访问

* 大部分经典ARM处理器只允许对齐（aligned）传输
* Cortex-M3和Cortex-M4处理器中，大部分存储器访问指令还支持非对齐（unaligned）数据传输

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428101044830.png" alt="image-20200428101044830" style="zoom:67%;" />

**非对齐的注意事项**

* 非对齐的问题
	* 非对齐传输会被拆分为两个对齐传输，导致数据访问花费更多的时间，降低了存储器的访问效率。在高性能应用中，确保数据的对齐存放是必要的
* 并非所有Cortex-M3和Cortex-M4的存储器访问指令都支持非对齐的数据传输。例如，多加载/存储指令、栈操作指令、排他访问指令必须是对齐的；位段操作也不支持非对齐传输
* 可设置Cortex-M3或Cortex-M4处理器在非对齐传输出现时触发异常
	* 需要在配置控制寄存器CCR中置位UNALIGN_TRP（非对齐陷阱）位
	* 软件开发过程中，程序员如果需要测试程序是否会产生非对齐传输，也可设置CCR的UNALIGN_TRP位

### (五) 位段操作

* 位段（也称作位带）操作：一次存储器操作只访问一个位
* Cortex-M3/M4处理器中，有两个位段区域
	* SRAM区域的最低1MB（0x2000 0000 ~ 0x200F FFFF)
	* 外设区域的最低1MB（0x4000 0000 ~ 0x400F FFFF）
	* 位段特性在Cortex-M3和Cortex-M4上是可选的
* 位段别名& 位段别名区域
	* 位段区域中特定存储单元的某一位，映射为一个位段的别名地址（一个字）
	* 一个字的32个比特被映射到32个位段别名地址（32个字）
* 位段别名地址数据的LSB$\Leftrightarrow$位段区存储单元的某一个位
	
* 使用位段别名地址访问存储器时，所得到字数据的最低位LSB即对应位段区域中某个特定的位
	
* 1 MB位段区映射为32 MB位段别名区域。如0x2000 0000地址的字节数据的8个比特被映射到0x2200 0000 ~ 0x2200 001C处的别名区域

	![image-20200428101336008](/assets/images/ARM处理器体系结构.assets/image-20200428101336008.png)

**外设区域的位段别名地址**

外设区域的位段别名地址如图所示，若读取别名地址0x4200002C，则返回结果可能是0x00000000或0x0000 0001，分别代表0x4000 0000位置字数据的第11位取值为“0”和“1”

![image-20200428104014349](/assets/images/ARM处理器体系结构.assets/image-20200428104014349.png)

通过位段别名对位段区域进行位访问（外设区域）

**修改某一位**

* 没有位段特性时，只能“读$\rightarrow$改$\rightarrow$写”（Read-Modify-Write）

* 位段操作可以帮助用户完成“读$\rightarrow$改$\rightarrow$写”

	* 示例：将地址为0x2000 0000的字数据第2位置1

		![image-20200428104141957](/assets/images/ARM处理器体系结构.assets/image-20200428104141957.png)

**读取特定位**

* 没有位段特性时，只能先读取字节/半字/字数据，再使用其他指令提取某一位，至少需要两次操作

* 位段操作可以简化程序

	* 例：读取地址为0x2000 0000字数据的第2位

		![image-20200428104231433](/assets/images/ARM处理器体系结构.assets/image-20200428104231433.png)

**位段操作的其他优点**

* 操作的原子性：操作过程不会被其它事务打断
	* 原子性是位段操作的一个重要优点
	* 无位段特性时，“读$\rightarrow$改$\rightarrow $写”流程可能会被其它行为打断（例如异常/中断处理、多任务切换），从而会有潜在的数据冲突风险
	* 位段操作可以避免这种竞态现象，这是因为位段操作所完成的“读$\rightarrow$改$\rightarrow $写”是由硬件保障的，具有原子性
* 简化转移决断过程
	* 假如程序是否转移执行是依据I/O端口某个状态寄存器中的某一位，位段操作可以直接读取该位数值，迅速完成判断

**C程序实现位段操作**

* C编译器本身不支持位段操作，其原因是：

	* 不知道可以用两个不同的地址来寻址同一个存储器位置
	* 也不了解对位段别名的访问只操作存储器数值的LSB

* 但是可以编程实现位段操作

	* 例：写地址为0x40000000的某端口寄存器的bit[1]

	可以在C程序中声明存储器位置的地址和位段别名

```c++
#define DEVICE_REG0			*(( volatileunsigned long*) (0x40000000))
#define DEVICE_REG0_BIT0	*(( volatileunsigned long*) (0x42000000))
#define DEVICE_REG0_BIT1	*(( volatileunsigned long*) (0x42000004))
...
DEVICE_REG0 = DEVICE_REG0 | 0x2;//未使用位段特性设置bit[1]
...
DEVICE_REG0_BIT1 = 0x1;//利用位段特性通过位段别名地址设置bit[1]

```

### (六) 存储器访问权限

* Cortex-M3/M4的处理器映射具有默认的存储器访问权限配置，除了个别寄存器以及芯片厂商定义区之外，不允许非特权用户程序访问包括SCS（NVIC）在内的内核私有区域，否则将引起总线错误异常
* 如果系统配置了MPU并且使能，MPU设置所定义的其他访问权限也会决定是否允许用户访问其他的存储器区域
* 在没有MPU时，或者有MPU但未使能时，将使用默认的存储器访问权限设置

**Cortex M3/M4默认的存储器访问权限**

![image-20200428105606904](/assets/images/ARM处理器体系结构.assets/image-20200428105606904.png)

### (七) 存储器访问属性

* Cortex-M3/M4处理器的存储器访问属性
	* 可缓冲（Bufferable）：存储器写操作可能无法在一个流水线周期内完成，如果配置了写缓存，但剩下的工作交由写缓冲执行，处理器继续执行下一条指令
	* 可缓存（Cacheable）：读存储器所得到的数据可被复制到缓存，下次再访问时可以从缓存中取出这个数值从而加快程序执行
	* 可执行（Executable）：处理器可以从本存储器区域取出并执行程序代码
	* 可共享（Sharable）：存储器区域的数据可被多个总线主设备共用。但是，存储器系统需要在不同总线主设备之间，确保可共享存储器区域数据的一致性

#### 1、可缓冲

* Cortex-M3/M4支持总线接口的写缓冲

	* 即使总线接口上的实际传输需要多个时钟周期才能完成，对可缓冲存储器区域的写操作可在单个时钟周期内执行，处理器可继续执行后续指令

		<img src="/assets/images/ARM处理器体系结构.assets/image-20200428105835897.png" alt="image-20200428105835897" style="zoom: 67%;" />

	* 代价

		* 虽然存储器系统不会改变指令执行顺序，但是，并不能确保多条顺序执行指令中的存储器访问完成顺序与指令顺序一致
		* 存储器屏障指令，保证指令执行顺序与存储器访问结束顺序一致

#### 2、可缓存和可共享

* 可缓存属性需要硬件支持，Cortex-M3/M4处理器本身没有缓存存储器或缓存控制器，但芯片制造商可在MCU增加缓存单元，支持可缓存属性
* 若系统中存在多个处理器，并且缓存控制器具有缓存一致性管理功能，就需要用到可共享属性
* 缓存控制器用来确保共享数据在各个缓存单元是一致的，从而保证共享内存中的数据一致性

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428105926908.png" alt="image-20200428105926908" style="zoom:67%;" />

#### 3、存储器按访问属性分类

* 按照可缓冲和可缓存属性，存储器分以下三类

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200428110006413.png" alt="image-20200428110006413" style="zoom:50%;" />

	* 其中后两种都属于普通型，算作一类

* 现有多数基于Cortex-M3/M4的微控制器，只有可执行和可缓冲属性会影响到应用程序的执行

#### 4、代码顺序$\neq$存储器操作完成顺序

* 存储器系统会确保“强序”类型存储器和“器件”类型存储器的访问顺序
	* 例如，A1和A2是两条前后相连的存储器访问指令，A1指令在前，A2指令在后，当A1、A2指令所访问的存储器类型不同时，这两条指令实际存储器访问的先后顺序如表所示

![image-20200428110123649](/assets/images/ARM处理器体系结构.assets/image-20200428110123649.png)

#### 5、各存储器区域的默认访问属性

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428110149781.png" alt="image-20200428110149781" style="zoom:67%;" />

### (八) 排他访问

* 在多用户操作系统中，当多个用户共享某个特定资源时，常利用信号量（semaphore）进行协调。若某共享资源只能满足一个用户使用时，被称为互斥体（Mutex）
	* 若某资源已被用户占用，就会被锁定至该用户，在锁定解除前无法用于其他用户。每个用户在使用资源前，需要先检查资源是否已被锁定，若未被使用，则设置为锁定状态，再开始使用资源
	* 在传统ARM处理器中，锁定状态访问由SWP指令执行，以确保读写锁定状态的原子性，避免资源被两个用户同时锁定，但SWP指令只适用于读写位于同一总线的场景
	* 在Cortex-M3/M4，读/写访问可由独立的总线执行，此时使用SWP指令就无法保证存储器访问的原子性，所以采用了新的排他访问指令（Cortex-M3/M4 取消了SWP指令）

**排他写过程**

排他访问需要软硬件配合才能完成，一次排他写过程需要先用排他读指令获取拟访问地址是否被锁定的信息；未被锁定时才可进行排他写并设置锁定状态

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428110405856.png" alt="image-20200428110405856" style="zoom:67%;" />

### (九) 存储器屏障

* Cortex-M处理器不会调整程序中指令执行的顺序（在超标量处理或支持乱序执行的高性能处理器中可能会出现调整），同时，AHB Lite和APB协议较为简单，不允许在前面的传输还未完成时就开始新的传输
	* 通常情况下，存储器操作的先后顺序也是和指令的先后顺序一致的
* 但是，为提高处理器性能，Cortex-M3/M4增加了写缓冲，写操作可能会和下一条指令的操作同步执行
	* 如果程序员需要保证下一条指令的操作不会在当前指令写存储器操作完成前执行，需要使用存储器屏障指令

**存储器屏障指令**

* 存储器屏障指令可用于
	* 确保存储器访问顺序
	* 确保存储器访问和另外一个处理器操作之间的顺序
	* 确保系统配置发生在后序操作之前
* Cortex-M3/M4支持三种存储器屏障指令
* DBM：数据存储器屏障。确保执行新的存储器操作之前所有的存储器操作都已经完成
* DSB：数据同步屏障。确保下一条指令执行前所有的存储器访问都已经完成
* ISB：指令屏障。清空流水线，确保在执行新的指令前，之前所有的指令都已经完成

### (十) MCU的存储器系统

* 在许多MCU中，芯片制造商还集成了其他一些存储器特性，以提高存储器映射的灵活性，例如：
	* Bootloader（上电复位后的第一段代码）
	* 存储器重映射
	* 存储器别名
* 很多情况下，MCU中除了CODE区的Flash之外，还有一个单独的ROM（也可能是Flash），其中包含了Bootloader，其功能包括：
	* Flash编程功能，可以通过UART对Flash进行编程
	* 通信协议栈，便于开发者通过API调用
	* 通过芯片内部的自检功能

**Bootloader**

* 对于具有BootloaderROM的芯片，系统上电时执行的是BootloaderROM中的引导程序，因此BootloaderROM应该位于地址0x0
* 但是，系统再次启动时，可能不再运行BootloaderROM中的程序，而是运行Flash中的程序。因此，可以使用下图所示电路修改存储器的映射关系

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428111602492.png" alt="image-20200428111602492" style="zoom:67%;" />

**存储器重映射和存储器别名**

* 以上切换操作称为存储器重映射（Memory Remap），由Bootloader实现。但是，在重映射切换的同时无法跳到Bootloader新地址。因此，可采用一种名为“存储器别名”的方法，从两个不同的位置访问Bootloader
* 有多种存储器配置方法，下图只是其中的一种

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428111646350.png" alt="image-20200428111646350" style="zoom:67%;" />

## 五、Cortex-M处理器异常与中断

### (一) Cortex-M异常管理模型

#### 1、异常类型

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428112600484.png" alt="image-20200428112600484" style="zoom:67%;" />

#### 2、异常状态

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428112614725.png" alt="image-20200428112614725" style="zoom:67%;" />

#### 3、异常处理程序

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428112628581.png" alt="image-20200428112628581" style="zoom:67%;" />

#### 4、异常向量表

* Thumb-2指令有16位和32位两种长度，指令代码至少对齐在半字边界，程序入口地址的LSB应是“0”
* 但是异常向量的LSB必须是“1”，表示异常处理程序处于Thumb状态，否则将引起总线错误

![image-20200428112735876](/assets/images/ARM处理器体系结构.assets/image-20200428112735876.png)

#### 5、异常的优先级

* Cortex-M3/M4中，每一个中断都有一个8位的中断优先级（配置）寄存器（Interrupt Priority-level Registers，0xE000E400~ 0xE000E4EF，位于NVIC中），实际使用位数3~8位，取决于MCU设计的中断数量

* 优先级的减少通过去除优先级配置寄存器的最低位（LSB）实现

	* 两种不同的移除方法

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200428114151251.png" alt="image-20200428114151251" style="zoom:67%;" />

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200428114336662.png" alt="image-20200428114336662" style="zoom:50%;" />

**中断优先级寄存器：**3位宽和4位宽对比

* 每一个中断的优先级由各自的Priority-level Registers定义，Priority-level Registers寄存器可以按照字节/半字/字进行访问

	* 若MCU设计了3位优先级，则有8个可编程优先级
	* 若设计了4位优先级，会得到16个可编程优先级
	* ARMv7-M架构，宽度最少为3位

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200428114657751.png" alt="image-20200428114657751" style="zoom: 67%;" />

**自然顺序优先级机制**

* 如果优先级相同的异常同时产生，会怎样？
	* 处理器会先处理异常类型号低的，称之为“自然顺序优先级”
		* 例如，假设IRQ#0和IRQ#1的优先级被设为相同数值，当IRQ#0和IRQ#1同时出现或均处于挂起状态时，处理器会先处理IRQ#0的ISR
* 复位后的初识状态：
	* 所有可配置中断处于禁止状态，默认优先级为0
	* 固定不变：复位为-3、NMI为-2、硬件错误为-1

#### 6、中断优先级分组

* 优先级寄存器3~8位又分为两部分（以8位为例）
	* 分组优先级（group priority），过去称为抢占优先级（preempt priority）
		* 后来的中断能否产生嵌套，由该中断的分组优先级决定
	* 子优先级（subpriority）
		* 两个具有相同分组优先级的异常同时出现时，首先处理子优先级（数值更小）高的异常

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428115037828.png" alt="image-20200428115037828" style="zoom: 67%;" />

**优先级分组的设置：AIRCR**

* AIRCR（Application Interrupt and Reset Control Register，0xE000 ED0C）的PRIGROUP位域（AIRCR[10:8]），使用3位定义优先级分组的8种配置方案

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428115204208.png" alt="image-20200428115204208" style="zoom:67%;" />

**优先级分组+优先级寄存器**

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428115234303.png" alt="image-20200428115234303" style="zoom:67%;" />

* 优先级配置寄存器的宽度不同，设置优先级分组的方法：

	* 例1，优先级配置寄存器的宽度为8，优先级分组为配置0

		<img src="/assets/images/ARM处理器体系结构.assets/image-20200428115321060.png" alt="image-20200428115321060" style="zoom:67%;" />

	* 例2，优先级配置寄存器的宽度为3，优先级分组为配置1

		<img src="/assets/images/ARM处理器体系结构.assets/image-20200428115338672.png" alt="image-20200428115338672" style="zoom:67%;" />

	* 例3，优先级配置寄存器的宽度为3，优先级分组为配置5未使用

		<img src="/assets/images/ARM处理器体系结构.assets/image-20200428115356722.png" alt="image-20200428115356722" style="zoom:67%;" />

#### 7、异常流程

* 在计算机系统中，中断的整个过程分为：中断响应、中断处理和中断返回等三个阶段
	* 中断响应：CPU确定响应某中断后，根据中断类型码查找中断向量表中对应的表项，获得中断服务子程序入口地址；接下来保护断点（将标志寄存器和断点地址等信息压入堆栈）；随后（粗糙描述）中断向量被装入PC寄存器，下一个指令周期即进入中断服务子程序
	* 中断处理：就是执行中断服务子程序的过程，处理之前需要保护现场（保护现场的执行主体是ISR）
	* 中断返回：包括从堆栈中恢复现场和恢复断点，恢复现场需要编程实现，而恢复断点由硬件电路自动完成
* 异常处理的过程包括：
	* 处理器接受异常请求；进入异常处理；执行异常处理程序；异常返回

##### (1) 异常请求的接受

* 处理器接受请求的条件
	* 处理器处于运行状态
	* 异常处于使能状态
	* 异常的优先级高于当前等级
	* 异常没有被屏蔽（如没有设置PRIMASK）
* 注意，如果异常处理程序中出现了SVC指令，而该异常的优先级不低于SVC的优先级，就会触发硬件错误，从而进入硬件错误的处理程序

##### (2) 异常进入流程

* 异常进入流程包括如下操作：

	1. 多个寄存器的值和返回地址被压入当前使用的栈若处理器处于线程模式且正在使用进程栈指针（PSP），则PSP指向的堆栈区域就会用于该压栈过程，否则就会使用主栈指针（MSP）指向的堆栈区域
	2. 从向量表中取出异常向量
	3. 取出异常处理程序中的指令
	4. 更新多个NVIC寄存器（后续介绍）和内核寄存器（PSR、LR、PC及SP）

* 在异常进入过程中，硬件自动完成的处理有：

	* 根据压栈时实际使用的栈，MSP或PSP的数值会在异常处理开始前自动调整（稍后解释）
	* PC被更新为异常处理的起始地址
	* LR被更新为EXC_RETURN
		* EXC_RETURN用于异常返回，位宽为32位，高28位为1，低4位用于保存异常流程的状态信息（稍后详细解析EXC_RETURN）
	* R0~R3、R12，LR、PC（返回地址）和PSR共8个寄存器被压栈（注意：压栈顺序和栈帧结构不同）
	* 如果需要压栈保存FPU状态，则共有26字
	* 如果使能双字栈对齐，可能还会修改已入栈的PSR[9]

* 加快中断执行速度—压栈顺序

	* 压栈时为了尽快更新PC，首先压栈的是PC（返回地址）和PSR，出栈时为了尽快恢复处理器状态和返回主程序，出栈时也应该先出栈PSR和PC，咋办？
	* 前述栈指针“...会在异常处理开始前自动调整”的意义

	![image-20200428115807025](/assets/images/ARM处理器体系结构.assets/image-20200428115807025.png)

	* 此外，如果中断向量位于CODE区，压栈的同时可以使用I-Code总线取中断向量，以充分利用哈佛结构的优点；如果中断向量表在SRAM区或者RAM区，压栈和取向量只能都使用System总线，会略微增加中断响应延迟

##### (3) 执行异常处理程序

* 进入异常处理程序内部后，处理器进入处理模式，并运行于特权访问等级，栈操作使用MSP
* 此过程中如果有更高优先级的异常产生，处理器会接受新的中断，当前正在执行的处理被更高优先级的处理抢占而进入挂起状态，此即异常嵌套
* 若执行过程中产生的其他异常具有相同或更低的优先级，新产生的异常就会进入挂起状态，待当前异常处理完成后才可能被处理

**在异常处理的结尾**

* 程序代码执行的返回指令会引起EXC_RETURN数值被加载到程序计数器中（PC），并触发异常返回机制

##### (4) 异常返回

* Cortex-M处理器的异常返回机制由EXC_RETURN触发，该数值在异常入口处产生且被存储在LR中
* EXC_RETURN写入PC时，就会触发异常返回流程
* 异常返回可由表中所示的指令产生。异常返回机制被触发后，进入异常期间被压入栈中的寄存器数值会被恢复到寄存器组中，因而多个NVIC寄存器和处理器内核中的寄存器（如PSR、SP和CONTROL）都会被更新

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428120149568.png" alt="image-20200428120149568" style="zoom:67%;" />

* 使能了FPU的时候，进入异常处理的现场保护过程会保存更多寄存器信息到栈中，故返回的时候也需要恢复更多的寄存器信息。故而是否使能了FPU会导致异常进入和返回时有差异

<img src="/assets/images/ARM处理器体系结构.assets/image-20200428120212548.png" alt="image-20200428120212548" style="zoom:67%;" />

**加速中断处理速度—咬尾中断**

* 观察以下情形：

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200428120413093.png" alt="image-20200428120413093" style="zoom:67%;" />

	* 中断#1正在服务，又出现中断#2，因优先级问题。中断#2被挂起
	* 当中断#1结束后，一般流程是：中断#1返回（一系列的出栈操作（恢复现场和恢复断点），紧接着响应中断#2，又有一系列的入栈操作（保护断点和保护现场）

* 咬尾中断

	* 流程优化思想：中断#1结束后，读取中断#2的中断向量，立即为中断#2服务，减少了中断#2的时延

		<img src="/assets/images/ARM处理器体系结构.assets/image-20200428120458030.png" alt="image-20200428120458030" style="zoom:67%;" />

**加速中断处理速度—晚到中断**

* 观察以下情形：

	* 当优先级较低的中断#n刚刚被响应，正在进行压栈，但是尚未取中断向量和进入ISR，此时又有优先级更高的中断#m到达
	* 一般流程：响应中断#n时关中断，进入ISR后开中断，再响应优先级更高的中断#m，中断#m的服务可能被延误

* 晚到中断

	* 仍然压栈保护断点，但是取ISR#m的中断向量，提前为中断#m服务

		<img src="/assets/images/ARM处理器体系结构.assets/image-20200428120604461.png" alt="image-20200428120604461" style="zoom:67%;" />

### (二) 向量表重定位机制

#### 1、重定位的原因

* 向量表默认位置位于CODE区最开始处，MCU制造商在此区域一般配置的是存放启动代码的Flash或者是ROM型存储器，这些器件运行时无法修改，而有些应用需要修改或者增加中断向量。一种解决方案是将向量表“迁移”到CODE区或者SRAM区其他可以修改的SRAM或者RAM型器件中
* 在有些MCU中，包含Bootloader的ROM就位于CODE区的最开始位置，而且没有使用存储器重定位特性或者存储器别名，这样就挤占了中断向量表原来应该的存放位置，中断向量表只能“背井离乡”，重新择址“安家”
* 上述中断向量表的迁移称为“向量表的重定位”

#### 2、重定位的实现方法

* 在Cortex-M3/M4 处理器所集成的NVIC中，有一个名为VTOR（Vector Table Offset Register，地址为0x0E000 ED08）的寄存器，修改VTOR的值就能实现中断向量表的重定位

#### 3、对中断向量表起始地址的要求

* 起始地址必须能够被大于等于（中断向量数×4）的最小2的整数次幂整除（句子太长了，并且有点拗口）
* 例如：CM3/M4最少中断数是8个，再加16个系统异常，8+16=24，24×4=96，大于96的最小2的整数次幂是128（=27），所以向量表的起始地址应该是0x80的整数倍，换言之，向量表起始地址低7位为000 0000

#### 4、VTOR的格式

* r2p0版本之前的Cortex-M3，向量表只能“迁移”CODE区或者SRAM区；而新版Cortex-M3和所有Cortex-M4取消了上述限制。因此，VTOR的内容有区别

	* 如前所述，VTOR的最低7位[6:0]为000 0000
	* r2p0版本之前的Cortex-M3最高两位没有意义，位[29]为0或1表明中断向量表位于CODE区还是SRAM区
	* 在Cortex-M4和新版本的Cortex-M3中，最后7位没有变化，但是其他位是向量表起始地址的高25位

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200428135651306.png" alt="image-20200428135651306" style="zoom:67%;" />


#### 5、向量表重定位应用示例

**示例1：**具有Bootloader的设备

* MCU启动时，首先执行ROM中的Boot loader代码
* 在跳转到Flash中的用户程序前，设置VTOR指向用户Flash存储器的开始处（此处放置重定位后的向量表）
* 向量表切换为用户Flash中的向量表

<img src="/assets/images/ARM处理器体系结构.assets/image-20200430141151905.png" alt="image-20200430141151905" style="zoom:50%;" />

**示例2：**应用程序是从外部加载到RAM中执行

* 存储在片上存储器的启动程序初始化相关硬件，把外部设备（如SD卡或U盘）中的应用程序复制到RAM（包括SRAM）中
* 更新VTOR，指向位于RAM中新的向量表
* 最后执行已加载到RAM的程序

<img src="/assets/images/ARM处理器体系结构.assets/image-20200430141314241.png" alt="image-20200430141314241" style="zoom:50%;" />

### (三) 中断请求和挂起

* 在传统ARM处理器中，若设备产生了中断请求，在得到处理前需要一直保持中断请求信号。在NVIC中设计了用于保存中断请求的挂起请求寄存器，即使请求中断的源设备取消了请求信号，已产生的中断仍会被处理
* 如果处理器空闲，处于挂起状态的中断请求会马上得到处理，此时，中断的挂起状态被自动清除。但如果处理器正在处理另外一个更高优先级或同等优先级的中断，或者产生请求的中断源被屏蔽了（通过设置中断屏蔽寄存器），那么在其他中断处理结束前或中断屏蔽被清除前，该中断会一直保持在挂起状态
* 某个中断被处理时就会进入激活状态。在NVIC中，中断激活状态寄存器保存每个中断的激活状态，只有在中断服务完成，处理器执行了异常返回后，中断激活状态寄存器中对应已完成服务中断的位才会被清除（自动完成）

#### 1、中断的状态：请求$\rightarrow$挂起$\rightarrow$激活

* 挂起状态、挂起状态清除、进入激活状态、清除激活状态

* 线程模式$\rightarrow$处理模式$\rightarrow$线程模式

	* 从线程模式切换到处理模式时，多个寄存器会被自动压栈，并从向量表取出ISR的起始地址
	* 从处理模式回到线程模式时，之前自动压栈的寄存器会被恢复，继续此前被打断的程序

	![image-20200430141559611](/assets/images/ARM处理器体系结构.assets/image-20200430141559611.png)

#### 2、工程中可能遇到的问题

* 在Cortex-M3/M4中，出现中断请求之后，如果没有得到服务，就一直被挂起。即使中断源因某种原因撤销了请求，仍然会被处理，此举会不会是“自作多情”？

* 解决方法：在编写ISR时，应先读取中断源相关状态，若的确需要服务，继续执行ISR；否则退出

* 一般而言，需要中断服务的外设，应该设置专门的“中断请求触发器”，在得到服务前，一直维持请求信号有效，在中断响应之后再撤销

	* 对比：x86系统有一个8259 PIC，其中的IRR（中断请求寄存器）为非锁存结构，请求必须一直有效，如果CPU响应了某个中断，在读IRR前，外设撤销了中断请求，CPU读到的IRR中“空空如也”，此时8259会怎么办？

		8259会将最低优先级的IRQ7的类型号送上总线

### (四) NVIC寄存器

* NVIC中的寄存器组只能管理类型16~255的外部中断，管理NMI和Systick等系统异常需要SCB中的寄存器

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200430141742376.png" alt="image-20200430141742376" style="zoom:67%;" />

#### 1、中断的使能和禁止

* 中断使能和禁止是通过对2个寄存器（Interrupt Set-enable Registers和Interrupt Clear-enable Registers）进行写操作，实际是对一个物理寄存器进行配置

	* 设置中断使能需要写入NVIC_ISERn寄存器的相应位

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200430141832115.png" alt="image-20200430141832115" style="zoom:67%;" />

	**注意**：中断使能和禁止使用两个地址，操作的是同一个物理寄存器	

* 清除使能（禁止中断）需要写入NVIC_ICERn寄存器的相应位

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200430141952654.png" alt="image-20200430141952654" style="zoom:67%;" />

	* 每个ISER/ICER寄存器都是32位，每位对应一个中断输入，若外部中断源超过32个，ISER和ICER寄存器不止一个
	* ISER/ICER分开设置，操作的是同一个寄存器，某位置1无需担心其他位被置零；没有“读-改-写”过程，操作具有原子性

#### 2、中断挂起和清除挂起

* 设置中断挂起状态或者读取中断挂起状态，可以通过访问中断设置挂起寄存器（Interrupt Set-pending Registers，NVIC_ISPRn）实现

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200430142048308.png" alt="image-20200430142048308" style="zoom:67%;" />

* 通过写ISPR将某个中断设置为挂起状态，该中断就进入了等待中断服务的队伍中

* 清除中断挂起状态可以通过中断清除挂起（Interrupt Clear-pending Registers，NVIC_ICPRn）寄存器实现

	<img src="/assets/images/ARM处理器体系结构.assets/image-20200430142119051.png" alt="image-20200430142119051" style="zoom:67%;" />

	* 每个ISPR/ICPR寄存器也是32位，每位对应一个中断输入，若外部中断源超过32个，ISPR和ICPR寄存器也不止一个

#### 3、中断的激活状态

* 只要进入中断服务子程序，中断激活状态寄存器（Interrupt Active Bit Registers，NVIC_IABR）中的对应位就置1
* 如果发生中断嵌套，会出现多个中断处于激活状态
* NVIC_IABR为只读类型

<img src="/assets/images/ARM处理器体系结构.assets/image-20200430142217135.png" alt="image-20200430142217135" style="zoom:67%;" />

#### 4、中断优先级配置寄存器

* 每个中断都有各自的优先级寄存器（Interrupt Priority Registers），每个优先级寄存器位宽为8位（实际位宽为3~8位），一个32位的NVIC_IPRn管理4个中断
* 每个优先级寄存器又分成分组优先级和子优先级两部分
* 优先级寄存器的数量取决于芯片实际的外部中断数

<img src="/assets/images/ARM处理器体系结构.assets/image-20200430142356680.png" alt="image-20200430142356680" style="zoom:67%;" />

#### 5、软件触发中断寄存器

* 除了写ISPR以外，还可以向软件触发中断寄存器（Software Trigger Interrupt Register，STIR）写类型号来触发相应中断（写ISPR是置位对应位）
	* 可以通过设置CCR，允许非特权程序访问STIR
	* 但是只有特权访问等级才可以访问ISPR

<img src="/assets/images/ARM处理器体系结构.assets/image-20200430142503443.png" alt="image-20200430142503443" style="zoom:67%;" />

### (五) SCB寄存器

<img src="/assets/images/ARM处理器体系结构.assets/image-20200430142534339.png" alt="image-20200430142534339" style="zoom:67%;" />

#### 1、中断控制和状态寄存器

ICSR: Interrupt Control and State Register

<img src="/assets/images/ARM处理器体系结构.assets/image-20200430142613316.png" alt="image-20200430142613316" style="zoom:67%;" />

#### 2、应用中断和复位控制寄存器

AIRCR: Application Interrupt and Reset Control Register

<img src="/assets/images/ARM处理器体系结构.assets/image-20200430142654908.png" alt="image-20200430142654908" style="zoom:67%;" />

#### 3、系统处理优先级寄存器

* SHPR: System Handler Priority Register
* 共3个，SHPR1到SHPR3，SHPR的位域定义与中断优先级寄存器定义相同，差别在于SHPR用于（除了复位、NMI和硬件错误以外的）系统异常

<img src="/assets/images/ARM处理器体系结构.assets/image-20200430142730357.png" alt="image-20200430142730357" style="zoom:67%;" />

#### 4、系统处理控制和状态寄存器

SHCSR: System Handler Control and State Register

<img src="/assets/images/ARM处理器体系结构.assets/image-20200430142802077.png" alt="image-20200430142802077" style="zoom:67%;" />