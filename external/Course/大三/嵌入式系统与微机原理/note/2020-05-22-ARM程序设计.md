---
title: ARM程序设计
tags: 微机原理与嵌入式系统
article_header:
  type: cover
  image:
    src: /assets/images/embed.jpg
---

<!--more-->

* 目前基于ARM处理器的程序大多采用C语言开发
	* 无操作系统(while语句无限循环体内功能实现+中断)
	* 有操作系统（μC/OS、Linux、Android 进行任务调度）
* 特定场合下必须使用汇编语言（系统启动程序）
	* 汇编指令可以直接对ARM处理器中的寄存器进行操作，掌握必要的汇编程序设计知识，就能更全面、更深入地理解ARM处理器的工作原理

## 一、ARM程序开发环境

### (一) 常用ARM程序开发环境简介

* 分类
	* 基于Windows平台
		* SDT(ARM Software Development Kit)是ARM公司最早推出的开发工具
		* ADS (ARM Developer Suite)由ARM公司约1999年推出，用来代替SDT
		* RealView Developer Suite，是ARM公司继ADS之后推出的集成开发工具
		* RealViewMDK(Microcontroller Development Kit)
		* ARM Development Studio 5
	* 基于Linux平台
		* ARM-Linux-GCC
	* 其他的分类方法
		* 开源软件，典型如ARM-Linux-GCC
		* 商业软件，ARM公司推出的软件工具
* 目前ARM官方提供的软件工具
	* KeilMDK
		* Software development package for Arm-based microcontrollers
	* Arm Development Studio
		* Software development tool suite for any Arm-based project
	* Compiler
		* Embedded C/C++ toolchain, from Armv6 M to Armv8-A 64-bit
	* KeilRTX5
		* Real-time operating system implementing the CMSIS-RTOS APIv2
	* Software Test Libraries
		* Efficient processor specific test suites enabling on-line processor testing
	* FuSaRTS
		* Run-time system for embedded functional safety applications

* ARM-Linux-GCC
	* GNU Compiler Collection（GCC）是一套由GNU开发的编译器集，不仅支持C语言编译，还支持C++、Ada、Object C等许多语言。GCC还支持多种处理器架构，包括X86、ARM、和MIPS等处理器架构，是在Linux平台下被广泛使用的软件开发工具。
	* GNU：是“GNU is Not Unix”的递归缩写，是一个自由软件工程项目。这些软件在GNU通用公共许可的保护下允许任何人免费使用和传播（但必须同时提供源程序），GNU软件许可相当宽松，有很多公司利用GNU软件进行商业活动。
	* ARM-Linux-GCC是基于ARM目标机的交叉编译软件，所谓交叉编译简单来说就是在一个平台上生成另一个平台上的可执行代码。
		* 平台实际上包含两个概念：体系结构（Architecture）和操作系统（OS）
		* 同一个体系结构可以运行不同的操作系统；同样，同一个操作系统也可以在不同的体系结构上运行。
		* 一个常见的例子是：嵌入式软件开发人员通常在个人计算机上为运行在基于ARM、PowerPC或MIPS的目标机编译软件。
	* ARM-Linux-GCC使用命令行来调用命令执行
		* 相比于RVDS和MDK等IDE而言上手较难。但由于ARM-Linux-GCC不需要授权费用，因而受到使用Linux开发嵌入式系统应用工程师的欢迎。
* MDK
	* MDK由Keil公司推出
		* Keil公司是一家业界领先的MCU软件开发工具的独立供应商，最流行的单片机开发工具KeilC51就是Keil公司出品的。
	* MDK主要特点：
		* 支持内核：ARM7，ARM9，Cortex-M4/M3/M1，Cortex-R0/R3/R4等ARM微控制器内核，后续可能变化；
		* IDE：μVision IDE；
		* 编译器：ARM C/C++编译器(armcc)；
		* 仿真器：μVision CPU & Peripheral Simulation；
		* 硬件调试单元：ULink/JLink。
* ARM Development Studio 5（DS-5）
	* DS-5是一款支持开发所有ARM内核芯片的IDE，主要特点如下：
		* 支持内核：全部；
		* 定制的Eclipse IDE；
		* 编译器：ARM Compiler 6、ARM Compiler 5、GCC（LinaroGNU GCCCompiler for Linux）；
		* 调试器：DS-5调试器支持ETM指令和数据跟踪、PTM程序跟踪；
		* 仿真器：DS-5支持ULINK2、ULINKPRO和DSTREAM仿真器。

* MDK vs DS-5
	* 不同的应用领域
		* MDK可满足开发者基于ARM7/9，ARM Cortex-M处理器的开发需求，包括它自带的RTX实时操作系统和中间库，都是属于MCU应用领域的。
		* DS-5是用于创建Linux/Andriod的复杂嵌入式系统应用和系统平台驱动接口，DS-5支持设备添加，包括多核调试和支持，主要针对复杂的多核调试、片上系统开发而推出的。
	* 使用经验
		* 如果需要做MCU应用，推荐用KEILMDK；
		* 如果需要做片上系统、Linux/Android驱动和应用开发，推荐使用DS-5+DSTREAM。
		* 用户可以根据自己的功能需求、使用习惯（比如很多从单片机开发转到嵌入式开发的开发者更习惯使用MDK）、开发用途等选择不同的开发环境。

### (二) MDK开发环境简介

* MDK-ARM
* μVision IDE

#### 嵌入式系统调试方法

* 调试是任何项目开发过程中必不可少的一部分，特别是在软硬件结合非常紧密的嵌入式系统开发中。一般来说，大多数的调试工作是在RAM中进行的，只有当程序完成并能运行后才切换到ROM上。
* 嵌入式系统的调试有多种方法，可分为
	* 模拟器方式
	* ICE（In-Circuit Emulator，在线仿真器）方式
	* ICD（In-Circuit Debugger，在线调试器）方式
	* 监控器方式

## 二、ARM汇编程序中的伪指令

**伪指令简介**

* 由于ARM Compiler支持的Pseudo-instructions数目非常有限，本节内容仅限于directives，且沿用中文资料习惯翻译“伪指令”
* 在ARM汇编语言程序里，有一些特殊指令助记符，这些助记符与指令系统的助记符不同，没有相对应的操作码，通常称这些特殊指令助记符为伪指令，他们所完成的操作称为伪操作。
* 伪指令不像机器指令那样在处理器运行期间由机器执行，而是汇编程序对源程序汇编期间由汇编程序处理，包括：定义变量、分配数据存储空间、控制汇编过程、定义程序入口等，这些伪指令仅在汇编过程中起作用，一旦汇编结束，伪指令的使命就完成了。

### (一) 符号定义伪指令

* 符号定义伪指令用于定义ARM汇编程序中的变量、对变量赋值以及定义寄存器的别名等操作。常见的符号定义伪指令有如下几种：
	* 用于定义全局变量的GBLA、GBLL和GBLS
	* 用于定义局部变量的LCLA、LCLL和LCLS
	* 用于对变量赋值的SETA、SETL、SETS
	* 为通用寄存器列表定义名称的RLIST

#### 1、GBLA、GBLL和GBLS

* 语法格式：
	* GBLA（GBLL或GBLS）全局变量名;

* GBLA、GBLL和GBLS伪指令用于定义一个ARM程序中的全局变量，并将其初始化。其中：
	* GBLA伪指令用于定义一个全局的数字变量，并初始化为0；
	* GBLL伪指令用于定义一个全局的逻辑变量，并初始化为F（假）；
	* GBLS伪指令用于定义一个全局的字符串变量，并初始化为空；
	* 由于以上三条伪指令用于定义全局变量，因此在整个程序范围内变量名必须唯一。

例：

```
GBLA Test1			;定义一个全局的数字变量，变量名为Test1
Test1 SETA 0xaa		;将该变量赋值为0xaa
GBLL Test2			;定义一个全局的逻辑变量，变量名为Test2
Test2 SETL{TRUE}	;将该变量赋值为真
GBLS Test3			;定义一个全局的字符串变量，变量名为Test3
Test3 SETS “Testing”;将该变量赋值为“Testing”
```

#### 2、LCLA、LCLL和LCLS

* 语法格式：
	* LCLA（LCLL或LCLS）局部变量名;

* LCLA、LCLL和LCLS伪指令用于定义一个ARM程序中的局部变量，并将其初始化。其中：
	* LCLA伪指令用于定义一个局部的数字变量，并初始化为0；
	* LCLL伪指令用于定义一个局部的逻辑变量，并初始化为F（假）；
	* LCLS伪指令用于定义一个局部的字符串变量，并初始化为空；
	* 以上三条伪指令用于声明局部变量，在其作用范围内变量名必须唯一。

例

```
LCLA Test4			;声明一个局部的数字变量，变量名为Test4
Test3 SETA 0xaa		;将该变量赋值为0xaa
LCLL Test5			;声明一个局部的逻辑变量，变量名为Test5
Test4 SETL {TRUE}	;将该变量赋值为真
LCLS Test6			;定义一个局部的字符串变量，变量名为Test6
Test6 SETS “Testing”;将该变量赋值为“Testing”
```

#### 3、SETA、SETL和SETS

* 语法格式：

	* 变量名 SETA（SETL或SETS）表达式;

* 伪指令SETA、SETL、SETS用于给一个已经定义的全局变量或局部变量赋值。

	* SETA伪指令用于给一个数学变量赋值；
	* SETL伪指令用于给一个逻辑变量赋值；
	* SETS伪指令用于给一个字符串变量赋值；
	* 其中，变量名为已经定义过的全局变量或局部变量，表达式为将要赋给变量的值。

* 例

	```
	LCLA Test3			;声明一个局部的数字变量，变量名为Test3
	Test3 SETA 0xaa		;将该变量赋值为0xaa
	LCLL Test4			;声明一个局部的逻辑变量，变量名为Test4
	Test4 SETL{TRUE}	;将该变量赋值为真
	```

#### 4、RLIST

* 语法格式
	
	* 名称 RLIST {寄存器列表};
* RLIST伪指令可用于对一个通用寄存器列表定义名称，使用该伪指令定义的名称可在ARM指令LDM/STM中使用。在LDM/STM指令中，列表中的寄存器访问次序为根据寄存器的编号由低到高，而与列表中的寄存器排列次序无关。

* 例

	```
	RegList RLIST {R0-R5，R8，R10}	;将寄存器列表名称定义为RegList，可在ARM指令LDM/STM中通过该名称访问寄存器列表
	```

### (二) 数据定义伪指令

* 数据定义伪指令一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化。常见的数据定义伪指令有如下几种：
	* DCB用于分配一段连续的字节存储单元并用指定的数据初始化
	* DCW（DCWU）用于分配一段连续的半字存储单元并用指定的数据初始化
	* DCD（DCDU）用于分配一段连续的字存储单元并用指定的数据初始化
	* DCFD（DCFDU）用于为双精度的浮点数分配一段连续的字存储单元并用指定数据初始化
	* DCFS（DCFSU）用于为单精度的浮点数分配一段连续的字存储单元并用指定数据初始化
	* DCQ（DCQU）用于分配一段以8字节为单位的连续的存储单元并用指定的数据初始化
	* SPACE 用于分配一段连续的存储单元
	* MAP 用于定义一个结构化的内存表首地址
	* FIELD 用于定义一个结构化的内存表的数据域

#### 1、DCB

* 语法格式

	* 标号 DCB 表达式;

* DCB伪指令用于分配一段连续的字节（8位）存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为0～255的数字或字符串。DCB也可用“=”代替。

* 例

	```
	StrDCB“Thisisatest!”;分配一段连续的字节存储单元并初始化
	```

#### 2、DCW（或DCWU）

* 语法格式

	* 标号 DCW（或DCWU） 表达式;

* DCW（或DCWU）伪指令用于分配一段连续的半字（16位）存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为程序标号或数字表达式。

* 用DCW分配的字存储单元是半字对齐的，而用DCWU分配的字存储单元并不严格半字对齐

* 例

	```
	DataTest DCW 1,2,3	;分配3个连续的半字存储单元并用1，2，3初始化
	```

#### 3、DCD（或DCDU）

* 语法格式

	* 标号 DCD（或DCDU） 表达式;

* DCD（或DCDU）伪指令用于分配一段连续的字（32位）存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为程序标号或数字表达式，DCD也可用“&”代替。

* 用DCD分配的字存储单元是字对齐的，而用DCDU分配的字存储单元并不严格字对齐。

* 例

	```
	DataTest DCD4,5,6	;分配3个连续的字存储单元并用4，5，6初始化
	```

#### 4、DCFD（或DCFDU）

* 语法格式

	* 标号 DCFD（或DCFDU）表达式;

* DCFD（或DCFDU）伪指令用于为双精度的浮点数分配一段连续的字存储单元并用伪指令中指定的表达式初始化，每个双精度的浮点数占据两个字单元。

* 用DCFD分配的字存储单元是字对齐的，而用DCFDU分配的字存储单元并不严格字对齐

* 例

	```
	FDataTest DCFD 0.1,0.2,0.3	;分配3个连续的双字存储单元并初始化为0.1,0.2,0.3的双精度数表达
	```

#### 5、DCFS（或DCFSU）

* 语法格式

	* 标号 DCFS（或DCFSU）表达式;

* DCFS（或DCFSU）伪指令用于为单精度的浮点数分配一段连续的字存储单元并用伪指令中指定的表达式初始化，每个单精度的浮点数占据一个字单元。

* 用DCFS分配的字存储单元是字对齐的，而用DCFSU分配的字存储单元并不严格字对齐。

* 例

	```
	FDataTest DCFS-0.1,-0.2,-0.3 ;分配3个连续的字存储单元并初始化为-0.1，-0.2，-0.3的单精度数表达
	```

#### 6、DCQ(或DCQU）

* 语法格式：

	* 标号 DCQ（或DCQU）表达式;

* DCQ（或DCQU）伪指令用于分配一段以8个字节为单位的连续存储区域并用伪指令中指定的表达式初始化。

* 用DCQ分配的存储单元是字对齐的，而用DCQU分配的存储单元并不严格字对齐。

* 例

	```
	DataTest DCQ 100,101,102;分配3个连续的双字内存单元，并用100D，101D，102D的16进制数据进行初始化
	```

#### 7、SPACE

* 语法格式：

	* 标号 SPACE 表达式;

* SPACE伪指令用于分配一片连续的存储区域并初始化为0。其中，表达式为要分配的字节数。SPACE也可用“％”代替。

* 例

	```
	DataSpace SPACE 100		;分配连续100字节的存储单元并初始化为0
	```

#### 8、MAP和FIELD

* 伪指令MAP和FIELD经常结合在一起使用。MAP用于定义一个结构化的内存表的首地址，可以用“＾”代替。

	**MAP：**

* MAP语法格式：

	* MAP 表达式 {，基址寄存器};

* 表达式可以为程序中的标号或数学表达式，基址寄存器为可选项，当基址寄存器选项不存在时，表达式的值即为内存表的首地址，当该选项存在时，内存表的首地址为表达式的值与基址寄存器的和

* 例：

	```
	MAP 0x100，R0	;定义结构化内存表首地址的值为0x100＋R0。
	```

	**FIELD：**

* FIELD语法格式

	* 标号FIELD表达式;

* 表达式的值为当前数据域在内存表中所占的字节数。

* 注意MAP和FIELD伪指令仅用于定义数据结构，并不实际分配存储单元。

* 例：

	```
	MAP 0x100	;定义结构化内存表首地址的值为0x100。
	A FIELD 16	;定义A的长度为16字节，起始位置为0x100
	B FIELD 32	;定义B的长度为32字节，起始位置为0x110
	S FIELD 256	;定义S的长度为256字节，起始位置为0x130
	```

### (三) 汇编控制伪指令

* 汇编控制伪指令用于控制汇编程序的执行流程：
	* IF、ELSE、ENDIF
	* WHILE、WEND
	* MACRO、MEND
	* MEXIT

#### 1、IF、ELSE、ENDIF

* 语法格式：

	```
	IF 逻辑表达式
	指令序列1
	ELSE 指令序列2
	ENDIF
	```

* IF、ELSE、ENDIF伪指令能根据条件的成立与否决定是否执行某个指令序列，当IF后面的逻辑表达式为真，则执行指令序列1，否则执行指令序列2。其中，ELSE及指令序列2可以没有，此时，当IF后面的逻辑表达式为真，则执行指令序列1，否则继续执行后面的指令。

* 例：

	```
	GBLL Test	;声明一个全局的逻辑变量，变量名为Test
	......
	IF Test=TRUE
	指令序列1
	ELSE
	指令序列2
	ENDIF
	```

#### 2、WHILE、WEND

* 语法格式：

	```
	WHILE 逻辑表达式
	指令序列
	WEND
	```

* WHILE、WEND伪指令能根据条件的成立与否决定是否循环执行某个指令序列。当WHILE后面的逻辑表达式为真，则执行指令序列，该指令序列执行完毕后，再判断逻辑表达式的值，若为真则继续执行，一直到逻辑表达式的值为假

* 例：

	```
	GBLA Counter	;声明一个全局的数学变量，变量名为Counter
	Counter SETA3	;由变量Counter控制循环次数
	......
	WHILE Counter<10
	指令序列
	WEND
	```

#### 3、MACRO、MEND、MEXIT

* 语法格式

	```
	MACRO
	{$标号}宏名{$参数1,$参数2,......}
	指令序列
	MEND
	```

* MACRO、MEND伪指令可以将一段代码定义为一个整体，这两条指令称为宏指令，需要时可以在程序中通过宏指令多次调用这段代码。其中，$标号在宏指令被展开时会被替换为用户定义的符号。宏指令可以使用一个或多个参数，当宏指令被展开时，这些参数被相应的值替换

* 例

	```
	 MACRO					;宏定义开始
	$label test $p1,$p2,$p3	;宏的名称为test，有三个参数p1,p2,p3
	;宏的标号$label可用于构造宏定义体内的其他标号名称
	 CMP $p1,$p2				;比较参数p1,p2大小
	 BHI $label.save			;无符号比较后若p1>p2，跳转到$labe.save标号处，$label.save
	;为宏定义体的内部标号
	 MOV $p3,$p2 
	 B $label.end
	$label.save MOV $p3,$p1
	$label.end				;宏定义功能即将参数p1,p2无符号比较后的大值存入参数p3
	 MEND					;宏定义结束
	```

	调用上述宏可以采用下面的方式：abc test R0,R1,R2;通过宏的名称test调用宏，宏的标号为abc;三个参数为寄存器R0,R1,R2汇编处理宏时会将宏展开还原为一段代码，结果如下：

	```
	CMP R0,R1
	BHI abc.save
	MOV R2,R1
	B abc.end
	abc.save MOV R2,R0
	abc.end
	......
	```

### (四) 其他常用的伪指令

#### 1、AREA

* 语法格式：

	* AREA段名属性1，属性2，......;
	* AREA伪指令用于定义一个代码段或数据段，段名若以数字开头，则该段名需用“|”括起来，如|1_test|。

* 例：

	```
	AREA RESET,CODE,READONLY
	......
	;该伪指令定义了一个代码段，段名为RESET，属性为只读
	```

#### 2、ENTY

* 语法格式：

	* ENTRY;
	* ENTRY伪指令用于指定汇编程序的入口点。在一个完整的汇编程序中至少要有一个ENTRY（也可以有多个，当有多个ENTRY时，程序的真正入口点由链接器指定），但在一个源文件里最多只能有一个ENTRY（可以没有）。

* 例：

	```
	AREA RESET,CODE,READONLY
	ENTRY;指定应用程序的入口点
	......
	```

#### 3、EXPORT

* 语法格式：

	* EXPORT标号{[WEAK]};

* EXPORT伪指令用于在程序中声明一个全局的标号，该标号可在其他的文件中引用。

* 例：

	```
	AREA RESET,CODE,READONLY
	EXPORT Stest	;声明一个可全局引用的标号Stest
	......
	END
	```

#### 4、IMPORT

* 语法格式：

	* IMPORT标号{[WEAK]};

* IMPORT伪指令用于通知编译器要使用的标号在其他的源文件中定义。

* 例：

	```
	AREA RESET,CODE,READONLY
	IMPORT MAIN				;通知编译器当前文件要引用标号MAIN，但MAIN在其他源文件中定义
	......
	END
	```

#### 5、END

* 语法格式：

	* END;
	* END伪指令用于通知编译器已经到了源程序的结尾。

* 例：

	```
	AREA RESET,CODE,READONLY
	......
	END	;指定应用程序的结尾
	```

### (五) 汇编语言中常用的符号

#### 1、程序中的变量

* 程序中的变量是指其值在程序的运行过程中可以改变的量。ARM（Thumb）汇编程序所支持的变量有数字变量、逻辑变量和字符串变量。
* 数字变量用于在程序的运行中保存数字值，但注意数字值的大小不应超出数字变量所能表示的范围。
* 逻辑变量用于在程序的运行中保存逻辑值，逻辑值只有两种取值情况：真或假。
* 字符串变量用于在程序的运行中保存一个字符串，但注意字符串的长度不应超出字符串变量所能表示的范围。

```
LCLS S1	;
LCLS S2	;定义局部字符串变量S1和S2
S1 SETS “Test!”	;字符串变量S1的值为“Test!”
S2 SETS “Hello!”;字符串变量S2的值为“Hello!”
```

#### 2、程序中的常量

* 程序中的常量是指其值在程序的运行过程中不能被改变的量。ARM（Thumb）汇编程序所支持的常量有数字常量、逻辑常量和字符串常量。
* 数字常量一般为32位的整数，当作为无符号数时，其取值范围为0\~2^32^-1，当作为有符号数时，其取值范围为-2^31^\~2^32^-1，逻辑常量只有两种取值情况：真或假

```
NUM EQU 64
abcd EQU 2				;定义abcd符号的值为2
abcd EQU label+16		;定义abcd符号的值为(label+16)
abcd EQU 0x1c，CODE32	;定义abcd符号的值为绝对地址值0x1c，而且此处为ARM32指令
```

#### 3、程序中的变量代换

```
LCLS S1					;定义局部字符串变量S1和S2
LCLS S2
S1 SETS “Test!”
S2 SETS “This is a $S1” ;字符串变量S2的值为“This is a Test！”
```

### (六) 汇编语言中常用运算符和表达式

* 数字表达式及运算符
	* “＋”、“－”、“×”、“/” 及“MOD”算术运算符
	* “ROL”、“ROR”、“SHL”及“SHR”移位运算符
	* “AND”、“OR”、“NOT”及“EOR”按位逻辑运算符
* 逻辑表达式及运算符
	* “=”、“>”、“<”、“>=”、“<= ”、“/=”、“<>” 运算符
	* “LAND”、“LOR”、“LNOT”及“LEOR”运算符
* 字符串表达式及运算符
	* LEN、CHR、STR、LEFT、RIGHT、CC
* 与寄存器和程序计数器（PC）相关的表达式及运算符
	* BASE、INDEX
* 其他常用运算符
	* ？运算符
	* DEF运算符

## 三、ARM汇编语言程序设计

* 由于C语言便于理解，有大量的支持库，所以它是当前ARM程序设计所使用的主要编程语言。
* 但是对硬件系统的初始化、CPU状态设定、中断使能、主频设定以及RAM控制参数初始化等C程序力所不能及的底层操作，还是要由汇编语言程序来完成。
	* 注：C编译器不一定能够把C代码翻译为最佳的机器指令！特别是在一些指令特别丰富的专用处理器中。
* ARM程序在完成上述功能时通常是C语言和汇编语言混合编程。

### (一) ARM汇编语言的语句格式

```
{symbol} {instruction | directive | pseudo-instruction} {;comment}
```

* `symbol`
	* 通常就是标号，在一些directive中有时为常数或者变量;代码中要顶格写
	* ARM汇编中语句中所有标号必须在一行的顶格书写，其后面不要添加“:”，而所有指令均不能顶格书写。ARM汇编器对标识符大小写敏感，书写标号及指令时字母大小写要一致，在ARM汇编程序中，一个ARM指令、伪指令、寄存器名可以全部为大写字母，也可以全部为小写字母，但不要大小写混合使用
* `Instruction | directive | pseudo-instruction`
	* `Instruction`，即ARM或Thumb指令
	* `pseudo-instructions`，ARM汇编器支持少数几条伪指令，伪指令在编译的时候被翻译为一组ARM或Thumb指令
	* `directive`，指示符，指示ARM汇编器行为，中文资料中习惯翻译为伪指令或伪操作
* `comment`，注释
	* 注释使用“;”，注释内容由“;”开始到此行结束，注释可以在一行的顶格书写。

#### 1、标号域

* 标号域用来表示指令的地址、变量、过程名、数据的地址和常量。
* 标号是可以自己起名的标识符，语句标号可以是大小写字母混合，通常以字母开头，由字母、数字、下划线等组成。
* 语句标号不能与寄存器名、指令助记符、伪指令(操作)助记符、变量名同名。
* ARM汇编规范规定：语句标号必须在一行的开头书写，不能留空格；指令则在行开头必须要留出空格。

#### 2、操作助记符域

* 操作助记符域可以为指令、伪操作、宏指令或伪指令的助记符。
* ARM汇编器对大小写敏感，在汇编语言程序设计中，每一条指令的助记符可以全部用大写、或全部用小写，但不允许在一条指令中大、小写混用。
* 所有的指令都不能在行的开头书写，必须在指令的前面有空格，然后再书写指令
* 指令助记符和后面的操作数或操作寄存器之间必须有空格，不可以在这之间使用逗号

#### 3、操作数域

* 操作数域表示操作的对象，操作数可以是常量、变量、标号、寄存器名或表达式，不同对象之间必须用逗号“,”分开

### (二) ARM汇编语言程序结构

* 在ARM（Thumb）汇编语言程序中，通常以段为单位来组织代码段是具有特定名称且功能相对独立的指令或数据序列根据段的内容，分为代码段和数据段。

* 一个汇编程序至少应该有一个代码段，当程序较长时，可以分割为多个代码段和数据段。

* 例如，定义一个可读写属性的数据段

	```
	AREA Buf，DATA，READWRITE	;定义一个可读写属性的数据段
	Num DCD 0x11
	Nums DCD 0x22	;分配一片连续字存储单元并初始化
	;本节及下节所有汇编代码程序都是利用MDKIDE编写，Device设置为STM32F407ZG，代码段放在IROM中起始地址为0x08000000，数据段放在IRAM中起始地址为0x20000000
	```

* 示例，一个代码段的定义

	```
	AREA RESET，CODE，READONLY	   ;只读的代码段，RESET为段名
	ENTRY							;程序入口点
	START LDR R0，= Num				;取Num地址赋给R0
	 LDRR1，[R0]  					;取Num中内容赋给R1
	 ADD R1，#0x9A;   R1=R1+0x9A	
	 STRR1，[R0]  					;R1内容赋给Num单元
	 LDRR0，= Nums					;......
	 LDRR2，[R0]
	 ADD R2，#0xAB
	 STRR2，[R0]
	LOOP   B   LOOP   				;无限循环反复执行
	END								;段结束
	```

### (三) ARM汇编程序设计实例

#### 1、顺序结构

* 顺序结构是一种最简单的程序结构，这种程序按指令排列的先后顺序逐条执行
	* AREA、DCB、ENTRY、END
	* LDR、MOV、B

* 例：

	```
	REA BUF,DATA,READWRITE	;定义数据段Buf
	Array DCB 0x11,0x22,0x33,0x44
	DCB 0x55,0x66,0x77,0x88
	DCB 0x00,0x00,0x00,0x00	;定义12个字节的数组Array
	AREA RESET,CODE,READONLY
	ENTRY
	LDRR0,=Array		;取得数组Array的首地址
	LDRR2,[R0]			;从数组第1字节取32位数据给R2即R2=0x44332211
	MOVR1,#1			;R1=1
	LDRR3,[R0,R1,LSL#2]	;将存储器地址为R0＋R1×4的32位数据读入寄存器R3，
	;R3=0x88776655
	LOOP B LOOP
	END
	```

#### 2、分支结构

* 一般情况下，程序按指令的先后顺序逐条执行，但经常要求程序根据不同条件选择不同的处理方法，利用条件指令或条件转移指令根据当前CPSR中的状态标志值选择路径，使用带有条件码的指令实现的分支程序段。

	<img src="https://chaphlagical.github.io/assets/images/ARM程序设计.assets/image-20200521205810833.png" alt="image-20200521205810833" style="zoom:50%;" />

* 分支结构中经常使用的条件码助记后缀：HI无符号数大于，LS无符号数小于或等于；GT带符号数大于，LE带符号数小于或等于。

* 例如寄存器中R0和R1分别保存两个数，如果R0小于R1，将R1值传给R0，实现代码如下：

	```
	CMP R0，R1	;比较R0和R1
	MOVLT R0，R1	;MOVLT=MOV+LT LT是有符号数比较小于
	```

* 分支结构的几种实现方法：

	* 利用条件码可以很方便地实现IF ELSE分支结构的程序，ARM汇编语言实现分支结构代码片段：

		```
		MOV R0，#76		;初始化R0的值
		MOV R1，#88		;初始化R1的值
		CMP R0，R1		;判断R0>R1？
		MOVHI R2，#100	;R0>R1时，R2=100
		MOVLS R2，#50	;R0<=R1时，R2=50
		......
		```

	* B（Branch）条件转移及衍生指令实现分支结构

		1. B指令

			* 格式：B{条件}+目标地址

			* 用法：B指令是最简单的跳转指令，一旦遇到一个B指令，ARM处理器将立即跳转到给定的目标地址，从那里继续执行

			* 例：

				```
				B Label	;程序无条件跳转到标号Label处执行
				```

			* 例：

				```
				CMP R1,#0
				BEQ Label	;当CPSR寄存器中Z条件码置位时，程序跳转到标号Label处执行......
				```

		2. BL指令

			* 格式：BL{条件}+目标地址

			* 用法：BL是一个跳转指令，但跳转之前，会在寄存器R14中保存PC当前的内容。因此，可以通过将R14的内容重新加载到PC中，来返回到跳转指令之后的那个指令处执行。这个指令是实现子函数调用的一个基本且常用的手段。

				```
				BL Label ;让程序无条件跳转到标号是Label处执行，同时将当前的PC值保存到R14（LR）中。
				```

			* BL实现子函数调用时完成如下的三个操作：

				* 将子程序的返回地址（当前PC）保存在R14（LR）中。
				* 将PC指向子程序的入口即跳转（也即BL后面的目标指令）。
				* 子程序执行完毕之后需要返回时，只需将R14中的LR赋给PC。

			* 使用BL调用子程序后，通常在子程序的尾部添加MOV PC，LR来返回。

#### 3、循环结构，重复执行某段代码

循环结构可以减少源程序重复书写的工作量，用来描述重复执行某段算法的问题，这是程序设计中最能发挥计算机特长的程序结构

1. for循环结构实现

	* C语言实现：

		```
		for(i=0;i<10;i++)
			x++;
		```

	* ARM汇编语言实现：R0为x，R2为i，均为无符号整数:

		```
		MOV R0,#0		;初始化R0=0
		MOV R2,#0		;初始化R2=0
		LOOP CMP R2,#10	;判断R2<10?
		BCS FOR_E		;若条件失败（即R>=10），退出循环
		ADD R0,R0,#1	;执行循环体，R0=R0+1，即x++，ADDR0,#1也可
		ADDR2,R2,#1;R2=R2+1，即i++
		B LOOP
		FOR_E......
		```

2. while循环结构实现

	* C语言实现：

		```
		while(x<=y)
			x*=2;
		```

	* ARM汇编代码片段实现：x为R0，y为R1，均为无符号整数

		```
		MOV R0,#1			;初始化R0=1
		MOV R1,#20			;初始化R1=20
		W1 CMP R0,R1		;判断R0<=R1，即x<=y
		MOVLS R0,R0,LSL#1	;循环体，R0*=2
		BLS W1				;若R0<=R1，继续循环体
		W_END......
		```

#### 4、子程序调用与返回

* 在ARM汇编语言中，子程序的调用一般是通过BL指令来完成的。BL指令的语法格式如下：

	```
	BL SUB
	```

	* SUB是被调用的子程序的名称。
	* BL指令完成2个操作，即将子程序的返回地址放在LR寄存器中，同时将PC寄存器指向子程序的入口点，当子程序执行完毕需要返回主程序时，只需将存放在LR中的返回地址重新赋给指令指针寄存器PC即可。

* BL调用子程序的经典用法如下：

	```
	  BL NEXT		;跳转到NEXT
	  ......
	NEXT
	  ......
	  MOV PC，LR		;从子程序返回
	```

	* 当子程序需要使用的寄存器与主程序使用的寄存器发生冲突（即子程序与主程序都要使用同一组寄存器时），为了防止主程序这些寄存器中的有用数据丢失，在子程序的开始应该把这些寄存器数据压入堆栈以保护现场，在子程序返回之前需要把保护到堆栈的数据自堆栈中弹出以恢复现场。

* 保存和恢复数据可以用PUSH/POP指令实现，PUSH{R4，LR}将寄存器R4入栈，LR也入栈。POP{R4，PC}将堆栈中的数据弹出到寄存器R4及PC中。

* 如果需要保存数据较多即需要入栈和出栈多个寄存器时，可以用PUSH{R0-R7，LR}将寄存器R0-R7全部入栈，LR也入栈；POP{R0-R7，PC}将堆栈中的数据弹出到寄存器R0-R7及PC中。

* ARM汇编指令中还有与PUSH/POP功能类似的压栈和出栈指令：STMFD SP!,{R0-R7,LR};功能是满递减入栈，将寄存器R0-R7、LR压栈，SP不断减4，执行后SP=SP-9\*4[SP]=R0，[SP+4]=R1，....，[SP+4\*8]=LR。

	<img src="https://chaphlagical.github.io/assets/images/ARM程序设计.assets/image-20200521220402517.png" alt="image-20200521220402517" style="zoom:50%;" />

* LDMFDSP!,{R0-R7,PC};满递减出栈，给寄存器R0-R9出栈，并使程序跳转回函数的调用点，SP不断增4；同理，LDMFD是STMFD的逆操作，[SP]->R0，[SP+4]->R1，...，[SP+4\*8]->PCSP=SP+4\*9

	<img src="https://chaphlagical.github.io/assets/images/ARM程序设计.assets/image-20200521220510693.png" alt="image-20200521220510693" style="zoom:50%;" />

* 另外有一点需要注意：BL SUB...MOV PC，LR这种调用子程序结构在一些情况下是会出现问题的，例如当出现子程序嵌套调用时，LR寄存器中内容在第二次子程序调用时会被覆盖，如果仍使用常用调用方式会出现无法返回现场的问题，这个时候使用STMFD/LDMFD指令可以有效避免LR被覆盖而出现错误。

* 子程序嵌套调用时，STMFD/LDMFD指令的用法

	```
	AREA RESET，CODE，READONLY
	ENTRY
	START LDR SP，=0x20000460
			MOV R0,#0x03
			MOV R1,#0x04
	MOV R7,#0x07
		BL POW
	LOOP B LOOP
	POW STMFD SP!，{R0-R7，LR}
		MOVS R2,R1
		MOVEQ R0,#1
		BEQ POW_END
		MOV R1,R0
		SUB R2,R2,#1
	POW_L1 BL DO_MUL;子程序调用嵌套，这个时候如果不用STMFD/LDMFD指令会出现LR覆盖，影响子程序调用的正常返回
		SUBS R2,R2,#1
		BNE POW_L1
	POW_END LDMFD SP!,{R0-R7，PC}
	DO_MUL MUL R0,R1,R0
		MOV PC,LR
	END
	```

## 四、ARM汇编语言与C/C++的混合编程

### (一) C语言与汇编语言之间的函数调用

#### 1、ATPCS

* 为了使单独编译的C语言程序和汇编程序之间能够相互调用，必须为子程序之间的调用制定一定的规则。ATPCS就是ARM程序和Thumb程序中子程序调用的基本规则。
* ATPCS（ARM-ThumbProcedureCallStandard，基于ARM指令集和Thumb指令集过程调用规则）规定了一些不同语言撰写的函数之间相互调用（mixcalls）的基本规则，这些基本规则包括子程序调用过程中寄存器的使用规则、数据栈的使用规则、以及参数的传递规则
* TPCS规定了在子程序调用时的一些基本规则，主要包括以下3方面的内容：
	* 各寄存器的使用规则及其相应的名字；
	* 数据栈的使用规则（FD）；
	* 参数传递的规则；
		* 当参数个数不超过4个时，可以使用寄存器R0\~R3来传递参数，如果参数多于4个，则将剩余的字数据通过堆栈传递，入栈顺序与参数传递顺序相反，即最后一个字数据先入栈，第一个字数据最后入栈

#### 2、C程序调用汇编函数实例

* ARM编译器使用的函数调用规则就是ATPCS标准，也是设计可被C程序调用的汇编函数的编写规则。为了保证程序调用时参数传递正确，C程序调用的汇编函数时必须严格按照ATPCS规则。

* 如果汇编函数和调用函数的C程序不在同一个文件中，则需要在汇编语言中用EXPORT声明汇编语言起始处的标号为外部可引用符号，该标号应该为C语言中所调用函数的名称。

* 例：调用汇编函数，实现把字符串srcstr复制到字符串dststr中

	```
	//main.c
	extern void strcopy(char*d,char*s);//需要调用的汇编函数原型并加extern关键字
	int main()
	{
		char* srcstr="0123456";
		chardststr[]="abcdefg";
		strcopy(dststr,srcstr);
		return 0;
	}
	```

	汇编语言源程序Scopy.s，汇编文件和*.c文件在同一工程中

	```
	AREA Scopy,CODE,READONLY
	 EXPORTstrcopy
	strcopy;必须与EXPORT后面标号一致
	LOOP LDRB R2,[R1],#1;R1指向源地址
		 STRB R2,[R0],#1;R0指向目标地址
		 CMP R2,#0
		 BNE LOOP;先执行后判断，源字符串的终止符‘\0’
		 		 ;也复制到目的字符串
		 MOV PC,LR
	END
	```

#### 3、汇编程序调用C函数实例

* 在汇编程序中调用C语言函数，需要在汇编程序中利用IMPORT说明对应的C函数名，按照ATPCS的规则保存参数。完成各项准备工作后利用跳转指令跳转到C函数入口处开始执行。跳转指令后所跟标号为C函数的函数名。

* 例：汇编程序中调用C函数实现求5个整数相加的和；test.s，工程设置为基于汇编的工程，不需要从main函数启动，代码段名称必须设为RESET

	```
	PRESERVE8
	AREA RESET,CODE,READONLY
	ENTRY
	IMPORT CAL;
	LDR SP,=0x20000460;设置堆栈指针
	MOV R0，#1;R0=1
	ADD R1，R0，R0;R1=2
	ADD R2，R1，R0;R2=3
	ADD R3，R0，R2;R3=4
	ADD R4，R0，R3;R4=5
	STR R4，[SP，#-4]!
	BL CAL 
	LDR R4,=0x20000000;结果R0存入内存单元
	STR R0,[R4]
	END
	```

	```
	//C源程序example.c和汇编文件在同一个工程中
	int CAL(int a, int b, int c, int d, int e)
	{
		return (a+b+c+d+e);
	}
	```

### (二) C/C++语言与汇编语言的混合编程

* 嵌入式系统开发中，目前使用的主要编程语言是C和汇编，C++已经有相应的编译器，但是现在使用还是比较少的。在稍大规模的嵌入式软件中，大部分的代码都是用C编写的。
* C语言中使用内嵌汇编代码，可以在C/C++程序中实现C/C++不能完成的一些操作，同时程序的代码效率也会更高。

#### 1、在C语言程序中嵌入汇编指令

如果要在C程式中嵌入汇编可以有两种方法：内联汇编和内嵌汇编。嵌入汇编使用的标记是__asm或者asm关键字，用法如下：

```
__asm
{
instruction [;instruction]
...
[instruction]
}
asm(“instruction[;instruction]”);
```

1. 内联汇编的示例代码如下：

	```
	int Add(int i)
	{
		int R0;
		__asm
		{
			ADD R0,i,1
			EOR i,R0,i
		}
		return i;
	}
	```

2. 内嵌汇编的示例代码如下：

	```
	#include<stdio.h>
	__asm void my_strcpy(constchar*src,char*dst)
	{
		LOOP LDRB R2,[R0],#1;R0保存第一个参数
		STRB R2,[R1],#1;R1保存第二个参数
		CMP R2,#0
		BNE LOOP BLX LR;返回指令须要手动加入
	}
	```

```
int main(void)//主程序
{
	constchar*a="Helloworld!";
	char b[20];
	my_strcpy(a,b);//调用内嵌汇编程序
	return 0;
}
```

由两种方法的示例可以看出：内联汇编可以直接嵌入C代码使用，而内嵌汇编更像一个函数。由于内联式汇编只能在ARM状态中进行，而Cortex-M3/M4只支持Thumb-2，所以Cortex-M3/M4只能使用内嵌汇编的方式，也就是第二种方法

在C语言中内嵌汇编指令与汇编程序中的指令有些不同，存在一些限制，主要有下面几个方面：

* 不能直接向PC寄存器赋值，程序跳转要使用B或者BL指令。
* 在使用物理寄存器时，不要使用过于复杂的C表达式，避免物理寄存器冲突。
* R12和R13可能被编译器用来存放中间编译结果，计算表达式值时可能将R0到R3、R12及R14用于子程序调用，因此要避免直接使用这些物理寄存器。
* 一般不要直接指定物理寄存器，而让编译器进行分配。

**示例：**

```
#include<stdio.h>
void my_strcpy(constchar*src，char*dest)
{
	charch;__asm//注意是双下划线
	{
		LOOP:
		LDRB ch,[src],#1
		STRB ch,[dest],#1
		CMP ch,#0
		BNE LOOP
	}
}

int main()
{
	char* a="ok!";
	char b[64];
	my_strcpy(a,b);
	return 0;
}
```

#### 2、在汇编中调用C语言定义的函数和全局变量

* 使用内联或者内嵌汇编不用单独编辑汇编语言文件使用起来比较方便，但是有诸多限制。
* 当汇编文件较多的时候就需要使用专门的汇编文件编写汇编程序，在C语言和汇编语言进行数据传递的最简单的形式是使用全局变量。

### (三) C编程中访问特殊寄存器的指令

